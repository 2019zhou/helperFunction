,cve_id,patch,summary
0,CVE-2009-1194,"  pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)
   while (new_len > string->space)
     {
       if (string->space == 0)
	{
	  string->space = 4;
	}
       else
 	{
	  const guint max_space =
	    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));

	  guint more_space = (guint)string->space * 2;

	  if (more_space > max_space)
	    {
	      more_space = max_space;

	      if ((guint)new_len > max_space)
		{
		  g_error (""%s: failed to allocate glyph string of length %i\n"",
			   G_STRLOC, new_len);
		}
	    }

	  string->space = more_space;
 	}
     }
 ","Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox."
1,CVE-2010-1155," 
 
 #include <openssl/crypto.h>
 #include <openssl/x509.h>
#include <openssl/x509v3.h>
 #include <openssl/pem.h>
 #include <openssl/ssl.h>
 #include <openssl/err.h>
  typedef struct
 	SSL *ssl;
 	SSL_CTX *ctx;
 	unsigned int verify:1;
	const char *hostname;
 } GIOSSLChannel;
 
 static SSL_CTX *ssl_ctx = NULL;
  static void irssi_ssl_free(GIOChannel *handle)
 	g_free(chan);
 }
 
 
static gboolean has_internal_nul(const char* str, int len) {
	 
	while (len > 0 && str[len-1] == 0)
		len--;
	return strlen(str) != len;
}

 
static const char *tls_dns_name(const GENERAL_NAME * gn)
{
	const char *dnsname;

	 
	if (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {
		g_warning(""Invalid ASN1 value type in subjectAltName"");
		return NULL;
	}

	 
	dnsname = (char *) ASN1_STRING_data(gn->d.ia5);

	if (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {
		g_warning(""Internal NUL in subjectAltName"");
		return NULL;
	}

	return dnsname;
}

 
static char *tls_text_name(X509_NAME *name, int nid)
{
	int     pos;
	X509_NAME_ENTRY *entry;
	ASN1_STRING *entry_str;
	int     utf8_length;
	unsigned char *utf8_value;
	char *result;

	if (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {
		return NULL;
    }

    entry = X509_NAME_get_entry(name, pos);
    g_return_val_if_fail(entry != NULL, NULL);
    entry_str = X509_NAME_ENTRY_get_data(entry);
    g_return_val_if_fail(entry_str != NULL, NULL);

     
    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {
    	g_warning(""Error decoding ASN.1 type=%d"", ASN1_STRING_type(entry_str));
    	return NULL;
    }

    if (has_internal_nul((char *)utf8_value, utf8_length)) {
    	g_warning(""NUL character in hostname in certificate"");
    	OPENSSL_free(utf8_value);
    	return NULL;
    }

    result = g_strdup((char *) utf8_value);
	OPENSSL_free(utf8_value);
	return result;
}


 
static gboolean match_hostname(const char *cert_hostname, const char *hostname)
{
	const char *hostname_left;

	if (!strcasecmp(cert_hostname, hostname)) {  
		return TRUE;
	} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) {  
		 
		hostname_left = strchr(hostname, '.');
		if (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {
			return TRUE;
		}
	}
	return FALSE;
}

 
static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)
{
	int gen_index, gen_count;
	gboolean matched = FALSE, has_dns_name = FALSE;
	const char *cert_dns_name;
	char *cert_subject_cn;
	const GENERAL_NAME *gn;
	STACK_OF(GENERAL_NAME) * gens;

	 
	gens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);
	if (gens) {
		gen_count = sk_GENERAL_NAME_num(gens);
		for (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {
			gn = sk_GENERAL_NAME_value(gens, gen_index);
			if (gn->type != GEN_DNS)
				continue;

			 
			has_dns_name = TRUE;
			cert_dns_name = tls_dns_name(gn);
			if (cert_dns_name && *cert_dns_name) {
				matched = match_hostname(cert_dns_name, hostname);
			}
    	}

	     
	    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	}

	if (has_dns_name) {
		if (! matched) {
			 
			g_warning(""None of the Subject Alt Names in the certificate match hostname '%s'"", hostname);
		}
		return matched;
	} else {  
		cert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);
	    if (cert_subject_cn && *cert_subject_cn) {
	    	matched = match_hostname(cert_subject_cn, hostname);
	    	if (! matched) {
				g_warning(""SSL certificate common name '%s' doesn't match host name '%s'"", cert_subject_cn, hostname);
	    	}
	    } else {
	    	g_warning(""No subjectAltNames and no valid common name in certificate"");
	    }
	    free(cert_subject_cn);
	}

	return matched;
}

static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, const char* hostname, X509 *cert)
 {
 	if (SSL_get_verify_result(ssl) != X509_V_OK) {
 		unsigned char md[EVP_MAX_MD_SIZE];
  static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)
 			}
 		}
 		return FALSE;
	} else if (! irssi_ssl_verify_hostname(cert, hostname)){
		return FALSE;
 	}
 	return TRUE;
 }
  static gboolean irssi_ssl_init(void)
 
 }
 
static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *hostname, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)
 {
 	GIOSSLChannel *chan;
 	GIOChannel *gchan;
  static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycer
 	chan->ssl = ssl;
 	chan->ctx = ctx;
 	chan->verify = verify;
	chan->hostname = hostname;
 
 	gchan = (GIOChannel *)chan;
 	gchan->funcs = &irssi_ssl_channel_funcs;
  static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycer
 	return gchan;
 }
 
GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)
 {
 	GIOChannel *handle, *ssl_handle;
 
 	handle = net_connect_ip(ip, port, my_ip);
 	if (handle == NULL)
 		return NULL;
	ssl_handle  = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);
 	if (ssl_handle == NULL)
 		g_io_channel_unref(handle);
 	return ssl_handle;
  int irssi_ssl_handshake(GIOChannel *handle)
 		g_warning(""SSL server supplied no certificate"");
 		return -1;
 	}
	ret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, chan->hostname, cert);
 	X509_free(cert);
 	return ret ? 0 : -1;
 }","Irssi before 0.8.15, when SSL is used, does not verify that the server hostname matches a domain name in the subject's Common Name (CN) field or a Subject Alternative Name field of the X.509 certificate, which allows man-in-the-middle attackers to spoof IRC servers via an arbitrary certificate."
2,CVE-2010-1152,"  static int try_read_command(conn *c) {
                     ++ptr;
                 }
 
                if (ptr - c->rcurr > 100 ||
                    (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                     conn_set_state(c, conn_closing);
                     return 1;
                 }",memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation.  NOTE: some of these details are obtained from third party information.
3,CVE-2011-2161,"  static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)
             avio_seek(pb, ape->wavheaderlength, SEEK_CUR);
     }
 
    if(!ape->totalframes){
        av_log(s, AV_LOG_ERROR, ""No frames in the file!\n"");
        return AVERROR(EINVAL);
    }
     if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){
         av_log(s, AV_LOG_ERROR, ""Too many frames: %d\n"", ape->totalframes);
         return -1;","The ape_read_header function in ape.c in libavformat in FFmpeg before 0.5.4, as used in MPlayer, VideoLAN VLC media player, and other products, allows remote attackers to cause a denial of service (application crash) via an APE (aka Monkey's Audio) file that contains a header but no frames."
4,CVE-2011-1575,"  static void randomdelay(void)
  * -Frank.
  */
 
static size_t scanned;
static size_t readnbd;

static void flush_cmd(void)
{
    scanned = readnbd = (size_t) 0U;
}

 int sfgets(void)
 {
     struct pollfd pfd;
     int pollret;
     ssize_t readnb;
     signed char seen_r = 0;
     
     if (scanned > (size_t) 0U) {        
         readnbd -= scanned;        
  void parser(void)
             addreply_noformat(234, ""AUTH TLS OK."");
             doreply();
             if (tls_cnx == NULL) {
                flush_cmd();
                 (void) tls_init_new_session();
             }
             goto wayout;","The STARTTLS implementation in ftp_parser.c in Pure-FTPd before 1.0.30 does not properly restrict I/O buffering, which allows man-in-the-middle attackers to insert commands into encrypted FTP sessions by sending a cleartext command that is processed after TLS is in place, related to a *plaintext command injection* attack, a similar issue to CVE-2011-0411."
5,CVE-2011-0530,"  gboolean do_oldstyle=FALSE;
 #define OFFT_MAX ~((off_t)1<<(sizeof(off_t)*8-1))
 #define LINELEN 256	   
#define BUFSIZE ((1024*1024)+sizeof(struct nbd_reply))  
 #define DIFFPAGESIZE 4096  
 #define F_READONLY 1       
 #define F_MULTIFILE 2	   
  int mainloop(CLIENT *client) {
 
 		if (request.magic != htonl(NBD_REQUEST_MAGIC))
 			err(""Not enough magic."");
		if (len > BUFSIZE - sizeof(struct nbd_reply))
 			err(""Request too big!"");
 #ifdef DODBG
 		printf(""%s from %llu (%llu) len %d, "", request.type ? ""WRITE"" :",Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.
6,CVE-2012-5532,"  int main(void)
 		len = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,
 				addr_p, &addr_l);
 
		if (len < 0) {
 			syslog(LOG_ERR, ""recvfrom failed; pid:%u error:%d %s"",
 					addr.nl_pid, errno, strerror(errno));
 			close(fd);
 			return -1;
 		}
 
		if (addr.nl_pid) {
			syslog(LOG_WARNING, ""Received packet from untrusted pid:%u"",
					addr.nl_pid);
			continue;
		}

 		incoming_msg = (struct nlmsghdr *)kvp_recv_buffer;
 		incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);
 		hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;","The main function in tools/hv/hv_kvp_daemon.c in hypervkvpd, as distributed in the Linux kernel before 3.8-rc1, allows local users to cause a denial of service (daemon exit) via a crafted application that sends a Netlink message.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2012-2669."
7,CVE-2012-5517,"  int __ref online_pages(unsigned long pfn, unsigned long nr_pages)
 
 	zone->present_pages += onlined_pages;
 	zone->zone_pgdat->node_present_pages += onlined_pages;
	if (onlined_pages) {
		node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
		if (need_zonelists_rebuild)
			build_all_zonelists(NULL, zone);
		else
			zone_pcp_update(zone);
	}
 
 	mutex_unlock(&zonelists_mutex);
 
 	init_per_zone_wmark_min();
 
	if (onlined_pages)
 		kswapd_run(zone_to_nid(zone));
 
 	vm_total_pages = nr_free_pagecache_pages();
 ",The online_pages function in mm/memory_hotplug.c in the Linux kernel before 3.6 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact in opportunistic circumstances by using memory that was hot-added by an administrator.
8,CVE-2012-4565,"  static void tcp_illinois_info(struct sock *sk, u32 ext,
 			.tcpv_rttcnt = ca->cnt_rtt,
 			.tcpv_minrtt = ca->base_rtt,
 		};
 
		if (info.tcpv_rttcnt > 0) {
			u64 t = ca->sum_rtt;
 
			do_div(t, info.tcpv_rttcnt);
			info.tcpv_rtt = t;
		}
 		nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);
 	}
 }","The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats."
9,CVE-2012-4508," 
 #define EXT4_EXT_MARK_UNINIT1	0x2   
 #define EXT4_EXT_MARK_UNINIT2	0x4   
 
#define EXT4_EXT_DATA_VALID1	0x8   
#define EXT4_EXT_DATA_VALID2	0x10  

 static __le32 ext4_extent_block_csum(struct inode *inode,
 				     struct ext4_extent_header *eh)
 {
  static int ext4_split_extent_at(handle_t *handle,
 	unsigned int ee_len, depth;
 	int err = 0;
 
	BUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==
	       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));

 	ext_debug(""ext4_split_extents_at: inode %lu, logical""
 		""block %llu\n"", inode->i_ino, (unsigned long long)split);
 
  static int ext4_split_extent_at(handle_t *handle,
 
 	err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);
 	if (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {
		if (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {
			if (split_flag & EXT4_EXT_DATA_VALID1)
				err = ext4_ext_zeroout(inode, ex2);
			else
				err = ext4_ext_zeroout(inode, ex);
		} else
			err = ext4_ext_zeroout(inode, &orig_ex);

 		if (err)
 			goto fix_extent_len;
 		 
  static int ext4_split_extent(handle_t *handle,
 	uninitialized = ext4_ext_is_uninitialized(ex);
 
 	if (map->m_lblk + map->m_len < ee_block + ee_len) {
		split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT;
 		flags1 = flags | EXT4_GET_BLOCKS_PRE_IO;
 		if (uninitialized)
 			split_flag1 |= EXT4_EXT_MARK_UNINIT1 |
 				       EXT4_EXT_MARK_UNINIT2;
		if (split_flag & EXT4_EXT_DATA_VALID2)
			split_flag1 |= EXT4_EXT_DATA_VALID1;
 		err = ext4_split_extent_at(handle, inode, path,
 				map->m_lblk + map->m_len, split_flag1, flags1);
 		if (err)
  static int ext4_split_extent(handle_t *handle,
 		return PTR_ERR(path);
 
 	if (map->m_lblk >= ee_block) {
		split_flag1 = split_flag & (EXT4_EXT_MAY_ZEROOUT |
					    EXT4_EXT_DATA_VALID2);
 		if (uninitialized)
 			split_flag1 |= EXT4_EXT_MARK_UNINIT1;
 		if (split_flag & EXT4_EXT_MARK_UNINIT2)
  static int ext4_split_unwritten_extents(handle_t *handle,
 
 	split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;
 	split_flag |= EXT4_EXT_MARK_UNINIT2;
	if (flags & EXT4_GET_BLOCKS_CONVERT)
		split_flag |= EXT4_EXT_DATA_VALID2;
 	flags |= EXT4_GET_BLOCKS_PRE_IO;
 	return ext4_split_extent(handle, inode, path, map, split_flag, flags);
 }
 
 static int ext4_convert_unwritten_extents_endio(handle_t *handle,
						struct inode *inode,
						struct ext4_map_blocks *map,
						struct ext4_ext_path *path)
 {
 	struct ext4_extent *ex;
	ext4_lblk_t ee_block;
	unsigned int ee_len;
 	int depth;
 	int err = 0;
 
 	depth = ext_depth(inode);
 	ex = path[depth].p_ext;
	ee_block = le32_to_cpu(ex->ee_block);
	ee_len = ext4_ext_get_actual_len(ex);
 
 	ext_debug(""ext4_convert_unwritten_extents_endio: inode %lu, logical""
 		""block %llu, max_blocks %u\n"", inode->i_ino,
		  (unsigned long long)ee_block, ee_len);

	 
	if (ee_block != map->m_lblk || ee_len > map->m_len) {
		err = ext4_split_unwritten_extents(handle, inode, map, path,
						   EXT4_GET_BLOCKS_CONVERT);
		if (err < 0)
			goto out;
		ext4_ext_drop_refs(path);
		path = ext4_ext_find_extent(inode, map->m_lblk, path);
		if (IS_ERR(path)) {
			err = PTR_ERR(path);
			goto out;
		}
		depth = ext_depth(inode);
		ex = path[depth].p_ext;
	}
 
 	err = ext4_ext_get_access(handle, inode, path + depth);
 	if (err)
  ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode,
 	}
 	 
 	if ((flags & EXT4_GET_BLOCKS_CONVERT)) {
		ret = ext4_convert_unwritten_extents_endio(handle, inode, map,
 							path);
 		if (ret >= 0) {
 			ext4_update_inode_fsync_trans(handle, inode, 1);",Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.
10,CVE-2012-4467,"  static int do_siocgstamp(struct net *net, struct socket *sock,
 	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);
 	set_fs(old_fs);
 	if (!err)
		err = compat_put_timeval(&ktv, up);
 
 	return err;
 }
  static int do_siocgstampns(struct net *net, struct socket *sock,
 	err = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);
 	set_fs(old_fs);
 	if (!err)
		err = compat_put_timespec(&kts, up);
 
 	return err;
 }","The (1) do_siocgstamp and (2) do_siocgstampns functions in net/socket.c in the Linux kernel before 3.5.4 use an incorrect argument order, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (system crash) via a crafted ioctl call."
11,CVE-2012-4444,"  int ip6_frag_match(struct inet_frag_queue *q, void *a)
 }
 EXPORT_SYMBOL(ip6_frag_match);
 
 void ip6_frag_init(struct inet_frag_queue *q, void *a)
 {
 	struct frag_queue *fq = container_of(q, struct frag_queue, q);
  static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,
 	}
 
 found:
 
	 
	if (prev &&
	    (FRAG6_CB(prev)->offset + prev->len) - offset > 0)
		goto discard_fq;
 
	 
	if (next && FRAG6_CB(next)->offset < end)
		goto discard_fq;
 
 	FRAG6_CB(skb)->offset = offset;
 
  static int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,
 	write_unlock(&ip6_frags.lock);
 	return -1;
 
discard_fq:
	fq_kill(fq);
 err:
 	IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
 		      IPSTATS_MIB_REASMFAILS);",The ip6_frag_queue function in net/ipv6/reassembly.c in the Linux kernel before 2.6.36 allows remote attackers to bypass intended network restrictions via overlapping IPv6 fragments.
12,CVE-2012-3552,"  struct ip_options {
 	unsigned char	__data[0];
 };
 
struct ip_options_rcu {
	struct rcu_head rcu;
	struct ip_options opt;
};

struct ip_options_data {
	struct ip_options_rcu	opt;
	char			data[40];
};
 
 struct inet_request_sock {
 	struct request_sock	req;
  struct inet_request_sock {
 				acked	   : 1,
 				no_srccheck: 1;
 	kmemcheck_bitfield_end(flags);
	struct ip_options_rcu	*opt;
 };
 
 static inline struct inet_request_sock *inet_rsk(const struct request_sock *sk)
  struct inet_sock {
 	__be16			inet_sport;
 	__u16			inet_id;
 
	struct ip_options_rcu __rcu	*inet_opt;
 	__u8			tos;
 	__u8			min_ttl;
 	__u8			mc_ttl;",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
13,CVE-2012-3525,"  static void _out_result(conn_t out, nad_t nad) {
     rkeylen = strlen(rkey);
 
      
    if(nad_find_attr(nad, 0, -1, ""type"", ""valid"") >= 0 && xhash_get(out->states, rkey) == (void*) conn_INPROGRESS) {
         log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s"", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? "", TLS negotiated"" : """", out->s->compressed ? "", ZLIB compression enabled"" : """");
 
         xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);     
  static void _out_verify(conn_t out, nad_t nad) {
     rkey = s2s_route_key(NULL, to->domain, from->domain);
 
     attr = nad_find_attr(nad, 0, -1, ""type"", ""valid"");
    if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {
         xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);
         log_write(in->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] incoming route '%s' is now valid%s%s"", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? "", TLS negotiated"" : """", in->s->compressed ? "", ZLIB compression enabled"" : """");
         valid = 1;","s2s/out.c in jabberd2 2.2.16 and earlier does not verify that a request was made for an XMPP Server Dialback response, which allows remote XMPP servers to spoof domains via a (1) Verify Response or (2) Authorization Response."
14,CVE-2012-3520,"  static __inline__ void scm_destroy(struct scm_cookie *scm)
 }
 
 static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
			       struct scm_cookie *scm, bool forcecreds)
 {
 	memset(scm, 0, sizeof(*scm));
	if (forcecreds)
		scm_set_cred(scm, task_tgid(current), current_cred());
 	unix_get_peersec_dgram(sock, scm);
 	if (msg->msg_controllen <= 0)
 		return 0;","The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager."
15,CVE-2012-3511," 
 #include <linux/sched.h>
 #include <linux/ksm.h>
 #include <linux/fs.h>
#include <linux/file.h>
 
  
 
 	if (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))
 		return -EINVAL;
 
	f = vma->vm_file;

	if (!f || !f->f_mapping || !f->f_mapping->host) {
 			return -EINVAL;
 	}
 
  static long madvise_remove(struct vm_area_struct *vma,
 	offset = (loff_t)(start - vma->vm_start)
 			+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);
 
	 
	get_file(f);
 	up_read(&current->mm->mmap_sem);
	error = do_fallocate(f,
 				FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
 				offset, end - start);
	fput(f);
 	down_read(&current->mm->mmap_sem);
 	return error;
 }",Multiple race conditions in the madvise_remove function in mm/madvise.c in the Linux kernel before 3.4.5 allow local users to cause a denial of service (use-after-free and system crash) via vectors involving a (1) munmap or (2) close system call.
16,CVE-2012-3510,"  void bacct_add_tsk(struct taskstats *stats, struct task_struct *tsk)
  */
 void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)
 {
	struct mm_struct *mm;

 	 
 	stats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;
 	stats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;
	mm = get_task_mm(p);
	if (mm) {
 		 
		stats->hiwater_rss   = mm->hiwater_rss * PAGE_SIZE / KB;
		stats->hiwater_vm    = mm->hiwater_vm * PAGE_SIZE / KB;
		mmput(mm);
 	}
 	stats->read_char	= p->rchar;
 	stats->write_char	= p->wchar;",Use-after-free vulnerability in the xacct_add_tsk function in kernel/tsacct.c in the Linux kernel before 2.6.19 allows local users to obtain potentially sensitive information from kernel memory or cause a denial of service (system crash) via a taskstats TASKSTATS_CMD_ATTR_PID command.
17,CVE-2012-3430,"  int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 
 	rdsdebug(""size %zu flags 0x%x timeo %ld\n"", size, msg_flags, timeo);
 
	msg->msg_namelen = 0;

 	if (msg_flags & MSG_OOB)
 		goto out;
 
  int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 			sin->sin_port = inc->i_hdr.h_sport;
 			sin->sin_addr.s_addr = inc->i_saddr;
 			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
			msg->msg_namelen = sizeof(*sin);
 		}
 		break;
 	}","The rds_recvmsg function in net/rds/recv.c in the Linux kernel before 3.0.44 does not initialize a certain structure member, which allows local users to obtain potentially sensitive information from kernel stack memory via a (1) recvfrom or (2) recvmsg system call on an RDS socket."
18,CVE-2012-3412,"  static int efx_probe_all(struct efx_nic *efx)
 		goto fail2;
 	}
 
	BUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);
	if (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {
		rc = -EINVAL;
		goto fail3;
	}
 	efx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;
 	rc = efx_probe_channels(efx);
 	if (rc)
  static int efx_register_netdev(struct efx_nic *efx)
 	net_dev->irq = efx->pci_dev->irq;
 	net_dev->netdev_ops = &efx_netdev_ops;
 	SET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);
	net_dev->gso_max_segs = EFX_TSO_MAX_SEGS;
 
 	 
 	efx->mac_op->update_stats(efx);",The sfc (aka Solarflare Solarstorm) driver in the Linux kernel before 3.2.30 allows remote attackers to cause a denial of service (DMA descriptor consumption and network-controller outage) via crafted TCP packets that trigger a small MSS value.
19,CVE-2012-3400,"  static int udf_load_logicalvol(struct super_block *sb, sector_t block,
 	struct genericPartitionMap *gpm;
 	uint16_t ident;
 	struct buffer_head *bh;
	unsigned int table_len;
 	int ret = 0;
 
 	bh = udf_read_tagged(sb, block, block, &ident);
 	if (!bh)
 		return 1;
 	BUG_ON(ident != TAG_IDENT_LVD);
 	lvd = (struct logicalVolDesc *)bh->b_data;
	table_len = le32_to_cpu(lvd->mapTableLength);
	if (sizeof(*lvd) + table_len > sb->s_blocksize) {
		udf_err(sb, ""error loading logical volume descriptor: ""
			""Partition table too long (%u > %lu)\n"", table_len,
			sb->s_blocksize - sizeof(*lvd));
		goto out_bh;
	}
 
 	ret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));
 	if (ret)
 		goto out_bh;
 
 	for (i = 0, offset = 0;
	     i < sbi->s_partitions && offset < table_len;
 	     i++, offset += gpm->partitionMapLength) {
 		struct udf_part_map *map = &sbi->s_partmaps[i];
 		gpm = (struct genericPartitionMap *)",Heap-based buffer overflow in the udf_load_logicalvol function in fs/udf/super.c in the Linux kernel before 3.4.5 allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted UDF filesystem.
20,CVE-2012-3375,"  SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
 	if (op == EPOLL_CTL_ADD) {
 		if (is_file_epoll(tfile)) {
 			error = -ELOOP;
			if (ep_loop_check(ep, tfile) != 0) {
				clear_tfile_check_list();
 				goto error_tgt_fput;
			}
 		} else
 			list_add(&tfile->f_tfile_llink, &tfile_check_list);
 	}","The epoll_ctl system call in fs/eventpoll.c in the Linux kernel before 3.2.24 does not properly handle ELOOP errors in EPOLL_CTL_ADD operations, which allows local users to cause a denial of service (file-descriptor consumption and system crash) via a crafted application that attempts to create a circular epoll dependency.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2011-1083."
21,CVE-2012-2745,"  int copy_creds(struct task_struct *p, unsigned long clone_flags)
 	struct cred *new;
 	int ret;
 
	p->replacement_session_keyring = NULL;

 	if (
 #ifdef CONFIG_KEYS
 		!p->cred->thread_keyring &&","The copy_creds function in kernel/cred.c in the Linux kernel before 3.3.2 provides an invalid replacement session keyring to a child process, which allows local users to cause a denial of service (panic) via a crafted application that uses the fork system call."
22,CVE-2012-2744,"  nf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)
 
 	 
 	fp = skb_shinfo(head)->frag_list;
	if (fp && NFCT_FRAG6_CB(fp)->orig == NULL)
 		 
 		fp = fp->next;
 
  struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 	hdr = ipv6_hdr(clone);
 	fhdr = (struct frag_hdr *)skb_transport_header(clone);
 
 	if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)
 		nf_ct_frag6_evictor();
 ","net/ipv6/netfilter/nf_conntrack_reasm.c in the Linux kernel before 2.6.34, when the nf_conntrack_ipv6 module is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via certain types of fragmented IPv6 packets."
23,CVE-2012-2675,"  static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *
 #if USE_MAGIC_HEADERS
 	size_t _alignment=alignment;
 	size_t *_ret=0;
	size_t bytes=size+alignment+3*sizeof(size_t);
	 
	if(bytes<size)
		return 0;
	size=bytes;
 	_alignment=0;
 #endif
 #if USE_ALLOCATOR==0
","Multiple integer overflows in the (1) CallMalloc (malloc) and (2) nedpcalloc (calloc) functions in nedmalloc (nedmalloc.c) before 1.10 beta2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected."
24,CVE-2012-2673,"  void * malloc(size_t lb)
   }
 #endif  
 
#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif
 void * calloc(size_t n, size_t lb)
 {
    if (lb && n > SIZE_MAX / lb)
      return NULL;
 #   if defined(GC_LINUX_THREADS)  
          
          ","Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected."
25,CVE-2012-2669,"  int main(void)
 	pfd.fd = fd;
 
 	while (1) {
		struct sockaddr *addr_p = (struct sockaddr *) &addr;
		socklen_t addr_l = sizeof(addr);
 		pfd.events = POLLIN;
 		pfd.revents = 0;
 		poll(&pfd, 1, -1);
 
		len = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,
				addr_p, &addr_l);
 
		if (len < 0 || addr.nl_pid) {
			syslog(LOG_ERR, ""recvfrom failed; pid:%u error:%d %s"",
					addr.nl_pid, errno, strerror(errno));
 			close(fd);
 			return -1;
 		}","The main function in tools/hv/hv_kvp_daemon.c in hypervkvpd, as distributed in the Linux kernel before 3.4.5, does not validate the origin of Netlink messages, which allows local users to spoof Netlink communication via a crafted connector message."
26,CVE-2012-2390,"  static void hugetlb_vm_op_open(struct vm_area_struct *vma)
 		kref_get(&reservations->refs);
 }
 
static void resv_map_put(struct vm_area_struct *vma)
{
	struct resv_map *reservations = vma_resv_map(vma);

	if (!reservations)
		return;
	kref_put(&reservations->refs, resv_map_release);
}

 static void hugetlb_vm_op_close(struct vm_area_struct *vma)
 {
 	struct hstate *h = hstate_vma(vma);
  static void hugetlb_vm_op_close(struct vm_area_struct *vma)
 		reserve = (end - start) -
 			region_count(&reservations->regions, start, end);
 
		resv_map_put(vma);
 
 		if (reserve) {
 			hugetlb_acct_memory(h, -reserve);
  int hugetlb_reserve_pages(struct inode *inode,
 		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
 	}
 
	if (chg < 0) {
		ret = chg;
		goto out_err;
	}
 
 	 
	if (hugepage_subpool_get_pages(spool, chg)) {
		ret = -ENOSPC;
		goto out_err;
	}
 
 	/*
 	 * Check enough hugepages are available for the reservation.
  int hugetlb_reserve_pages(struct inode *inode,
 	ret = hugetlb_acct_memory(h, chg);
 	if (ret < 0) {
 		hugepage_subpool_put_pages(spool, chg);
		goto out_err;
 	}
 
 	/*
  int hugetlb_reserve_pages(struct inode *inode,
 	if (!vma || vma->vm_flags & VM_MAYSHARE)
 		region_add(&inode->i_mapping->private_list, from, to);
 	return 0;
out_err:
	resv_map_put(vma);
	return ret;
 }
 
 void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)",Memory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.
27,CVE-2012-2385,"  int Dispatcher::getparam( size_t N, int defaultval )
   if ( parsed_params.size() > N ) {
     ret = parsed_params[ N ];
   }

  if ( ret > PARAM_MAX ) {
    ret = defaultval;
  }

   if ( ret < 1 ) ret = defaultval;
 
   return ret;",The terminal dispatcher in mosh before 1.2.1 allows remote authenticated users to cause a denial of service (long loop and CPU consumption) via an escape sequence with a large repeat count value.
28,CVE-2012-2384,"  i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 			return -EINVAL;
 		}
 
		if (args->num_cliprects > UINT_MAX / sizeof(*cliprects)) {
			DRM_DEBUG(""execbuf with %u cliprects\n"",
				  args->num_cliprects);
			return -EINVAL;
		}
 		cliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),
 				    GFP_KERNEL);
 		if (cliprects == NULL) {",Integer overflow in the i915_gem_do_execbuffer function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.
29,CVE-2012-2383,"  i915_gem_execbuffer2(struct drm_device *dev, void *data,
 	struct drm_i915_gem_exec_object2 *exec2_list = NULL;
 	int ret;
 
	if (args->buffer_count < 1 ||
	    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {
 		DRM_DEBUG(""execbuf2 with %d buffers\n"", args->buffer_count);
 		return -EINVAL;
 	}",Integer overflow in the i915_gem_execbuffer2 function in drivers/gpu/drm/i915/i915_gem_execbuffer.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.3.5 on 32-bit platforms allows local users to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted ioctl call.
30,CVE-2012-2375,"  static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu
 		if (acl_len > buflen)
 			goto out_free;
 		_copy_from_pages(buf, pages, res.acl_data_offset,
				acl_len);
 	}
 	ret = acl_len;
 out_free:","The __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the NFSv4 implementation in the Linux kernel before 3.3.2 uses an incorrect length variable during a copy operation, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words in an FATTR4_ACL reply.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-4131."
31,CVE-2012-2373,"  static inline void native_set_pte(pte_t *ptep, pte_t pte)
 	ptep->pte_low = pte.pte_low;
 }
 
#define pmd_read_atomic pmd_read_atomic
 
#ifndef CONFIG_TRANSPARENT_HUGEPAGE
static inline pmd_t pmd_read_atomic(pmd_t *pmdp)
{
	pmdval_t ret;
	u32 *tmp = (u32 *)pmdp;

	ret = (pmdval_t) (*tmp);
	if (ret) {
		 
		smp_rmb();
		ret |= ((pmdval_t)*(tmp + 1)) << 32;
	}

	return (pmd_t) { ret };
}
#else  
static inline pmd_t pmd_read_atomic(pmd_t *pmdp)
{
	return (pmd_t) { atomic64_read((atomic64_t *)pmdp) };
}
#endif  

 static inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)
 {
 	set_64bit((unsigned long long *)(ptep), native_pte_val(pte));","The Linux kernel before 3.4.5 on the x86 platform, when Physical Address Extension (PAE) is enabled, does not properly use the Page Middle Directory (PMD), which allows local users to cause a denial of service (panic) via a crafted application that triggers a race condition."
32,CVE-2012-2319,"  int hfsplus_rename_cat(u32 cnid,
 	err = hfs_brec_find(&src_fd);
 	if (err)
 		goto out;
	if (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {
		err = -EIO;
		goto out;
	}
 
 	hfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,
 				src_fd.entrylength);","Multiple buffer overflows in the hfsplus filesystem implementation in the Linux kernel before 3.3.5 allow local users to gain privileges via a crafted HFS plus filesystem, a related issue to CVE-2009-4020."
33,CVE-2012-2313,"  rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	int phy_addr;
 	struct netdev_private *np = netdev_priv(dev);
	struct mii_ioctl_data *miidata = if_mii(rq);
 
 	phy_addr = np->phy_addr;
 	switch (cmd) {
	case SIOCGMIIPHY:
		miidata->phy_id = phy_addr;
 		break;
	case SIOCGMIIREG:
		miidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);
 		break;
	case SIOCSMIIREG:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;
		mii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);
 		break;
 	default:
 		return -EOPNOTSUPP;
 	}","The rio_ioctl function in drivers/net/ethernet/dlink/dl2k.c in the Linux kernel before 3.3.7 does not restrict access to the SIOCSMIIREG command, which allows local users to write data to an Ethernet adapter via an ioctl call."
34,CVE-2012-2136,"  struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
 	gfp_t gfp_mask;
 	long timeo;
 	int err;
	int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;

	err = -EMSGSIZE;
	if (npages > MAX_SKB_FRAGS)
		goto failure;
 
 	gfp_mask = sk->sk_allocation;
 	if (gfp_mask & __GFP_WAIT)
  struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,
 		if (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
 			skb = alloc_skb(header_len, gfp_mask);
 			if (skb) {
 				int i;
 
 				 
 				if (!data_len)
 					break;
 
 				skb->truesize += data_len;
 				skb_shinfo(skb)->nr_frags = npages;
 				for (i = 0; i < npages; i++) {","The sock_alloc_send_pskb function in net/core/sock.c in the Linux kernel before 3.4.5 does not properly validate a certain length value, which allows local users to cause a denial of service (heap-based buffer overflow and system crash) or possibly gain privileges by leveraging access to a TUN/TAP device."
35,CVE-2012-2133,"  static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 		spin_lock(&sbinfo->stat_lock);
 		 
		if (sbinfo->spool) {
			long free_pages;

			spin_lock(&sbinfo->spool->lock);
			buf->f_blocks = sbinfo->spool->max_hpages;
			free_pages = sbinfo->spool->max_hpages
				- sbinfo->spool->used_hpages;
			buf->f_bavail = buf->f_bfree = free_pages;
			spin_unlock(&sbinfo->spool->lock);
 			buf->f_files = sbinfo->max_inodes;
 			buf->f_ffree = sbinfo->free_inodes;
 		}
  static void hugetlbfs_put_super(struct super_block *sb)
 
 	if (sbi) {
 		sb->s_fs_info = NULL;

		if (sbi->spool)
			hugepage_put_subpool(sbi->spool);

 		kfree(sbi);
 	}
 }
  hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_fs_info = sbinfo;
 	sbinfo->hstate = config.hstate;
 	spin_lock_init(&sbinfo->stat_lock);
 	sbinfo->max_inodes = config.nr_inodes;
 	sbinfo->free_inodes = config.nr_inodes;
	sbinfo->spool = NULL;
	if (config.nr_blocks != -1) {
		sbinfo->spool = hugepage_new_subpool(config.nr_blocks);
		if (!sbinfo->spool)
			goto out_free;
	}
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_blocksize = huge_page_size(config.hstate);
 	sb->s_blocksize_bits = huge_page_shift(config.hstate);
  hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_root = root;
 	return 0;
 out_free:
	if (sbinfo->spool)
		kfree(sbinfo->spool);
 	kfree(sbinfo);
 	return -ENOMEM;
 }
 
 static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {","Use-after-free vulnerability in the Linux kernel before 3.3.6, when huge pages are enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges by interacting with a hugetlbfs filesystem, as demonstrated by a umount operation that triggers improper handling of quota data."
36,CVE-2012-2127,"  static struct file_system_type proc_fs_type = {
 
 void __init proc_root_init(void)
 {
 	int err;
 
 	proc_init_inodecache();
 	err = register_filesystem(&proc_fs_type);
 	if (err)
 		return;
	err = pid_ns_prepare_proc(&init_pid_ns);
	if (err) {
 		unregister_filesystem(&proc_fs_type);
 		return;
 	}
 
 	proc_symlink(""mounts"", NULL, ""self/mounts"");
 
 	proc_net_init();
  int pid_ns_prepare_proc(struct pid_namespace *ns)
 
 void pid_ns_release_proc(struct pid_namespace *ns)
 {
	kern_unmount(ns->proc_mnt);
 }","fs/proc/root.c in the procfs implementation in the Linux kernel before 3.2 does not properly interact with CLONE_NEWPID clone system calls, which allows remote attackers to cause a denial of service (reference leak and memory consumption) by making many connections to a daemon that uses PID namespaces to isolate clients, as demonstrated by vsftpd."
37,CVE-2012-2123,"  int cap_bprm_set_creds(struct linux_binprm *bprm)
 	}
 skip:
 
	 
	if (!cap_issubset(new->cap_permitted, old->cap_permitted))
		bprm->per_clear |= PER_CLEAR_ON_SETID;


 	 ","The cap_bprm_set_creds function in security/commoncap.c in the Linux kernel before 3.3.3 does not properly handle the use of file system capabilities (aka fcaps) for implementing a privileged executable file, which allows local users to bypass intended personality restrictions via a crafted application, as demonstrated by an attack that uses a parent process to disable ASLR."
38,CVE-2012-2121,"  void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id);
 
 #ifdef CONFIG_IOMMU_API
 int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot);
void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot);
 int kvm_iommu_map_guest(struct kvm *kvm);
 int kvm_iommu_unmap_guest(struct kvm *kvm);
 int kvm_assign_device(struct kvm *kvm,
  static inline int kvm_iommu_map_pages(struct kvm *kvm,
 	return 0;
 }
 
static inline void kvm_iommu_unmap_pages(struct kvm *kvm,
					 struct kvm_memory_slot *slot)
{
}

 static inline int kvm_iommu_map_guest(struct kvm *kvm)
 {
 	return -ENODEV;","The KVM implementation in the Linux kernel before 3.3.4 does not properly manage the relationships between memory slots and the iommu, which allows guest OS users to cause a denial of service (memory leak and host OS crash) by leveraging administrative access to the guest OS to conduct hotunplug and hotplug operations on devices."
39,CVE-2012-2100,"  static int ext4_fill_flex_info(struct super_block *sb)
 	struct ext4_group_desc *gdp = NULL;
 	ext4_group_t flex_group_count;
 	ext4_group_t flex_group;
	unsigned int groups_per_flex = 0;
 	size_t size;
 	int i;
 
 	sbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;
	if (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {
 		sbi->s_log_groups_per_flex = 0;
 		return 1;
 	}
	groups_per_flex = 1 << sbi->s_log_groups_per_flex;
 
 	 
 	flex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +","The ext4_fill_flex_info function in fs/ext4/super.c in the Linux kernel before 3.2.2, on the x86 platform and unspecified other platforms, allows user-assisted remote attackers to trigger inconsistent filesystem-groups data and possibly cause a denial of service via a malformed ext4 filesystem containing a super block with a large FLEX_BG group size (aka s_log_groups_per_flex value).  NOTE: this vulnerability exists because of an incomplete fix for CVE-2009-4307."
40,CVE-2012-1836,"  looks like this, walks like this or tastes like this.
 #include ""configreader.h""
 #include ""socket.h""
 
#define DN_COMP_BITMASK	0xC000		 

  
 enum QueryInfo
  class DNSRequest
 
 	DNSRequest(DNS* dns, int id, const std::string &original);
 	~DNSRequest();
	DNSInfo ResultIsReady(DNSHeader &h, unsigned length);
 	int SendRequests(const DNSHeader *header, const int length, QueryType qt);
 };
 
  int CachedQuery::CalcTTLRemaining()
  
 DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)
 {
	 
	res = new unsigned char[sizeof(DNSHeader) * 2];
 	*res = 0;
 	orig = original;
 	RequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);
  DNSResult DNS::GetResult()
 }
 
  
DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
 {
	unsigned i = 0, o;
 	int q = 0;
	int curanswer;
 	ResourceRecord rr;
  	unsigned short ptr;
 
  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 
 	switch (rr.type)
 	{
		 
 		case DNS_QUERY_CNAME:
 		case DNS_QUERY_PTR:
 			o = 0;
 			q = 0;
 			while (q == 0 && i < length && o + 256 < 1023)
 			{
				 
 				if (header.payload[i] > 63)
 				{
 					memcpy(&ptr,&header.payload[i],2);

					i = ntohs(ptr);

					 
					if (!(i & DN_COMP_BITMASK))
						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");

					 
					i &= ~DN_COMP_BITMASK;

					 
					i =- 12;
 				}
 				else
 				{
  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 						res[o] = 0;
 						if (o != 0)
 							res[o++] = '.';

						if (o + header.payload[i] > sizeof(DNSHeader))
							return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");

						memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
 						o += header.payload[i];
 						i += header.payload[i] + 1;
 					}
  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)
 			res[o] = 0;
 		break;
 		case DNS_QUERY_AAAA:
			if (rr.rdlength != sizeof(struct in6_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");

 			memcpy(res,&header.payload[i],rr.rdlength);
 			res[rr.rdlength] = 0;
 		break;
 		case DNS_QUERY_A:
			if (rr.rdlength != sizeof(struct in_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");

 			memcpy(res,&header.payload[i],rr.rdlength);
 			res[rr.rdlength] = 0;
 		break;
 		default:
			return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
 		break;
 	}
 	return std::make_pair(res,""No error"");",Heap-based buffer overflow in dns.cpp in InspIRCd 2.0.5 might allow remote attackers to execute arbitrary code via a crafted DNS query that uses compression.
41,CVE-2012-1601,"  static enum hrtimer_restart hlt_timer_fn(struct hrtimer *data)
 
 #define PALE_RESET_ENTRY    0x80000000ffffffb0UL
 
bool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)
{
	return irqchip_in_kernel(vcpu->kcm) == (vcpu->arch.apic != NULL);
}

 int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 {
 	struct kvm_vcpu *v;",The KVM implementation in the Linux kernel before 3.3.6 allows host OS users to cause a denial of service (NULL pointer dereference and host OS crash) by making a KVM_CREATE_IRQCHIP ioctl call after a virtual CPU already exists.
42,CVE-2012-1584,"  ByteVector ByteVector::mid(uint index, uint length) const
 
   ConstIterator endIt;
 
  if(length < size() - index)
     endIt = d->data.begin() + index + length;
   else
     endIt = d->data.end();","Integer overflow in the mid function in toolkit/tbytevector.cpp in TagLib 1.7 and earlier allows context-dependent attackers to cause a denial of service (application crash) via a crafted file header field in a media file, which triggers a large memory allocation."
43,CVE-2012-1583,"  static int xfrm6_tunnel_rcv(struct sk_buff *skb)
 	__be32 spi;
 
 	spi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);
	return xfrm6_rcv_spi(skb, spi) > 0 ? : 0;
 }
 
 static int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,","Double free vulnerability in the xfrm6_tunnel_rcv function in net/ipv6/xfrm6_tunnel.c in the Linux kernel before 2.6.22, when the xfrm6_tunnel module is enabled, allows remote attackers to cause a denial of service (panic) via crafted IPv6 packets."
44,CVE-2012-1571," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")
 #endif
 
 #include <assert.h>
  static union {
 #define CDF_TOLE2(x)	((uint16_t)(NEED_SWAP ? _cdf_tole2(x) : (uint16_t)(x)))
 #define CDF_GETUINT32(x, y)	cdf_getuint32(x, y)
 

  
  ssize_t
 cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,
     size_t len, const cdf_header_t *h, cdf_secid_t id)
 {
	size_t ss = CDF_SHORT_SEC_SIZE(h);
 	size_t pos = CDF_SHORT_SEC_POS(h, id);
 	assert(ss == len);
	if (pos > CDF_SEC_SIZE(h) * sst->sst_len) {
 		DPRINTF((""Out of bounds read %"" SIZE_T_FORMAT ""u > %""
 		    SIZE_T_FORMAT ""u\n"",
		    pos, CDF_SEC_SIZE(h) * sst->sst_len));
 		return -1;
 	}
 	(void)memcpy(((char *)buf) + offs,
  cdf_read_short_sector_chain(const cdf_header_t *h,
     const cdf_sat_t *ssat, const cdf_stream_t *sst,
     cdf_secid_t sid, size_t len, cdf_stream_t *scn)
 {
	size_t ss = CDF_SHORT_SEC_SIZE(h), i, j;
 	scn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));
 	scn->sst_dirlen = len;
 
  cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
 		q = (const uint8_t *)(const void *)
		    ((const char *)(const void *)p + ofs
		    - 2 * sizeof(uint32_t));
 		if (q > e) {
 			DPRINTF((""Ran of the end %p > %p\n"", q, e));
 			goto out;
 		}
 		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
 		inp[i].pi_type = CDF_GETUINT32(q, 0);
		DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"",
		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
 		if (inp[i].pi_type & CDF_VECTOR) {
 			nelements = CDF_GETUINT32(q, 1);
 			o = 2;",file before 5.11 and libmagic allow remote attackers to cause a denial of service (crash) via a crafted Composite Document File (CDF) file that triggers (1) an out-of-bounds read or (2) an invalid pointer dereference.
45,CVE-2012-1179,"  static void mark_screen_rdonly(struct mm_struct *mm)
 	spinlock_t *ptl;
 	int i;
 
	down_write(&mm->mmap_sem);
 	pgd = pgd_offset(mm, 0xA0000);
 	if (pgd_none_or_clear_bad(pgd))
 		goto out;
  static void mark_screen_rdonly(struct mm_struct *mm)
 	}
 	pte_unmap_unlock(pte, ptl);
 out:
	up_write(&mm->mmap_sem);
 	flush_tlb();
 }
 ","The Linux kernel before 3.3.1, when KVM is used, allows guest OS users to cause a denial of service (host OS crash) by leveraging administrative access to the guest OS, related to the pmd_none_or_clear_bad function and page faults for huge pages."
46,CVE-2012-1146,"  static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,
 	 */
 	BUG_ON(!thresholds);
 
	if (!thresholds->primary)
		goto unlock;

 	usage = mem_cgroup_usage(memcg, type == _MEMSWAP);
 
 	 
  static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,
 
 	 
 	synchronize_rcu();
unlock:
 	mutex_unlock(&memcg->thresholds_lock);
 }
 ","The mem_cgroup_usage_unregister_event function in mm/memcontrol.c in the Linux kernel before 3.2.10 does not properly handle multiple events that are attached to the same eventfd, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by registering memory threshold events."
47,CVE-2012-1108,"  void Ogg::XiphComment::parse(const ByteVector &data)
 
    
 
  uint commentFields = data.mid(pos, 4).toUInt(false);
   pos += 4;
 
  if(commentFields > (data.size() - 8) / 4) {
    return;
  }

  for(uint i = 0; i < commentFields; i++) {
 
      
      
 
    uint commentLength = data.mid(pos, 4).toUInt(false);
     pos += 4;
 
     String comment = String(data.mid(pos, commentLength), String::UTF8);
     pos += commentLength;
    if(pos > data.size()) {
      break;
    }
 
     int commentSeparatorPosition = comment.find(""="");
    if(commentSeparatorPosition == -1) {
      break;
    }
 
     String key = comment.substr(0, commentSeparatorPosition);
     String value = comment.substr(commentSeparatorPosition + 1);",The parse function in ogg/xiphcomment.cpp in TagLib 1.7 and earlier allows remote attackers to cause a denial of service (crash) via a crafted vendorLength field in an ogg file.
48,CVE-2012-1107,"  void APE::Properties::analyzeCurrent()
   uint blocksPerFrame = header.mid(4, 4).toUInt(false);
   uint finalFrameBlocks = header.mid(8, 4).toUInt(false);
   uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;
  d->length = d->sampleRate > 0 ? totalBlocks / d->sampleRate : 0;
   d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;
 }
 ","The analyzeCurrent function in ape/apeproperties.cpp in TagLib 1.7 and earlier allows context-dependent attackers to cause a denial of service (application crash) via a crafted sampleRate in an ape file, which triggers a divide-by-zero error."
49,CVE-2012-1097,"  static int fill_thread_core_info(struct elf_thread_core_info *t,
 	for (i = 1; i < view->n; ++i) {
 		const struct user_regset *regset = &view->regsets[i];
 		do_thread_regset_writeback(t->task, regset);
		if (regset->core_note_type && regset->get &&
 		    (!regset->active || regset->active(t->task, regset))) {
 			int ret;
 			size_t size = regset->n * regset->size;","The regset (aka register set) feature in the Linux kernel before 3.2.10 does not properly handle the absence of .get and .set methods, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via a (1) PTRACE_GETREGSET or (2) PTRACE_SETREGSET ptrace call."
50,CVE-2012-1090,"  cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,
 			 * If either that or op not supported returned, follow
 			 * the normal lookup.
 			 */
			switch (rc) {
			case 0:
				 
				if (newInode && !S_ISREG(newInode->i_mode)) {
					CIFSSMBClose(xid, pTcon, fileHandle);
					break;
				}
			case -ENOENT:
 				posix_open = true;
			case -EOPNOTSUPP:
				break;
			default:
 				pTcon->broken_posix_open = true;
			}
 		}
 		if (!posix_open)
 			rc = cifs_get_inode_info_unix(&newInode, full_path,","The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO."
51,CVE-2012-1013,"  check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
     char *password = *passptr;
 
      
    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 ","The check_1_6_dummy function in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) 1.8.x, 1.9.x, and 1.10.x before 1.10.2 allows remote authenticated administrators to cause a denial of service (NULL pointer dereference and daemon crash) via a KRB5_KDB_DISALLOW_ALL_TIX create request that lacks a password."
52,CVE-2012-0957,"  DECLARE_RWSEM(uts_sem);
  * Work around broken programs that cannot handle ""Linux 3.0"".
  * Instead we map 3.x to 2.6.40+x, so e.g. 3.0 would be 2.6.40
  */
static int override_release(char __user *release, size_t len)
 {
 	int ret = 0;
 
 	if (current->personality & UNAME26) {
		const char *rest = UTS_RELEASE;
		char buf[65] = { 0 };
 		int ndots = 0;
 		unsigned v;
		size_t copy;
 
 		while (*rest) {
 			if (*rest == '.' && ++ndots >= 3)
  static int override_release(char __user *release, int len)
 			rest++;
 		}
 		v = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;
		copy = min(sizeof(buf), max_t(size_t, 1, len));
		copy = scnprintf(buf, copy, ""2.6.%u%s"", v, rest);
		ret = copy_to_user(release, buf, copy + 1);
 	}
 	return ret;
 }",The override_release function in kernel/sys.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from kernel stack memory via a uname system call in conjunction with a UNAME26 personality.
53,CVE-2012-0879,"  void exit_io_context(void)
 			ioc->aic->exit(ioc->aic);
 		cfq_exit(ioc);
 
 	}
	put_io_context(ioc);
 }
 
 struct io_context *alloc_io_context(gfp_t gfp_flags, int node)","The I/O implementation for block devices in the Linux kernel before 2.6.33 does not properly handle the CLONE_IO feature, which allows local users to cause a denial of service (I/O instability) by starting multiple processes that share an I/O context."
54,CVE-2012-0863,"  Database::Database() {
 		qWarning(""Database: Database is read-only"");
 	}
 
	{
		QFile f(db.databaseName());
		f.setPermissions(f.permissions() & ~(QFile::ReadGroup | QFile::WriteGroup | QFile::ExeGroup | QFile::ReadOther | QFile::WriteOther | QFile::ExeOther));
	}

 	QSqlQuery query;
 
 	query.exec(QLatin1String(""CREATE TABLE IF NOT EXISTS `servers` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT, `hostname` TEXT, `port` INTEGER DEFAULT "" MUMTEXT(DEFAULT_MUMBLE_PORT) "", `username` TEXT, `password` TEXT)""));","Mumble 1.2.3 and earlier uses world-readable permissions for .local/share/data/Mumble/.mumble.sqlite files in home directories, which might allow local users to obtain a cleartext password and configuration data by reading a file."
55,CVE-2012-0207,"  static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,
 		 * to be intended in a v3 query.
 		 */
 		max_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);
		if (!max_delay)
			max_delay = 1;	 
 	} else {  
 		if (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))
 			return;",The igmp_heard_query function in net/ipv4/igmp.c in the Linux kernel before 3.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and panic) via IGMP packets.
56,CVE-2012-0058,"  static void kiocb_batch_init(struct kiocb_batch *batch, long total)
 	batch->count = total;
 }
 
static void kiocb_batch_free(struct kioctx *ctx, struct kiocb_batch *batch)
 {
 	struct kiocb *req, *n;
 
	if (list_empty(&batch->head))
		return;

	spin_lock_irq(&ctx->ctx_lock);
 	list_for_each_entry_safe(req, n, &batch->head, ki_batch) {
 		list_del(&req->ki_batch);
		list_del(&req->ki_list);
 		kmem_cache_free(kiocb_cachep, req);
		ctx->reqs_active--;
 	}
	spin_unlock_irq(&ctx->ctx_lock);
 }
 
 /*
  long do_io_submit(aio_context_t ctx_id, long nr,
 	}
 	blk_finish_plug(&plug);
 
	kiocb_batch_free(ctx, &batch);
 	put_ioctx(ctx);
 	return i ? i : ret;
 }",The kiocb_batch_free function in fs/aio.c in the Linux kernel before 3.2.2 allows local users to cause a denial of service (OOPS) via vectors that trigger incorrect iocb management.
57,CVE-2012-0045,"  struct x86_emulate_ctxt {
 #define X86EMUL_MODE_PROT     (X86EMUL_MODE_PROT16|X86EMUL_MODE_PROT32| \
 			       X86EMUL_MODE_PROT64)
 
 
#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx 0x68747541
#define X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx 0x444d4163
#define X86EMUL_CPUID_VENDOR_AuthenticAMD_edx 0x69746e65

#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx 0x69444d41
#define X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx 0x21726574
#define X86EMUL_CPUID_VENDOR_AMDisbetterI_edx 0x74656273

#define X86EMUL_CPUID_VENDOR_GenuineIntel_ebx 0x756e6547
#define X86EMUL_CPUID_VENDOR_GenuineIntel_ecx 0x6c65746e
#define X86EMUL_CPUID_VENDOR_GenuineIntel_edx 0x49656e69

 enum x86_intercept_stage {
 	X86_ICTP_NONE = 0,    
 	X86_ICPT_PRE_EXCEPT,","The em_syscall function in arch/x86/kvm/emulate.c in the KVM implementation in the Linux kernel before 3.2.14 does not properly handle the 0f05 (aka syscall) opcode, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application, as demonstrated by an NASM file."
58,CVE-2012-0044,"  int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
 	}
 
 	if (num_clips && clips_ptr) {
		if (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {
			ret = -EINVAL;
			goto out_err1;
		}
 		clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
 		if (!clips) {
 			ret = -ENOMEM;",Integer overflow in the drm_mode_dirtyfb_ioctl function in drivers/gpu/drm/drm_crtc.c in the Direct Rendering Manager (DRM) subsystem in the Linux kernel before 3.1.5 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted ioctl call.
59,CVE-2012-0038,"  xfs_acl_from_disk(struct xfs_acl *aclp)
 	int count, i;
 
 	count = be32_to_cpu(aclp->acl_cnt);
	if (count > XFS_ACL_MAX_ENTRIES)
		return ERR_PTR(-EFSCORRUPTED);
 
 	acl = posix_acl_alloc(count, GFP_KERNEL);
 	if (!acl)","Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow."
60,CVE-2012-0036," 
 #include ""urldata.h""
 #include ""warnless.h""
 #include ""non-ascii.h""
#include ""escape.h""
 
 #define _MPRINTF_REPLACE  
 #include <curl/mprintf.h>
  char *curl_easy_escape(CURL *handle, const char *string, int inlength)
   char *testing_ptr = NULL;
   unsigned char in;  
   size_t newlen = alloc;
  size_t strindex=0;
   size_t length;
   CURLcode res;
 
  char *curl_easy_escape(CURL *handle, const char *string, int inlength)
 }
 
  
CURLcode Curl_urldecode(struct SessionHandle *data,
                        const char *string, size_t length,
                        char **ostring, size_t *olen,
                        bool reject_ctrl)
 {
  size_t alloc = (length?length:strlen(string))+1;
   char *ns = malloc(alloc);
   unsigned char in;
  size_t strindex=0;
   unsigned long hex;
   CURLcode res;
 
   if(!ns)
    return CURLE_OUT_OF_MEMORY;
 
   while(--alloc > 0) {
     in = *string;
  char *curl_easy_unescape(CURL *handle, const char *string, int length,
 
       in = curlx_ultouc(hex);  
 
      res = Curl_convert_from_network(data, &in, 1);
       if(res) {
          
         free(ns);
        return res;
       }
 
       string+=2;
       alloc-=2;
     }
    if(reject_ctrl && (in < 0x20)) {
      free(ns);
      return CURLE_URL_MALFORMAT;
    }
 
     ns[strindex++] = in;
     string++;
  char *curl_easy_unescape(CURL *handle, const char *string, int length,
   if(olen)
      
     *olen = strindex;

  if(ostring)
     
    *ostring = ns;

  return CURLE_OK;
}

 
char *curl_easy_unescape(CURL *handle, const char *string, int length,
                         int *olen)
{
  char *str = NULL;
  size_t inputlen = length;
  size_t outputlen;
  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
                                FALSE);
  if(res)
    return NULL;
  if(olen)
    *olen = curlx_uztosi(outputlen);
  return str;
 }
 
 /* For operating systems/environments that use different malloc/free","curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol."
61,CVE-2012-0028," 
 #include <linux/cn_proc.h>
 #include <linux/mutex.h>
 #include <linux/futex.h>
 #include <linux/pipe_fs_i.h>
 #include <linux/audit.h>  
 #include <linux/resource.h>
  NORET_TYPE void do_exit(long code)
 		exit_itimers(tsk->signal);
 	}
 	acct_collect(code, group_dead);
 	if (group_dead)
 		tty_audit_exit();
 	if (unlikely(tsk->audit_context))","The robust futex implementation in the Linux kernel before 2.6.28 does not properly handle processes that make exec system calls, which allows local users to cause a denial of service or possibly gain privileges by writing to a memory location in a child process."
62,CVE-2011-4914," 
 
 #define	ROSE_MIN_LEN			3
 
#define	ROSE_CALL_REQ_ADDR_LEN_OFF	3
#define	ROSE_CALL_REQ_ADDR_LEN_VAL	0xAA	 
#define	ROSE_CALL_REQ_DEST_ADDR_OFF	4
#define	ROSE_CALL_REQ_SRC_ADDR_OFF	9
#define	ROSE_CALL_REQ_FACILITIES_OFF	14

 #define	ROSE_GFI			0x10
 #define	ROSE_Q_BIT			0x80
 #define	ROSE_D_BIT			0x40
  extern void rose_requeue_frames(struct sock *);
 extern int  rose_validate_nr(struct sock *, unsigned short);
 extern void rose_write_internal(struct sock *, int);
 extern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);
extern int  rose_parse_facilities(unsigned char *, unsigned int, struct rose_facilities_struct *);
 extern void rose_disconnect(struct sock *, int, int, int);
 
  ","The ROSE protocol implementation in the Linux kernel before 2.6.39 does not verify that certain data-length values are consistent with the amount of data sent, which might allow remote attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) via crafted data to a ROSE socket."
63,CVE-2011-4913,"  static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *
 				facilities->source_ndigis = 0;
 				facilities->dest_ndigis   = 0;
 				for (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {
					if (pt[6] & AX25_HBIT) {
						if (facilities->dest_ndigis >= ROSE_MAX_DIGIS)
							return -1;
 						memcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);
					} else {
						if (facilities->source_ndigis >= ROSE_MAX_DIGIS)
							return -1;
 						memcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);
					}
 				}
 			}
 			p   += l + 2;
  static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *fac
 
 		case 0xC0:
 			l = p[1];

			 
			if (l < 10 || l > 20)
				return -1;

 			if (*p == FAC_CCITT_DEST_NSAP) {
 				memcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);
 				memcpy(callsign, p + 12,   l - 10);
  int rose_parse_facilities(unsigned char *p,
 			switch (*p) {
 			case FAC_NATIONAL:		 
 				len = rose_parse_national(p + 1, facilities, facilities_len - 1);
				if (len < 0)
					return 0;
 				facilities_len -= len + 1;
 				p += len + 1;
 				break;
 
 			case FAC_CCITT:		 
 				len = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);
				if (len < 0)
					return 0;
 				facilities_len -= len + 1;
 				p += len + 1;
 				break;","The rose_parse_ccitt function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 does not validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields, which allows remote attackers to (1) cause a denial of service (integer underflow, heap memory corruption, and panic) via a small length value in data sent to a ROSE socket, or (2) conduct stack-based buffer overflow attacks via a large length value in data sent to a ROSE socket."
64,CVE-2011-4621,"  static struct task_struct *dup_task_struct(struct task_struct *orig)
 
 	setup_thread_stack(tsk, orig);
 	clear_user_return_notifier(tsk);
	clear_tsk_need_resched(tsk);
 	stackend = end_of_stack(tsk);
 	*stackend = STACK_END_MAGIC;	 
 ","The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop."
65,CVE-2011-4611," 
 #define PV_970		0x0039
 #define PV_POWER5	0x003A
 #define PV_POWER5p	0x003B
#define PV_POWER7	0x003F
 #define PV_970FX	0x003C
 #define PV_630		0x0040
 #define PV_630p	0x0041",Integer overflow in the perf_event_interrupt function in arch/powerpc/kernel/perf_event.c in the Linux kernel before 2.6.39 on powerpc platforms allows local users to cause a denial of service (unhandled performance monitor exception) via vectors that trigger certain outcomes of performance events.
66,CVE-2011-4594,"  static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
 	 * used_address->name_len is initialized to UINT_MAX so that the first
 	 * destination address never matches.
 	 */
	if (used_address && msg_sys->msg_name &&
	    used_address->name_len == msg_sys->msg_namelen &&
	    !memcmp(&used_address->name, msg_sys->msg_name,
 		    used_address->name_len)) {
 		err = sock_sendmsg_nosec(sock, msg_sys, total_len);
 		goto out_freectl;
  static int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
 	 */
 	if (used_address && err >= 0) {
 		used_address->name_len = msg_sys->msg_namelen;
		if (msg_sys->msg_name)
			memcpy(&used_address->name, msg_sys->msg_name,
			       used_address->name_len);
 	}
 
 out_freectl:","The __sys_sendmsg function in net/socket.c in the Linux kernel before 3.1 allows local users to cause a denial of service (system crash) via crafted use of the sendmmsg system call, leading to an incorrect pointer dereference."
67,CVE-2011-4326,"  static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)
 	skb->ip_summed = CHECKSUM_NONE;
 
 	 
	if ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&
 	    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))
 		goto out;
 ","The udp6_ufo_fragment function in net/ipv6/udp.c in the Linux kernel before 2.6.39, when a certain UDP Fragmentation Offload (UFO) configuration is enabled, allows remote attackers to cause a denial of service (system crash) by sending fragmented IPv6 UDP packets to a bridge device."
68,CVE-2011-4324,"  static void nfs_file_set_open_context(struct file *filp, struct nfs_open_context
  
struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)
 {
 	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_open_context *pos, *ctx = NULL;",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
69,CVE-2011-4131,"  static inline int nfs4_server_supports_acls(struct nfs_server *server)
  */
 #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)
 
 static int buf_to_pages_noslab(const void *buf, size_t buflen,
 		struct page **pages, unsigned int *pgbase)
 {
  static void nfs4_write_cached_acl(struct inode *inode, const char *buf, size_t a
 	nfs4_set_cached_acl(inode, acl);
 }
 
 
 static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)
 {
	struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };
 	struct nfs_getaclargs args = {
 		.fh = NFS_FH(inode),
 		.acl_pages = pages,
  static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu
 		.rpc_argp = &args,
 		.rpc_resp = &res,
 	};
	int ret = -ENOMEM, npages, i, acl_len = 0;
 
	npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;
	 
	if (npages == 0)
		npages = 1;

	for (i = 0; i < npages; i++) {
		pages[i] = alloc_page(GFP_KERNEL);
		if (!pages[i])
			goto out_free;
	}
	if (npages > 1) {
		 
		args.acl_scratch = alloc_page(GFP_KERNEL);
		if (!args.acl_scratch)
			goto out_free;
 	}
	args.acl_len = npages * PAGE_SIZE;
	args.acl_pgbase = 0;
	 
	if (buf == NULL)
		res.acl_flags |= NFS4_ACL_LEN_REQUEST;
	resp_buf = page_address(pages[0]);

	dprintk(""%s  buf %p buflen %ld npages %d args.acl_len %ld\n"",
		__func__, buf, buflen, npages, args.acl_len);
	ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),
			     &msg, &args.seq_args, &res.seq_res, 0);
 	if (ret)
 		goto out_free;

	acl_len = res.acl_len - res.acl_data_offset;
	if (acl_len > args.acl_len)
		nfs4_write_cached_acl(inode, NULL, acl_len);
 	else
		nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,
				      acl_len);
 	if (buf) {
 		ret = -ERANGE;
		if (acl_len > buflen)
 			goto out_free;
		_copy_from_pages(buf, pages, res.acl_data_offset,
				res.acl_len);
 	}
	ret = acl_len;
 out_free:
	for (i = 0; i < npages; i++)
		if (pages[i])
			__free_page(pages[i]);
	if (args.acl_scratch)
		__free_page(args.acl_scratch);
 	return ret;
 }
 
  static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)
 		nfs_zap_acl_cache(inode);
 	ret = nfs4_read_cached_acl(inode, buf, buflen);
 	if (ret != -ENOENT)
		 
 		return ret;
 	return nfs4_get_acl_uncached(inode, buf, buflen);
 }","The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words."
70,CVE-2011-4127,"  static int flakey_status(struct dm_target *ti, status_type_t type,
 static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)
 {
 	struct flakey_c *fc = ti->private;
	struct dm_dev *dev = fc->dev;
	int r = 0;
 
	 
	if (fc->start ||
	    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)
		r = scsi_verify_blk_ioctl(NULL, cmd);

	return r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);
 }
 
 static int flakey_merge(struct dm_target *ti, struct bvec_merge_data *bvm,","The Linux kernel before 3.2.2 does not properly restrict SG_IO ioctl calls, which allows local users to bypass intended restrictions on disk read and write operations by sending a SCSI command to (1) a partition block device or (2) an LVM volume."
71,CVE-2011-4112,"  static void _isdn_setup(struct net_device *dev)
 
 	 
 	dev->flags = IFF_NOARP|IFF_POINTOPOINT;

	 
	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev->header_ops = NULL;
 	dev->netdev_ops = &isdn_netdev_ops;
 ","The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface."
72,CVE-2011-4097,"  static bool oom_unkillable_task(struct task_struct *p,
 unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,
 		      const nodemask_t *nodemask, unsigned long totalpages)
 {
	long points;
 
 	if (oom_unkillable_task(p, mem, nodemask))
 		return 0;",Integer overflow in the oom_badness function in mm/oom_kill.c in the Linux kernel before 3.1.8 on 64-bit platforms allows local users to cause a denial of service (memory consumption or process termination) by using a certain large amount of memory.
73,CVE-2011-4086,"  static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)
 	clear_buffer_mapped(bh);
 	clear_buffer_req(bh);
 	clear_buffer_new(bh);
	clear_buffer_delay(bh);
	clear_buffer_unwritten(bh);
 	bh->b_bdev = NULL;
 	return may_free;
 }","The journal_unmap_buffer function in fs/jbd2/transaction.c in the Linux kernel before 3.3.1 does not properly handle the _Delay and _Unwritten buffer head states, which allows local users to cause a denial of service (system crash) by leveraging the presence of an ext4 filesystem that was mounted with a journal."
74,CVE-2011-4081,"  static int ghash_update(struct shash_desc *desc,
 	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
 	u8 *dst = dctx->buffer;
 
	if (!ctx->gf128)
		return -ENOKEY;

 	if (dctx->bytes) {
 		int n = min(srclen, dctx->bytes);
 		u8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);
  static int ghash_final(struct shash_desc *desc, u8 *dst)
 	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
 	u8 *buf = dctx->buffer;
 
	if (!ctx->gf128)
		return -ENOKEY;

 	ghash_flush(ctx, dctx);
 	memcpy(dst, buf, GHASH_BLOCK_SIZE);
 ","crypto/ghash-generic.c in the Linux kernel before 3.1 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by triggering a failed or missing ghash_setkey function call, followed by a (1) ghash_update function call or (2) ghash_final function call, as demonstrated by a write operation on an AF_ALG socket."
75,CVE-2011-4080,"  static int proc_taint(struct ctl_table *table, int write,
 			       void __user *buffer, size_t *lenp, loff_t *ppos);
 #endif
 
#ifdef CONFIG_PRINTK
static int proc_dmesg_restrict(struct ctl_table *table, int write,
				void __user *buffer, size_t *lenp, loff_t *ppos);
#endif

 #ifdef CONFIG_MAGIC_SYSRQ
  
 static int __sysrq_enabled = SYSRQ_DEFAULT_ENABLE;
  static struct ctl_table kern_table[] = {
 		.data		= &kptr_restrict,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
		.proc_handler	= proc_dmesg_restrict,
 		.extra1		= &zero,
 		.extra2		= &two,
 	},
  static int proc_taint(struct ctl_table *table, int write,
 	return err;
 }
 
#ifdef CONFIG_PRINTK
static int proc_dmesg_restrict(struct ctl_table *table, int write,
				void __user *buffer, size_t *lenp, loff_t *ppos)
{
	if (write && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
}
#endif

 struct do_proc_dointvec_minmax_conv_param {
 	int *min;
 	int *max;","The sysrq_sysctl_handler function in kernel/sysctl.c in the Linux kernel before 2.6.39 does not require the CAP_SYS_ADMIN capability to modify the dmesg_restrict value, which allows local users to bypass intended access restrictions and read the kernel ring buffer by leveraging root privileges, as demonstrated by a root user in a Linux Containers (aka LXC) environment."
76,CVE-2011-3637,"  static void m_stop(struct seq_file *m, void *v)
 	struct proc_maps_private *priv = m->private;
 	struct vm_area_struct *vma = v;
 
	if (!IS_ERR(vma))
		vma_stop(priv, vma);
 	if (priv->task)
 		put_task_struct(priv->task);
 }",The m_stop function in fs/proc/task_mmu.c in the Linux kernel before 2.6.39 allows local users to cause a denial of service (OOPS) via vectors that trigger an m_start error.
77,CVE-2011-3363,"  cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
 
 remote_path_check:
 	 
	if (!rc && tcon) {
 		 
 		full_path = cifs_build_path_to_root(cifs_sb, tcon);
 		if (full_path == NULL) {","The setup_cifs_sb function in fs/cifs/connect.c in the Linux kernel before 2.6.39 does not properly handle DFS referrals, which allows remote CIFS servers to cause a denial of service (system crash) by placing a referral at the root of a share."
78,CVE-2011-3359,"  static void dma_rx(struct b43_dmaring *ring, int *slot)
 		dmaaddr = meta->dmaaddr;
 		goto drop_recycle_buffer;
 	}
	if (unlikely(len + ring->frameoffset > ring->rx_buffersize)) {
 		/* The data did not fit into one descriptor buffer
 		 * and is split over multiple buffers.
 		 * This should never happen, as we try to allocate buffers","The dma_rx function in drivers/net/wireless/b43/dma.c in the Linux kernel before 2.6.39 does not properly allocate receive buffers, which allows remote attackers to cause a denial of service (system crash) via a crafted frame."
79,CVE-2011-3353,"  static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,
 	if (outarg.namelen > FUSE_NAME_MAX)
 		goto err;
 
	err = -EINVAL;
	if (size != sizeof(outarg) + outarg.namelen + 1)
		goto err;

 	name.name = buf;
 	name.len = outarg.namelen;
 	err = fuse_copy_one(cs, buf, outarg.namelen + 1);",Buffer overflow in the fuse_notify_inval_entry function in fs/fuse/dev.c in the Linux kernel before 3.1 allows local users to cause a denial of service (BUG_ON and system crash) by leveraging the ability to mount a FUSE filesystem.
80,CVE-2011-3209,"  typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
 #include <linux/module.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
#include <linux/math64.h>
 
 #define elf_prstatus elf_prstatus32
 struct elf_prstatus32
  jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)
 	 * one divide.
 	 */
 	u64 nsec = (u64)jiffies * TICK_NSEC;
	u32 rem;
	value->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);
 	value->tv_usec = rem / NSEC_PER_USEC;
 }
 ",The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.
81,CVE-2011-3191,"  int CIFSFindNext(const int xid, struct cifs_tcon *tcon,
 	T2_FNEXT_RSP_PARMS *parms;
 	char *response_data;
 	int rc = 0;
	int bytes_returned;
	unsigned int name_len;
 	__u16 params, byte_count;
 
 	cFYI(1, ""In FindNext"");",Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory.
82,CVE-2011-3188,"  ctl_table random_table[] = {
 };
 #endif 	 
 
static u32 random_int_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;
 
static int __init random_int_secret_init(void)
 {
	get_random_bytes(random_int_secret, sizeof(random_int_secret));
 	return 0;
 }
late_initcall(random_int_secret_init);
 
  
DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
 unsigned int get_random_int(void)
 {
 	__u32 *hash = get_cpu_var(get_random_int_hash);
	unsigned int ret;
 
 	hash[0] += current->pid + jiffies + get_cycles();
	md5_transform(hash, random_int_secret);
	ret = hash[0];
 	put_cpu_var(get_random_int_hash);
 
 	return ret;","The (1) IPv4 and (2) IPv6 implementations in the Linux kernel before 3.1 use a modified MD4 algorithm to generate sequence numbers and Fragment Identification values, which makes it easier for remote attackers to cause a denial of service (disrupted networking) or hijack network sessions by predicting these values and sending crafted packets."
83,CVE-2011-2918,"  static void alpha_perf_event_irq_handler(unsigned long la_ptr,
 	data.period = event->hw.last_period;
 
 	if (alpha_perf_event_set_period(event, hwc, idx)) {
		if (perf_event_overflow(event, &data, regs)) {
 			 ","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
84,CVE-2011-2906,"  static long pmcraid_ioctl_passthrough(
 			pmcraid_err(""couldn't build passthrough ioadls\n"");
 			goto out_free_buffer;
 		}
	} else if (request_size < 0) {
		rc = -EINVAL;
		goto out_free_buffer;
 	}
 
 	/* If data is being written into the device, copy the data from user",** DISPUTED ** Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call.  NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor.
85,CVE-2011-2898,"  struct tpacket_auxdata {
 	__u16		tp_mac;
 	__u16		tp_net;
 	__u16		tp_vlan_tci;
	__u16		tp_padding;
 };
 
  
  struct tpacket2_hdr {
 	__u32		tp_sec;
 	__u32		tp_nsec;
 	__u16		tp_vlan_tci;
	__u16		tp_padding;
 };
 
 #define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))","net/packet/af_packet.c in the Linux kernel before 2.6.39.3 does not properly restrict user-space access to certain packet data structures associated with VLAN Tag Control Information, which allows local users to obtain potentially sensitive information via a crafted application."
86,CVE-2011-2707,"  int ptrace_setxregs(struct task_struct *child, void __user *uregs)
 	elf_xtregs_t *xtregs = uregs;
 	int ret = 0;
 
	if (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))
		return -EFAULT;

 #if XTENSA_HAVE_COPROCESSORS
 	 
 	coprocessor_flush_all(ti);","The ptrace_setxregs function in arch/xtensa/kernel/ptrace.c in the Linux kernel before 3.1 does not validate user-space pointers, which allows local users to obtain sensitive information from kernel memory locations via a crafted PTRACE_SETXTREGS request."
87,CVE-2011-2699,"  __u32 secure_ip_id(__be32 daddr)
 	return half_md4_transform(hash, keyptr->secret);
 }
 
__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];

	keyptr = get_keyptr();

	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];

	return half_md4_transform(hash, keyptr->secret);
}

 #ifdef CONFIG_INET
 
 __u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,","The IPv6 implementation in the Linux kernel before 3.1 does not generate Fragment Identification values separately for each destination, which makes it easier for remote attackers to cause a denial of service (disrupted networking) by predicting these values and sending crafted packets."
88,CVE-2011-2521,"  static inline void x86_assign_hw_event(struct perf_event *event,
 		hwc->event_base	= 0;
 	} else if (hwc->idx >= X86_PMC_IDX_FIXED) {
 		hwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;
		hwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);
 	} else {
 		hwc->config_base = x86_pmu_config_addr(hwc->idx);
 		hwc->event_base  = x86_pmu_event_addr(hwc->idx);","The x86_assign_hw_event function in arch/x86/kernel/cpu/perf_event.c in the Performance Events subsystem in the Linux kernel before 2.6.39 does not properly calculate counter values, which allows local users to cause a denial of service (panic) via the perf program."
89,CVE-2011-2518,"  static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
 	}
 	if (need_dev) {
 		 
		if (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {
 			error = -ENOENT;
 			goto out;
 		}","The tomoyo_mount_acl function in security/tomoyo/mount.c in the Linux kernel before 2.6.39.2 calls the kern_path function with arguments taken directly from a mount system call, which allows local users to cause a denial of service (OOPS) or possibly have unspecified other impact via a NULL value for the device name."
90,CVE-2011-2517,"  static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 	i = 0;
 	if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {
 		nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {
			request->ssids[i].ssid_len = nla_len(attr);
 			if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {
 				err = -EINVAL;
 				goto out_free;
 			}
 			memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));
 			i++;
 		}
 	}
  static int nl80211_start_sched_scan(struct sk_buff *skb,
 	if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {
 		nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],
 				    tmp) {
			request->ssids[i].ssid_len = nla_len(attr);
 			if (request->ssids[i].ssid_len >
 			    IEEE80211_MAX_SSID_LEN) {
 				err = -EINVAL;
 				goto out_free;
 			}
 			memcpy(request->ssids[i].ssid, nla_data(attr),
 			       nla_len(attr));
 			i++;
 		}
 	}",Multiple buffer overflows in net/wireless/nl80211.c in the Linux kernel before 2.6.39.2 allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability during scan operations with a long SSID value.
91,CVE-2011-2496,"  static struct vm_area_struct *vma_to_resize(unsigned long addr,
 	if (old_len > vma->vm_end - addr)
 		goto Efault;
 
	 
	if (new_len > old_len) {
		unsigned long pgoff;

		if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))
 			goto Efault;
		pgoff = (addr - vma->vm_start) >> PAGE_SHIFT;
		pgoff += vma->vm_pgoff;
		if (pgoff + (new_len >> PAGE_SHIFT) < pgoff)
			goto Einval;
 	}
 
 	if (vma->vm_flags & VM_LOCKED) {",Integer overflow in the vma_to_resize function in mm/mremap.c in the Linux kernel before 2.6.39 allows local users to cause a denial of service (BUG_ON and system crash) via a crafted mremap system call that expands a memory mapping.
92,CVE-2011-2495,"  static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
 	struct task_io_accounting acct = task->ioac;
 	unsigned long flags;
 
	if (!ptrace_may_access(task, PTRACE_MODE_READ))
		return -EACCES;

 	if (whole && lock_task_sighand(task, &flags)) {
 		struct task_struct *t = task;
 
  static const struct pid_entry tgid_base_stuff[] = {
 	REG(""coredump_filter"", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
	INF(""io"",	S_IRUSR, proc_tgid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),
  static const struct pid_entry tid_base_stuff[] = {
 	REG(""make-it-fail"", S_IRUGO|S_IWUSR, proc_fault_inject_operations),
 #endif
 #ifdef CONFIG_TASK_IO_ACCOUNTING
	INF(""io"",	S_IRUSR, proc_tid_io_accounting),
 #endif
 #ifdef CONFIG_HARDWALL
 	INF(""hardwall"",   S_IRUGO, proc_pid_hardwall),","fs/proc/base.c in the Linux kernel before 2.6.39.4 does not properly restrict access to /proc/#####/io files, which allows local users to obtain sensitive I/O statistics by polling a file, as demonstrated by discovering the length of another user's password."
93,CVE-2011-2494,"  static struct genl_ops taskstats_ops = {
 	.cmd		= TASKSTATS_CMD_GET,
 	.doit		= taskstats_user_cmd,
 	.policy		= taskstats_cmd_get_policy,
	.flags		= GENL_ADMIN_PERM,
 };
 
 static struct genl_ops cgroupstats_ops = {","kernel/taskstats.c in the Linux kernel before 3.1 allows local users to obtain sensitive I/O statistics by sending taskstats commands to a netlink socket, as demonstrated by discovering the length of another user's password."
94,CVE-2011-2493,"  static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	get_random_bytes(&sbi->s_next_generation, sizeof(u32));
 	spin_lock_init(&sbi->s_next_gen_lock);
 
	init_timer(&sbi->s_err_report);
	sbi->s_err_report.function = print_daily_error_info;
	sbi->s_err_report.data = (unsigned long) sb;

 	err = percpu_counter_init(&sbi->s_freeblocks_counter,
 			ext4_count_free_blocks(sb));
 	if (!err) {
  static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		 ""Opts: %s%s%s"", descr, sbi->s_es->s_mount_opts,
 		 *sbi->s_es->s_mount_opts ? ""; "" : """", orig_data);
 
 	if (es->s_error_count)
 		mod_timer(&sbi->s_err_report, jiffies + 300*HZ);  
 
  static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		sbi->s_journal = NULL;
 	}
 failed_mount3:
	del_timer(&sbi->s_err_report);
 	if (sbi->s_flex_groups) {
 		if (is_vmalloc_addr(sbi->s_flex_groups))
 			vfree(sbi->s_flex_groups);","The ext4_fill_super function in fs/ext4/super.c in the Linux kernel before 2.6.39 does not properly initialize a certain error-report data structure, which allows local users to cause a denial of service (OOPS) by attempting to mount a crafted ext4 filesystem."
95,CVE-2011-2486,"  int rpc_type_of_NPNVariable(int variable)
   case NPNVisOfflineBool:
   case NPNVSupportsXEmbedBool:
   case NPNVSupportsWindowless:
  case NPNVprivateModeBool:
  case NPNVsupportsAdvancedKeyHandling:
 	type = RPC_TYPE_BOOLEAN;
 	break;
   case NPNVToolkit:
  int rpc_type_of_NPPVariable(int variable)
   case NPPVpluginNameString:
   case NPPVpluginDescriptionString:
   case NPPVformValue:  
  case NPPVpluginNativeAccessibleAtkPlugId:
 	type = RPC_TYPE_STRING;
 	break;
   case NPPVpluginWindowSize:
  int rpc_type_of_NPPVariable(int variable)
   case NPPVpluginTransparentBool:
   case NPPVjavascriptPushCallerBool:
   case NPPVpluginKeepLibraryInMemory:
  case NPPVpluginUrlRequestsDisplayedBool:
  case NPPVpluginWantsAllNetworkStreams:
  case NPPVpluginCancelSrcStream:
  case NPPVSupportsAdvancedKeyHandling:
 	type = RPC_TYPE_BOOLEAN;
 	break;
   case NPPVpluginScriptableNPObject:","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash."
96,CVE-2011-2211,"  SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)
 		return -EFAULT;
 
 	len = namelen;
	if (len > 32)
 		len = 32;
 
 	down_read(&uts_sem);
  SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)
 	down_read(&uts_sem);
 	res = sysinfo_table[offset];
 	len = strlen(res)+1;
	if ((unsigned long)len > (unsigned long)count)
 		len = count;
 	if (copy_to_user(buf, res, len))
 		err = -EFAULT;
  SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,
 		return 1;
 
 	case GSI_GET_HWRPB:
		if (nbytes > sizeof(*hwrpb))
 			return -EINVAL;
 		if (copy_to_user(buffer, hwrpb, nbytes) != 0)
 			return -EFAULT;
  SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,
 {
 	struct rusage r;
 	long ret, err;
	unsigned int status = 0;
 	mm_segment_t old_fs;
 
 	if (!ur)
  SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,
 	old_fs = get_fs();
 		
 	set_fs (KERNEL_DS);
	ret = sys_wait4(pid, (unsigned int __user *) &status, options,
			(struct rusage __user *) &r);
 	set_fs (old_fs);
 
 	if (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))
 		return -EFAULT;
 
 	err = 0;
	err |= put_user(status, ustatus);
 	err |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);
 	err |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);
 	err |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);","The osf_wait4 function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform uses an incorrect pointer, which allows local users to gain privileges by writing a certain integer value to kernel memory."
97,CVE-2011-2183,"  static struct rmap_item *scan_get_next_rmap_item(struct page **page)
 		slot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);
 		ksm_scan.mm_slot = slot;
 		spin_unlock(&ksm_mmlist_lock);
		 
		if (slot == &ksm_mm_head)
			return NULL;
 next_mm:
 		ksm_scan.address = 0;
 		ksm_scan.rmap_list = &slot->rmap_list;","Race condition in the scan_get_next_rmap_item function in mm/ksm.c in the Linux kernel before 2.6.39.3, when Kernel SamePage Merging (KSM) is enabled, allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via a crafted application."
98,CVE-2011-2182,"  static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)
 
 	list_add_tail (&f->list, frags);
 found:
	if (rec >= f->num) {
		ldm_error(""REC value (%d) exceeds NUM value (%d)"", rec, f->num);
		return false;
	}

 	if (f->map & (1 << rec)) {
 		ldm_error (""Duplicate VBLK, part %d."", rec);
 		f->map &= 0x7F;			 ","The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017."
99,CVE-2011-1927,"  static void ip_expire(unsigned long arg)
 
 	if ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {
 		struct sk_buff *head = qp->q.fragments;
		const struct iphdr *iph;
		int err;
 
 		rcu_read_lock();
 		head->dev = dev_get_by_index_rcu(net, qp->iif);
 		if (!head->dev)
 			goto out_rcu_unlock;
 
		 
		skb_dst_drop(head);
		iph = ip_hdr(head);
		err = ip_route_input_noref(head, iph->daddr, iph->saddr,
					   iph->tos, head->dev);
		if (err)
			goto out_rcu_unlock;

 		 
		if (qp->user == IP_DEFRAG_CONNTRACK_IN &&
		    skb_rtable(head)->rt_type != RTN_LOCAL)
			goto out_rcu_unlock;
 
 
 		 
 		icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);","The ip_expire function in net/ipv4/ip_fragment.c in the Linux kernel before 2.6.39 does not properly construct ICMP_TIME_EXCEEDED packets after a timeout, which allows remote attackers to cause a denial of service (invalid pointer dereference) via crafted fragmented packets."
100,CVE-2011-1833,"  enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,
        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,
        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,
        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,
       ecryptfs_opt_check_dev_ruid,
        ecryptfs_opt_err };
 
 static const match_table_t tokens = {
  static const match_table_t tokens = {
 	{ecryptfs_opt_fn_cipher_key_bytes, ""ecryptfs_fn_key_bytes=%u""},
 	{ecryptfs_opt_unlink_sigs, ""ecryptfs_unlink_sigs""},
 	{ecryptfs_opt_mount_auth_tok_only, ""ecryptfs_mount_auth_tok_only""},
	{ecryptfs_opt_check_dev_ruid, ""ecryptfs_check_dev_ruid""},
 	{ecryptfs_opt_err, NULL}
 };
 
  static void ecryptfs_init_mount_crypt_stat(
  * ecryptfs_parse_options
  * @sb: The ecryptfs super block
  * @options: The options passed to the kernel
 * @check_ruid: set to 1 if device uid should be checked against the ruid
  *
  * Parse mount options:
  * debug=N 	   - ecryptfs_verbosity level for debug output
  static void ecryptfs_init_mount_crypt_stat(
  *
  * Returns zero on success; non-zero on error
  */
static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,
				  uid_t *check_ruid)
 {
 	char *p;
 	int rc = 0;
  static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 	char *cipher_key_bytes_src;
 	char *fn_cipher_key_bytes_src;
 
	*check_ruid = 0;

 	if (!options) {
 		rc = -EINVAL;
 		goto out;
  static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)
 			mount_crypt_stat->flags |=
 				ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;
 			break;
		case ecryptfs_opt_check_dev_ruid:
			*check_ruid = 1;
			break;
 		case ecryptfs_opt_err:
 		default:
 			printk(KERN_WARNING
  static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	const char *err = ""Getting sb failed"";
 	struct inode *inode;
 	struct path path;
	uid_t check_ruid;
 	int rc;
 
 	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
  static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 		goto out;
 	}
 
	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
 	if (rc) {
 		err = ""Error parsing options"";
 		goto out;
  static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 			""known incompatibilities\n"");
 		goto out_free;
 	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

 	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;",Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.
101,CVE-2011-1768,"  static int __init ipip_init(void)
 
 	printk(banner);
 
	err = register_pernet_device(&ipip_net_ops);
	if (err < 0)
		return err;
	err = xfrm4_tunnel_register(&ipip_handler, AF_INET);
	if (err < 0) {
		unregister_pernet_device(&ipip_net_ops);
 		printk(KERN_INFO ""ipip init: can't register tunnel\n"");
 	}
 	return err;
 }
 ","The tunnels implementation in the Linux kernel before 2.6.34, when tunnel functionality is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."
102,CVE-2011-1767,"  static int __init ipgre_init(void)
 
 	printk(KERN_INFO ""GRE over IPv4 tunneling driver\n"");
 
 	err = register_pernet_device(&ipgre_net_ops);
 	if (err < 0)
		return err;

	err = inet_add_protocol(&ipgre_protocol, IPPROTO_GRE);
	if (err < 0) {
		printk(KERN_INFO ""ipgre init: can't add protocol\n"");
		goto add_proto_failed;
	}
 
 	err = rtnl_link_register(&ipgre_link_ops);
 	if (err < 0)
  static int __init ipgre_init(void)
 tap_ops_failed:
 	rtnl_link_unregister(&ipgre_link_ops);
 rtnl_link_failed:
 	inet_del_protocol(&ipgre_protocol, IPPROTO_GRE);
add_proto_failed:
	unregister_pernet_device(&ipgre_net_ops);
 	goto out;
 }
 
 static void __exit ipgre_fini(void)
 {
 	rtnl_link_unregister(&ipgre_tap_ops);
 	rtnl_link_unregister(&ipgre_link_ops);
 	if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)
 		printk(KERN_INFO ""ipgre close: can't remove protocol\n"");
	unregister_pernet_device(&ipgre_net_ops);
 }
 
 module_init(ipgre_init);","net/ipv4/ip_gre.c in the Linux kernel before 2.6.34, when ip_gre is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."
103,CVE-2011-1759,"  asmlinkage long sys_oabi_semtimedop(int semid,
 	long err;
 	int i;
 
	if (nsops < 1 || nsops > SEMOPM)
 		return -EINVAL;
 	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
 	if (!sops)","Integer overflow in the sys_oabi_semtimedop function in arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 2.6.39 on the ARM platform, when CONFIG_OABI_COMPAT is enabled, allows local users to gain privileges or cause a denial of service (heap memory corruption) by providing a crafted argument and leveraging a race condition."
104,CVE-2011-1479,"  static void inotify_free_group_priv(struct fsnotify_group *group)
 	idr_for_each(&group->inotify_data.idr, idr_callback, group);
 	idr_remove_all(&group->inotify_data.idr);
 	idr_destroy(&group->inotify_data.idr);
	atomic_dec(&group->inotify_data.user->inotify_devs);
 	free_uid(group->inotify_data.user);
 }
 ",Double free vulnerability in the inotify subsystem in the Linux kernel before 2.6.39 allows local users to cause a denial of service (system crash) via vectors involving failed attempts to create files.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-4250.
105,CVE-2011-1477,"  static int opl3_load_patch(int dev, int format, const char __user *addr,
 
 static void opl3_panning(int dev, int voice, int value)
 {

	if (voice < 0 || voice >= devc->nr_voice)
		return;

 	devc->voc[voice].panning = value;
 }
 
  static int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info
 
 static void opl3_setup_voice(int dev, int voice, int chn)
 {
	struct channel_info *info;

	if (voice < 0 || voice >= devc->nr_voice)
		return;

	if (chn < 0 || chn > 15)
		return;

	info = &synth_devs[dev]->chn_info[chn];
 
 	opl3_set_instr(dev, voice, info->pgm_num);
 ",Multiple array index errors in sound/oss/opl3.c in the Linux kernel before 2.6.39 allow local users to cause a denial of service (heap memory corruption) or possibly gain privileges by leveraging write access to /dev/sequencer.
106,CVE-2011-1476,"  struct synth_operations
 	void (*reset) (int dev);
 	void (*hw_control) (int dev, unsigned char *event);
 	int (*load_patch) (int dev, int format, const char __user *addr,
	     int count, int pmgr_flag);
 	void (*aftertouch) (int dev, int voice, int pressure);
 	void (*controller) (int dev, int voice, int ctrl_num, int value);
 	void (*panning) (int dev, int voice, int value);",Integer underflow in the Open Sound System (OSS) subsystem in the Linux kernel before 2.6.39 on unspecified non-x86 platforms allows local users to cause a denial of service (memory corruption) by leveraging write access to /dev/sequencer.
107,CVE-2011-1160,"  int tpm_open(struct inode *inode, struct file *file)
 		return -EBUSY;
 	}
 
	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
 	if (chip->data_buffer == NULL) {
 		clear_bit(0, &chip->is_open);
 		put_device(chip->dev);","The tpm_open function in drivers/char/tpm/tpm.c in the Linux kernel before 2.6.39 does not initialize a certain buffer, which allows local users to obtain potentially sensitive information from kernel memory via unspecified vectors."
108,CVE-2011-1080,"  static int do_replace(struct net *net, const void __user *user,
 	if (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))
 		return -ENOMEM;
 
	tmp.name[sizeof(tmp.name) - 1] = 0;

 	countersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;
 	newinfo = vmalloc(sizeof(*newinfo) + countersize);
 	if (!newinfo)","The do_replace function in net/bridge/netfilter/ebtables.c in the Linux kernel before 2.6.39 does not ensure that a certain name field ends with a '0' character, which allows local users to obtain potentially sensitive information from kernel stack memory by leveraging the CAP_NET_ADMIN capability to replace a table, and then reading a modprobe command line."
109,CVE-2011-1079,"  static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long
 			sockfd_put(nsock);
 			return -EBADFD;
 		}
		ca.device[sizeof(ca.device)-1] = 0;
 
 		err = bnep_add_connection(&ca, nsock);
 		if (!err) {","The bnep_sock_ioctl function in net/bluetooth/bnep/sock.c in the Linux kernel before 2.6.39 does not ensure that a certain device field ends with a '0' character, which allows local users to obtain potentially sensitive information from kernel stack memory, or cause a denial of service (BUG and system crash), via a BNEPCONNADD command."
110,CVE-2011-1078,"  static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user
 			break;
 		}
 
		memset(&cinfo, 0, sizeof(cinfo));
 		cinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;
 		memcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);
 ","The sco_sock_getsockopt_old function in net/bluetooth/sco.c in the Linux kernel before 2.6.39 does not initialize a certain structure, which allows local users to obtain potentially sensitive information from kernel stack memory via the SCO_CONNINFO option."
111,CVE-2011-1023,"  int rds_ib_xmit(struct rds_connection *conn, struct rds_message *rm,
 	if (conn->c_loopback
 	    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {
 		rds_cong_map_updated(conn->c_fcong, ~(u64) 0);
		scat = &rm->data.op_sg[sg];
		ret = sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;
		ret = min_t(int, ret, scat->length - conn->c_xmit_data_off);
		return ret;
 	}
 
 	 ","The Reliable Datagram Sockets (RDS) subsystem in the Linux kernel before 2.6.38 does not properly handle congestion map updates, which allows local users to cause a denial of service (BUG_ON and system crash) via vectors involving (1) a loopback (aka loop) transmit operation or (2) an InfiniBand (aka ib) transmit operation."
112,CVE-2011-0716,"  static int br_multicast_add_group(struct net_bridge *br,
 		goto err;
 
 	if (!port) {
		if (hlist_unhashed(&mp->mglist))
			hlist_add_head(&mp->mglist, &br->mglist);
 		mod_timer(&mp->timer, now + br->multicast_membership_interval);
 		goto out;
 	}","The br_multicast_add_group function in net/bridge/br_multicast.c in the Linux kernel before 2.6.38, when a certain Ethernet bridge configuration is used, allows local users to cause a denial of service (memory corruption and system crash) by sending IGMP packets to a local interface."
113,CVE-2011-0006,"  static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,
 	result = security_filter_rule_init(entry->lsm[lsm_rule].type,
 					   Audit_equal, args,
 					   &entry->lsm[lsm_rule].rule);
	if (!entry->lsm[lsm_rule].rule)
		return -EINVAL;
 	return result;
 }
 ","The ima_lsm_rule_init function in security/integrity/ima/ima_policy.c in the Linux kernel before 2.6.37, when the Linux Security Modules (LSM) framework is disabled, allows local users to bypass Integrity Measurement Architecture (IMA) rules in opportunistic circumstances by leveraging an administrator's addition of an IMA rule for LSM."
114,CVE-2010-4650,"  static int fuse_copy_ioctl_iovec(struct iovec *dst, void *src,
 	return 0;
 }
 
 
static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)
{
	size_t n;
	u32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;

	for (n = 0; n < count; n++) {
		if (iov->iov_len > (size_t) max)
			return -ENOMEM;
		max -= iov->iov_len;
	}
	return 0;
}

 /*
  * For ioctls, there is no generic way to determine how much memory
  * needs to be read and/or written.  Furthermore, ioctls are allowed
  long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
 		in_iov = page_address(iov_page);
 		out_iov = in_iov + in_iovs;
 
		err = fuse_verify_ioctl_iov(in_iov, in_iovs);
		if (err)
			goto out;

		err = fuse_verify_ioctl_iov(out_iov, out_iovs);
		if (err)
			goto out;

 		goto retry;
 	}
 ",Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.
115,CVE-2010-4648,"  static int orinoco_ioctl_set_auth(struct net_device *dev,
 		 */
 		if (param->value) {
 			priv->tkip_cm_active = 1;
			ret = hermes_disable_port(hw, 0);
 		} else {
 			priv->tkip_cm_active = 0;
			ret = hermes_enable_port(hw, 0);
 		}
 		break;
 ","The orinoco_ioctl_set_auth function in drivers/net/wireless/orinoco/wext.c in the Linux kernel before 2.6.37 does not properly implement a TKIP protection mechanism, which makes it easier for remote attackers to obtain access to a Wi-Fi network by reading Wi-Fi frames."
116,CVE-2010-4250,"  SYSCALL_DEFINE1(inotify_init1, int, flags)
 	if (ret >= 0)
 		return ret;
 
	fsnotify_put_group(group);
 	atomic_dec(&user->inotify_devs);
 out_free_uid:
 	free_uid(user);",Memory leak in the inotify_init1 function in fs/notify/inotify/inotify_user.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service (memory consumption) via vectors involving failed attempts to create files.
117,CVE-2013-7027,"  int ieee80211_radiotap_iterator_init(
 	struct ieee80211_radiotap_header *radiotap_header,
 	int max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)
 {
	 
	if (max_length < sizeof(struct ieee80211_radiotap_header))
		return -EINVAL;

 	 
 	if (radiotap_header->it_version)
 		return -EINVAL;
  int ieee80211_radiotap_iterator_init(
 			 */
 
 			if ((unsigned long)iterator->_arg -
			    (unsigned long)iterator->_rtheader +
			    sizeof(uint32_t) >
 			    (unsigned long)iterator->_max_length)
 				return -EINVAL;
 		}","The ieee80211_radiotap_iterator_init function in net/wireless/radiotap.c in the Linux kernel before 3.11.7 does not check whether a frame contains any data outside of the header, which might allow attackers to cause a denial of service (buffer over-read) via a crafted header."
118,CVE-2013-7026,"  static void shm_open(struct vm_area_struct *vma)
  */
 static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
	struct file *shm_file;

	shm_file = shp->shm_file;
	shp->shm_file = NULL;
 	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp);
 	shm_unlock(shp);
	if (!is_file_hugepages(shm_file))
		shmem_lock(shm_file, 0, shp->mlock_user);
 	else if (shp->mlock_user)
		user_shm_unlock(file_inode(shm_file)->i_size, shp->mlock_user);
	fput(shm_file);
 	ipc_rcu_putref(shp, shm_rcu_free);
 }
 
  SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 		}
 
 		shm_file = shp->shm_file;

		 
		if (shm_file == NULL) {
			err = -EIDRM;
			goto out_unlock0;
		}

 		if (is_file_hugepages(shm_file))
 			goto out_unlock0;
 
  long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,
 		goto out_unlock;
 
 	ipc_lock_object(&shp->shm_perm);

	 
	if (shp->shm_file == NULL) {
		ipc_unlock_object(&shp->shm_perm);
		err = -EIDRM;
		goto out_unlock;
	}

 	path = shp->shm_file->f_path;
 	path_get(&path);
 	shp->shm_nattch++;",Multiple race conditions in ipc/shm.c in the Linux kernel before 3.12.2 allow local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted application that uses shmctl IPC_RMID operations in conjunction with other shm system calls.
119,CVE-2013-7024,"  static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
 
 
             y    = tile->comp[compno].coord[1][0] - s->image_offset_y;
            line = picture->data[plane] + y / s->cdy[compno] * picture->linesize[plane];
             for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {
                 uint8_t *dst;
 
                 x   = tile->comp[compno].coord[0][0] - s->image_offset_x;
                dst = line + x / s->cdx[compno] * pixelsize + compno*!planar;
 
                 if (codsty->transform == FF_DWT97) {
                     for (; x < w; x += s->cdx[compno]) {
  static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,
                 plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);
 
             y     = tile->comp[compno].coord[1][0] - s->image_offset_y;
            linel = (uint16_t *)picture->data[plane] + y / s->cdy[compno] * (picture->linesize[plane] >> 1);
             for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {
                 uint16_t *dst;
 
                 x   = tile->comp[compno].coord[0][0] - s->image_offset_x;
                dst = linel + (x / s->cdx[compno] * pixelsize + compno*!planar);
                 if (codsty->transform == FF_DWT97) {
                     for (; x < w; x += s-> cdx[compno]) {
                         int  val = lrintf(*datap) + (1 << (cbps - 1));","The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not consider the component number in certain calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data."
120,CVE-2013-7023,"  int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_s
     if(next == END_NOT_FOUND){
         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);
 
        if(!new_buffer) {
            pc->index = 0;
             return AVERROR(ENOMEM);
        }
         pc->buffer = new_buffer;
         memcpy(&pc->buffer[pc->index], *buf, *buf_size);
         pc->index += *buf_size;
  int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_s
      
     if(pc->index){
         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);
        if(!new_buffer) {
            pc->overread_index =
            pc->index = 0;
             return AVERROR(ENOMEM);
        }
         pc->buffer = new_buffer;
         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)
             memcpy(&pc->buffer[pc->index], *buf,","The ff_combine_frame function in libavcodec/parser.c in FFmpeg before 2.1 does not properly handle certain memory-allocation errors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data."
121,CVE-2013-7022,"  static int g2m_init_buffers(G2MContext *c)
     int aligned_height;
 
     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {
        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;
        aligned_height     = c->height + 15;
         av_free(c->framebuf);
         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);
         if (!c->framebuf)","The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data."
122,CVE-2013-7021,"  static int filter_frame(AVFilterLink *inlink, AVFrame *buf)
     }
 
      
    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {
         return write_to_fifo(s->fifo, buf);
     }
 ","The filter_frame function in libavfilter/vf_fps.c in FFmpeg before 2.1 does not properly ensure the availability of FIFO content, which allows remote attackers to cause a denial of service (double free) or possibly have unspecified other impact via crafted data."
123,CVE-2013-7020,"  static int read_header(FFV1Context *f)
     memset(state, 128, sizeof(state));
 
     if (f->version < 2) {
        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;
         unsigned v= get_symbol(c, state, 0);
         if (v >= 2) {
             av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
  static int read_header(FFV1Context *f)
                 f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];
         }
 
        colorspace     = get_symbol(c, state, 0);  
        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;
         chroma_planes  = get_rac(c, state);
         chroma_h_shift = get_symbol(c, state, 0);
         chroma_v_shift = get_symbol(c, state, 0);
         transparency   = get_rac(c, state);
 
         if (f->plane_count) {
            if (   colorspace    != f->colorspace
                || bits_per_raw_sample != f->avctx->bits_per_raw_sample
                || chroma_planes != f->chroma_planes
                 || chroma_h_shift!= f->chroma_h_shift
                 || chroma_v_shift!= f->chroma_v_shift
                 || transparency  != f->transparency) {
  static int read_header(FFV1Context *f)
             }
         }
 
        f->colorspace     = colorspace;
        f->avctx->bits_per_raw_sample = bits_per_raw_sample;
         f->chroma_planes  = chroma_planes;
         f->chroma_h_shift = chroma_h_shift;
         f->chroma_v_shift = chroma_v_shift;","The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not properly enforce certain bit-count and colorspace constraints, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data."
124,CVE-2013-7019,"  static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)
         return AVERROR_INVALIDDATA;
     }
 
    if (c->nreslevels <= s->reduction_factor) {
         
        av_log(s->avctx, AV_LOG_ERROR, ""reduction_factor too large for this bitstream, max is %d\n"", c->nreslevels - 1);
        s->reduction_factor = c->nreslevels - 1;
        return AVERROR(EINVAL);
    }

      
    c->nreslevels2decode = c->nreslevels - s->reduction_factor;
 
     c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2;  
     c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2;  ","The get_cox function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not properly validate the reduction factor, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data."
125,CVE-2013-7018,"  static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)
         return AVERROR_INVALIDDATA;
     }
 
    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {
        avpriv_request_sample(s->avctx, ""cblk size > 64"");
        return AVERROR_PATCHWELCOME;
    }

     c->cblk_style = bytestream2_get_byteu(&s->g);
     if (c->cblk_style != 0) {  
         av_log(s->avctx, AV_LOG_WARNING, ""extra cblk styles %X\n"", c->cblk_style);
  static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,
     int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;
     int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;
 
    av_assert0(width  <= JPEG2000_MAX_CBLKW);
    av_assert0(height <= JPEG2000_MAX_CBLKH);

     for (y = 0; y < height; y++)
         memset(t1->data[y], 0, width * sizeof(**t1->data));
 ","libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not ensure the use of valid code-block dimension values, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data."
126,CVE-2013-7017,"  int ff_jpeg2000_init_component(Jpeg2000Component *comp,
                                         reslevel->log2_prec_height) -
                 (reslevel->coord[1][0] >> reslevel->log2_prec_height);
 
        reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));
         if (!reslevel->band)
             return AVERROR(ENOMEM);
 
  int ff_jpeg2000_init_component(Jpeg2000Component *comp,
             for (j = 0; j < 2; j++)
                 band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);
 
            band->prec = av_calloc(reslevel->num_precincts_x *
                                          (uint64_t)reslevel->num_precincts_y,
                                          sizeof(*band->prec));
             if (!band->prec)
  void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)
         for (bandno = 0; bandno < reslevel->nbands; bandno++) {
             Jpeg2000Band *band = reslevel->band + bandno;
             for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {
                if (band->prec) {
                    Jpeg2000Prec *prec = band->prec + precno;
                    av_freep(&prec->zerobits);
                    av_freep(&prec->cblkincl);
                    av_freep(&prec->cblk);
                }
             }
 
             av_freep(&band->prec);",libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data.
127,CVE-2013-7016,"  static int get_siz(Jpeg2000DecoderContext *s)
         s->sgnd[i]   = !!(x & 0x80);
         s->cdx[i]    = bytestream2_get_byteu(&s->g);
         s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
             av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample seperation\n"");
             return AVERROR_INVALIDDATA;
         }","The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not ensure the expected sample separation, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data."
128,CVE-2013-7015,"  static int flashsv_decode_frame(AVCodecContext *avctx, void *data,
                     }
                     s->diff_start  = get_bits(&gb, 8);
                     s->diff_height = get_bits(&gb, 8);
                    if (s->diff_start + s->diff_height > cur_blk_height) {
                        av_log(avctx, AV_LOG_ERROR, ""Block parameters invalid\n"");
                        return AVERROR_INVALIDDATA;
                    }
                     av_log(avctx, AV_LOG_DEBUG,
                            ""%dx%d diff start %d height %d\n"",
                            i, j, s->diff_start, s->diff_height);","The flashsv_decode_frame function in libavcodec/flashsv.c in FFmpeg before 2.1 does not properly validate a certain height value, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Flash Screen Video data."
129,CVE-2013-7014," 
 static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
 {
     long i;
    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {
         long a = *(long *)(src1 + i);
         long b = *(long *)(src2 + i);
         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);",Integer signedness error in the add_bytes_l2_c function in libavcodec/pngdsp.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted PNG data.
130,CVE-2013-7013,"  static int g2m_init_buffers(G2MContext *c)
     if (!c->synth_tile || !c->jpeg_tile ||
         c->old_tile_w < c->tile_width ||
         c->old_tile_h < c->tile_height) {
        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;
         aligned_height = FFALIGN(c->tile_height,    16);
         av_free(c->synth_tile);
         av_free(c->jpeg_tile);","The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 uses an incorrect ordering of arithmetic operations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data."
131,CVE-2013-7012,"  static int get_siz(Jpeg2000DecoderContext *s)
     s->tile_offset_y  = bytestream2_get_be32u(&s->g);  
     ncomponents       = bytestream2_get_be16u(&s->g);  
 
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    }

     if (ncomponents <= 0) {
         av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
                s->ncomponents);","The get_siz function in libavcodec/jpeg2000dec.c in FFmpeg before 2.1 does not prevent attempts to use non-zero image offsets, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG2000 data."
132,CVE-2013-7011,"  static int read_header(FFV1Context *f)
     memset(state, 128, sizeof(state));
 
     if (f->version < 2) {
        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;
         unsigned v= get_symbol(c, state, 0);
         if (v >= 2) {
             av_log(f->avctx, AV_LOG_ERROR, ""invalid version %d in ver01 header\n"", v);
  static int read_header(FFV1Context *f)
         if (f->version > 0)
             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);
 
        chroma_planes  = get_rac(c, state);
        chroma_h_shift = get_symbol(c, state, 0);
        chroma_v_shift = get_symbol(c, state, 0);
        transparency   = get_rac(c, state);

        if (f->plane_count) {
            if (   chroma_planes != f->chroma_planes
                || chroma_h_shift!= f->chroma_h_shift
                || chroma_v_shift!= f->chroma_v_shift
                || transparency  != f->transparency) {
                av_log(f->avctx, AV_LOG_ERROR, ""Invalid change of global parameters\n"");
                return AVERROR_INVALIDDATA;
            }
        }

        f->chroma_planes  = chroma_planes;
        f->chroma_h_shift = chroma_h_shift;
        f->chroma_v_shift = chroma_v_shift;
        f->transparency   = transparency;

         f->plane_count    = 2 + f->transparency;
     }
 ","The read_header function in libavcodec/ffv1dec.c in FFmpeg before 2.1 does not prevent changes to global parameters, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted FFV1 data."
133,CVE-2013-7010,"  void ff_set_cmp(DSPContext* c, me_cmp_func *cmp, int type){
 
 static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
  static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2,
         }
     }else
 #endif
    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src1+i);
         long b = *(long*)(src2+i);
         *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);",Multiple integer signedness errors in libavcodec/dsputil.c in FFmpeg before 2.1 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted data.
134,CVE-2013-7009,"  static void rpza_decode_stream(RpzaContext *s)
     unsigned short *pixels = (unsigned short *)s->frame.data[0];
 
     int row_ptr = 0;
    int pixel_ptr = -4;
     int block_ptr;
     int pixel_x, pixel_y;
     int total_blocks;
  static void rpza_decode_stream(RpzaContext *s)
             colorA = AV_RB16 (&s->buf[stream_ptr]);
             stream_ptr += 2;
             while (n_blocks--) {
                ADVANCE_BLOCK()
                 block_ptr = row_ptr + pixel_ptr;
                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                     for (pixel_x = 0; pixel_x < 4; pixel_x++){
  static void rpza_decode_stream(RpzaContext *s)
                     }
                     block_ptr += row_inc;
                 }
             }
             break;
 
  static void rpza_decode_stream(RpzaContext *s)
             if (s->size - stream_ptr < n_blocks * 4)
                 return;
             while (n_blocks--) {
                ADVANCE_BLOCK();
                 block_ptr = row_ptr + pixel_ptr;
                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                     index = s->buf[stream_ptr++];
  static void rpza_decode_stream(RpzaContext *s)
                     }
                     block_ptr += row_inc;
                 }
             }
             break;
 
          
         case 0x00:
             if (s->size - stream_ptr < 16)
                 return;
            ADVANCE_BLOCK();
             block_ptr = row_ptr + pixel_ptr;
             for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                 for (pixel_x = 0; pixel_x < 4; pixel_x++){
  static void rpza_decode_stream(RpzaContext *s)
                 }
                 block_ptr += row_inc;
             }
             break;
 
          ","The rpza_decode_stream function in libavcodec/rpza.c in FFmpeg before 2.1 does not properly maintain a pointer to pixel data, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Apple RPZA data."
135,CVE-2013-7008,"  static int decode_slice_header(H264Context *h, H264Context *h0)
             assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);
 
              
            if (h0->cur_pic_ptr->tf.owner == h0->avctx) {
                 ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                           last_pic_structure == PICT_BOTTOM_FIELD);
             }
  static int decode_slice_header(H264Context *h, H264Context *h0)
             if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {
                  
                if (last_pic_structure != PICT_FRAME) {
                     ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                               last_pic_structure == PICT_TOP_FIELD);
                 }
  static int decode_slice_header(H264Context *h, H264Context *h0)
                      * different frame_nums. Consider this field first in
                      * pair. Throw away previous field except for reference
                      * purposes. */
                    if (last_pic_structure != PICT_FRAME) {
                         ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,
                                                   last_pic_structure == PICT_TOP_FIELD);
                     }","The decode_slice_header function in libavcodec/h264.c in FFmpeg before 2.1 incorrectly relies on a certain droppable field, which allows remote attackers to cause a denial of service (deadlock) or possibly have unspecified other impact via crafted H.264 data."
136,CVE-2013-6800,"  setup_server_realm(krb5_principal sprinc)
     kdc_realm_t         *newrealm;
 
     kret = 0;
    if (sprinc == NULL)
        return NULL;

     if (kdc_numrealms > 1) {
         if (!(newrealm = find_realm_data(sprinc->realm.data,
                                          (krb5_ui_4) sprinc->realm.length)))","An unspecified third-party database module for the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) 1.10.x allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request, a different vulnerability than CVE-2013-1418."
137,CVE-2013-6763,"  static int uio_mmap_physical(struct vm_area_struct *vma)
 {
 	struct uio_device *idev = vma->vm_private_data;
 	int mi = uio_find_mem_index(vma);
	struct uio_mem *mem;
 	if (mi < 0)
 		return -EINVAL;
	mem = idev->info->mem + mi;
 
	if (vma->vm_end - vma->vm_start > mem->size)
		return -EINVAL;
 
	vma->vm_ops = &uio_physical_vm_ops;
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
	 
 	return remap_pfn_range(vma,
 			       vma->vm_start,
			       mem->addr >> PAGE_SHIFT,
 			       vma->vm_end - vma->vm_start,
 			       vma->vm_page_prot);
 }","The uio_mmap_physical function in drivers/uio/uio.c in the Linux kernel before 3.12 does not validate the size of a memory block, which allows local users to cause a denial of service (memory corruption) or possibly gain privileges via crafted mmap operations, a different vulnerability than CVE-2013-4511."
138,CVE-2013-6432,"  int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	if (family == AF_INET) {
 		struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
 
		if (sin) {
			sin->sin_family = AF_INET;
			sin->sin_port = 0  ;
			sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
			*addr_len = sizeof(*sin);
		}
 
 		if (isk->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
  int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		struct sockaddr_in6 *sin6 =
 			(struct sockaddr_in6 *)msg->msg_name;
 
		if (sin6) {
			sin6->sin6_family = AF_INET6;
			sin6->sin6_port = 0;
			sin6->sin6_addr = ip6->saddr;
			sin6->sin6_flowinfo = 0;
			if (np->sndflow)
				sin6->sin6_flowinfo = ip6_flowinfo(ip6);
			sin6->sin6_scope_id =
				ipv6_iface_scope_id(&sin6->sin6_addr,
						    IP6CB(skb)->iif);
			*addr_len = sizeof(*sin6);
		}
 
 		if (inet6_sk(sk)->rxopt.all)
 			pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);","The ping_recvmsg function in net/ipv4/ping.c in the Linux kernel before 3.12.4 does not properly interact with read system calls on ping sockets, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging unspecified privileges to execute a crafted application."
139,CVE-2013-6431,"  int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)
 	fn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,
 			offsetof(struct rt6_info, rt6i_dst), allow_create,
 			replace_required);
 	if (IS_ERR(fn)) {
 		err = PTR_ERR(fn);
		fn = NULL;
 		goto out;
 	}
 ","The fib6_add function in net/ipv6/ip6_fib.c in the Linux kernel before 3.11.5 does not properly implement error-code encoding, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for an IPv6 SIOCADDRT ioctl call."
140,CVE-2013-6383,"  static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long
 static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
 ","The aac_compat_ioctl function in drivers/scsi/aacraid/linit.c in the Linux kernel before 3.11.8 does not require the CAP_SYS_RAWIO capability, which allows local users to bypass intended access restrictions via a crafted ioctl call."
141,CVE-2013-6381,"  int qeth_snmp_command(struct qeth_card *card, char __user *udata)
 	struct qeth_cmd_buffer *iob;
 	struct qeth_ipa_cmd *cmd;
 	struct qeth_snmp_ureq *ureq;
	unsigned int req_len;
 	struct qeth_arp_query_info qinfo = {0, };
 	int rc = 0;
 
  int qeth_snmp_command(struct qeth_card *card, char __user *udata)
 	 
 	if (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))
 		return -EFAULT;
	if (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -
		       sizeof(struct qeth_ipacmd_hdr) -
		       sizeof(struct qeth_ipacmd_setadpparms_hdr)))
		return -EINVAL;
 	ureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));
 	if (IS_ERR(ureq)) {
 		QETH_CARD_TEXT(card, 2, ""snmpnome"");",Buffer overflow in the qeth_snmp_command function in drivers/s390/net/qeth_core_main.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service or possibly have unspecified other impact via an SNMP ioctl call with a length value that is incompatible with the command-buffer size.
142,CVE-2013-6380,"  static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)
 		goto cleanup;
 	}
 
	if ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||
	    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {
 		rcode = -EINVAL;
 		goto cleanup;
 	}","The aac_send_raw_srb function in drivers/scsi/aacraid/commctrl.c in the Linux kernel through 3.12.1 does not properly validate a certain size value, which allows local users to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via an FSACTL_SEND_RAW_SRB ioctl call that triggers a crafted SRB command."
143,CVE-2013-6378,"  static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,
 	char *p2;
 	struct debug_data *d = f->private_data;
 
	if (cnt == 0)
		return 0;

	pdata = kmalloc(cnt + 1, GFP_KERNEL);
 	if (pdata == NULL)
 		return 0;
 
  static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,
 		kfree(pdata);
 		return 0;
 	}
	pdata[cnt] = '\0';
 
 	p0 = pdata;
 	for (i = 0; i < num_of_items; i++) {",The lbs_debugfs_write function in drivers/net/wireless/libertas/debugfs.c in the Linux kernel through 3.12.1 allows local users to cause a denial of service (OOPS) by leveraging root privileges for a zero-length write operation.
144,CVE-2013-6376,"  static inline int kvm_apic_id(struct kvm_lapic *apic)
 	return (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;
 }
 
#define KVM_X2APIC_CID_BITS 0

 static void recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
  static void recalculate_apic_map(struct kvm *kvm)
 		if (apic_x2apic_mode(apic)) {
 			new->ldr_bits = 32;
 			new->cid_shift = 16;
			new->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;
			new->lid_mask = 0xffff;
 		} else if (kvm_apic_sw_enabled(apic) &&
 				!new->cid_mask   &&
 				kvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {",The recalculate_apic_map function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (host OS crash) via a crafted ICR write operation in x2apic mode.
145,CVE-2013-6368,"  static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,
 void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
 {
 	u32 data;
 
 	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
 		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
 
 	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
 		return;
 
	kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,
				sizeof(u32));
 
 	apic_set_tpr(vcpu->arch.apic, data & 0xff);
 }
  void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)
 	u32 data, tpr;
 	int max_irr, max_isr;
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
 	apic_sync_pv_eoi_to_guest(vcpu, apic);
 
  void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)
 		max_isr = 0;
 	data = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);
 
	kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,
				sizeof(u32));
 }
 
int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)
 {
	if (vapic_addr) {
		if (kvm_gfn_to_hva_cache_init(vcpu->kvm,
					&vcpu->arch.apic->vapic_cache,
					vapic_addr, sizeof(u32)))
			return -EINVAL;
 		__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);
	} else {
 		__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);
	}

	vcpu->arch.apic->vapic_addr = vapic_addr;
	return 0;
 }
 
 int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)",The KVM subsystem in the Linux kernel through 3.12.5 allows local users to gain privileges or cause a denial of service (system crash) via a VAPIC synchronization operation involving a page-end address.
146,CVE-2013-6367,"  static u32 apic_get_tmcct(struct kvm_lapic *apic)
 	ASSERT(apic != NULL);
 
 	 
	if (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||
		apic->lapic_timer.period == 0)
 		return 0;
 
 	remaining = hrtimer_get_remaining(&apic->lapic_timer.timer);",The apic_get_tmcct function in arch/x86/kvm/lapic.c in the KVM subsystem in the Linux kernel through 3.12.5 allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via crafted modifications of the TMICT value.
147,CVE-2013-6282," 
 	.size \name , . - \name
 	.endm
 
	.macro check_uaccess, addr:req, size:req, limit:req, tmp:req, bad:req
#ifndef CONFIG_CPU_USE_DOMAINS
	adds	\tmp, \addr, #\size - 1
	sbcccs	\tmp, \tmp, \limit
	bcs	\bad
#endif
	.endm

 #endif  ","The (1) get_user and (2) put_user API functions in the Linux kernel before 3.5.5 on the v6k and v7 ARM platforms do not validate certain addresses, which allows attackers to read or modify the contents of arbitrary kernel memory locations via a crafted application, as exploited in the wild against Android devices in October and November 2013."
148,CVE-2013-5634,"  static void vcpu_pause(struct kvm_vcpu *vcpu)
 	wait_event_interruptible(*wq, !vcpu->arch.pause);
 }
 
static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.target >= 0;
}

  
	if (unlikely(!kvm_vcpu_initialized(vcpu)))
 		return -ENOEXEC;
 
 	ret = kvm_vcpu_first_run_init(vcpu);
  long kvm_arch_vcpu_ioctl(struct file *filp,
 	case KVM_SET_ONE_REG:
 	case KVM_GET_ONE_REG: {
 		struct kvm_one_reg reg;

		if (unlikely(!kvm_vcpu_initialized(vcpu)))
			return -ENOEXEC;

 		if (copy_from_user(&reg, argp, sizeof(reg)))
 			return -EFAULT;
 		if (ioctl == KVM_SET_ONE_REG)
  long kvm_arch_vcpu_ioctl(struct file *filp,
 		struct kvm_reg_list reg_list;
 		unsigned n;
 
		if (unlikely(!kvm_vcpu_initialized(vcpu)))
			return -ENOEXEC;

 		if (copy_from_user(&reg_list, user_list, sizeof(reg_list)))
 			return -EFAULT;
 		n = reg_list.n;","arch/arm/kvm/arm.c in the Linux kernel before 3.10 on the ARM platform, when KVM is used, allows host OS users to cause a denial of service (NULL pointer dereference, OOPS, and host OS crash) or possibly have unspecified other impact by omitting vCPU initialization before a KVM_GET_REG_LIST ioctl call."
149,CVE-2013-4592,"  int __kvm_set_memory_region(struct kvm *kvm,
 		 
 	}
 
	if (!npages || base_gfn != old.base_gfn) {
 		struct kvm_memory_slot *slot;
 
 		r = -ENOMEM;
  int __kvm_set_memory_region(struct kvm *kvm,
 		old_memslots = kvm->memslots;
 		rcu_assign_pointer(kvm->memslots, slots);
 		synchronize_srcu_expedited(&kvm->srcu);
		/* From this point no new shadow pages pointing to a deleted,
		 * or moved, memslot will be created.
 		 *
 		 * validation of sp->gfn happens in:
 		 * 	- gfn_to_hva (kvm_read_guest, gfn_to_pfn)",Memory leak in the __kvm_set_memory_region function in virt/kvm/kvm_main.c in the Linux kernel before 3.9 allows local users to cause a denial of service (memory consumption) by leveraging certain device access to trigger movement of memory slots.
150,CVE-2013-4591,"  static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu
 		goto out_free;
 	}
 	nfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);
	if (buf) {
		if (res.acl_len > buflen) {
			ret = -ERANGE;
			goto out_free;
		}
 		_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);
	}
 out_ok:
 	ret = res.acl_len;
 out_free:",Buffer overflow in the __nfs4_get_acl_uncached function in fs/nfs/nfs4proc.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact via a getxattr system call for the system.nfs4_acl extended attribute of a pathname on an NFSv4 filesystem.
151,CVE-2013-4588,"  do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)
		return -EINVAL;
	if (len < 0 || len >  MAX_ARG_LEN)
		return -EINVAL;
 	if (len != set_arglen[SET_CMDID(cmd)]) {
 		pr_err(""set_ctl: len %u != %u\n"",
 		       len, set_arglen[SET_CMDID(cmd)]);
  do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
 {
 	unsigned char arg[128];
 	int ret = 0;
	unsigned int copylen;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)
		return -EINVAL;

 	if (*len < get_arglen[GET_CMDID(cmd)]) {
 		pr_err(""get_ctl: len %u < %u\n"",
 		       *len, get_arglen[GET_CMDID(cmd)]);
 		return -EINVAL;
 	}
 
	copylen = get_arglen[GET_CMDID(cmd)];
	if (copylen > 128)
		return -EINVAL;

	if (copy_from_user(arg, user, copylen) != 0)
 		return -EFAULT;
 
 	if (mutex_lock_interruptible(&__ip_vs_mutex))","Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function."
152,CVE-2013-4587,"  static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 	int r;
 	struct kvm_vcpu *vcpu, *v;
 
	if (id >= KVM_MAX_VCPUS)
		return -EINVAL;

 	vcpu = kvm_arch_vcpu_create(kvm, id);
 	if (IS_ERR(vcpu))
 		return PTR_ERR(vcpu);",Array index error in the kvm_vm_ioctl_create_vcpu function in virt/kvm/kvm_main.c in the KVM subsystem in the Linux kernel through 3.12.5 allows local users to gain privileges via a large id value.
153,CVE-2013-4563,"  static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
 
 		 
 		tnl_hlen = skb_tnl_header_len(skb);
		if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {
 			if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))
 				goto out;
 		}","The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline."
154,CVE-2013-4516,"  static int mp_wait_modem_status(struct sb_uart_state *state, unsigned long arg)
 
 static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)
 {
	struct serial_icounter_struct icount = {};
 	struct sb_uart_icount cnow;
 	struct sb_uart_port *port = state->port;
 ","The mp_get_count function in drivers/staging/sb105x/sb_pci_mp.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a TIOCGICOUNT ioctl call."
155,CVE-2013-4515,"  static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)
 
 		BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, ""Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\n"");
 
		memset(&DevInfo, 0, sizeof(DevInfo));
 		DevInfo.MaxRDMBufferSize = BUFFER_4K;
 		DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;
 		DevInfo.u32RxAlignmentCorrection = 0;","The bcm_char_ioctl function in drivers/staging/bcm/Bcmchar.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via an IOCTL_BCM_GET_DEVICE_DRIVER_INFO ioctl call."
156,CVE-2013-4514,"  int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)
 	ltv_t                   *pLtv;
 	bool_t                  ltvAllocated = FALSE;
 	ENCSTRCT                sEncryption;
	size_t			len;
 
 #ifdef USE_WDS
 	hcf_16                  hcfPort  = HCF_PORT_0;
  int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)
 					break;
 				case CFG_CNF_OWN_NAME:
 					memset(lp->StationName, 0, sizeof(lp->StationName));
					len = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));
					strlcpy(lp->StationName, &pLtv->u.u8[2], len);
 					pLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);
 					break;
 				case CFG_CNF_LOAD_BALANCING:
  int wvlan_set_station_nickname(struct net_device *dev,
 {
 	struct wl_private *lp = wl_priv(dev);
 	unsigned long flags;
	size_t len;
 	int         ret = 0;
 	 
 
  int wvlan_set_station_nickname(struct net_device *dev,
 	wl_lock(lp, &flags);
 
 	memset(lp->StationName, 0, sizeof(lp->StationName));
	len = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));
	strlcpy(lp->StationName, extra, len);
 
 	 
 	wl_apply(lp);","Multiple buffer overflows in drivers/staging/wlags49_h2/wl_priv.c in the Linux kernel before 3.12 allow local users to cause a denial of service or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability and providing a long station-name string, related to the (1) wvlan_uil_put_info and (2) wvlan_set_station_nickname functions."
157,CVE-2013-4513,"  static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,
 	struct oz_app_hdr *app_hdr;
 	struct oz_serial_ctx *ctx;
 
	if (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))
		return -EINVAL;

 	spin_lock_bh(&g_cdev.lock);
 	pd = g_cdev.active_pd;
 	if (pd)",Buffer overflow in the oz_cdev_write function in drivers/staging/ozwpan/ozcdev.c in the Linux kernel before 3.12 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted write operation.
158,CVE-2013-4512,"  static ssize_t exitcode_proc_write(struct file *file,
 		const char __user *buffer, size_t count, loff_t *pos)
 {
 	char *end, buf[sizeof(""nnnnn\0"")];
	size_t size;
 	int tmp;
 
	size = min(count, sizeof(buf));
	if (copy_from_user(buf, buffer, size))
 		return -EFAULT;
 
 	tmp = simple_strtol(buf, &end, 0);",Buffer overflow in the exitcode_proc_write function in arch/um/kernel/exitcode.c in the Linux kernel before 3.12 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging root privileges for a write operation.
159,CVE-2013-4483,"  long do_msgsnd(int msqid, long mtype, void __user *mtext,
 			goto out_unlock_free;
 		}
 		ss_add(msq, &s);

		if (!ipc_rcu_getref(msq)) {
			err = -EIDRM;
			goto out_unlock_free;
		}

 		msg_unlock(msq);
 		schedule();
 ","The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application."
160,CVE-2013-4470,"  static inline int ip_ufo_append_data(struct sock *sk,
 		 
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	 
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }","The Linux kernel before 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly initialize certain data structures, which allows local users to cause a denial of service (memory corruption and system crash) or possibly gain privileges via a crafted application that uses the UDP_CORK option in a setsockopt system call and sends both short and long packets, related to the ip_ufo_append_data function in net/ipv4/ip_output.c and the ip6_ufo_append_data function in net/ipv6/ip6_output.c."
161,CVE-2013-4387,"  static inline int ip6_ufo_append_data(struct sock *sk,
 	 * udp datagram
 	 */
 	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
		struct frag_hdr fhdr;

 		skb = sock_alloc_send_skb(sk,
 			hh_len + fragheaderlen + transhdrlen + 20,
 			(flags & MSG_DONTWAIT), &err);
  static inline int ip6_ufo_append_data(struct sock *sk,
 		skb->protocol = htons(ETH_P_IPV6);
 		skb->ip_summed = CHECKSUM_PARTIAL;
 		skb->csum = 0;
 
 		 
 
	return skb_append_datato_frags(sk, skb, getfrag, from,
				       (length - transhdrlen));
 }
 
 static inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,
  int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	 * --yoshfuji
 	 */
 
	if ((length > mtu) && dontfrag && (sk->sk_protocol == IPPROTO_UDP ||
					   sk->sk_protocol == IPPROTO_RAW)) {
		ipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);
		return -EMSGSIZE;
	}
 
	skb = skb_peek_tail(&sk->sk_write_queue);
	cork->length += length;
	if (((length > mtu) ||
	     (skb && skb_is_gso(skb))) &&
	    (sk->sk_protocol == IPPROTO_UDP) &&
	    (rt->dst.dev->features & NETIF_F_UFO)) {
		err = ip6_ufo_append_data(sk, getfrag, from, length,
					  hh_len, fragheaderlen,
					  transhdrlen, mtu, flags, rt);
		if (err)
			goto error;
		return 0;
 	}
 
	if (!skb)
 		goto alloc_new_skb;
 
 	while (length > 0) {","net/ipv6/ip6_output.c in the Linux kernel through 3.11.4 does not properly determine the need for UDP Fragmentation Offload (UFO) processing of small packets after the UFO queueing of a large packet, which allows remote attackers to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact via network traffic that triggers a large response packet."
162,CVE-2013-4350,"  static void sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 		in6_dev_put(idev);
 }
 
 static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)
 {
 	struct sock *sk = skb->sk;
 	struct ipv6_pinfo *np = inet6_sk(sk);
	struct flowi6 *fl6 = &transport->fl.u.ip6;
 
 	pr_debug(""%s: skb:%p, len:%d, src:%pI6 dst:%pI6\n"", __func__, skb,
		 skb->len, &fl6->saddr, &fl6->daddr);
 
	IP6_ECN_flow_xmit(sk, fl6->flowlabel);
 
 	if (!(transport->param_flags & SPP_PMTUD_ENABLE))
 		skb->local_df = 1;
 
	SCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);

	return ip6_xmit(sk, skb, fl6, np->opt, np->tclass);
 }
 
 /* Returns the dst cache entry for the given source and destination ip
  static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 	struct dst_entry *dst = NULL;
 	struct flowi6 *fl6 = &fl->u.ip6;
 	struct sctp_bind_addr *bp;
	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sctp_sockaddr_entry *laddr;
 	union sctp_addr *baddr = NULL;
 	union sctp_addr *daddr = &t->ipaddr;
 	union sctp_addr dst_saddr;
	struct in6_addr *final_p, final;
 	__u8 matchlen = 0;
 	__u8 bmatchlen;
 	sctp_scope_t scope;
  static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 		pr_debug(""src=%pI6 - "", &fl6->saddr);
 	}
 
	final_p = fl6_update_dst(fl6, np->opt, &final);
	dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	if (!asoc || saddr)
 		goto out;
 
  static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,
 		}
 	}
 	rcu_read_unlock();

 	if (baddr) {
 		fl6->saddr = baddr->v6.sin6_addr;
 		fl6->fl6_sport = baddr->v6.sin6_port;
		final_p = fl6_update_dst(fl6, np->opt, &final);
		dst = ip6_dst_lookup_flow(sk, fl6, final_p, false);
 	}
 
 out:","The IPv6 SCTP implementation in net/sctp/ipv6.c in the Linux kernel through 3.11.1 uses data structures and function calls that do not trigger an intended configuration of IPsec encryption, which allows remote attackers to obtain sensitive information by sniffing the network."
163,CVE-2013-4300,"  static __inline__ int scm_check_creds(struct ucred *creds)
 		return -EINVAL;
 
 	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||","The scm_check_creds function in net/core/scm.c in the Linux kernel before 3.11 performs a capability check in an incorrect namespace, which allows local users to gain privileges via PID spoofing."
164,CVE-2013-4299,"  static chunk_t area_location(struct pstore *ps, chunk_t area)
 	return NUM_SNAPSHOT_HDR_CHUNKS + ((ps->exceptions_per_area + 1) * area);
 }
 
static void skip_metadata(struct pstore *ps)
{
	uint32_t stride = ps->exceptions_per_area + 1;
	chunk_t next_free = ps->next_free;
	if (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)
		ps->next_free++;
}

  
  static int persistent_prepare_exception(struct dm_exception_store *store,
 	 * Move onto the next free pending, making sure to take
 	 * into account the location of the metadata chunks.
 	 */
	ps->next_free++;
	skip_metadata(ps);
 
 	atomic_inc(&ps->pending_count);
 	return 0;",Interpretation conflict in drivers/md/dm-snap-persistent.c in the Linux kernel through 3.11.6 allows remote authenticated users to obtain sensitive information or modify data via a crafted mapping to a snapshot block device.
165,CVE-2013-4270,"  static int net_ctl_permissions(struct ctl_table_header *head,
 
 	 
 	if (ns_capable(net->user_ns, CAP_NET_ADMIN) ||
	    uid_eq(root_uid, current_euid())) {
 		int mode = (table->mode >> 6) & 7;
 		return (mode << 6) | (mode << 3) | mode;
 	}
 	 
	if (in_egroup_p(root_gid)) {
 		int mode = (table->mode >> 3) & 7;
 		return (mode << 3) | mode;
 	}","The net_ctl_permissions function in net/sysctl_net.c in the Linux kernel before 3.11.5 does not properly determine uid and gid values, which allows local users to bypass intended /proc/sys/net restrictions via a crafted application."
166,CVE-2013-4265,"  int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
 {
     void **ptrptr = ptr;
     *ptrptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!*ptrptr && nmemb && size)
         return AVERROR(ENOMEM);
     return 0;
 }",The av_reallocp_array function in libavutil/mem.c in FFmpeg before 2.0.1 has an unspecified impact and remote vectors related to a *wrong return code* and a resultant NULL pointer dereference.
167,CVE-2013-4264,"  static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,
         return 0;
     zsize = (src[0] << 8) | src[1]; src += 2;
 
    if (src_end - src < zsize + (sub_type != 2))
         return AVERROR_INVALIDDATA;
 
     ret = uncompress(c->kempf_buf, &dlen, src, zsize);
  static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,
     for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {
         for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {
             if (!bits) {
                if (src >= src_end)
                    return AVERROR_INVALIDDATA;
                 bitbuf = *src++;
                 bits   = 8;
             }",The kempf_decode_tile function in libavcodec/g2meet.c in FFmpeg before 2.0.1 allows remote attackers to cause a denial of service (out-of-bounds heap write) via a G2M4 encoded file.
168,CVE-2013-4263,"  static int filter_frame(AVFilterLink *inlink, AVFrame *in)
     }
     av_frame_copy_props(out, in);
 
    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
         hblur(out->data[plane], out->linesize[plane],
               in ->data[plane], in ->linesize[plane],
               w[plane], h[plane], s->radius[plane], s->power[plane],
               s->temp);
 
    for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)
         vblur(out->data[plane], out->linesize[plane],
               out->data[plane], out->linesize[plane],
               w[plane], h[plane], s->radius[plane], s->power[plane],","libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted *plane,* which triggers an out-of-bounds heap write."
169,CVE-2013-4254,"  validate_event(struct pmu_hw_events *hw_events,
 	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
 	struct pmu *leader_pmu = event->group_leader->pmu;
 
	if (is_software_event(event))
		return 1;

 	if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)
 		return 1;
 ",The validate_event function in arch/arm/kernel/perf_event.c in the Linux kernel before 3.10.8 on the ARM platform allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) by adding a hardware event to an event group led by a software event.
170,CVE-2013-4247,"  build_unc_path_to_root(const struct smb_vol *vol,
 	pos = full_path + unc_len;
 
 	if (pplen) {
		*pos = CIFS_DIR_SEP(cifs_sb);
		strncpy(pos + 1, vol->prepath, pplen);
 		pos += pplen;
 	}
 ",Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.
171,CVE-2013-4220,"  asmlinkage long do_ni_syscall(struct pt_regs *regs)
  */
 asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)
 {
	siginfo_t info;
	void __user *pc = (void __user *)instruction_pointer(regs);
 	console_verbose();
 
 	pr_crit(""Bad mode in %s handler detected, code 0x%08x\n"",
 		handler[reason], esr);
	__show_regs(regs);

	info.si_signo = SIGILL;
	info.si_errno = 0;
	info.si_code  = ILL_ILLOPC;
	info.si_addr  = pc;
 
	arm64_notify_die(""Oops - bad mode"", regs, &info, 0);
 }
 
 void __pte_error(const char *file, int line, unsigned long val)",The bad_mode function in arch/arm64/kernel/traps.c in the Linux kernel before 3.9.5 on the ARM64 platform allows local users to cause a denial of service (system crash) via vectors involving an attempted register access that triggers an unexpected value in the Exception Syndrome Register (ESR).
172,CVE-2013-4205,"  int create_user_ns(struct cred *new)
 int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)
 {
 	struct cred *cred;
	int err = -ENOMEM;
 
 	if (!(unshare_flags & CLONE_NEWUSER))
 		return 0;
 
 	cred = prepare_creds();
	if (cred) {
		err = create_user_ns(cred);
		if (err)
			put_cred(cred);
		else
			*new_cred = cred;
	}
 
	return err;
 }
 
 void free_user_ns(struct user_namespace *ns)",Memory leak in the unshare_userns function in kernel/user_namespace.c in the Linux kernel before 3.10.6 allows local users to cause a denial of service (memory consumption) via an invalid CLONE_NEWUSER unshare call.
173,CVE-2013-4163,"  static inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,
 	return src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;
 }
 
static void ip6_append_data_mtu(unsigned int *mtu,
 				int *maxfraglen,
 				unsigned int fragheaderlen,
 				struct sk_buff *skb,
				struct rt6_info *rt,
				bool pmtuprobe)
 {
 	if (!(rt->dst.flags & DST_XFRM_TUNNEL)) {
 		if (skb == NULL) {
  static void ip6_append_data_mtu(int *mtu,
 			 * this fragment is not first, the headers
 			 * space is regarded as data space.
 			 */
			*mtu = min(*mtu, pmtuprobe ?
				   rt->dst.dev->mtu :
				   dst_mtu(rt->dst.path));
 		}
 		*maxfraglen = ((*mtu - fragheaderlen) & ~7)
 			      + fragheaderlen - sizeof(struct frag_hdr);
  int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct inet_cork *cork;
 	struct sk_buff *skb, *skb_prev = NULL;
	unsigned int maxfraglen, fragheaderlen, mtu;
 	int exthdrlen;
 	int dst_exthdrlen;
 	int hh_len;
 	int copy;
 	int err;
 	int offset = 0;
  int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 			 
 			if (skb == NULL || skb_prev == NULL)
 				ip6_append_data_mtu(&mtu, &maxfraglen,
						    fragheaderlen, skb, rt,
						    np->pmtudisc ==
						    IPV6_PMTUDISC_PROBE);
 
 			skb_prev = skb;
 ","The ip6_append_data_mtu function in net/ipv6/ip6_output.c in the IPv6 implementation in the Linux kernel through 3.10.3 does not properly maintain information about whether the IPV6_MTU setsockopt option had been specified, which allows local users to cause a denial of service (BUG and system crash) via a crafted application that uses the UDP_CORK option in a setsockopt system call."
174,CVE-2013-4162,"  extern int udp_get_port(struct sock *sk, unsigned short snum,
 extern void udp_err(struct sk_buff *, u32);
 extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,
 			    struct msghdr *msg, size_t len);
extern int udp_push_pending_frames(struct sock *sk);
 extern void udp_flush_pending_frames(struct sock *sk);
 extern int udp_rcv(struct sk_buff *skb);
 extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);","The udp_v6_push_pending_frames function in net/ipv6/udp.c in the IPv6 implementation in the Linux kernel through 3.10.3 makes an incorrect function call for pending data, which allows local users to cause a denial of service (BUG and system crash) via a crafted application that uses the UDP_CORK option in a setsockopt system call."
175,CVE-2013-4129,"  static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)
 		call_rcu_bh(&p->rcu, br_multicast_free_pg);
 		err = 0;
 
		if (!mp->ports && !mp->mglist && mp->timer_armed &&
 		    netif_running(br->dev))
 			mod_timer(&mp->timer, jiffies);
 		break;","The bridge multicast implementation in the Linux kernel through 3.10.3 does not check whether a certain timer is armed before modifying the timeout value of that timer, which allows local users to cause a denial of service (BUG and system crash) via vectors involving the shutdown of a KVM virtual machine, related to net/bridge/br_mdb.c and net/bridge/br_multicast.c."
176,CVE-2013-4127,"  static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)
 {
 	kref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);
 	wait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));
}

static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)
{
	vhost_net_ubuf_put_and_wait(ubufs);
 	kfree(ubufs);
 }
 
  static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)
 	mutex_unlock(&vq->mutex);
 
 	if (oldubufs) {
		vhost_net_ubuf_put_wait_and_free(oldubufs);
 		mutex_lock(&vq->mutex);
 		vhost_zerocopy_signal_used(n, vq);
 		mutex_unlock(&vq->mutex);
  static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)
 	rcu_assign_pointer(vq->private_data, oldsock);
 	vhost_net_enable_vq(n, vq);
 	if (ubufs)
		vhost_net_ubuf_put_wait_and_free(ubufs);
 err_ubufs:
 	fput(sock->file);
 err_vq:",Use-after-free vulnerability in the vhost_net_set_backend function in drivers/vhost/net.c in the Linux kernel through 3.10.3 allows local users to cause a denial of service (OOPS and system crash) via vectors involving powering on a virtual machine.
177,CVE-2013-4125,"  static struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,
 	return ln;
 }
 
static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)
{
	return (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==
	       RTF_GATEWAY;
}

  
  static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,
 	int add = (!info->nlh ||
 		   (info->nlh->nlmsg_flags & NLM_F_CREATE));
 	int found = 0;
	bool rt_can_ecmp = rt6_qualify_for_ecmp(rt);
 
 	ins = &fn->leaf;
 
  static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,
 			 * To avoid long list, we only had siblings if the
 			 * route have a gateway.
 			 */
			if (rt_can_ecmp &&
			    rt6_qualify_for_ecmp(iter))
 				rt->rt6i_nsiblings++;
 		}
 
  static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,
 		 
 		sibling = fn->leaf;
 		while (sibling) {
			if (sibling->rt6i_metric == rt->rt6i_metric &&
			    rt6_qualify_for_ecmp(sibling)) {
 				list_add_tail(&rt->rt6i_siblings,
 					      &sibling->rt6i_siblings);
 				break;","The fib6_add_rt2node function in net/ipv6/ip6_fib.c in the IPv6 stack in the Linux kernel through 3.10.1 does not properly handle Router Advertisement (RA) messages in certain circumstances involving three routes that initially qualified for membership in an ECMP route set until a change occurred for one of the first two routes, which allows remote attackers to cause a denial of service (system crash) via a crafted sequence of messages."
178,CVE-2013-3302,"  smb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,
 
 	*sent = 0;
 
 	smb_msg.msg_name = (struct sockaddr *) &server->dstaddr;
 	smb_msg.msg_namelen = sizeof(struct sockaddr);
 	smb_msg.msg_control = NULL;
  smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)
 	struct socket *ssocket = server->ssocket;
 	int val = 1;
 
	if (ssocket == NULL)
		return -ENOTSOCK;

 	cFYI(1, ""Sending smb: smb_len=%u"", smb_buf_length);
 	dump_smb(iov[0].iov_base, iov[0].iov_len);
 ",Race condition in the smb_send_rqst function in fs/cifs/transport.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact via vectors involving a reconnection event.
179,CVE-2013-3301,"  ssize_t ftrace_filter_write(struct file *file, const char __user *ubuf,
 			    size_t cnt, loff_t *ppos);
 ssize_t ftrace_notrace_write(struct file *file, const char __user *ubuf,
 			     size_t cnt, loff_t *ppos);
loff_t ftrace_filter_lseek(struct file *file, loff_t offset, int whence);
 int ftrace_regex_release(struct inode *inode, struct file *file);
 
 void __init","The ftrace implementation in the Linux kernel before 3.8.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by leveraging the CAP_SYS_ADMIN capability for write access to the (1) set_ftrace_pid or (2) set_graph_function file, and then making an lseek system call."
180,CVE-2013-3237,"  vsock_stream_recvmsg(struct kiocb *kiocb,
 	vsk = vsock_sk(sk);
 	err = 0;
 
	msg->msg_namelen = 0;

 	lock_sock(sk);
 
 	if (sk->sk_state != SS_CONNECTED) {","The vsock_stream_sendmsg function in net/vmw_vsock/af_vsock.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
181,CVE-2013-3236,"  static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,
 	if (flags & MSG_OOB || flags & MSG_ERRQUEUE)
 		return -EOPNOTSUPP;
 
	msg->msg_namelen = 0;

 	 
 	err = 0;
 	skb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);
  static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,
 	if (err)
 		goto out;
 
 	if (msg->msg_name) {
 		struct sockaddr_vm *vm_addr;
 ","The vmci_transport_dgram_dequeue function in net/vmw_vsock/vmci_transport.c in the Linux kernel before 3.9-rc7 does not properly initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
182,CVE-2013-3235,"  static void set_orig_addr(struct msghdr *m, struct tipc_msg *msg)
 	if (addr) {
 		addr->family = AF_TIPC;
 		addr->addrtype = TIPC_ADDR_ID;
		memset(&addr->addr, 0, sizeof(addr->addr));
 		addr->addr.id.ref = msg_origport(msg);
 		addr->addr.id.node = msg_orignode(msg);
 		addr->addr.name.domain = 0;	 
  static int recv_msg(struct kiocb *iocb, struct socket *sock,
 		goto exit;
 	}
 
	 
	m->msg_namelen = 0;

 	timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 restart:
 
  static int recv_stream(struct kiocb *iocb, struct socket *sock,
 		goto exit;
 	}
 
	 
	m->msg_namelen = 0;

 	target = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);
 	timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
 ","net/tipc/socket.c in the Linux kernel before 3.9-rc7 does not initialize a certain data structure and a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
183,CVE-2013-3234,"  static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,
 	skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 
 	if (srose != NULL) {
		memset(srose, 0, msg->msg_namelen);
 		srose->srose_family = AF_ROSE;
 		srose->srose_addr   = rose->dest_addr;
 		srose->srose_call   = rose->dest_call;","The rose_recvmsg function in net/rose/af_rose.c in the Linux kernel before 3.9-rc7 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
184,CVE-2013-3233,"  static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	pr_debug(""%p %zu\n"", sk, len);
 
	msg->msg_namelen = 0;

 	lock_sock(sk);
 
 	if (sk->sk_state == LLCP_CLOSED &&
  static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 		pr_debug(""Datagram socket %d %d\n"", ui_cb->dsap, ui_cb->ssap);
 
		memset(sockaddr, 0, sizeof(*sockaddr));
 		sockaddr->sa_family = AF_NFC;
 		sockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;
 		sockaddr->dsap = ui_cb->dsap;","The llcp_sock_recvmsg function in net/nfc/llcp/sock.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable and a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
185,CVE-2013-3232,"  static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,
 	}
 
 	if (sax != NULL) {
		memset(sax, 0, sizeof(sax));
 		sax->sax25_family = AF_NETROM;
 		skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,
 			      AX25_ADDR_LEN);","The nr_recvmsg function in net/netrom/af_netrom.c in the Linux kernel before 3.9-rc7 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
186,CVE-2013-3231,"  static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,
 	int target;	 
 	long timeo;
 
	msg->msg_namelen = 0;

 	lock_sock(sk);
 	copied = -ENOTCONN;
 	if (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))","The llc_ui_recvmsg function in net/llc/af_llc.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
187,CVE-2013-3230,"  static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,
 		lsa->l2tp_addr = ipv6_hdr(skb)->saddr;
 		lsa->l2tp_flowinfo = 0;
 		lsa->l2tp_scope_id = 0;
		lsa->l2tp_conn_id = 0;
 		if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
 			lsa->l2tp_scope_id = IP6CB(skb)->iif;
 	}","The l2tp_ip6_recvmsg function in net/l2tp/l2tp_ip6.c in the Linux kernel before 3.9-rc7 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
188,CVE-2013-3229,"  static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 	struct sk_buff *skb, *rskb, *cskb;
 	int err = 0;
 
	msg->msg_namelen = 0;

 	if ((sk->sk_state == IUCV_DISCONN) &&
 	    skb_queue_empty(&iucv->backlog_skb_q) &&
 	    skb_queue_empty(&sk->sk_receive_queue) &&","The iucv_sock_recvmsg function in net/iucv/af_iucv.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
189,CVE-2013-3228,"  static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,
 
 	IRDA_DEBUG(4, ""%s()\n"", __func__);
 
	msg->msg_namelen = 0;

 	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
 				flags & MSG_DONTWAIT, &err);
 	if (!skb)","The irda_recvmsg_dgram function in net/irda/af_irda.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
190,CVE-2013-3227,"  static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,
 	if (m->msg_flags&MSG_OOB)
 		goto read_error;
 
	m->msg_namelen = 0;

 	skb = skb_recv_datagram(sk, flags, 0 , &ret);
 	if (!skb)
 		goto read_error;","The caif_seqpkt_recvmsg function in net/caif/caif_socket.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
191,CVE-2013-3226,"  static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 	    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {
 		hci_conn_accept(pi->conn->hcon, 0);
 		sk->sk_state = BT_CONFIG;
		msg->msg_namelen = 0;
 
 		release_sock(sk);
 		return 0;","The sco_sock_recvmsg function in net/bluetooth/sco.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
192,CVE-2013-3225,"  static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {
 		rfcomm_dlc_accept(d);
		msg->msg_namelen = 0;
 		return 0;
 	}
 ","The rfcomm_sock_recvmsg function in net/bluetooth/rfcomm/sock.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
193,CVE-2013-3224,"  int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
 
	msg->msg_namelen = 0;

 	skb = skb_recv_datagram(sk, flags, noblock, &err);
 	if (!skb) {
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
 			return 0;
 		return err;
 	}
 
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;","The bt_sock_recvmsg function in net/bluetooth/af_bluetooth.c in the Linux kernel before 3.9-rc7 does not properly initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
194,CVE-2013-3223,"  static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,
 		ax25_address src;
 		const unsigned char *mac = skb_mac_header(skb);
 
		memset(sax, 0, sizeof(struct full_sockaddr_ax25));
 		ax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,
 				&digi, NULL, NULL);
 		sax->sax25_family = AF_AX25;","The ax25_recvmsg function in net/ax25/af_ax25.c in the Linux kernel before 3.9-rc7 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
195,CVE-2013-3222,"  int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 	struct sk_buff *skb;
 	int copied, error = -EINVAL;
 
	msg->msg_namelen = 0;

 	if (sock->state != SS_CONNECTED)
 		return -ENOTCONN;
 ","The vcc_recvmsg function in net/atm/common.c in the Linux kernel before 3.9-rc7 does not initialize a certain length variable, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
196,CVE-2013-3076,"  static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;

 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;","The crypto API in the Linux kernel through 3.9-rc8 does not initialize certain length variables, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call, related to the hash_recvmsg function in crypto/algif_hash.c and the skcipher_recvmsg function in crypto/algif_skcipher.c."
197,CVE-2013-2930,"  static int perf_trace_event_perm(struct ftrace_event_call *tp_event,
 {
 	 
 	if (ftrace_event_is_function(tp_event) &&
	    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	 ","The perf_trace_event_perm function in kernel/trace/trace_event_perf.c in the Linux kernel before 3.12.2 does not properly restrict access to the perf subsystem, which allows local users to enable function tracing via a crafted application."
198,CVE-2013-2929,"  struct thread_struct {
 	regs->loadrs = 0;									\
 	regs->r8 = get_dumpable(current->mm);	 		\
 	regs->r12 = new_sp - 16;	 			\
	if (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {	\
 		/*										\
 		 * Zap scratch regs to avoid leaking bits between processes with different	\
 		 * uid/privileges.								\","The Linux kernel before 3.12.2 does not properly use the get_dumpable function, which allows local users to bypass intended ptrace restrictions or obtain sensitive information from IA64 scratch registers via a crafted application, related to kernel/ptrace.c and arch/ia64/include/asm/processor.h."
199,CVE-2013-2850,"  static int iscsi_add_notunderstood_response(
 	}
 	INIT_LIST_HEAD(&extra_response->er_list);
 
	strlcpy(extra_response->key, key, sizeof(extra_response->key));
	strlcpy(extra_response->value, NOTUNDERSTOOD,
		sizeof(extra_response->value));
 
 	list_add_tail(&extra_response->er_list,
 			&param_list->extra_response_list);
  int iscsi_decode_text_input(
 
 		if (phase & PHASE_SECURITY) {
 			if (iscsi_check_for_auth_key(key) > 0) {
 				kfree(tmpbuf);
 				return 1;
 			}",Heap-based buffer overflow in the iscsi_add_notunderstood_response function in drivers/target/iscsi/iscsi_target_parameters.c in the iSCSI target subsystem in the Linux kernel through 3.9.4 allows remote attackers to cause a denial of service (memory corruption and OOPS) or possibly execute arbitrary code via a long key that is not properly handled during construction of an error-response packet.
200,CVE-2013-2765,"  static apr_status_t modsecurity_request_body_store_memory(modsec_rec *msr,
 
      
     if ((msr->msc_reqbody_spilltodisk)
        && (msr->txcfg->reqbody_buffering != REQUEST_BODY_FORCEBUF_ON)
         && (msr->msc_reqbody_length + length > (apr_size_t)msr->txcfg->reqbody_inmemory_limit))
     {
         msc_data_chunk **chunks;","The ModSecurity module before 2.7.4 for the Apache HTTP Server allows remote attackers to cause a denial of service (NULL pointer dereference, process crash, and disk consumption) via a POST request with a large body and a crafted Content-Type header."
201,CVE-2013-2636,"  static int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,
 				port = p->port;
 				if (port) {
 					struct br_mdb_entry e;
					memset(&e, 0, sizeof(e));
 					e.ifindex = port->dev->ifindex;
 					e.state = p->state;
 					if (p->addr.proto == htons(ETH_P_IP))
  static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)
 				break;
 
 			bpm = nlmsg_data(nlh);
			memset(bpm, 0, sizeof(*bpm));
 			bpm->ifindex = dev->ifindex;
 			if (br_mdb_fill_info(skb, cb, dev) < 0)
 				goto out;
  static int nlmsg_populate_mdb_fill(struct sk_buff *skb,
 		return -EMSGSIZE;
 
 	bpm = nlmsg_data(nlh);
	memset(bpm, 0, sizeof(*bpm));
 	bpm->family  = AF_BRIDGE;
 	bpm->ifindex = dev->ifindex;
 	nest = nla_nest_start(skb, MDBA_MDB);
  void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 {
 	struct br_mdb_entry entry;
 
	memset(&entry, 0, sizeof(entry));
 	entry.ifindex = port->dev->ifindex;
 	entry.addr.proto = group->proto;
 	entry.addr.u.ip4 = group->u.ip4;","net/bridge/br_mdb.c in the Linux kernel before 3.8.4 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."
202,CVE-2013-2635,"  static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
 			 * report anything.
 			 */
 			ivi.spoofchk = -1;
			memset(ivi.mac, 0, sizeof(ivi.mac));
 			if (dev->netdev_ops->ndo_get_vf_config(dev, i, &ivi))
 				break;
 			vf_mac.vf =","The rtnl_fill_ifinfo function in net/core/rtnetlink.c in the Linux kernel before 3.8.4 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
203,CVE-2013-2634,"  static int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,
 	if (!netdev->dcbnl_ops->getpermhwaddr)
 		return -EOPNOTSUPP;
 
	memset(perm_addr, 0, sizeof(perm_addr));
 	netdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);
 
 	return nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);
  static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)
 
 	if (ops->ieee_getets) {
 		struct ieee_ets ets;
		memset(&ets, 0, sizeof(ets));
 		err = ops->ieee_getets(netdev, &ets);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))
  static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)
 
 	if (ops->ieee_getmaxrate) {
 		struct ieee_maxrate maxrate;
		memset(&maxrate, 0, sizeof(maxrate));
 		err = ops->ieee_getmaxrate(netdev, &maxrate);
 		if (!err) {
 			err = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,
  static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)
 
 	if (ops->ieee_getpfc) {
 		struct ieee_pfc pfc;
		memset(&pfc, 0, sizeof(pfc));
 		err = ops->ieee_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))
  static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)
 	 
 	if (ops->ieee_peer_getets) {
 		struct ieee_ets ets;
		memset(&ets, 0, sizeof(ets));
 		err = ops->ieee_peer_getets(netdev, &ets);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))
  static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)
 
 	if (ops->ieee_peer_getpfc) {
 		struct ieee_pfc pfc;
		memset(&pfc, 0, sizeof(pfc));
 		err = ops->ieee_peer_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))
  static int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)
 	 
 	if (ops->cee_peer_getpg) {
 		struct cee_pg pg;
		memset(&pg, 0, sizeof(pg));
 		err = ops->cee_peer_getpg(netdev, &pg);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))
  static int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)
 
 	if (ops->cee_peer_getpfc) {
 		struct cee_pfc pfc;
		memset(&pfc, 0, sizeof(pfc));
 		err = ops->cee_peer_getpfc(netdev, &pfc);
 		if (!err &&
 		    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))","net/dcb/dcbnl.c in the Linux kernel before 3.8.4 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
204,CVE-2013-2596,"  fb_mmap(struct file *file, struct vm_area_struct * vma)
 {
 	struct fb_info *info = file_fb_info(file);
 	struct fb_ops *fb;
	unsigned long mmio_pgoff;
 	unsigned long start;
 	u32 len;
 
 	if (!info)
 		return -ENODEV;
 	fb = info->fbops;
 	if (!fb)
 		return -ENODEV;
  fb_mmap(struct file *file, struct vm_area_struct * vma)
 		return res;
 	}
 
	 
 	start = info->fix.smem_start;
	len = info->fix.smem_len;
	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
	if (vma->vm_pgoff >= mmio_pgoff) {
		vma->vm_pgoff -= mmio_pgoff;
 		start = info->fix.mmio_start;
		len = info->fix.mmio_len;
 	}
 	mutex_unlock(&info->mm_lock);

 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
	fb_pgprotect(file, vma, start);

	return vm_iomap_memory(vma, start, len);
 }
 
 static int","Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program."
205,CVE-2013-2548,"  static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	strncpy(rblkcipher.type, ""ablkcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<default>"",
		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
  static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;","The crypto_report_one function in crypto/crypto_user.c in the report API in the crypto user configuration API in the Linux kernel through 3.8.2 uses an incorrect length value during a copy operation, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability."
206,CVE-2013-2237,"  static int key_notify_policy_flush(const struct km_event *c)
 	hdr->sadb_msg_pid = c->portid;
 	hdr->sadb_msg_version = PF_KEY_V2;
 	hdr->sadb_msg_errno = (uint8_t) 0;
	hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 	return 0;","The key_notify_policy_flush function in net/key/af_key.c in the Linux kernel before 3.9 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify_policy interface of an IPSec key_socket."
207,CVE-2013-2234,"  static int key_notify_sa_flush(const struct km_event *c)
 	hdr->sadb_msg_version = PF_KEY_V2;
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
	hdr->sadb_msg_reserved = 0;
 
 	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 
  static int key_notify_policy_flush(const struct km_event *c)
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
	hdr->sadb_msg_reserved = 0;
 	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 	return 0;
 ","The (1) key_notify_sa_flush and (2) key_notify_policy_flush functions in net/key/af_key.c in the Linux kernel before 3.10 do not initialize certain structure members, which allows local users to obtain sensitive information from kernel heap memory by reading a broadcast message from the notify interface of an IPSec key_socket."
208,CVE-2013-2232,"  static struct dst_entry *ip6_sk_dst_check(struct sock *sk,
 					  const struct flowi6 *fl6)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
	struct rt6_info *rt;
 
 	if (!dst)
 		goto out;
 
	if (dst->ops->family != AF_INET6) {
		dst_release(dst);
		return NULL;
	}

	rt = (struct rt6_info *)dst;
 	/* Yes, checking route validity in not connected
 	 * case is not very simple. Take into account,
 	 * that we do not support routing by source, TOS,",The ip6_sk_dst_check function in net/ipv6/ip6_output.c in the Linux kernel before 3.10 allows local users to cause a denial of service (system crash) by using an AF_INET6 socket for a connection to an IPv4 interface.
209,CVE-2013-2220,"  PHP_FUNCTION(radius_get_attr)
  
 PHP_FUNCTION(radius_get_vendor_attr)
 {
	const void *data, *raw;
 	int len;
 	u_int32_t vendor;
	unsigned char type;
	size_t data_len;
 
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &raw, &len) == FAILURE) {
 		return;
 	}
 
	if (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {
 		RETURN_FALSE;
 	} else {
 
 		array_init(return_value);
		add_assoc_long(return_value, ""attr"", type);
 		add_assoc_long(return_value, ""vendor"", vendor);
		add_assoc_stringl(return_value, ""data"", (char *) data, data_len, 1);
 		return;
 	}
 }",Buffer overflow in the radius_get_vendor_attr function in the Radius extension before 1.2.7 for PHP allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large Vendor Specific Attributes (VSA) length value.
210,CVE-2013-2206,"  sctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,
 	}
 
 	 
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));
 	sctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());
 
 	/* Restore association pointer to provide SCTP command interpeter","The sctp_sf_do_5_2_4_dupcook function in net/sctp/sm_statefuns.c in the SCTP implementation in the Linux kernel before 3.8.5 does not properly handle associations during the processing of a duplicate COOKIE ECHO chunk, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via crafted SCTP traffic."
211,CVE-2013-2174," 
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
 * Copyright (C) 1998 - 2013, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  CURLcode Curl_urldecode(struct SessionHandle *data,
 
   while(--alloc > 0) {
     in = *string;
    if(('%' == in) && (alloc > 2) &&
       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
        
       char hexstr[3];
       char *ptr;",Heap-based buffer overflow in the curl_easy_unescape function in lib/escape.c in cURL and libcurl 7.7 through 7.30.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted string ending in a *%* (percent) character.
212,CVE-2013-2146,"  static struct event_constraint intel_gen_event_constraints[] __read_mostly =
 };
 
 static struct extra_reg intel_snb_extra_regs[] __read_mostly = {
	INTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3f807f8fffull, RSP_0),
	INTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3f807f8fffull, RSP_1),
	EVENT_EXTRA_END
};

static struct extra_reg intel_snbep_extra_regs[] __read_mostly = {
	INTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffff8fffull, RSP_0),
	INTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffff8fffull, RSP_1),
 	EVENT_EXTRA_END
 };
 
  __init int intel_pmu_init(void)
 		x86_pmu.event_constraints = intel_snb_event_constraints;
 		x86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;
 		x86_pmu.pebs_aliases = intel_pebs_aliases_snb;
		if (boot_cpu_data.x86_model == 45)
			x86_pmu.extra_regs = intel_snbep_extra_regs;
		else
			x86_pmu.extra_regs = intel_snb_extra_regs;
 		 
 		x86_pmu.er_flags |= ERF_HAS_RSP_1;
 		x86_pmu.er_flags |= ERF_NO_HT_SHARING;
  __init int intel_pmu_init(void)
 		x86_pmu.event_constraints = intel_ivb_event_constraints;
 		x86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;
 		x86_pmu.pebs_aliases = intel_pebs_aliases_snb;
		if (boot_cpu_data.x86_model == 62)
			x86_pmu.extra_regs = intel_snbep_extra_regs;
		else
			x86_pmu.extra_regs = intel_snb_extra_regs;
 		 
 		x86_pmu.er_flags |= ERF_HAS_RSP_1;
 		x86_pmu.er_flags |= ERF_NO_HT_SHARING;","arch/x86/kernel/cpu/perf_event_intel.c in the Linux kernel before 3.8.9, when the Performance Events Subsystem is enabled, specifies an incorrect bitmask, which allows local users to cause a denial of service (general protection fault and system crash) by attempting to set a reserved bit."
213,CVE-2013-2141,"  do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)
 
 static int do_tkill(pid_t tgid, pid_t pid, int sig)
 {
	struct siginfo info = {};
 
 	info.si_signo = sig;
 	info.si_errno = 0;","The do_tkill function in kernel/signal.c in the Linux kernel before 3.8.9 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via a crafted application that makes a (1) tkill or (2) tgkill system call."
214,CVE-2013-2140,"  static int dispatch_discard_io(struct xen_blkif *blkif,
 	int status = BLKIF_RSP_OKAY;
 	struct block_device *bdev = blkif->vbd.bdev;
 	unsigned long secure;
	struct phys_req preq;

	preq.sector_number = req->u.discard.sector_number;
	preq.nr_sects      = req->u.discard.nr_sectors;
 
	err = xen_vbd_translate(&preq, blkif, WRITE);
	if (err) {
		pr_warn(DRV_PFX ""access denied: DISCARD [%llu->%llu] on dev=%04x\n"",
			preq.sector_number,
			preq.sector_number + preq.nr_sects, blkif->vbd.pdevice);
		goto fail_response;
	}
 	blkif->st_ds_req++;
 
 	xen_blkif_get(blkif);
  static int dispatch_discard_io(struct xen_blkif *blkif,
 	err = blkdev_issue_discard(bdev, req->u.discard.sector_number,
 				   req->u.discard.nr_sectors,
 				   GFP_KERNEL, secure);
fail_response:
 	if (err == -EOPNOTSUPP) {
 		pr_debug(DRV_PFX ""discard op failed, not supported\n"");
 		status = BLKIF_RSP_EOPNOTSUPP;",The dispatch_discard_io function in drivers/block/xen-blkback/blkback.c in the Xen blkback implementation in the Linux kernel before 3.10.5 allows guest OS users to cause a denial of service (data loss) via filesystem write operations on a read-only disk that supports the (1) BLKIF_OP_DISCARD (aka discard or TRIM) or (2) SCSI UNMAP feature.
215,CVE-2013-2128,"  int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,
 		sk_eat_skb(sk, skb, 0);
 		if (!desc->count)
 			break;
		tp->copied_seq = seq;
 	}
 	tp->copied_seq = seq;
 ","The tcp_read_sock function in net/ipv4/tcp.c in the Linux kernel before 2.6.34 does not properly manage skb consumption, which allows local users to cause a denial of service (system crash) via a crafted splice system call for a TCP socket."
216,CVE-2013-2127,"  int LibRaw::subtract_black()
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #define LIM(x,min,max) MAX(min,MIN(x,max))
 #define CLIP(x) LIM(x,0,65535)
			int dmax = 0;
			for(i=0; i< size*4; i++)
               {
                 int val = imgdata.image[0][i];
                 val -= cblk[i & 3];
                 imgdata.image[0][i] = CLIP(val);
                if(dmax < val) dmax = val;
               }
			C.data_maximum = dmax & 0xffff;
 #undef MIN
 #undef MAX
 #undef LIM
  int LibRaw::subtract_black()
            
           int idx;
           ushort *p = (ushort*)imgdata.image;
		  int dmax = 0;
           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)
            if(dmax < p[idx]) dmax = p[idx];
		  C.data_maximum = dmax;
         }
 		return 0;
 	}
  void LibRaw::exp_bef(float shift, float smooth)
             imgdata.image[i][3] = lut[imgdata.image[i][3]];
         }
 
	if(C.data_maximum <=TBLN)
		C.data_maximum = lut[C.data_maximum];
	if(C.maximum <= TBLN)
		C.maximum = lut[C.maximum];
      
     free(lut);
 }
  int LibRaw::dcraw_process(void)
 
         raw2image_ex(subtract_inline);  
 
		int save_4color = O.four_color_rgb;
 
         if (IO.zero_is_bad) 
           {",Buffer overflow in the exposure correction code in LibRaw before 0.15.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via unspecified vectors.
217,CVE-2013-2126,"  int LibRaw::unpack(void)
                 IO.shrink = 0;
 				S.raw_pitch = S.width*8;
                  
                imgdata.rawdata.raw_alloc = 0;
                imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));
               }
             ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);
 
  int LibRaw::unpack(void)
             (this->*load_raw)();
 			if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,""Nikon""))
 				C.maximum = m_save;
			if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)
			{
				 
				imgdata.rawdata.raw_alloc = imgdata.image;
				imgdata.image = 0; 
			}
           }
 
         if(imgdata.rawdata.raw_image)",Multiple double free vulnerabilities in the LibRaw::unpack function in libraw_cxx.cpp in LibRaw before 0.15.2 allow context-dependent attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a malformed full-color (1) Foveon or (2) sRAW image file.
218,CVE-2013-2094,"  static void sw_perf_event_destroy(struct perf_event *event)
 
 static int perf_swevent_init(struct perf_event *event)
 {
	u64 event_id = event->attr.config;
 
 	if (event->attr.type != PERF_TYPE_SOFTWARE)
 		return -ENOENT;","The perf_swevent_init function in kernel/events/core.c in the Linux kernel before 3.8.9 uses an incorrect integer data type, which allows local users to gain privileges via a crafted perf_event_open system call."
219,CVE-2013-2061,"  buf_read_u32 (struct buffer *buf, bool *good)
     }
 }
 
 
 static inline bool
 buf_string_match (const struct buffer *src, const void *match, int size)
 {
  buf_string_match (const struct buffer *src, const void *match, int size)
   return memcmp (BPTR (src), match, size) == 0;
 }
 
 
 static inline bool
 buf_string_match_head (const struct buffer *src, const void *match, int size)
 {","The openvpn_decrypt function in crypto.c in OpenVPN 2.3.0 and earlier, when running in UDP mode, allows remote attackers to obtain sensitive information via a timing attack involving an HMAC comparison function that does not run in constant time and a padding oracle attack on the CBC mode cipher."
220,CVE-2013-2058,"  static int host_start(struct ci13xxx *ci)
 	else
 		ci->hcd = hcd;
 
	if (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)
		hw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);

 	return ret;
 }
 ","The host_start function in drivers/usb/chipidea/host.c in the Linux kernel before 3.7.4 does not properly support a certain non-streaming option, which allows local users to cause a denial of service (system crash) by sending a large amount of network traffic through a USB/Ethernet adapter."
221,CVE-2013-2021,"  static void pdfobj_flag(struct pdf_struct *pdf, struct pdf_obj *obj, enum pdf_fl
 	case MANY_FILTERS:
 	    s = ""more than 2 filters per obj"";
 	    break;
	case DECRYPTABLE_PDF:
	    s = ""decryptable PDF"";
	    break;
     }
     cli_dbgmsg(""cli_pdf: %s flagged in object %u %u\n"", s, obj->id>>8, obj->id&0xff);
 }
  static int pdf_extract_obj(struct pdf_struct *pdf, struct pdf_obj *obj)
     char *ascii_decoded = NULL;
     int dump = 1;
 
    cli_dbgmsg(""pdf_extract_obj: obj %u %u\n"", obj->id>>8, obj->id&0xff);

      
     if ((!(obj->flags & (1 << OBJ_STREAM)) ||
 	(obj->flags & (1 << OBJ_HASFILTERS)))
  static int pdf_extract_obj(struct pdf_struct *pdf, struct pdf_obj *obj)
     }
     if (!dump)
 	return CL_CLEAN;
    cli_dbgmsg(""cli_pdf: dumping obj %u %u\n"", obj->id>>8, obj->id&0xff);
     snprintf(fullname, sizeof(fullname), ""%s""PATHSEP""pdf%02u"", pdf->dir, pdf->files++);
     fout = open(fullname,O_RDWR|O_CREAT|O_EXCL|O_TRUNC|O_BINARY, 0600);
     if (fout < 0) {
  static void pdf_parseobj(struct pdf_struct *pdf, struct pdf_obj *obj)
 	q2 = pdf_nextobject(q, bytesleft);
 	bytesleft -= q2 -q;
 	if (!q2 || bytesleft < 0) {
            cli_dbgmsg(""cli_pdf: %u %u obj: no dictionary\n"", obj->id>>8, obj->id&0xff);
 	    return;
 	}
 	q3 = memchr(q-1, '<', q2-q+1);
  static void pdf_parseobj(struct pdf_struct *pdf, struct pdf_obj *obj)
 	q2 = pdf_nextobject(q, bytesleft);
 	bytesleft -= q2 -q;
 	if (!q2 || bytesleft < 0) {
            cli_dbgmsg(""cli_pdf: %u %u obj: broken dictionary\n"", obj->id>>8, obj->id&0xff);
 	    return;
 	}
 	q3 = memchr(q-1, '>', q2-q+1);
  static void check_user_password(struct pdf_struct *pdf, int R, const char *O,
 	    password_empty = 1;
 	     
 	}
    } else if ((R >= 2) && (R <= 4)) {
 	 
 	cli_md5_init(&md5);
 	 
  static void check_user_password(struct pdf_struct *pdf, int R, const char *O,
 	    cli_md5_update(&md5, &v, 4);
 	}
 	cli_md5_final(result, &md5);
	if (length > 128)
	    length = 128;
 	if (R >= 3) {
 	    for (i=0;i<50;i++) {
 		cli_md5_init(&md5);
 		cli_md5_update(&md5, result, length/8);
  static void check_user_password(struct pdf_struct *pdf, int R, const char *O,
 	    cli_dbgmsg(""cli_pdf: invalid revision %d\n"", R);
 	}
     }
    else {
	 
	cli_dbgmsg(""cli_pdf: R value out of range\n"");
	return;
    }
     if (password_empty) {
 	cli_dbgmsg(""cli_pdf: user password is empty\n"");
 	/* The key we computed above is the key used to encrypt the streams.
  static void pdf_handle_enc(struct pdf_struct *pdf)
 	    cli_dbgmsg(""cli_pdf: invalid R\n"");
 	    break;
 	}
	if ((R > 5) || (R < 2)) {
	    cli_dbgmsg(""cli_pdf: R value outside supported range [2..5]\n"");
	    break;
	}
 
 	if (R < 5)
 	    oulen = 32;",pdf.c in ClamAV 0.97.1 through 0.97.7 allows remote attackers to cause a denial of service (out-of-bounds-read) via a crafted length value in an encrypted PDF file.
222,CVE-2013-2017,"  static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 
 rx_drop:
 	rcv_stats->rx_dropped++;
 	return NETDEV_TX_OK;
 }","The veth (aka virtual Ethernet) driver in the Linux kernel before 2.6.34 does not properly manage skbs during congestion, which allows remote attackers to cause a denial of service (system crash) by leveraging lack of skb consumption in conjunction with a double-free error."
223,CVE-2013-2015,"  int ext4_orphan_del(handle_t *handle, struct inode *inode)
 	struct ext4_iloc iloc;
 	int err = 0;
 
	if ((!EXT4_SB(inode->i_sb)->s_journal) &&
	    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS))
 		return 0;
 
 	mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);","The ext4_orphan_del function in fs/ext4/namei.c in the Linux kernel before 3.7.3 does not properly handle orphan-list entries for non-journal filesystems, which allows physically proximate attackers to cause a denial of service (system hang) via a crafted filesystem on removable media, as demonstrated by the e2fsprogs tests/f_orphan_extents_inode/image.gz test."
224,CVE-2013-1979,"  static __inline__ void scm_set_cred(struct scm_cookie *scm,
 	scm->pid  = get_pid(pid);
 	scm->cred = cred ? get_cred(cred) : NULL;
 	scm->creds.pid = pid_vnr(pid);
	scm->creds.uid = cred ? cred->uid : INVALID_UID;
	scm->creds.gid = cred ? cred->gid : INVALID_GID;
 }
 
 static __inline__ void scm_destroy_cred(struct scm_cookie *scm)","The scm_set_cred function in include/net/scm.h in the Linux kernel before 3.8.11 uses incorrect uid and gid values during credentials passing, which allows local users to gain privileges via a crafted application."
225,CVE-2013-1959," 
 
 static struct kmem_cache *user_ns_cachep __read_mostly;
 
static bool new_idmap_permitted(const struct file *file,
				struct user_namespace *ns, int cap_setid,
 				struct uid_gid_map *map);
 
 static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)
  static ssize_t map_write(struct file *file, const char __user *buf,
 
 	ret = -EPERM;
 	 
	if (!new_idmap_permitted(file, ns, cap_setid, &new_map))
 		goto out;
 
 	 
  static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,
 
 	 
	if (ns_capable(ns->parent, cap_setid) &&
	    file_ns_capable(file, ns->parent, cap_setid))
 		return true;
 
 	return false;","kernel/user_namespace.c in the Linux kernel before 3.8.9 does not have appropriate capability requirements for the uid_map and gid_map files, which allows local users to gain privileges by opening a file within an unprivileged process and then modifying the file within a privileged process."
226,CVE-2013-1958," 
 #include <linux/interrupt.h>
 #include <linux/netdevice.h>
 #include <linux/security.h>
#include <linux/pid_namespace.h>
 #include <linux/pid.h>
 #include <linux/nsproxy.h>
 #include <linux/slab.h>
  static __inline__ int scm_check_creds(struct ucred *creds)
 	if (!uid_valid(uid) || !gid_valid(gid))
 		return -EINVAL;
 
	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
 	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
 	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
 	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||","The scm_check_creds function in net/core/scm.c in the Linux kernel before 3.8.6 does not properly enforce capability requirements for controlling the PID value associated with a UNIX domain socket, which allows local users to bypass intended access restrictions by leveraging the time interval during which a user namespace has been created but a PID namespace has not been created."
227,CVE-2013-1957,"  static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 	}
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;
	 
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

 	atomic_inc(&sb->s_active);
 	mnt->mnt.mnt_sb = sb;
 	mnt->mnt.mnt_root = dget(root);
  static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,
 	 
 	copy_flags = CL_COPY_ALL | CL_EXPIRE;
 	if (user_ns != mnt_ns->user_ns)
		copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;
 	new = copy_tree(old, old->mnt.mnt_root, copy_flags);
 	if (IS_ERR(new)) {
 		up_write(&namespace_sem);","The clone_mnt function in fs/namespace.c in the Linux kernel before 3.8.6 does not properly restrict changes to the MNT_READONLY flag, which allows local users to bypass an intended read-only property of a filesystem by leveraging a separate mount namespace."
228,CVE-2013-1956,"  bool our_mnt(struct vfsmount *mnt)
 	return check_mnt(real_mount(mnt));
 }
 
bool current_chrooted(void)
{
	 
	struct path ns_root;
	struct path fs_root;
	bool chrooted;

	 
	ns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;
	ns_root.dentry = ns_root.mnt->mnt_root;
	path_get(&ns_root);
	while (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))
		;

	get_fs_root(current->fs, &fs_root);

	chrooted = !path_equal(&fs_root, &ns_root);

	path_put(&fs_root);
	path_put(&ns_root);

	return chrooted;
}

 static void *mntns_get(struct task_struct *task)
 {
 	struct mnt_namespace *ns = NULL;","The create_user_ns function in kernel/user_namespace.c in the Linux kernel before 3.8.6 does not check whether a chroot directory exists that differs from the namespace root directory, which allows local users to bypass intended filesystem restrictions via a crafted clone system call."
229,CVE-2013-1944,"  static void freecookie(struct Cookie *co)
   free(co);
 }
 
static bool tailmatch(const char *cooke_domain, const char *hostname)
 {
  size_t cookie_domain_len = strlen(cooke_domain);
  size_t hostname_len = strlen(hostname);
 
  if(hostname_len < cookie_domain_len)
     return FALSE;
 
  if(!Curl_raw_equal(cooke_domain, hostname+hostname_len-cookie_domain_len))
    return FALSE;

   
  if(hostname_len == cookie_domain_len)
    return TRUE;
  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))
    return TRUE;
  return FALSE;
 }
 
 /*","The tailMatch function in cookie.c in cURL and libcurl before 7.30.0 does not properly match the path domain when sending cookies, which allows remote attackers to steal cookies via a matching suffix in the domain of a URL."
230,CVE-2013-1943,"  static int FNAME(walk_addr_generic)(struct guest_walker *walker,
 		}
 
 		ptep_user = (pt_element_t __user *)((void *)host_addr + offset);
		if (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {
 			present = false;
 			break;
 		}","The KVM subsystem in the Linux kernel before 3.0 does not check whether kernel addresses are specified during allocation of memory slots for use in a guest's physical address space, which allows local users to gain privileges or obtain sensitive information from kernel memory via a crafted application, related to arch/x86/kvm/paging_tmpl.h and virt/kvm/kvm_main.c."
231,CVE-2013-1929,"  static void tg3_read_vpd(struct tg3 *tp)
 		if (j + len > block_end)
 			goto partno;
 
		if (len >= sizeof(tp->fw_ver))
			len = sizeof(tp->fw_ver) - 1;
		memset(tp->fw_ver, 0, sizeof(tp->fw_ver));
		snprintf(tp->fw_ver, sizeof(tp->fw_ver), ""%.*s bc "", len,
			 &vpd_data[j]);
 	}
 
 partno:",Heap-based buffer overflow in the tg3_read_vpd function in drivers/net/ethernet/broadcom/tg3.c in the Linux kernel before 3.8.6 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via crafted firmware that specifies a long string in the Vital Product Data (VPD) data structure.
232,CVE-2013-1928,"  static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,
 
 	err  = get_user(palp, &up->palette);
 	err |= get_user(length, &up->length);
	if (err)
		return -EFAULT;
 
 	up_native = compat_alloc_user_space(sizeof(struct video_spu_palette));
 	err  = put_user(compat_ptr(palp), &up_native->palette);","The do_video_set_spu_palette function in fs/compat_ioctl.c in the Linux kernel before 3.6.5 on unspecified architectures lacks a certain error check, which might allow local users to obtain sensitive information from kernel stack memory via a crafted VIDEO_SET_SPU_PALETTE ioctl call on a /dev/dvb device."
233,CVE-2013-1915,"  void *create_directory_config(apr_pool_t *mp, char *path)
     dcfg->crypto_hash_framesrc_pm = NOT_SET;
 
 
     
    dcfg->xml_external_entity = NOT_SET;

     return dcfg;
 }
 
  void *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)
     merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET
         ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);
 
     
    merged->xml_external_entity = (child->xml_external_entity == NOT_SET
        ? parent->xml_external_entity : child->xml_external_entity);

     return merged;
 }
 
  void init_directory_config(directory_config *dcfg)
     if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;
     if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;
 
     
    if (dcfg->xml_external_entity == NOT_SET) dcfg->xml_external_entity = 0;

 }
 
  
static const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = (directory_config *)_dcfg;
    if (dcfg == NULL) return NULL;

    if (strcasecmp(p1, ""on"") == 0)  {
        dcfg->xml_external_entity = 1;
    }
    else if (strcasecmp(p1, ""off"") == 0)    {
        dcfg->xml_external_entity = 0;
    }
    else return apr_psprintf(cmd->pool, ""ModSecurity: Invalid value for SecXmlExternalEntity: %s"", p1);

    return NULL;
}

 
 /**
* \brief Add SecHashEngine configuration option
 *
 * \param cmd Pointer to configuration data
 * \param _dcfg Pointer to directory configuration
  static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
         dcfg->hash_is_enabled = HASH_DISABLED;
         dcfg->hash_enforcement = HASH_DISABLED;
     }
    else return apr_psprintf(cmd->pool, ""ModSecurity: Invalid value for SexHashEngine: %s"", p1);
 
     return NULL;
 }
  const command_rec module_directives[] = {
         ""On or Off""
     ),
 
    AP_INIT_TAKE1 (
        ""SecXmlExternalEntity"",
        cmd_xml_external_entity,
        NULL,
        CMD_SCOPE_ANY,
        ""On or Off""
    ),

     AP_INIT_FLAG (
         ""SecRuleInheritance"",
         cmd_rule_inheritance,","ModSecurity before 2.7.3 allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via an XML external entity declaration in conjunction with an entity reference, aka an XML External Entity (XXE) vulnerability."
234,CVE-2013-1860,"  MODULE_DEVICE_TABLE (usb, wdm_ids);
 #define WDM_RESPONDING		7
 #define WDM_SUSPENDING		8
 #define WDM_RESETTING		9
#define WDM_OVERFLOW		10
 
 #define WDM_MAX			16
 
  static void wdm_in_callback(struct urb *urb)
 {
 	struct wdm_device *desc = urb->context;
 	int status = urb->status;
	int length = urb->actual_length;
 
 	spin_lock(&desc->iuspin);
 	clear_bit(WDM_RESPONDING, &desc->flags);
  static void wdm_in_callback(struct urb *urb)
 	}
 
 	desc->rerr = status;
	if (length + desc->length > desc->wMaxCommand) {
		 
		set_bit(WDM_OVERFLOW, &desc->flags);
	} else {
		 
		if (!test_bit(WDM_OVERFLOW, &desc->flags)) {
			memmove(desc->ubuf + desc->length, desc->inbuf, length);
			desc->length += length;
			desc->reslength = length;
		}
	}
 skip_error:
 	wake_up(&desc->wait);
 
  static ssize_t wdm_read
 			rv = -ENODEV;
 			goto err;
 		}
		if (test_bit(WDM_OVERFLOW, &desc->flags)) {
			clear_bit(WDM_OVERFLOW, &desc->flags);
			rv = -ENOBUFS;
			goto err;
		}
 		i++;
 		if (file->f_flags & O_NONBLOCK) {
 			if (!test_bit(WDM_READ, &desc->flags)) {
  static ssize_t wdm_read
 			spin_unlock_irq(&desc->iuspin);
 			goto retry;
 		}

 		if (!desc->reslength) {  
 			dev_dbg(&desc->intf->dev, ""%s: zero length - clearing WDM_READ\n"", __func__);
 			clear_bit(WDM_READ, &desc->flags);
  static int wdm_post_reset(struct usb_interface *intf)
 	struct wdm_device *desc = wdm_find_device(intf);
 	int rv;
 
	clear_bit(WDM_OVERFLOW, &desc->flags);
 	clear_bit(WDM_RESETTING, &desc->flags);
 	rv = recover_from_urb_loss(desc);
 	mutex_unlock(&desc->wlock);",Heap-based buffer overflow in the wdm_in_callback function in drivers/usb/class/cdc-wdm.c in the Linux kernel before 3.8.4 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted cdc-wdm USB device.
235,CVE-2013-1858,"  static struct task_struct *copy_process(unsigned long clone_flags,
 	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
 		return ERR_PTR(-EINVAL);
 
	if ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))
		return ERR_PTR(-EINVAL);

 	 
 	if (unshare_flags & CLONE_NEWUSER)
		unshare_flags |= CLONE_THREAD | CLONE_FS;
 	 ","The clone system-call implementation in the Linux kernel before 3.8.3 does not properly handle a combination of the CLONE_NEWUSER and CLONE_FS flags, which allows local users to gain privileges by calling chroot and leveraging the sharing of the / directory between a parent process and a child process."
236,CVE-2013-1848,"  static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
 	return bdev;
 
 fail:
	ext3_msg(sb, KERN_ERR, ""error: failed to open journal device %s: %ld"",
 		__bdevname(dev, b), PTR_ERR(bdev));
 
 	return NULL;
  static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)
 	 
 	sb_block = simple_strtoul(options, &options, 0);
 	if (*options && *options != ',') {
		ext3_msg(sb, KERN_ERR, ""error: invalid sb specification: %s"",
 		       (char *) *data);
 		return 1;
 	}","fs/ext3/super.c in the Linux kernel before 3.8.4 uses incorrect arguments to functions in certain circumstances related to printk input, which allows local users to conduct format-string attacks and possibly gain privileges via a crafted application."
237,CVE-2013-1828,"  static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,
 	if (len < sizeof(sctp_assoc_t))
 		return -EINVAL;
 
	 
	len = min_t(size_t, len, sizeof(sas));

 	if (copy_from_user(&sas, optval, len))
 		return -EFAULT;
 
  static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,
 	 
 	asoc->stats.max_obs_rto = asoc->rto_min;
 
 	if (put_user(len, optlen))
 		return -EFAULT;
 ","The sctp_getsockopt_assoc_stats function in net/sctp/socket.c in the Linux kernel before 3.8.4 does not validate a size value before proceeding to a copy_from_user operation, which allows local users to gain privileges via a crafted application that contains an SCTP_GET_ASSOC_STATS getsockopt system call."
238,CVE-2013-1827,"  static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,
 					u32 __user *optval, int __user *optlen)
 {
 	int rc = -ENOPROTOOPT;
	if (ccid != NULL && ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)
 		rc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,
 						 optval, optlen);
 	return rc;
  static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,
 					u32 __user *optval, int __user *optlen)
 {
 	int rc = -ENOPROTOOPT;
	if (ccid != NULL && ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)
 		rc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,
 						 optval, optlen);
 	return rc;",net/dccp/ccid.h in the Linux kernel before 3.5.4 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for a certain (1) sender or (2) receiver getsockopt call.
239,CVE-2013-1826,"  static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,
 {
 	struct xfrm_dump_info info;
 	struct sk_buff *skb;
	int err;
 
 	skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);
 	if (!skb)
  static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,
 	info.nlmsg_seq = seq;
 	info.nlmsg_flags = 0;
 
	err = dump_one_state(x, 0, &info);
	if (err) {
 		kfree_skb(skb);
		return ERR_PTR(err);
 	}
 
 	return skb;","The xfrm_state_netlink function in net/xfrm/xfrm_user.c in the Linux kernel before 3.5.7 does not properly handle error conditions in dump_one_state function calls, which allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability."
240,CVE-2013-1819,"  _xfs_buf_find(
 	struct rb_node		*parent;
 	xfs_buf_t		*bp;
 	xfs_daddr_t		blkno = map[0].bm_bn;
	xfs_daddr_t		eofs;
 	int			numblks = 0;
 	int			i;
 
  _xfs_buf_find(
 	ASSERT(!(numbytes < (1 << btp->bt_sshift)));
 	ASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));
 
	 
	eofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);
	if (blkno >= eofs) {
		 
		xfs_alert(btp->bt_mount,
			  ""%s: Block out of range: block 0x%llx, EOFS 0x%llx "",
			  __func__, blkno, eofs);
		return NULL;
	}

 	 
 	pag = xfs_perag_get(btp->bt_mount,
 				xfs_daddr_to_agno(btp->bt_mount, blkno));","The _xfs_buf_find function in fs/xfs/xfs_buf.c in the Linux kernel before 3.7.6 does not validate block numbers, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by leveraging the ability to mount an XFS filesystem containing a metadata inode with an invalid extent map."
241,CVE-2013-1798,"  static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 			u32 redir_index = (ioapic->ioregsel - 0x10) >> 1;
 			u64 redir_content;
 
			if (redir_index < IOAPIC_NUM_PINS)
				redir_content =
					ioapic->redirtbl[redir_index].bits;
			else
				redir_content = ~0ULL;
 
 			result = (ioapic->ioregsel & 0x1) ?
 			    (redir_content >> 32) & 0xffffffff :
 			    redir_content & 0xffffffff;","The ioapic_read_indirect function in virt/kvm/ioapic.c in the Linux kernel through 3.8.4 does not properly handle a certain combination of invalid IOAPIC_REG_SELECT and IOAPIC_REG_WINDOW operations, which allows guest OS users to obtain sensitive information from host OS memory or cause a denial of service (host OS OOPS) via a crafted application."
242,CVE-2013-1797,"  struct kvm_vcpu_arch {
 	gpa_t time;
 	struct pvclock_vcpu_time_info hv_clock;
 	unsigned int hw_tsc_khz;
	struct gfn_to_hva_cache pv_time;
	bool pv_time_enabled;
 	 
 	bool pvclock_set_guest_stopped_request;
 ",Use-after-free vulnerability in arch/x86/kvm/x86.c in the Linux kernel through 3.8.4 allows guest OS users to cause a denial of service (host OS memory corruption) or possibly have unspecified other impact via a crafted application that triggers use of a guest physical address (GPA) in (1) movable or (2) removable memory during an MSR_KVM_SYSTEM_TIME kvm_set_msr_common operation.
243,CVE-2013-1796,"  int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		 
 		vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);
 
		 
		if (vcpu->arch.time_offset &
				(sizeof(struct pvclock_vcpu_time_info) - 1))
			break;

 		vcpu->arch.time_page =
 				gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);
 ","The kvm_set_msr_common function in arch/x86/kvm/x86.c in the Linux kernel through 3.8.4 does not ensure a required time_page alignment during an MSR_KVM_SYSTEM_TIME operation, which allows guest OS users to cause a denial of service (buffer overflow and host OS memory corruption) or possibly have unspecified other impact via a crafted application."
244,CVE-2013-1792,"  int install_user_keyrings(void)
 
 	kenter(""%p{%u}"", user, uid);
 
	if (user->uid_keyring && user->session_keyring) {
 		kleave("" = 0 [exist]"");
 		return 0;
 	}",Race condition in the install_user_keyrings function in security/keys/process_keys.c in the Linux kernel before 3.8.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) via crafted keyctl system calls that trigger keyring operations in simultaneous threads.
245,CVE-2013-1774,"  static void chase_port(struct edgeport_port *port, unsigned long timeout,
 	wait_queue_t wait;
 	unsigned long flags;
 
	if (!tty)
		return;

 	if (!timeout)
 		timeout = (HZ * EDGE_CLOSING_WAIT)/100;
 ",The chase_port function in drivers/usb/serial/io_ti.c in the Linux kernel before 3.7.4 allows local users to cause a denial of service (NULL pointer dereference and system crash) via an attempted /dev/ttyUSB read or write operation on a disconnected Edgeport USB serial converter.
246,CVE-2013-1773,"  kvp_respond_to_host(char *key, char *value, int error)
 	 * The windows host expects the key/value pair to be encoded
 	 * in utf16.
 	 */
	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
				(wchar_t *) kvp_data->data.key,
				HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
 	kvp_data->data.key_size = 2*(keylen + 1);  
	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
				(wchar_t *) kvp_data->data.value,
				HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);
 	kvp_data->data.value_size = 2*(valuelen + 1);  
 
 	kvp_data->data.value_type = REG_SZ;  ","Buffer overflow in the VFAT filesystem implementation in the Linux kernel before 3.3 allows local users to gain privileges or cause a denial of service (system crash) via a VFAT write operation on a filesystem with the utf8 mount option, which is not properly handled during UTF-8 to UTF-16 conversion."
247,CVE-2013-1772," 
 #define SYSLOG_FROM_CALL 0
 #define SYSLOG_FROM_FILE 1
 
 
#define SYSLOG_PRI_MAX_LENGTH 5

 int do_syslog(int type, char __user *buf, int count, bool from_file);
 
 #endif  ","The log_prefix function in kernel/printk.c in the Linux kernel 3.x before 3.4.33 does not properly remove a prefix string from a syslog header, which allows local users to cause a denial of service (buffer overflow and system crash) by leveraging /dev/kmsg write access and triggering a call_console_drivers function call."
248,CVE-2013-1767,"  static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
 	unsigned long inodes;
 	int error = -EINVAL;
 
	config.mpol = NULL;
 	if (shmem_parse_options(data, &config, true))
 		return error;
 
  static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
 	sbinfo->max_inodes  = config.max_inodes;
 	sbinfo->free_inodes = config.max_inodes - inodes;
 
	 
	if (config.mpol) {
		mpol_put(sbinfo->mpol);
		sbinfo->mpol = config.mpol;	 
	}
 out:
 	spin_unlock(&sbinfo->stat_lock);
 	return error;",Use-after-free vulnerability in the shmem_remount_fs function in mm/shmem.c in the Linux kernel before 3.7.10 allows local users to gain privileges or cause a denial of service (system crash) by remounting a tmpfs filesystem without specifying a required mpol (aka mempolicy) mount option.
249,CVE-2013-1763,"  static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	if (nlmsg_len(nlh) < sizeof(*req))
 		return -EINVAL;
 
	if (req->sdiag_family >= AF_MAX)
		return -EINVAL;

 	hndl = sock_diag_lock_handler(req->sdiag_family);
 	if (hndl == NULL)
 		err = -ENOENT;",Array index error in the __sock_diag_rcv_msg function in net/core/sock_diag.c in the Linux kernel before 3.7.10 allows local users to gain privileges via a large family value in a Netlink message.
250,CVE-2013-1428,"  static void receive_udppacket(node_t *n, vpn_packet_t *inpkt) {
 void receive_tcppacket(connection_t *c, const char *buffer, int len) {
 	vpn_packet_t outpkt;
 
	if(len > sizeof outpkt.data)
		return;

 	outpkt.len = len;
 	if(c->options & OPTION_TCPONLY)
 		outpkt.priority = 0;",Stack-based buffer overflow in the receive_tcppacket function in net_packet.c in tinc before 1.0.21 and 1.1 before 1.1pre7 allows remote authenticated peers to cause a denial of service (crash) or possibly execute arbitrary code via a large TCP packet.
251,CVE-2013-1417,"  find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,
         goto cleanup;
     }
 cleanup:
    if (retval == 0 && server_ptr == NULL)
        retval = KRB5_KDB_NOENTRY;
     if (retval != 0)
         *status = ""UNKNOWN_SERVER"";
 
  find_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,
         goto cleanup;
     }
      
    if (realms == NULL || realms[0] == NULL || *realms[0] == '\0' ||
         data_eq_string(srealm, realms[0])) {
         retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
         goto cleanup;","do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) 1.11 before 1.11.4, when a single-component realm name is used, allows remote authenticated users to cause a denial of service (daemon crash) via a TGS-REQ request that triggers an attempted cross-realm referral for a host-based service principal."
252,CVE-2013-1416,"  prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)
             retval = ENOMEM;
             goto cleanup;
         }
        if (comp1->data != NULL)
            memcpy(comp1_str, comp1->data, comp1->length);
 
         if ((krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_HST ||
              krb5_princ_type(kdc_context, request->server) == KRB5_NT_SRV_INST ||
  prep_reprocess_req(krb5_kdc_req *request, krb5_principal *krbtgt_princ)
                 retval = ENOMEM;
                 goto cleanup;
             }
            if (comp2->data != NULL)
                memcpy(temp_buf, comp2->data, comp2->length);
             retval = krb5int_get_domain_realm_mapping(kdc_context, temp_buf, &realms);
             free(temp_buf);
             if (retval) {","The prep_reprocess_req function in do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.5 does not properly perform service-principal realm referral, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted TGS-REQ request."
253,CVE-2013-1415,"  pkinit_check_kdc_pkid(krb5_context context,
     pkiDebug(""found kdcPkId in AS REQ\n"");
     is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);
     if (is == NULL)
        return retval;
 
     status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);
     if (!status) {
  pkinit_check_kdc_pkid(krb5_context context,
     }
 
     retval = 0;
     X509_NAME_free(is->issuer);
     ASN1_INTEGER_free(is->serial);
     free(is);","The pkinit_check_kdc_pkid function in plugins/preauth/pkinit/pkinit_crypto_openssl.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 and 1.11.x before 1.11.1 does not properly handle errors during extraction of fields from an X.509 certificate, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a malformed KRB5_PADATA_PK_AS_REQ AS-REQ request."
254,CVE-2013-0914,"  flush_signal_handlers(struct task_struct *t, int force_default)
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
#ifdef SA_RESTORER
		ka->sa.sa_restorer = NULL;
#endif
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}","The flush_signal_handlers function in kernel/signal.c in the Linux kernel before 3.8.4 preserves the value of the sa_restorer field across an exec operation, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application containing a sigaction system call."
255,CVE-2013-0871,"  void set_task_blockstep(struct task_struct *task, bool on)
 	 * Ensure irq/preemption can't change debugctl in between.
 	 * Note also that both TIF_BLOCKSTEP and debugctl should
 	 * be changed atomically wrt preemption.
	 *
	 * NOTE: this means that set/clear TIF_BLOCKSTEP is only safe if
	 * task is current or it can't be running, otherwise we can race
	 * with __switch_to_xtra(). We rely on ptrace_freeze_traced() but
	 * PTRACE_KILL is not safe.
 	 */
 	local_irq_disable();
 	debugctl = get_debugctlmsr();","Race condition in the ptrace functionality in the Linux kernel before 3.7.5 allows local users to gain privileges via a PTRACE_SETREGS ptrace system call in a crafted application, as demonstrated by ptrace_death."
256,CVE-2013-0349,"  static int hidp_setup_hid(struct hidp_session *session,
 	hid->version = req->version;
 	hid->country = req->country;
 
	strncpy(hid->name, req->name, sizeof(req->name) - 1);
 
 	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
 		 &bt_sk(session->ctrl_sock->sk)->src);","The hidp_setup_hid function in net/bluetooth/hidp/core.c in the Linux kernel before 3.7.6 does not properly copy a certain name field, which allows local users to obtain sensitive information from kernel memory by setting a long name and making an HIDPCONNADD ioctl call."
257,CVE-2013-0313,"  int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,
 		rc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,
 					   &xattr_data,
 					   sizeof(xattr_data), 0);
	} else if (rc == -ENODATA && inode->i_op->removexattr) {
 		rc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);
	}
 	return rc;
 }
 ","The evm_update_evmxattr function in security/integrity/evm/evm_crypto.c in the Linux kernel before 3.7.5, when the Extended Verification Module (EVM) is enabled, allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an attempted removexattr operation on an inode of a sockfs filesystem."
258,CVE-2013-0311,"  static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,
 		}
 		_iov = iov + ret;
 		size = reg->memory_size - addr + reg->guest_phys_addr;
		_iov->iov_len = min((u64)len - s, size);
 		_iov->iov_base = (void __user *)(unsigned long)
 			(reg->userspace_addr + addr - reg->guest_phys_addr);
 		s += size;","The translate_desc function in drivers/vhost/vhost.c in the Linux kernel before 3.7 does not properly handle cross-region descriptors, which allows guest OS users to obtain host OS privileges by leveraging KVM guest OS privileges."
259,CVE-2013-0310,"  int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)
 		case CIPSO_V4_TAG_LOCAL:
 			 
			 * not the loopback device drop the packet. Further,
			 * there is no legitimate reason for setting this from
			 * userspace so reject it if skb is NULL. */
			if (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {
 				err_offset = opt_iter;
 				goto validate_return_locked;
 			}",The cipso_v4_validate function in net/ipv4/cipso_ipv4.c in the Linux kernel before 3.4.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via an IPOPT_CIPSO IP_OPTIONS setsockopt system call.
260,CVE-2013-0309,"  static inline unsigned long pmd_pfn(pmd_t pmd)
 
 static inline int pmd_large(pmd_t pte)
 {
	return pmd_flags(pte) & _PAGE_PSE;
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
  static inline int pte_hidden(pte_t pte)
 
 static inline int pmd_present(pmd_t pmd)
 {
	 
	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);
 }
 
 static inline int pmd_none(pmd_t pmd)","arch/x86/include/asm/pgtable.h in the Linux kernel before 3.6.2, when transparent huge pages are used, does not properly support PROT_NONE memory regions, which allows local users to cause a denial of service (system crash) via a crafted application."
261,CVE-2013-0290,"  struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 		skb_queue_walk(queue, skb) {
 			*peeked = skb->peeked;
 			if (flags & MSG_PEEK) {
				if (*off >= skb->len && skb->len) {
 					*off -= skb->len;
 					continue;
 				}","The __skb_recv_datagram function in net/core/datagram.c in the Linux kernel before 3.8 does not properly handle the MSG_PEEK flag with zero-length data, which allows local users to cause a denial of service (infinite loop and system hang) via a crafted application."
262,CVE-2013-0281,"  do_local_notify(xmlNode * notify_src, const char *client_id,
         int rid = 0;
 
         if(sync_reply) {
            if (client_obj->ipc) {
                CRM_LOG_ASSERT(client_obj->request_id);
 
                rid = client_obj->request_id;
                client_obj->request_id = 0;
 
                crm_trace(""Sending response %d to %s %s"",
                       rid, client_obj->name, from_peer?""(originator of delegated request)"":"""");
            } else {
                crm_trace(""Sending response to %s %s"",
                      client_obj->name, from_peer?""(originator of delegated request)"":"""");
            }
 
         } else {
             crm_trace(""Sending an event to %s %s"",","Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking)."
263,CVE-2013-0268,"  static int msr_open(struct inode *inode, struct file *file)
 	unsigned int cpu;
 	struct cpuinfo_x86 *c;
 
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;

 	cpu = iminor(file->f_path.dentry->d_inode);
 	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
 		return -ENXIO;	 ","The msr_open function in arch/x86/kernel/msr.c in the Linux kernel before 3.7.6 allows local users to bypass intended capability restrictions by executing a crafted application as root, as demonstrated by msr32.c."
264,CVE-2013-0217,"  void xen_netbk_remove_xenvif(struct xenvif *vif)
 	atomic_dec(&netbk->netfront_count);
 }
 
static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,
				  u8 status);
 static void make_tx_response(struct xenvif *vif,
 			     struct xen_netif_tx_request *txp,
 			     s8       st);
  static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,
 {
 	struct gnttab_copy *gop = *gopp;
 	u16 pending_idx = *((u16 *)skb->data);
 	struct skb_shared_info *shinfo = skb_shinfo(skb);
 	int nr_frags = shinfo->nr_frags;
 	int i, err, start;
 
 	 
 	err = gop->status;
	if (unlikely(err))
		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);
 
 	 
 	start = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);
 
 	for (i = start; i < nr_frags; i++) {
 		int j, newerr;
 
 		pending_idx = frag_get_pending_idx(&shinfo->frags[i]);
 
  static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,
 		if (likely(!newerr)) {
 			 
 			if (unlikely(err))
				xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
 			continue;
 		}
 
 		 
		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);
 
 		 
 		if (err)
 			continue;
 
 		 
 		pending_idx = *((u16 *)skb->data);
		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
 		for (j = start; j < i; j++) {
 			pending_idx = frag_get_pending_idx(&shinfo->frags[j]);
			xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
 		}
 
 		 
  static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)
 
 		 
 		get_page(netbk->mmap_pages[pending_idx]);
		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
 	}
 }
 
  static void xen_netbk_tx_submit(struct xen_netbk *netbk)
 			txp->size -= data_len;
 		} else {
 			 
			xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
 		}
 
 		if (txp->flags & XEN_NETTXF_csum_blank)
  static void xen_netbk_tx_action(struct xen_netbk *netbk)
 	xen_netbk_tx_submit(netbk);
 }
 
static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,
				  u8 status)
 {
 	struct xenvif *vif;
 	struct pending_tx_info *pending_tx_info;
  static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)
 
 	vif = pending_tx_info->vif;
 
	make_tx_response(vif, &pending_tx_info->req, status);
 
 	index = pending_index(netbk->pending_prod++);
 	netbk->pending_ring[index] = pending_idx;",Memory leak in drivers/net/xen-netback/netback.c in the Xen netback functionality in the Linux kernel before 3.7.8 allows guest OS users to cause a denial of service (memory consumption) by triggering certain error conditions.
265,CVE-2013-0216,"  void xen_netbk_queue_tx_skb(struct xenvif *vif, struct sk_buff *skb);
  
 void xenvif_notify_tx_completion(struct xenvif *vif);
 
 
void xenvif_carrier_off(struct xenvif *vif);

  
 unsigned int xen_netbk_count_skb_slots(struct xenvif *vif, struct sk_buff *skb);
 ",The Xen netback functionality in the Linux kernel before 3.7.8 allows guest OS users to cause a denial of service (loop) by triggering ring pointer corruption.
266,CVE-2013-0211,"  static ssize_t
 _archive_write_data(struct archive *_a, const void *buff, size_t s)
 {
 	struct archive_write *a = (struct archive_write *)_a;
	const size_t max_write = INT_MAX;

 	archive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,
 	    ARCHIVE_STATE_DATA, ""archive_write_data"");
	 
	if (s > max_write)
		s = max_write;
 	archive_clear_error(&a->archive);
 	return ((a->format_write_data)(a, buff, s));
 }","Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow."
267,CVE-2012-6549,"  isofs_export_encode_fh(struct inode *inode,
 	len = 3;
 	fh32[0] = ei->i_iget5_block;
  	fh16[2] = (__u16)ei->i_iget5_offset;   
	fh16[3] = 0;   
 	fh32[2] = inode->i_generation;
 	if (parent) {
 		struct iso_inode_info *eparent;","The isofs_export_encode_fh function in fs/isofs/export.c in the Linux kernel before 3.6 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel heap memory via a crafted application."
268,CVE-2012-6548,"  static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
 	*lenp = 3;
 	fid->udf.block = location.logicalBlockNum;
 	fid->udf.partref = location.partitionReferenceNum;
	fid->udf.parent_partref = 0;
 	fid->udf.generation = inode->i_generation;
 
 	if (parent) {","The udf_encode_fh function in fs/udf/namei.c in the Linux kernel before 3.6 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel heap memory via a crafted application."
269,CVE-2012-6547,"  static long __tun_chr_ioctl(struct file *file, unsigned int cmd,
 	int vnet_hdr_sz;
 	int ret;
 
	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
 		if (copy_from_user(&ifr, argp, ifreq_len))
 			return -EFAULT;
	} else
		memset(&ifr, 0, sizeof(ifr));
 
 	if (cmd == TUNGETFEATURES) {
 		/* Currently this just means: ""what IFF flags are valid?"".","The __tun_chr_ioctl function in drivers/net/tun.c in the Linux kernel before 3.6 does not initialize a certain structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
270,CVE-2012-6546,"  int vcc_getsockopt(struct socket *sock, int level, int optname,
 
 		if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 			return -ENOTCONN;
		memset(&pvc, 0, sizeof(pvc));
 		pvc.sap_family = AF_ATMPVC;
 		pvc.sap_addr.itf = vcc->dev->number;
 		pvc.sap_addr.vpi = vcc->vpi;","The ATM implementation in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
271,CVE-2012-6545,"  static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
	memset(sa, 0, sizeof(*sa));
 	sa->rc_family  = AF_BLUETOOTH;
 	sa->rc_channel = rfcomm_pi(sk)->channel;
 	if (peer)","The Bluetooth RFCOMM implementation in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."
272,CVE-2012-6544,"  static int hci_sock_getsockopt(struct socket *sock, int level, int optname,
 		{
 			struct hci_filter *f = &hci_pi(sk)->filter;
 
			memset(&uf, 0, sizeof(uf));
 			uf.type_mask = f->type_mask;
 			uf.opcode    = f->opcode;
 			uf.event_mask[0] = *((u32 *) f->event_mask + 0);","The Bluetooth protocol stack in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application that targets the (1) L2CAP or (2) HCI implementation."
273,CVE-2012-6543,"  static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,
 	lsa->l2tp_family = AF_INET6;
 	lsa->l2tp_flowinfo = 0;
 	lsa->l2tp_scope_id = 0;
	lsa->l2tp_unused = 0;
 	if (peer) {
 		if (!lsk->peer_conn_id)
 			return -ENOTCONN;","The l2tp_ip6_getname function in net/l2tp/l2tp_ip6.c in the Linux kernel before 3.6 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
274,CVE-2012-6542,"  static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
 	struct sockaddr_llc sllc;
 	struct sock *sk = sock->sk;
 	struct llc_sock *llc = llc_sk(sk);
	int rc = -EBADF;
 
 	memset(&sllc, 0, sizeof(sllc));
 	lock_sock(sk);
 	if (sock_flag(sk, SOCK_ZAPPED))
 		goto out;
 	*uaddrlen = sizeof(sllc);
 	if (peer) {
 		rc = -ENOTCONN;
 		if (sk->sk_state != TCP_ESTABLISHED)","The llc_ui_getname function in net/llc/af_llc.c in the Linux kernel before 3.6 has an incorrect return value in certain circumstances, which allows local users to obtain sensitive information from kernel stack memory via a crafted application that leverages an uninitialized pointer argument."
275,CVE-2012-6541,"  static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,
 	case DCCP_SOCKOPT_CCID_TX_INFO:
 		if (len < sizeof(tfrc))
 			return -EINVAL;
		memset(&tfrc, 0, sizeof(tfrc));
 		tfrc.tfrctx_x	   = hc->tx_x;
 		tfrc.tfrctx_x_recv = hc->tx_x_recv;
 		tfrc.tfrctx_x_calc = hc->tx_x_calc;","The ccid3_hc_tx_getsockopt function in net/dccp/ccids/ccid3.c in the Linux kernel before 3.6 does not initialize a certain structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
276,CVE-2012-6540,"  do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
 	{
 		struct ip_vs_timeout_user t;
 
		memset(&t, 0, sizeof(t));
 		__ip_vs_get_timeouts(net, &t);
 		if (copy_to_user(user, &t, sizeof(t)) != 0)
 			ret = -EFAULT;","The do_ip_vs_get_ctl function in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 3.6 does not initialize a certain structure for IP_VS_SO_GET_TIMEOUT commands, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
277,CVE-2012-6539,"  static int dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)
 	if (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))
 		return -EFAULT;
 
	memset(&ifc, 0, sizeof(ifc));
 	if (ifc32.ifcbuf == 0) {
 		ifc32.ifc_len = 0;
 		ifc.ifc_len = 0;","The dev_ifconf function in net/socket.c in the Linux kernel before 3.6 does not initialize a certain structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
278,CVE-2012-6538,"  static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)
 		return -EMSGSIZE;
 
 	algo = nla_data(nla);
	strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));
 	memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);
 	algo->alg_key_len = auth->alg_key_len;
 ","The copy_to_user_auth function in net/xfrm/xfrm_user.c in the Linux kernel before 3.6 uses an incorrect C library function for copying a string, which allows local users to obtain sensitive information from kernel heap memory by leveraging the CAP_NET_ADMIN capability."
279,CVE-2012-6537,"  static int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
	memset(p, 0, sizeof(*p));
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));","net/xfrm/xfrm_user.c in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability."
280,CVE-2012-6536,"  struct xfrm_replay_state {
 	__u32	bitmap;
 };
 
#define XFRMA_REPLAY_ESN_MAX	4096

 struct xfrm_replay_state_esn {
 	unsigned int	bmp_len;
 	__u32		oseq;","net/xfrm/xfrm_user.c in the Linux kernel before 3.6 does not verify that the actual Netlink message length is consistent with a certain header field, which allows local users to obtain sensitive information from kernel heap memory by leveraging the CAP_NET_ADMIN capability and providing a (1) new or (2) updated state."
281,CVE-2012-5375,"  void btrfs_update_root_times(struct btrfs_trans_handle *trans,
 			     struct btrfs_root *root);
 
  
int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,
			  const char *name, int name_len);
 int btrfs_insert_dir_item(struct btrfs_trans_handle *trans,
 			  struct btrfs_root *root, const char *name,
 			  int name_len, struct inode *dir,","The CRC32C feature in the Btrfs implementation in the Linux kernel before 3.8-rc1 allows local users to cause a denial of service (prevention of file creation) by leveraging the ability to write to a directory important to the victim, and creating a file with a crafted name that is associated with a specific CRC32C hash value."
282,CVE-2012-4530,"  static int load_misc_binary(struct linux_binprm *bprm)
 		goto _error;
 	bprm->argc ++;
 
	 
	retval = bprm_change_interp(iname, bprm);
	if (retval < 0)
		goto _error;
 
 	interp_file = open_exec (iname);
 	retval = PTR_ERR (interp_file);","The load_script function in fs/binfmt_script.c in the Linux kernel before 3.7.2 does not properly handle recursion, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
283,CVE-2012-3364,"  static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,
 	nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));
 	data += 2;
 
	nfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);
 
 	pr_debug(""sens_res 0x%x, nfcid1_len %d\n"",
 		 nfca_poll->sens_res, nfca_poll->nfcid1_len);
  static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,
 			struct rf_tech_specific_params_nfcb_poll *nfcb_poll,
 						     __u8 *data)
 {
	nfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);
 
 	pr_debug(""sensb_res_len %d\n"", nfcb_poll->sensb_res_len);
 
  static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
 						     __u8 *data)
 {
 	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);
 
 	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
 		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);
  static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,
 	switch (ntf->activation_rf_tech_and_mode) {
 	case NCI_NFC_A_PASSIVE_POLL_MODE:
 		nfca_poll = &ntf->activation_params.nfca_poll_iso_dep;
		nfca_poll->rats_res_len = min_t(__u8, *data++, 20);
 		pr_debug(""rats_res_len %d\n"", nfca_poll->rats_res_len);
 		if (nfca_poll->rats_res_len > 0) {
 			memcpy(nfca_poll->rats_res,
  static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,
 
 	case NCI_NFC_B_PASSIVE_POLL_MODE:
 		nfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;
		nfcb_poll->attrib_res_len = min_t(__u8, *data++, 50);
 		pr_debug(""attrib_res_len %d\n"", nfcb_poll->attrib_res_len);
 		if (nfcb_poll->attrib_res_len > 0) {
 			memcpy(nfcb_poll->attrib_res,",Multiple stack-based buffer overflows in the Near Field Communication Controller Interface (NCI) in the Linux kernel before 3.4.5 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via incoming frames with crafted length fields.
284,CVE-2012-2119,"  static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,
 		}
 		base = (unsigned long)from->iov_base + offset;
 		size = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;
		if (i + size > MAX_SKB_FRAGS)
			return -EMSGSIZE;
 		num_pages = get_user_pages_fast(base, size, 0, &page[i]);
		if (num_pages != size) {
 			for (i = 0; i < num_pages; i++)
 				put_page(page[i]);
 			return -EFAULT;
  static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 	int err;
 	struct virtio_net_hdr vnet_hdr = { 0 };
 	int vnet_hdr_len = 0;
	int copylen = 0;
 	bool zerocopy = false;
 
 	if (q->flags & IFF_VNET_HDR) {
  static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 	if (unlikely(len < ETH_HLEN))
 		goto err;
 
	err = -EMSGSIZE;
	if (unlikely(count > UIO_MAXIOV))
		goto err;

 	if (m && m->msg_control && sock_flag(&q->sk, SOCK_ZEROCOPY))
 		zerocopy = true;
 
 	if (zerocopy) {
		 
		if (count > MAX_SKB_FRAGS) {
			copylen = iov_length(iv, count - MAX_SKB_FRAGS);
			if (copylen < vnet_hdr_len)
				copylen = 0;
			else
				copylen -= vnet_hdr_len;
		}
 		 
		if (copylen < vnet_hdr.hdr_len)
			copylen = vnet_hdr.hdr_len;
 		if (!copylen)
 			copylen = GOODCOPY_LEN;
 	} else","Buffer overflow in the macvtap device driver in the Linux kernel before 3.4.5, when running in certain configurations, allows privileged KVM guest users to cause a denial of service (crash) via a long descriptor with a long vector length."
285,CVE-2012-1016,"  pkinit_server_return_padata(krb5_context context,
          rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||
         (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {
 
         
        if (rep != NULL && rep->u.dh_Info.kdfID) {
            secret.data = (char *)server_key;
             secret.length = server_key_len;
 
             retval = pkinit_alg_agility_kdf(context, &secret,","The pkinit_server_return_padata function in plugins/preauth/pkinit/pkinit_srv.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 attempts to find an agility KDF identifier in inappropriate circumstances, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted Draft 9 request."
286,CVE-2011-4604,"  static ssize_t bat_socket_read(struct file *file, char __user *buf,
 
 	spin_unlock_bh(&socket_client->lock);
 
	packet_len = min(count, socket_packet->icmp_len);
	error = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);
 
 	kfree(socket_packet);
 
 	if (error)",The bat_socket_read function in net/batman-adv/icmp_socket.c in the Linux kernel before 3.3 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted batman-adv ICMP packet.
287,CVE-2011-4348,"  int sctp_rcv(struct sk_buff *skb)
 	 */
 	sctp_bh_lock_sock(sk);
 
	if (sk != rcvr->sk) {
		 
		sctp_bh_unlock_sock(sk);
		sk = rcvr->sk;
		sctp_bh_lock_sock(sk);
	}

 	if (sock_owned_by_user(sk)) {
 		SCTP_INC_STATS_BH(SCTP_MIB_IN_PKT_BACKLOG);
 		sctp_add_backlog(sk, skb);","Race condition in the sctp_rcv function in net/sctp/input.c in the Linux kernel before 2.6.29 allows remote attackers to cause a denial of service (system hang) via SCTP packets.  NOTE: in some environments, this issue exists because of an incomplete fix for CVE-2011-2482."
288,CVE-2011-4098," 
 #include <linux/spinlock.h>
 #include <linux/completion.h>
 #include <linux/buffer_head.h>
#include <linux/blkdev.h>
 #include <linux/gfs2_ondisk.h>
 #include <linux/crc32.h>
 
  static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,
 {
 	struct gfs2_inode *ip = GFS2_I(inode);
 	struct gfs2_sbd *sdp = GFS2_SB(inode);
	struct super_block *sb = sdp->sd_vfs;
 	struct buffer_head *dibh = mp->mp_bh[0];
 	u64 bn, dblock = 0;
 	unsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;
 	unsigned dblks = 0;
 	unsigned ptrs_per_blk;
 	const unsigned end_of_metadata = height - 1;
	int ret;
 	int eob = 0;
 	enum alloc_state state;
 	__be64 *ptr;
  static int gfs2_bmap_alloc(struct inode *inode, const sector_t lblock,
 			dblock = bn;
 			while (n-- > 0)
 				*ptr++ = cpu_to_be64(bn++);
			if (buffer_zeronew(bh_map)) {
				ret = sb_issue_zeroout(sb, dblock, dblks,
						       GFP_NOFS);
				if (ret) {
					fs_err(sdp,
					       ""Failed to zero data buffers\n"");
					clear_buffer_zeronew(bh_map);
				}
			}
 			break;
 		}
 	} while ((state != ALLOC_DATA) || !dblock);","The fallocate implementation in the GFS2 filesystem in the Linux kernel before 3.2 relies on the page cache, which might allow local users to cause a denial of service by preallocating blocks in certain situations involving insufficient memory."
289,CVE-2011-4087,"  static int br_parse_ip_options(struct sk_buff *skb)
 		goto drop;
 	}
 
	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
	if (iph->ihl == 5)
 		return 0;
 
 	opt->optlen = iph->ihl*4 - sizeof(struct iphdr);
 	if (ip_options_compile(dev_net(dev), opt, skb))","The br_parse_ip_options function in net/bridge/br_netfilter.c in the Linux kernel before 2.6.39 does not properly initialize a certain data structure, which allows remote attackers to cause a denial of service by leveraging connectivity to a network interface that uses an Ethernet bridge device."
290,CVE-2011-3638,"  static int ext4_ext_convert_to_initialized(handle_t *handle,
 					   struct ext4_map_blocks *map,
 					   struct ext4_ext_path *path)
 {
	struct ext4_map_blocks split_map;
	struct ext4_extent zero_ex;
	struct ext4_extent *ex;
 	ext4_lblk_t ee_block, eof_block;
 	unsigned int allocated, ee_len, depth;
 	int err = 0;
	int split_flag = 0;
 
 	ext_debug(""ext4_ext_convert_to_initialized: inode %lu, logical""
 		""block %llu, max_blocks %u\n"", inode->i_ino,
  static int ext4_ext_convert_to_initialized(handle_t *handle,
 		eof_block = map->m_lblk + map->m_len;
 
 	depth = ext_depth(inode);
 	ex = path[depth].p_ext;
 	ee_block = le32_to_cpu(ex->ee_block);
 	ee_len = ext4_ext_get_actual_len(ex);
 	allocated = ee_len - (map->m_lblk - ee_block);
 
	WARN_ON(map->m_lblk < ee_block);
 	 
	split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;
 
 	 
	if (ee_len <= 2*EXT4_EXT_ZERO_LEN &&
	    (EXT4_EXT_MAY_ZEROOUT & split_flag)) {
		err = ext4_ext_zeroout(inode, ex);
 		if (err)
 			goto out;
 
 		err = ext4_ext_get_access(handle, inode, path + depth);
 		if (err)
 			goto out;
		ext4_ext_mark_initialized(ex);
		ext4_ext_try_to_merge(inode, path, ex);
		err = ext4_ext_dirty(handle, inode, path + depth);
		goto out;
 	}

 	 
	split_map.m_lblk = map->m_lblk;
	split_map.m_len = map->m_len;

	if (allocated > map->m_len) {
		if (allocated <= EXT4_EXT_ZERO_LEN &&
		    (EXT4_EXT_MAY_ZEROOUT & split_flag)) {
			 
			zero_ex.ee_block =
					 cpu_to_le32(map->m_lblk + map->m_len);
			zero_ex.ee_len = cpu_to_le16(allocated - map->m_len);
			ext4_ext_store_pblock(&zero_ex,
				ext4_ext_pblock(ex) + map->m_lblk - ee_block);
			err = ext4_ext_zeroout(inode, &zero_ex);
 			if (err)
 				goto out;
			split_map.m_lblk = map->m_lblk;
			split_map.m_len = allocated;
		} else if ((map->m_lblk - ee_block + map->m_len <
			   EXT4_EXT_ZERO_LEN) &&
			   (EXT4_EXT_MAY_ZEROOUT & split_flag)) {
			 
			if (map->m_lblk != ee_block) {
				zero_ex.ee_block = ex->ee_block;
				zero_ex.ee_len = cpu_to_le16(map->m_lblk -
							ee_block);
				ext4_ext_store_pblock(&zero_ex,
						      ext4_ext_pblock(ex));
				err = ext4_ext_zeroout(inode, &zero_ex);
				if (err)
					goto out;
			}

			allocated = map->m_lblk - ee_block + map->m_len;

			split_map.m_lblk = ee_block;
			split_map.m_len = allocated;
 		}
 	}

	allocated = ext4_split_extent(handle, inode, path,
				       &split_map, split_flag, 0);
	if (allocated < 0)
		err = allocated;

 out:
 	return err ? err : allocated;
 }
 
  
	depth = ext_depth(inode);
	ex = path[depth].p_ext;
	ee_block = le32_to_cpu(ex->ee_block);
	ee_len = ext4_ext_get_actual_len(ex);
 
	split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;
	split_flag |= EXT4_EXT_MARK_UNINIT2;
 
	flags |= EXT4_GET_BLOCKS_PRE_IO;
	return ext4_split_extent(handle, inode, path, map, split_flag, flags);
 }
 
 static int ext4_convert_unwritten_extents_endio(handle_t *handle,","fs/ext4/extents.c in the Linux kernel before 3.0 does not mark a modified extent as dirty in certain cases of extent splitting, which allows local users to cause a denial of service (system crash) via vectors involving ext4 umount and mount operations."
291,CVE-2011-3619,"  static int apparmor_setprocattr(struct task_struct *task, char *name,
 			sa.aad.op = OP_SETPROCATTR;
 			sa.aad.info = name;
 			sa.aad.error = -EINVAL;
			return aa_audit(AUDIT_APPARMOR_DENIED,
					__aa_current_profile(), GFP_KERNEL,
 					&sa, NULL);
 		}
 	} else if (strcmp(name, ""exec"") == 0) {","The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 3.0 does not properly handle invalid parameters, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by writing to a /proc/#####/attr/current file."
292,CVE-2011-2905,"  static int perf_config_global(void)
 int perf_config(config_fn_t fn, void *data)
 {
 	int ret = 0, found = 0;
 	const char *home = NULL;
 
 	 
  int perf_config(config_fn_t fn, void *data)
 		free(user_config);
 	}
 
 	if (found == 0)
 		return -1;
 	return ret;","Untrusted search path vulnerability in the perf_config function in tools/perf/util/config.c in perf, as distributed in the Linux kernel before 3.1, allows local users to overwrite arbitrary files via a crafted config file in the current working directory."
293,CVE-2011-2491,"  static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)
 
 	if (task->tk_status < 0) {
 		dprintk(""lockd: unlock failed (err = %d)\n"", -task->tk_status);
		switch (task->tk_status) {
		case -EACCES:
		case -EIO:
			goto die;
		default:
			goto retry_rebind;
		}
 	}
 	if (status == NLM_LCK_DENIED_GRACE_PERIOD) {
 		rpc_delay(task, NLMCLNT_GRACE_WAIT);",The Network Lock Manager (NLM) protocol implementation in the NFS client functionality in the Linux kernel before 3.0 allows local users to cause a denial of service (system hang) via a LOCK_UN flock system call.
294,CVE-2011-2482,"  void sctp_wait_for_close(struct sock *sk, long timeout)
 	finish_wait(sk->sk_sleep, &wait);
 }
 
static void sctp_sock_rfree_frag(struct sk_buff *skb)
{
	struct sk_buff *frag;

	if (!skb->data_len)
		goto done;

	 
	for (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)
		sctp_sock_rfree_frag(frag);

done:
	sctp_sock_rfree(skb);
}

static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)
{
	struct sk_buff *frag;

	if (!skb->data_len)
		goto done;

	 
	for (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)
		sctp_skb_set_owner_r_frag(frag, sk);

done:
	sctp_skb_set_owner_r(skb, sk);
}

  
  static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
 	sctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {
 		event = sctp_skb2event(skb);
 		if (event->asoc == assoc) {
			sctp_sock_rfree_frag(skb);
 			__skb_unlink(skb, &oldsk->sk_receive_queue);
 			__skb_queue_tail(&newsk->sk_receive_queue, skb);
			sctp_skb_set_owner_r_frag(skb, newsk);
 		}
 	}
 
  static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
 		sctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {
 			event = sctp_skb2event(skb);
 			if (event->asoc == assoc) {
				sctp_sock_rfree_frag(skb);
 				__skb_unlink(skb, &oldsp->pd_lobby);
 				__skb_queue_tail(queue, skb);
				sctp_skb_set_owner_r_frag(skb, newsk);
 			}
 		}
 
  static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
 
 	}
 
	sctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {
		sctp_sock_rfree_frag(skb);
		sctp_skb_set_owner_r_frag(skb, newsk);
	}

	sctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {
		sctp_sock_rfree_frag(skb);
		sctp_skb_set_owner_r_frag(skb, newsk);
	}

 	/* Set the type of socket to indicate that it is peeled off from the
 	 * original UDP-style socket or created with the accept() call on a
 	 * TCP-style socket..","A certain Red Hat patch to the sctp_sock_migrate function in net/sctp/socket.c in the Linux kernel before 2.6.21, as used in Red Hat Enterprise Linux (RHEL) 5, allows remote attackers to cause a denial of service (NULL pointer dereference and OOPS) via a crafted SCTP packet."
295,CVE-2011-2479,"  static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,
 					 unsigned long end,
 					 long adjust_next)
 {
	if (!vma->anon_vma || vma->vm_ops)
 		return;
 	__vma_adjust_trans_huge(vma, start, end, adjust_next);
 }","The Linux kernel before 2.6.39 does not properly create transparent huge pages in response to a MAP_PRIVATE mmap system call on /dev/zero, which allows local users to cause a denial of service (system crash) via a crafted application."
296,CVE-2011-1585," 
 #define MAX_SHARE_SIZE  64	 
 #define MAX_USERNAME_SIZE 32	 
#define MAX_PASSWORD_SIZE 512   
 
 #define CIFS_MIN_RCV_POOL 4
 ","The cifs_find_smb_ses function in fs/cifs/connect.c in the Linux kernel before 2.6.36 does not properly determine the associations between users and sessions, which allows local users to bypass CIFS share authentication by leveraging a mount of a share by a different user."
297,CVE-2011-1182,"  SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,
 		return -EFAULT;
 
 	 
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (info.si_code != SI_QUEUE) {
		 
		WARN_ON_ONCE(info.si_code < 0);
 		return -EPERM;
	}
 	info.si_signo = sig;
 
 	 
  long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 		return -EINVAL;
 
 	 
	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
	 */
	if (info->si_code != SI_QUEUE) {
		 
		WARN_ON_ONCE(info->si_code < 0);
 		return -EPERM;
	}
 	info->si_signo = sig;
 
 	return do_send_specific(tgid, pid, sig, info);",kernel/signal.c in the Linux kernel before 2.6.39 allows local users to spoof the uid and pid of a signal sender via a sigqueueinfo system call.
298,CVE-2011-1180,"  static void iriap_getvaluebyclass_indication(struct iriap_cb *self,
 	n = 1;
 
 	name_len = fp[n++];

	IRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);

 	memcpy(name, fp+n, name_len); n+=name_len;
 	name[name_len] = '\0';
 
 	attr_len = fp[n++];

	IRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);

 	memcpy(attr, fp+n, attr_len); n+=attr_len;
 	attr[attr_len] = '\0';
 ",Multiple stack-based buffer overflows in the iriap_getvaluebyclass_indication function in net/irda/iriap.c in the Linux kernel before 2.6.39 allow remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging connectivity to an IrDA infrared network and sending a large integer value for a (1) name length or (2) attribute length.
299,CVE-2011-1019,"  extern int netdev_notice(const struct net_device *dev, const char *format, ...)
 extern int netdev_info(const struct net_device *dev, const char *format, ...)
 	__attribute__ ((format (printf, 2, 3)));
 
#define MODULE_ALIAS_NETDEV(device) \
	MODULE_ALIAS(""netdev-"" device)

 #if defined(DEBUG)
 #define netdev_dbg(__dev, format, args...)			\
 	netdev_printk(KERN_DEBUG, __dev, format, ##args)",The dev_load function in net/core/dev.c in the Linux kernel before 2.6.38 allows local users to bypass an intended CAP_SYS_MODULE capability requirement and load arbitrary modules by leveraging the CAP_NET_ADMIN capability.
300,CVE-2002-2443,"  process_chpw_request(krb5_context context, void *server_handle, char *realm,
         ret = KRB5KRB_AP_ERR_MODIFIED;
         numresult = KRB5_KPASSWD_MALFORMED;
         strlcpy(strresult, ""Request was truncated"", sizeof(strresult));
        goto bailout;
     }
 
     ptr = req->data;
  process_chpw_request(krb5_context context, void *server_handle, char *realm,
         numresult = KRB5_KPASSWD_MALFORMED;
         strlcpy(strresult, ""Request length was inconsistent"",
                 sizeof(strresult));
        goto bailout;
     }
 
      
  process_chpw_request(krb5_context context, void *server_handle, char *realm,
         numresult = KRB5_KPASSWD_BAD_VERSION;
         snprintf(strresult, sizeof(strresult),
                  ""Request contained unknown protocol version number %d"", vno);
        goto bailout;
     }
 
      
  process_chpw_request(krb5_context context, void *server_handle, char *realm,
         numresult = KRB5_KPASSWD_MALFORMED;
         strlcpy(strresult, ""Request was truncated in AP-REQ"",
                 sizeof(strresult));
        goto bailout;
     }
 
      ","schpw.c in the kpasswd service in kadmind in MIT Kerberos 5 (aka krb5) before 1.11.3 does not properly validate UDP packets before sending responses, which allows remote attackers to cause a denial of service (CPU and bandwidth consumption) via a forged packet that triggers a communication loop, as demonstrated by krb_pingpong.nasl, a related issue to CVE-1999-0103."
301,CVE-2014-9420,"  struct rock_state {
 	int cont_size;
 	int cont_extent;
 	int cont_offset;
	int cont_loops;
 	struct inode *inode;
 };
 
  static void init_rock_state(struct rock_state *rs, struct inode *inode)
 	rs->inode = inode;
 }
 
 
#define RR_MAX_CE_ENTRIES 32

 /*
  * Returns 0 if the caller should continue scanning, 1 if the scan must end
  * and -ve on error.
  static int rock_continue(struct rock_state *rs)
 			goto out;
 		}
 		ret = -EIO;
		if (++rs->cont_loops >= RR_MAX_CE_ENTRIES)
			goto out;
 		bh = sb_bread(rs->inode->i_sb, rs->cont_extent);
 		if (bh) {
 			memcpy(rs->buffer, bh->b_data + rs->cont_offset,","The rock_continue function in fs/isofs/rock.c in the Linux kernel through 3.18.1 does not restrict the number of Rock Ridge continuation entries, which allows local users to cause a denial of service (infinite loop, and system crash or hang) via a crafted iso9660 image."
302,CVE-2014-9419,"  __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 
 	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
 
	 
 	load_sp0(tss, next);
 
 	 
 	load_TLS(next, cpu);
 
 	 
 	arch_end_context_switch(next_p);
 
	 
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);

	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);

 	 
 	if (unlikely(fsindex | next->fsindex | prev->fs)) {
 		loadsegment(fs, next->fsindex);

 		 
 		if (fsindex)
 			prev->fs = 0;
 	}
 	if (next->fs)
 		wrmsrl(MSR_FS_BASE, next->fs);
 	prev->fsindex = fsindex;
 
 	if (unlikely(gsindex | next->gsindex | prev->gs)) {
 		load_gs_index(next->gsindex);

		 
 		if (gsindex)
 			prev->gs = 0;
 	}","The __switch_to function in arch/x86/kernel/process_64.c in the Linux kernel through 3.18.1 does not ensure that Thread Local Storage (TLS) descriptors are loaded before proceeding with other steps, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application that reads a TLS base address."
303,CVE-2014-9351,"  void CServer::ProcessClientPacket(CNetChunk *pPacket)
 				return;
 
 			int Chunk = Unpacker.GetInt();
			unsigned int ChunkSize = 1024-128;
			unsigned int Offset = Chunk * ChunkSize;
 			int Last = 0;
 
 			 ",engine/server/server.cpp in Teeworlds 0.6.x before 0.6.3 allows remote attackers to read memory and cause a denial of service (crash) via unspecified vectors.
304,CVE-2014-9322," 
 #define THREAD_SIZE_ORDER	1
 #define THREAD_SIZE		(PAGE_SIZE << THREAD_SIZE_ORDER)
 
 #define DOUBLEFAULT_STACK 1
 #define NMI_STACK 0
 #define DEBUG_STACK 0","arch/x86/kernel/entry_64.S in the Linux kernel before 3.17.5 does not properly handle faults associated with the Stack Segment (SS) segment register, which allows local users to gain privileges by triggering an IRET instruction that leads to access to a GS Base address from the wrong space."
305,CVE-2014-9140,"  static void
 ppp_hdlc(netdissect_options *ndo,
          const u_char *p, int length)
 {
	u_char *b, *t, c;
	const u_char *s;
 	int i, proto;
 	const void *se;
 
         if (length <= 0)
                 return;
 
	b = (u_char *)malloc(length);
 	if (b == NULL)
 		return;
 
  ppp_hdlc(netdissect_options *ndo,
 	 * Do this so that we dont overwrite the original packet
 	 * contents.
 	 */
	for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {
 		c = *s++;
 		if (c == 0x7d) {
			if (i <= 1 || !ND_TTEST(*s))
				break;
			i--;
			c = *s++ ^ 0x20;
 		}
 		*t++ = c;
 	}",Buffer overflow in the ppp_hdlc function in print-ppp.c in tcpdump 4.6.2 and earlier allows remote attackers to cause a denial of service (crash) cia a crafted PPP packet.
306,CVE-2014-9050,"  int cli_scanpe(cli_ctx *ctx)
 	char sname[9], epbuff[4096], *tempfile;
 	uint32_t epsize;
 	ssize_t bytes, at;
	unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;
 	unsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;
 	int (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;
 	const char *src = NULL;
 	char *dest = NULL;
 	int ndesc, ret = CL_CLEAN, upack = 0, native=0;
 	size_t fsize;
	uint32_t valign, falign, hdr_size;
 	struct cli_exe_section *exe_sections;
 	char timestr[32];
 	struct pe_image_data_dir *dirs;
  int cli_scanpe(cli_ctx *ctx)
     cli_jsonint(pe_json, ""NumberOfSections"", nsections);
 #endif
 
    while (rescan==1) {
        rescan=0;
        for (i=0; i < nsections; i++) {
            exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);
            exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);
            exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);
            exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);
            exe_sections[i].chr = EC32(section_hdr[i].Characteristics);
            exe_sections[i].urva = EC32(section_hdr[i].VirtualAddress);  
            exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);
            exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);
            exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);

            if (exe_sections[i].rsz) {  
                if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)
                    || exe_sections[i].raw >= fsize) {
                    cli_dbgmsg(""Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\n"", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);
                    if (nsections == 1) {
                        free(section_hdr);
                        free(exe_sections);

                        if(DETECT_BROKEN_PE) {
                            cli_append_virus(ctx, ""Heuristics.Broken.Executable"");
                            return CL_VIRUS;
                        }

                        return CL_CLEAN;  
                    }

                    for (j=i; j < nsections-1; j++)
                        memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));

                    for (j=i; j < nsections-1; j++)
                        memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));

                    nsections--;
                    rescan=1;
                    break;
                }
            }
        }
    }

     for(i = 0; i < nsections; i++) {
        strncpy(sname, (char *) section_hdr[i].Name, 8);
        sname[8] = 0;
 
 #if HAVE_JSON
         add_section_info(ctx, &exe_sections[i]);
  int cli_scanpe(cli_ctx *ctx)
 	}
 
 	if (exe_sections[i].rsz) {  
 	    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;
 
 	     ",Heap-based buffer overflow in the cli_scanpe function in libclamav/pe.c in ClamAV before 0.98.5 allows remote attackers to cause a denial of service (crash) via a crafted y0da Crypter PE file.
307,CVE-2014-8884,"  static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struc
 		   0x00, 0x00, 0x00, 0x00,
 		   0x00, 0x00 };
 
	if (cmd->msg_len > sizeof(b) - 4)
		return -EINVAL;

 	memcpy(&b[4], cmd->msg, cmd->msg_len);
 
 	state->config->send_command(fe, 0x72,",Stack-based buffer overflow in the ttusbdecfe_dvbs_diseqc_send_master_cmd function in drivers/media/usb/ttusb-dec/ttusbdecfe.c in the Linux kernel before 3.17.4 allows local users to cause a denial of service (system crash) or possibly gain privileges via a large message length in an ioctl call.
308,CVE-2014-8709,"  static int ieee80211_fragment(struct ieee80211_tx_data *tx,
 	}
 
 	 
	skb_trim(skb, hdrlen + per_fragm);
 	return 0;
 }
 ","The ieee80211_fragment function in net/mac80211/tx.c in the Linux kernel before 3.13.5 does not properly maintain a certain tail pointer, which allows remote attackers to obtain sensitive cleartext information by reading packets."
309,CVE-2014-8509," 
 /*
 
Copyright (c) 2008-2014, Arvid Norberg
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
  namespace
 namespace libtorrent
 {
 
	namespace
	{
		int fail(int* error_pos
			, std::vector<lazy_entry*>& stack
			, char const* start
			, char const* orig_start)
		{
			while (!stack.empty()) {
				lazy_entry* top = stack.back();
				if (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t)
				{
					top->pop();
					break;
				}
				stack.pop_back();
			}
			if (error_pos) *error_pos = start - orig_start;
			return -1;
		}
 	}
 
#define TORRENT_FAIL_BDECODE(code) do { ec = make_error_code(code); return fail(error_pos, stack, start, orig_start); } while (false)
 
	namespace { bool numeric(char c) { return c >= '0' && c <= '9'; } }
 
 	 
 	 
 	 
 	 
	char const* parse_int(char const* start, char const* end, char delimiter
		, boost::int64_t& val, bdecode_errors::error_code_enum& ec)
 	{
 		while (start < end && *start != delimiter)
 		{
			if (!numeric(*start))
			{
				ec = bdecode_errors::expected_string;
				return start;
			}
			if (val > INT64_MAX / 10)
			{
				ec = bdecode_errors::overflow;
				return start;
			}
 			val *= 10;
			int digit = *start - '0';
			if (val > INT64_MAX - digit)
			{
				ec = bdecode_errors::overflow;
				return start;
			}
			val += digit;
 			++start;
 		}
		if (*start != delimiter)
			ec = bdecode_errors::expected_colon;
 		return start;
 	}
 
  namespace libtorrent
 		std::vector<lazy_entry*> stack;
 
 		stack.push_back(&ret);
		while (start <= end)
 		{
 			if (stack.empty()) break;  
 
  namespace libtorrent
 						stack.pop_back();
 						continue;
 					}
					if (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);
 					boost::int64_t len = t - '0';
					bdecode_errors::error_code_enum e = bdecode_errors::no_error;
					start = parse_int(start, end, ':', len, e);
					if (e)
						TORRENT_FAIL_BDECODE(e);

					if (start + len + 1 > end)
						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);

					if (len < 0)
						TORRENT_FAIL_BDECODE(bdecode_errors::overflow);

 					++start;
 					if (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
 					lazy_entry* ent = top->dict_append(start);
  namespace libtorrent
 				}
 				default:
 				{
					if (!numeric(t))
 						TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);
 
 					boost::int64_t len = t - '0';
					bdecode_errors::error_code_enum e = bdecode_errors::no_error;
					start = parse_int(start, end, ':', len, e);
					if (e)
						TORRENT_FAIL_BDECODE(e);
					if (start + len + 1 > end)
						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
					if (len < 0)
						TORRENT_FAIL_BDECODE(bdecode_errors::overflow);

 					++start;
 					top->construct_string(start, int(len));
 					stack.pop_back();
  namespace libtorrent
 		boost::int64_t val = 0;
 		bool negative = false;
 		if (*m_data.start == '-') negative = true;
		bdecode_errors::error_code_enum ec = bdecode_errors::no_error;
		parse_int(m_data.start + negative
			, m_data.start + m_size, 'e', val, ec);
		if (ec) return 0;
 		if (negative) val = -val;
 		return val;
 	}
  namespace libtorrent
 		return e;
 	}
 
	lazy_entry const* lazy_entry::dict_find_dict(std::string const& name) const
	{
		lazy_entry const* e = dict_find(name);
		if (e == 0 || e->type() != lazy_entry::dict_t) return 0;
		return e;
	}

 	lazy_entry const* lazy_entry::dict_find_list(char const* name) const
 	{
 		lazy_entry const* e = dict_find(name);
  namespace libtorrent
 		return 0;
 	}
 
	lazy_entry* lazy_entry::dict_find(std::string const& name)
	{
		TORRENT_ASSERT(m_type == dict_t);
		for (int i = 0; i < int(m_size); ++i)
		{
			lazy_dict_entry& e = m_data.dict[i];
			if (name.size() != e.val.m_begin - e.name) continue;
			if (std::equal(name.begin(), name.end(), e.name))
				return &e.val;
		}
		return 0;
	}

 	lazy_entry* lazy_entry::list_append()
 	{
 		TORRENT_ASSERT(m_type == list_t);
  namespace libtorrent
 				char const* str = e.string_ptr();
 				for (int i = 0; i < e.string_length(); ++i)
 				{
					char c = str[i];
					if (c >= 32 && c < 127) continue;
 					printable = false;
 					break;
 				}
 				ret += ""'"";
 				if (printable)
 				{
					if (single_line && e.string_length() > 30)
					{
						ret.append(e.string_ptr(), 14);
						ret += ""..."";
						ret.append(e.string_ptr() + e.string_length()-14, 14);
					}
					else
						ret.append(e.string_ptr(), e.string_length());
 					ret += ""'"";
 					return ret;
 				}
				if (single_line && e.string_length() > 20)
 				{
					for (int i = 0; i < 9; ++i)
					{
						char tmp[5];
						snprintf(tmp, sizeof(tmp), ""%02x"", (unsigned char)str[i]);
						ret += tmp;
					}
					ret += ""..."";
					for (int i = e.string_length() - 9
						, len(e.string_length()); i < len; ++i)
					{
						char tmp[5];
						snprintf(tmp, sizeof(tmp), ""%02x"", (unsigned char)str[i]);
						ret += tmp;
					}
				}
				else
				{
					for (int i = 0; i < e.string_length(); ++i)
					{
						char tmp[5];
						snprintf(tmp, sizeof(tmp), ""%02x"", (unsigned char)str[i]);
						ret += tmp;
					}
 				}
 				ret += ""'"";
 				return ret;
  namespace libtorrent
 			""expected value (list, dict, int or string) in bencoded string"",
 			""bencoded nesting depth exceeded"",
 			""bencoded item count limit exceeded"",
			""integer overflow"",
 		};
 		if (ev < 0 || ev >= int(sizeof(msgs)/sizeof(msgs[0])))
 			return ""Unknown error"";
  namespace libtorrent
 		return bdecode_category;
 	}
 
	namespace bdecode_errors
	{
		boost::system::error_code make_error_code(error_code_enum e)
		{
			return boost::system::error_code(e, get_bdecode_category());
		}
	}
 };
 ","The lazy_bdecode function in BitTorrent bootstrap-dht (aka Bootstrap) allows remote attackers to execute arbitrary code via a crafted packet, which triggers an out-of-bounds read, related to *Improper Indexing.*"
310,CVE-2014-8483,"  QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)
     }
     else
     {
         
        if ((temp.length() % 12) != 0)
            return cipherText;

         temp = b64ToByte(temp);
         while ((temp.length() % 8) != 0) temp.append('\0');
     }
  QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)
     if (!cipher.ok())
         return cipherText;
 
    if (direction) {
         
        if ((temp2.length() % 8) != 0)
            return cipherText;

         temp2 = byteToB64(temp2);
    }
 
     return temp2;
 }",The blowfishECB function in core/cipher.cpp in Quassel IRC 0.10.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a malformed string.
311,CVE-2014-8481,"  int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)
 	 
 	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);
 
 	if (ctxt->rip_relative)
 		ctxt->memopp->addr.mem.ea += ctxt->_eip;
 
done:
 	return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;
 }
 ","The instruction decoder in arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel before 3.18-rc2 does not properly handle invalid instructions, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) via a crafted application that triggers (1) an improperly fetched instruction or (2) an instruction that occupies too many bytes.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-8480."
312,CVE-2014-8480,"  static const struct opcode group11[] = {
 };
 
 static const struct gprefix pfx_0f_ae_7 = {
	I(SrcMem | ByteOp, em_clflush), N, N, N,
 };
 
 static const struct group_dual group15 = { {
  static const struct opcode twobyte_table[256] = {
 	N, I(ImplicitOps | EmulateOnUD, em_syscall),
 	II(ImplicitOps | Priv, em_clts, clts), N,
 	DI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,
	N, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,
 	 
 	N, N, N, N, N, N, N, N,
	D(ImplicitOps | ModRM | SrcMem | NoAccess),
	N, N, N, N, N, N, D(ImplicitOps | ModRM | SrcMem | NoAccess),
 	 
 	DIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_read),
 	DIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),","The instruction decoder in arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel before 3.18-rc2 lacks intended decoder-table flags for certain RIP-relative instructions, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) via a crafted application."
313,CVE-2014-8369,"  static void kvm_iommu_put_pages(struct kvm *kvm,
 				gfn_t base_gfn, unsigned long npages);
 
 static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
			   unsigned long npages)
 {
 	gfn_t end_gfn;
 	pfn_t pfn;
 
 	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + npages;
 	gfn    += 1;
 
 	if (is_error_noslot_pfn(pfn))
  int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		 * Pin all pages we are about to map in memory. This is
 		 * important because we unmap and unpin in 4kb steps later.
 		 */
		pfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);
 		if (is_error_noslot_pfn(pfn)) {
 			gfn += 1;
 			continue;
  int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		if (r) {
 			printk(KERN_ERR ""kvm_iommu_map_address:""
 			       ""iommu failed to map pfn=%llx\n"", pfn);
			kvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);
 			goto unmap_pages;
 		}
 ","The kvm_iommu_map_pages function in virt/kvm/iommu.c in the Linux kernel through 3.17.2 miscalculates the number of pages during the handling of a mapping failure, which allows guest OS users to cause a denial of service (host OS page unpinning) or possibly have unspecified other impact by leveraging guest OS privileges.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2014-3601."
314,CVE-2014-8133,"  static int get_free_idx(void)
 	return -ESRCH;
 }
 
static bool tls_desc_okay(const struct user_desc *info)
{
	if (LDT_empty(info))
		return true;

	 
	if (!info->seg_32bit)
		return false;

	return true;
}

 static void set_tls_desc(struct task_struct *p, int idx,
 			 const struct user_desc *info, int n)
 {
  int do_set_thread_area(struct task_struct *p, int idx,
 	if (copy_from_user(&info, u_info, sizeof(info)))
 		return -EFAULT;
 
	if (!tls_desc_okay(&info))
		return -EINVAL;

 	if (idx == -1)
 		idx = info.entry_number;
 
  int regset_tls_set(struct task_struct *target, const struct user_regset *regset,
 {
 	struct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];
 	const struct user_desc *info;
	int i;
 
 	if (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||
 	    (pos % sizeof(struct user_desc)) != 0 ||
  int regset_tls_set(struct task_struct *target, const struct user_regset *regset,
 	else
 		info = infobuf;
 
	for (i = 0; i < count / sizeof(struct user_desc); i++)
		if (!tls_desc_okay(info + i))
			return -EINVAL;

 	set_tls_desc(target,
 		     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),
 		     info, count / sizeof(struct user_desc));","arch/x86/kernel/tls.c in the Thread Local Storage (TLS) implementation in the Linux kernel through 3.18.1 allows local users to bypass the espfix protection mechanism, and consequently makes it easier for local users to bypass the ASLR protection mechanism, via a crafted application that makes a set_thread_area system call and later reads a 16-bit value."
315,CVE-2014-8117," 
  */
  
 
 #ifndef __file_h__
  protected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,
 protected void file_regfree(file_regex_t *);
 protected void file_regerror(file_regex_t *, int, struct magic_set *);
 
typedef struct {
	char *buf;
	uint32_t offset;
} file_pushbuf_t;

protected file_pushbuf_t *file_push_buffer(struct magic_set *);
protected char  *file_pop_buffer(struct magic_set *, file_pushbuf_t *);

 #ifndef COMPILE_ONLY
 extern const char *file_names[];
 extern const size_t file_nnames;","softmagic.c in file before 5.21 does not properly limit recursion, which allows remote attackers to cause a denial of service (CPU consumption or crash) via unspecified vectors."
316,CVE-2014-8116," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.105 2014/11/22 16:04:29 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
 	Elf32_Shdr sh32;
 	Elf64_Shdr sh64;
 	int stripped = 1;
	size_t nbadcap = 0;
 	void *nbuf;
 	off_t noff, coff, name_off;
 	uint64_t cap_hw1 = 0;	 
  doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
 				goto skip;
 			}
 
			if (nbadcap > 5)
				break;
 			if (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {
 				file_badseek(ms);
 				return -1;
  doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
 					    (unsigned long long)xcap_tag,
 					    (unsigned long long)xcap_val) == -1)
 						return -1;
					if (nbadcap++ > 2)
						coff = xsh_size;
 					break;
 				}
 			}",The ELF parser (readelf.c) in file before 5.21 allows remote attackers to cause a denial of service (CPU consumption or crash) via a large number of (1) program or (2) section headers or (3) invalid capabilities.
317,CVE-2014-7842,"  static int handle_emulation_failure(struct kvm_vcpu *vcpu)
 
 	++vcpu->stat.insn_emulation_fail;
 	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {
 		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
 		vcpu->run->internal.ndata = 0;","Race condition in arch/x86/kvm/x86.c in the Linux kernel before 3.17.4 allows guest OS users to cause a denial of service (guest OS crash) via a crafted application that performs an MMIO transaction or a PIO transaction to trigger a guest userspace emulation error report, a similar issue to CVE-2010-5313."
318,CVE-2014-7841,"  static int sctp_process_param(struct sctp_association *asoc,
 		addr_param = param.v + sizeof(sctp_addip_param_t);
 
 		af = sctp_get_af_specific(param_type2af(param.p->type));
		if (af == NULL)
			break;

 		af->from_addr_param(&addr, addr_param,
 				    htons(asoc->peer.port), 0);
 ","The sctp_process_param function in net/sctp/sm_make_chunk.c in the SCTP implementation in the Linux kernel before 3.17.4, when ASCONF is used, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via a malformed INIT chunk."
319,CVE-2014-7826,"  static void ftrace_syscall_enter(void *data, struct pt_regs *regs, long id)
 	int size;
 
 	syscall_nr = trace_get_syscall_nr(current, regs);
	if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
 		return;
 
 	 
  static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)
 	int syscall_nr;
 
 	syscall_nr = trace_get_syscall_nr(current, regs);
	if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
 		return;
 
 	 
  static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)
 	int size;
 
 	syscall_nr = trace_get_syscall_nr(current, regs);
	if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
 		return;
 	if (!test_bit(syscall_nr, enabled_perf_enter_syscalls))
 		return;
  static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)
 	int size;
 
 	syscall_nr = trace_get_syscall_nr(current, regs);
	if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
 		return;
 	if (!test_bit(syscall_nr, enabled_perf_exit_syscalls))
 		return;","kernel/trace/trace_syscalls.c in the Linux kernel through 3.17.2 does not properly handle private syscall numbers during use of the ftrace subsystem, which allows local users to gain privileges or cause a denial of service (invalid pointer dereference) via a crafted application."
320,CVE-2014-7284,"  do {								\
 bool __net_get_random_once(void *buf, int nbytes, bool *done,
 			   struct static_key *done_key);
 
 #define net_get_random_once(buf, nbytes)				\
 	({								\
 		bool ___ret = false;					\
 		static bool ___done = false;				\
		static struct static_key ___once_key =			\
			STATIC_KEY_INIT_TRUE;				\
		if (static_key_true(&___once_key))			\
 			___ret = __net_get_random_once(buf,		\
 						       nbytes,		\
 						       &___done,	\
						       &___once_key);	\
 		___ret;							\
 	})
 ","The net_get_random_once implementation in net/core/utils.c in the Linux kernel 3.13.x and 3.14.x before 3.14.5 on certain Intel processors does not perform the intended slow-path operation to initialize random seeds, which makes it easier for remote attackers to spoof or disrupt IP communication by leveraging the predictability of TCP sequence numbers, TCP and UDP port numbers, and IP ID values."
321,CVE-2014-7283,"  xfs_da3_fixhashpath(
 		node = blk->bp->b_addr;
 		dp->d_ops->node_hdr_from_disk(&nodehdr, node);
 		btree = dp->d_ops->node_tree_p(node);
		if (be32_to_cpu(btree[blk->index].hashval) == lasthash)
 			break;
 		blk->hashval = lasthash;
 		btree[blk->index].hashval = cpu_to_be32(lasthash);","The xfs_da3_fixhashpath function in fs/xfs/xfs_da_btree.c in the xfs implementation in the Linux kernel before 3.14.2 does not properly compare btree hash values, which allows local users to cause a denial of service (filesystem corruption, and OOPS or panic) via operations on directories that have hash collisions, as demonstrated by rmdir operations."
322,CVE-2014-7145,"  SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,
 tcon_error_exit:
 	if (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {
 		cifs_dbg(VFS, ""BAD_NETWORK_NAME: %s\n"", tree);
		if (tcon)
			tcon->bad_network_name = true;
 	}
 	goto tcon_exit;
 }",The SMB2_tcon function in fs/cifs/smb2pdu.c in the Linux kernel before 3.16.3 allows remote CIFS servers to cause a denial of service (NULL pointer dereference and client system crash) or possibly have unspecified other impact by deleting the IPC$ share during resolution of DFS referrals.
323,CVE-2014-6418," 
 #include ""auth_x.h""
 #include ""auth_x_protocol.h""
 
 static void ceph_x_validate_tickets(struct ceph_auth_client *ac, int *pneed);
 
 static int ceph_x_is_authenticated(struct ceph_auth_client *ac)
  static int ceph_x_encrypt(struct ceph_crypto_key *secret,
 }
 
 static int ceph_x_decrypt(struct ceph_crypto_key *secret,
			  void **p, void *end, void **obuf, size_t olen)
 {
 	struct ceph_x_encrypt_header head;
 	size_t head_len = sizeof(head);
  static int ceph_x_decrypt(struct ceph_crypto_key *secret,
 		return -EINVAL;
 
 	dout(""ceph_x_decrypt len %d\n"", len);
	if (*obuf == NULL) {
		*obuf = kmalloc(len, GFP_NOFS);
		if (!*obuf)
			return -ENOMEM;
		olen = len;
	}

	ret = ceph_decrypt2(secret, &head, &head_len, *obuf, &olen, *p, len);
 	if (ret)
 		return ret;
 	if (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)
  static void remove_ticket_handler(struct ceph_auth_client *ac,
 
 static int process_one_ticket(struct ceph_auth_client *ac,
 			      struct ceph_crypto_key *secret,
			      void **p, void *end)
 {
 	struct ceph_x_info *xi = ac->private;
 	int type;
 	u8 tkt_struct_v, blob_struct_v;
 	struct ceph_x_ticket_handler *th;
	void *dbuf = NULL;
 	void *dp, *dend;
 	int dlen;
 	char is_enc;
 	struct timespec validity;
 	struct ceph_crypto_key old_key;
	void *ticket_buf = NULL;
 	void *tp, *tpend;
 	struct ceph_timespec new_validity;
 	struct ceph_crypto_key new_session_key;
  static int process_one_ticket(struct ceph_auth_client *ac,
 	}
 
 	 
	dlen = ceph_x_decrypt(secret, p, end, &dbuf, 0);
 	if (dlen <= 0) {
 		ret = dlen;
 		goto out;
  static int process_one_ticket(struct ceph_auth_client *ac,
 
 	 
 	ceph_decode_8_safe(p, end, is_enc, bad);
 	if (is_enc) {
 		 
 		dout("" encrypted ticket\n"");
		dlen = ceph_x_decrypt(&old_key, p, end, &ticket_buf, 0);
 		if (dlen < 0) {
 			ret = dlen;
 			goto out;
 		}
		tp = ticket_buf;
 		dlen = ceph_decode_32(&tp);
 	} else {
 		 
 		ceph_decode_32_safe(p, end, dlen, bad);
		ticket_buf = kmalloc(dlen, GFP_NOFS);
		if (!ticket_buf) {
			ret = -ENOMEM;
			goto out;
		}
		tp = ticket_buf;
 		ceph_decode_need(p, end, dlen, bad);
 		ceph_decode_copy(p, ticket_buf, dlen);
 	}
  static int process_one_ticket(struct ceph_auth_client *ac,
 	xi->have_keys |= th->service;
 
 out:
	kfree(ticket_buf);
	kfree(dbuf);
 	return ret;
 
 bad:
  static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,
 				    void *buf, void *end)
 {
 	void *p = buf;
 	u8 reply_struct_v;
 	u32 num;
 	int ret;
 
 	ceph_decode_8_safe(&p, end, reply_struct_v, bad);
 	if (reply_struct_v != 1)
 		return -EINVAL;
  static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,
 	dout(""%d tickets\n"", num);
 
 	while (num--) {
		ret = process_one_ticket(ac, secret, &p, end);
 		if (ret)
			return ret;
 	}
 
	return 0;
 
 bad:
	return -EINVAL;
 }
 
 static int ceph_x_build_authorizer(struct ceph_auth_client *ac,
  static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,
 	struct ceph_x_ticket_handler *th;
 	int ret = 0;
 	struct ceph_x_authorize_reply reply;
	void *preply = &reply;
 	void *p = au->reply_buf;
 	void *end = p + sizeof(au->reply_buf);
 
 	th = get_ticket_handler(ac, au->service);
 	if (IS_ERR(th))
 		return PTR_ERR(th);
	ret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));
 	if (ret < 0)
 		return ret;
 	if (ret != sizeof(reply))","net/ceph/auth_x.c in Ceph, as used in the Linux kernel before 3.16.3, does not properly validate auth replies, which allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via crafted data from the IP address of a Ceph Monitor."
324,CVE-2014-6410,"  int udf_setsize(struct inode *inode, loff_t newsize)
 	return 0;
 }
 
 
#define UDF_MAX_ICB_NESTING 1024

 static void __udf_read_inode(struct inode *inode)
 {
 	struct buffer_head *bh = NULL;
  static void __udf_read_inode(struct inode *inode)
 	struct udf_inode_info *iinfo = UDF_I(inode);
 	struct udf_sb_info *sbi = UDF_SB(inode->i_sb);
 	unsigned int link_count;
	unsigned int indirections = 0;
 
reread:
 	/*
 	 * Set defaults, but the inode is still incomplete!
 	 * Note: get_new_inode() sets the following on a new inode:
  static void __udf_read_inode(struct inode *inode)
 		ibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,
 					&ident);
 		if (ident == TAG_IDENT_IE && ibh) {
 			struct kernel_lb_addr loc;
 			struct indirectEntry *ie;
 
 			ie = (struct indirectEntry *)ibh->b_data;
 			loc = lelb_to_cpu(ie->indirectICB.extLocation);
 
			if (ie->indirectICB.extLength) {
				brelse(bh);
				brelse(ibh);
				memcpy(&iinfo->i_location, &loc,
				       sizeof(struct kernel_lb_addr));
				if (++indirections > UDF_MAX_ICB_NESTING) {
					udf_err(inode->i_sb,
						""too many ICBs in ICB hierarchy""
						"" (max %d supported)\n"",
						UDF_MAX_ICB_NESTING);
					make_bad_inode(inode);
 					return;
 				}
				goto reread;
 			}
 		}
 		brelse(ibh);","The __udf_read_inode function in fs/udf/inode.c in the Linux kernel through 3.16.3 does not restrict the amount of ICB indirection, which allows physically proximate attackers to cause a denial of service (infinite loop or stack consumption) via a UDF filesystem with a crafted inode."
325,CVE-2014-6396,"  struct postgresql_status {
    u_char status;
    u_char user[65];
    u_char type;
   u_char password[66];
    u_char hash[33];
    u_char salt[9];
    u_char database[65];
  FUNC_DECODER(dissector_postgresql)
                int length;
                DEBUG_MSG(""\tDissector_postgresql RESPONSE type is clear-text!"");
                GET_ULONG_BE(length, ptr, 1);
               length -= 4;
               if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {
                   dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
                   return NULL;
               }
               snprintf((char*)conn_status->password, length+1, ""%s"", (char*)(ptr + 5));
                DISSECT_MSG(""PostgreSQL credentials:%s-%d:%s:%s\n"", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);
                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));
             }","The dissector_postgresql function in dissectors/ec_postgresql.c in Ettercap before 0.8.1 allows remote attackers to cause a denial of service and possibly execute arbitrary code via a crafted password length, which triggers a 0 character to be written to an arbitrary memory location."
326,CVE-2014-6229,"  class HashContext : public SweepableResourceData {
     context = malloc(ops->context_size);
     ops->hash_copy(context, ctx->context);
     options = ctx->options;
    if (ctx->key) {
      key = static_cast<char*>(malloc(ops->block_size));
      memcpy(key, ctx->key, ops->block_size);
    } else {
      key = nullptr;
    }
   }
 
   ~HashContext() {","The HashContext class in hphp/runtime/ext/ext_hash.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 incorrectly expects that a certain key string uses '0' for termination, which allows remote attackers to obtain sensitive information by leveraging read access beyond the end of the string, and makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging truncation of a string containing an internal '0' character."
327,CVE-2014-6228,"  String string_chunk_split(const char *src, int srclen, const char *end,
   int chunks = srclen / chunklen;  
   int restlen = srclen - chunks * chunklen;  
 
  String ret(
    safe_address(
      chunks + 1,
      endlen,
      srclen
    ),
    ReserveString
  );
   char *dest = ret.bufferSlice().ptr;
 
   const char *p; char *q;",Integer overflow in the string_chunk_split function in hphp/runtime/base/zend-string.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted arguments to the chunk_split function.
328,CVE-2014-5472,"  static void isofs_put_super(struct super_block *sb)
 	return;
 }
 
static int isofs_read_inode(struct inode *, int relocated);
 static int isofs_statfs (struct dentry *, struct kstatfs *);
 
 static struct kmem_cache *isofs_inode_cachep;
  static int isofs_read_level3_size(struct inode *inode)
 	goto out;
 }
 
static int isofs_read_inode(struct inode *inode, int relocated)
 {
 	struct super_block *sb = inode->i_sb;
 	struct isofs_sb_info *sbi = ISOFS_SB(sb);
  static int isofs_read_inode(struct inode *inode)
 	 */
 
 	if (!high_sierra) {
		parse_rock_ridge_inode(de, inode, relocated);
 		 
 		if (sbi->s_uid_set)
 			inode->i_uid = sbi->s_uid;
  static int isofs_iget5_set(struct inode *ino, void *data)
  * offset that point to the underlying meta-data for the inode.  The
  * code below is otherwise similar to the iget() code in
  * include/linux/fs.h */
struct inode *__isofs_iget(struct super_block *sb,
			   unsigned long block,
			   unsigned long offset,
			   int relocated)
 {
 	unsigned long hashval;
 	struct inode *inode;
  struct inode *isofs_iget(struct super_block *sb,
 		return ERR_PTR(-ENOMEM);
 
 	if (inode->i_state & I_NEW) {
		ret = isofs_read_inode(inode, relocated);
 		if (ret < 0) {
 			iget_failed(inode);
 			inode = ERR_PTR(ret);",The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel through 3.16.1 allows local users to cause a denial of service (unkillable mount process) via a crafted iso9660 image with a self-referential CL entry.
329,CVE-2014-5386," 
 
 #include ""hphp/runtime/base/base-includes.h""
 #include ""hphp/runtime/base/runtime-error.h""
#include ""hphp/runtime/ext/ext_math.h""
 
 #include <sys/types.h>
 #include <sys/stat.h>
  Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source  ) {
   } else {
     n = size;
     while (size) {
       
      iv[--size] = (char)f_rand(0, 255);
     }
   }
   return String(iv, n, AttachString);","The mcrypt_create_iv function in hphp/runtime/ext/mcrypt/ext_mcrypt.cpp in Facebook HipHop Virtual Machine (HHVM) before 3.3.0 does not seed the random number generator, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by leveraging the use of a single initialization vector."
330,CVE-2014-5354,"  krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,
     int num_versions = 1;
     int i, j, last;
     krb5_error_code err = 0;
    krb5_key_data *key_data = NULL;
 
    if (n_key_data < 0)
         return NULL;
 
      
     key_data = k5calloc(n_key_data, sizeof(*key_data), &err);
    if (key_data == NULL)
         goto cleanup;
     memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));
 
  krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,
     free(key_data);
     if (err != 0) {
         if (ret != NULL) {
            for (i = 0; ret[i] != NULL; i++)
                free (ret[i]);
             free (ret);
             ret = NULL;
         }
  krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,
         bersecretkey = krb5_encode_krbsecretkey (entry->key_data,
                                                  entry->n_key_data, mkvno);
 
        if (bersecretkey == NULL) {
            st = ENOMEM;
             goto cleanup;
        }
         
        if (bersecretkey[0] != NULL || !create_standalone_prinicipal) {
            st = krb5_add_ber_mem_ldap_mod(&mods, ""krbprincipalkey"",
                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                           bersecretkey);
            if (st != 0)
                goto cleanup;
        }
 
         if (!(entry->mask & KADM5_PRINCIPAL)) {
             memset(strval, 0, sizeof(strval));","plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.1, when the KDC uses LDAP, allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) by creating a database entry for a keyless principal, as demonstrated by a kadmin *add_principal -nokey* or *purgekeys -all* command."
331,CVE-2014-5353,"  krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,
     LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, ""(objectclass=krbPwdPolicy)"", password_policy_attributes);
 
     ent=ldap_first_entry(ld, result);
    if (ent == NULL) {
        st = KRB5_KDB_NOENTRY;
        goto cleanup;
     }
    st = populate_policy(context, ld, ent, pol_name, *policy);
 
 cleanup:
     ldap_msgfree(result);","The krb5_ldap_get_password_policy_from_dn function in plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c in MIT Kerberos 5 (aka krb5) before 1.13.1, when the KDC uses LDAP, allows remote authenticated users to cause a denial of service (daemon crash) via a successful LDAP query with no results, as demonstrated by using an incorrect object type for a password policy."
332,CVE-2014-5351,"  check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
     *passptr = NULL;
 }
 
 
static int
count_new_keys(int n_key_data, krb5_key_data *key_data)
{
    int n;

    for (n = 1; n < n_key_data; n++) {
        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)
            return n;
    }
    return n_key_data;
}

 kadm5_ret_t
 kadm5_create_principal(void *server_handle,
                        kadm5_principal_ent_t entry, long mask,
  kadm5_randkey_principal_3(void *server_handle,
     osa_princ_ent_rec           adb;
     krb5_int32                  now;
     kadm5_policy_ent_rec        pol;
    int                         ret, last_pwd, n_new_keys;
     krb5_boolean                have_pol = FALSE;
     kadm5_server_handle_t       handle = server_handle;
     krb5_keyblock               *act_mkey;
  kadm5_randkey_principal_3(void *server_handle,
     kdb->fail_auth_count = 0;
 
     if (keyblocks) {
         
        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);
        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,
                                keyblocks, n_keys);
         if (ret)
             goto done;","The kadm5_randkey_principal_3 function in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13 sends old keys in a response to a -randkey -keepold request, which allows remote authenticated users to forge tickets by leveraging administrative access."
333,CVE-2014-5336,"  struct session_request
     long port;
      
 
     
     int fd_file;
    int fd_is_fdt;

 
     int headers_len;
 ","Monkey HTTP Server before 1.5.3, when the File Descriptor Table (FDT) is enabled and custom error messages are set, allows remote attackers to cause a denial of service (file descriptor consumption) via an HTTP request that triggers an error message."
334,CVE-2014-5207,"  static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 
 	mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);
 	 
	if (flag & CL_UNPRIVILEGED) {
		mnt->mnt.mnt_flags |= MNT_LOCK_ATIME;

		if (mnt->mnt.mnt_flags & MNT_READONLY)
			mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

		if (mnt->mnt.mnt_flags & MNT_NODEV)
			mnt->mnt.mnt_flags |= MNT_LOCK_NODEV;

		if (mnt->mnt.mnt_flags & MNT_NOSUID)
			mnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;

		if (mnt->mnt.mnt_flags & MNT_NOEXEC)
			mnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;
	}
 
 	 
 	if ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))
  static int do_remount(struct path *path, int flags, int mnt_flags,
 	    !(mnt_flags & MNT_READONLY)) {
 		return -EPERM;
 	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&
	    !(mnt_flags & MNT_NODEV)) {
		return -EPERM;
	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&
	    !(mnt_flags & MNT_NOSUID)) {
		return -EPERM;
	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&
	    !(mnt_flags & MNT_NOEXEC)) {
		return -EPERM;
	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&
	    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {
		return -EPERM;
	}

 	err = security_sb_remount(sb, data);
 	if (err)
 		return err;
  static int do_new_mount(struct path *path, const char *fstype, int flags,
 		 */
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;
 		}
 	}
 ","fs/namespace.c in the Linux kernel through 3.16.1 does not properly restrict clearing MNT_NODEV, MNT_NOSUID, and MNT_NOEXEC and changing MNT_ATIME_MASK during a remount of a bind mount, which allows local users to gain privileges, interfere with backups and auditing on systems that had atime enabled, or cause a denial of service (excessive filesystem updating) on systems that had atime disabled via a *mount -o remount* command within a user namespace."
335,CVE-2014-5206,"  static int do_remount(struct path *path, int flags, int mnt_flags,
 		err = do_remount_sb(sb, flags, data, 0);
 	if (!err) {
 		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
 		mnt->mnt.mnt_flags = mnt_flags;
 		touch_mnt_namespace(mnt->mnt_ns);
 		unlock_mount_hash();","The do_remount function in fs/namespace.c in the Linux kernel through 3.16.1 does not maintain the MNT_LOCK_READONLY bit across a remount of a bind mount, which allows local users to bypass an intended read-only restriction and defeat certain sandbox protection mechanisms via a *mount -o remount* command within a user namespace."
336,CVE-2014-5077,"  void sctp_assoc_update(struct sctp_association *asoc,
 	asoc->c = new->c;
 	asoc->peer.rwnd = new->peer.rwnd;
 	asoc->peer.sack_needed = new->peer.sack_needed;
	asoc->peer.auth_capable = new->peer.auth_capable;
 	asoc->peer.i = new->peer.i;
 	sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,
 			 asoc->peer.i.initial_tsn, GFP_ATOMIC);","The sctp_assoc_update function in net/sctp/associola.c in the Linux kernel through 3.15.8, when SCTP authentication is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and OOPS) by starting to establish an association between two endpoints immediately after an exchange of INIT and INIT ACK chunks to establish an earlier association between these endpoints in the opposite direction."
337,CVE-2014-5045,"  mountpoint_last(struct nameidata *nd, struct path *path)
 		goto out;
 	}
 	path->dentry = dentry;
	path->mnt = nd->path.mnt;
 	if (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))
 		return 1;
	mntget(path->mnt);
 	follow_mount(path);
 	error = 0;
 out:","The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program."
338,CVE-2014-4943,"  static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,
 	int err;
 
 	if (level != SOL_PPPOL2TP)
		return -EINVAL;
 
 	if (optlen < sizeof(int))
 		return -EINVAL;
  static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,
 	struct pppol2tp_session *ps;
 
 	if (level != SOL_PPPOL2TP)
		return -EINVAL;
 
 	if (get_user(len, optlen))
 		return -EFAULT;",The PPPoL2TP feature in net/l2tp/l2tp_ppp.c in the Linux kernel through 3.15.6 allows local users to gain privileges by leveraging data-structure differences between an l2tp socket and an inet socket.
339,CVE-2014-4699,"  static inline unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
 
 #define ARCH_HAS_USER_SINGLE_STEP_INFO
 
 
#define arch_ptrace_stop_needed(code, info)				\
({									\
	set_thread_flag(TIF_NOTIFY_RESUME);				\
	false;								\
})

 struct user_desc;
 extern int do_get_thread_area(struct task_struct *p, int idx,
 			      struct user_desc __user *info);","The Linux kernel before 3.15.4 on Intel processors does not properly restrict use of a non-canonical value for the saved RIP address in the case of a system call that does not use IRET, which allows local users to leverage a race condition and gain privileges, or cause a denial of service (double fault), via a crafted application that makes ptrace and fork system calls."
340,CVE-2014-4668,"  cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,
 	 
 	if ((conn->validator == NULL) ||
	    cherokee_buffer_is_empty (&conn->validator->user) ||
	    cherokee_buffer_is_empty (&conn->validator->passwd))
 		return ret_error;
 
 	size = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, ""*()"");","The cherokee_validator_ldap_check function in validator_ldap.c in Cherokee 1.2.103 and earlier, when LDAP is used, does not properly consider unauthenticated-bind semantics, which allows remote attackers to bypass authentication via an empty password."
341,CVE-2014-4667,"  void sctp_association_free(struct sctp_association *asoc)
 	 
	if (!list_empty(&asoc->asocs)) {
 		list_del(&asoc->asocs);
 
 		/* Decrement the backlog value for a TCP-style listening","The sctp_association_free function in net/sctp/associola.c in the Linux kernel before 3.15.2 does not properly manage a certain backlog value, which allows remote attackers to cause a denial of service (socket outage) via a crafted SCTP packet."
342,CVE-2014-4656,"  static bool snd_ctl_remove_numid_conflict(struct snd_card *card,
 {
 	struct snd_kcontrol *kctl;
 
	 
	if (card->last_numid >= UINT_MAX - count)
		card->last_numid = 0;

 	list_for_each_entry(kctl, &card->controls, list) {
 		if (kctl->id.numid < card->last_numid + 1 + count &&
 		    kctl->id.numid + kctl->count > card->last_numid + 1) {","Multiple integer overflows in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allow local users to cause a denial of service by leveraging /dev/snd/controlCX access, related to (1) index values in the snd_ctl_add function and (2) numid values in the snd_ctl_remove_numid_conflict function."
343,CVE-2014-4655,"  static int snd_ctl_elem_add(struct snd_ctl_file *file,
 	struct user_element *ue;
 	int idx, err;
 
 	if (info->count < 1)
 		return -EINVAL;
 	access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
  static int snd_ctl_elem_add(struct snd_ctl_file *file,
 				 SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
 	info->id.numid = 0;
 	memset(&kctl, 0, sizeof(kctl));

	if (replace) {
		err = snd_ctl_remove_user_ctl(file, &info->id);
		if (err)
			return err;
 	}

	if (card->user_ctl_count >= MAX_USER_CONTROLS)
		return -ENOMEM;

 	memcpy(&kctl.id, &info->id, sizeof(info->id));
 	kctl.count = info->owner ? info->owner : 1;
 	access |= SNDRV_CTL_ELEM_ACCESS_USER;","The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not properly maintain the user_ctl_count value, which allows local users to cause a denial of service (integer overflow and limit bypass) by leveraging /dev/snd/controlCX access for a large number of SNDRV_CTL_IOCTL_ELEM_REPLACE ioctl calls."
344,CVE-2014-4653,"  int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)
 {
 	struct snd_ctl_elem_id id;
 	unsigned int idx;
	unsigned int count;
 	int err = -EINVAL;
 
 	if (! kcontrol)
  int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)
 	card->controls_count += kcontrol->count;
 	kcontrol->id.numid = card->last_numid + 1;
 	card->last_numid += kcontrol->count;
	count = kcontrol->count;
 	up_write(&card->controls_rwsem);
	for (idx = 0; idx < count; idx++, id.index++, id.numid++)
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
 	return 0;
 
  int snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,
 		    bool add_on_replace)
 {
 	struct snd_ctl_elem_id id;
	unsigned int count;
 	unsigned int idx;
 	struct snd_kcontrol *old;
 	int ret;
  int snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,
 	card->controls_count += kcontrol->count;
 	kcontrol->id.numid = card->last_numid + 1;
 	card->last_numid += kcontrol->count;
	count = kcontrol->count;
 	up_write(&card->controls_rwsem);
	for (idx = 0; idx < count; idx++, id.index++, id.numid++)
 		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
 	return 0;
 
  static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,
 			result = kctl->put(kctl, control);
 		}
 		if (result > 0) {
			struct snd_ctl_elem_id id = control->id;
 			up_read(&card->controls_rwsem);
			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);
 			return 0;
 		}
 	}
  static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,
 		}
 		err = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);
 		if (err > 0) {
			struct snd_ctl_elem_id id = kctl->id;
 			up_read(&card->controls_rwsem);
			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &id);
 			return 0;
 		}
 	} else {","sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not ensure possession of a read/write lock, which allows local users to cause a denial of service (use-after-free) and obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access."
345,CVE-2014-4652,"  struct snd_card {
 	int user_ctl_count;		 
 	struct list_head controls;	 
 	struct list_head ctl_files;	 
	struct mutex user_ctl_lock;	 
 
 	struct snd_info_entry *proc_root;	 
 	struct snd_info_entry *proc_id;	 ",Race condition in the tlv handler functionality in the snd_ctl_elem_user_tlv function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allows local users to obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.
346,CVE-2014-4611,"  static int lz4_uncompress(const char *source, char *dest, int osize)
 			len = *ip++;
 			for (; len == 255; length += 255)
 				len = *ip++;
			if (unlikely(length > (size_t)(length + len)))
				goto _output_error;
 			length += len;
 		}
 ","Integer overflow in the LZ4 algorithm implementation, as used in Yann Collet LZ4 before r118 and in the lz4_uncompress function in lib/lz4/lz4_decompress.c in the Linux kernel before 3.15.2, on 32-bit platforms might allow context-dependent attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted Literal Run that would be improperly handled by programs not complying with an API limitation, a different vulnerability than CVE-2014-4715."
347,CVE-2014-4608," 
 #include <linux/lzo.h>
 #include ""lzodefs.h""
 
#define HAVE_IP(t, x)					\
	(((size_t)(ip_end - ip) >= (size_t)(t + x)) &&	\
	 (((t + x) >= t) && ((t + x) >= x)))

#define HAVE_OP(t, x)					\
	(((size_t)(op_end - op) >= (size_t)(t + x)) &&	\
	 (((t + x) >= t) && ((t + x) >= x)))

#define NEED_IP(t, x)					\
	do {						\
		if (!HAVE_IP(t, x))			\
			goto input_overrun;		\
	} while (0)

#define NEED_OP(t, x)					\
	do {						\
		if (!HAVE_OP(t, x))			\
			goto output_overrun;		\
	} while (0)

#define TEST_LB(m_pos)					\
	do {						\
		if ((m_pos) < out)			\
			goto lookbehind_overrun;	\
	} while (0)
 
 int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 			  unsigned char *out, size_t *out_len)
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 					while (unlikely(*ip == 0)) {
 						t += 255;
 						ip++;
						NEED_IP(1, 0);
 					}
 					t += 15 + *ip++;
 				}
 				t += 3;
 copy_literal_run:
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
				if (likely(HAVE_IP(t, 15) && HAVE_OP(t, 15))) {
 					const unsigned char *ie = ip + t;
 					unsigned char *oe = op + t;
 					do {
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 				} else
 #endif
 				{
					NEED_OP(t, 0);
					NEED_IP(t, 3);
 					do {
 						*op++ = *ip++;
 					} while (--t > 0);
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 				m_pos -= t >> 2;
 				m_pos -= *ip++ << 2;
 				TEST_LB(m_pos);
				NEED_OP(2, 0);
 				op[0] = m_pos[0];
 				op[1] = m_pos[1];
 				op += 2;
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 				while (unlikely(*ip == 0)) {
 					t += 255;
 					ip++;
					NEED_IP(1, 0);
 				}
 				t += 31 + *ip++;
				NEED_IP(2, 0);
 			}
 			m_pos = op - 1;
 			next = get_unaligned_le16(ip);
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 				while (unlikely(*ip == 0)) {
 					t += 255;
 					ip++;
					NEED_IP(1, 0);
 				}
 				t += 7 + *ip++;
				NEED_IP(2, 0);
 			}
 			next = get_unaligned_le16(ip);
 			ip += 2;
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
 		if (op - m_pos >= 8) {
 			unsigned char *oe = op + t;
			if (likely(HAVE_OP(t, 15))) {
 				do {
 					COPY8(op, m_pos);
 					op += 8;
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 					m_pos += 8;
 				} while (op < oe);
 				op = oe;
				if (HAVE_IP(6, 0)) {
 					state = next;
 					COPY4(op, ip);
 					op += next;
 					ip += next;
 					continue;
 				}
 			} else {
				NEED_OP(t, 0);
 				do {
 					*op++ = *m_pos++;
 				} while (op < oe);
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 #endif
 		{
 			unsigned char *oe = op + t;
			NEED_OP(t, 0);
 			op[0] = m_pos[0];
 			op[1] = m_pos[1];
 			op += 2;
  int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
 		state = next;
 		t = next;
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
		if (likely(HAVE_IP(6, 0) && HAVE_OP(4, 0))) {
 			COPY4(op, ip);
 			op += t;
 			ip += t;
 		} else
 #endif
 		{
			NEED_IP(t, 3);
			NEED_OP(t, 0);
 			while (t > 0) {
 				*op++ = *ip++;
 				t--;",** DISPUTED ** Multiple integer overflows in the lzo1x_decompress_safe function in lib/lzo/lzo1x_decompress_safe.c in the LZO decompressor in the Linux kernel before 3.15.2 allow context-dependent attackers to cause a denial of service (memory corruption) via a crafted Literal Run.  NOTE: the author of the LZO algorithms says *the Linux kernel is *not* affected; media hype.*
348,CVE-2014-4503,"  static bool parse_notify(struct pool *pool, json_t *val)
 		pool->swork.nbit,
 		""00000000"",  
 		workpadding);
	if (unlikely(!hex2bin(pool->header_bin, header, 128))) {
		applog(LOG_WARNING, ""%s: Failed to convert header to header_bin, got %s"", __func__, header);
		pool_failed(pool);
		 
		return false;
	}
 
 	cb1 = (unsigned char *)calloc(cb1_len, 1);
 	if (unlikely(!cb1))
 		quithere(1, ""Failed to calloc cb1 in parse_notify"");
 	hex2bin(cb1, coinbase1, cb1_len);

 	cb2 = (unsigned char *)calloc(cb2_len, 1);
 	if (unlikely(!cb2))
 		quithere(1, ""Failed to calloc cb2 in parse_notify"");
 	hex2bin(cb2, coinbase2, cb2_len);

 	free(pool->coinbase);
 	align_len(&alloc_len);
 	pool->coinbase = (unsigned char *)calloc(alloc_len, 1);
 	if (unlikely(!pool->coinbase))
 		quit(1, ""Failed to calloc pool coinbase in parse_notify"");
 	memcpy(pool->coinbase, cb1, cb1_len);
 	memcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);
	 
 	memcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);
 	cg_wunlock(&pool->data_lock);
 ","The parse_notify function in util.c in sgminer before 4.2.2 and cgminer 3.3.0 through 4.0.1 allows man-in-the-middle attackers to cause a denial of service (application exit) via a crafted (1) bbversion, (2) prev_hash, (3) nbit, or (4) ntime parameter in a mining.notify action stratum message."
349,CVE-2014-4502," 
  
		free(job_id);
		free(coinbase1);
		free(coinbase2);
 		goto out;
 	}
 
  static bool parse_reconnect(struct pool *pool, json_t *val)
 	if (!port)
 		port = pool->stratum_port;
 
	snprintf(address, 254, ""%s:%s"", url, port);
 
 	if (!extract_sockaddr(address, &sockaddr_url, &stratum_port))
 		return false;
  bool initiate_stratum(struct pool *pool)
 	if (!sessionid)
 		applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum"");
 	nonce1 = json_array_string(res_val, 1);
	if (!valid_hex(nonce1)) {
		applog(LOG_INFO, ""Failed to get valid nonce1 in initiate_stratum"");
 		free(sessionid);
 		goto out;
 	}
 	n2size = json_integer_value(json_array_get(res_val, 2));
	if (n2size < 2 || n2size > 16) {
		applog(LOG_INFO, ""Failed to get valid n2size in initiate_stratum"");
 		free(sessionid);
 		free(nonce1);
 		goto out;","Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request."
350,CVE-2014-4501,"  bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)
 
 	if (url_len < 1)
 		return false;
	
	if (url_len >= sizeof(url_address))
	{
		applog(LOG_WARNING, ""%s: Truncating overflowed address '%.*s'"",
		       __func__, url_len, url_begin);
		url_len = sizeof(url_address) - 1;
	}
 
 	sprintf(url_address, ""%.*s"", url_len, url_begin);
 ","Multiple stack-based buffer overflows in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 3.3.0 allow remote pool servers to have unspecified impact via a long URL in a client.reconnect stratum message to the (1) extract_sockaddr or (2) parse_reconnect functions in util.c."
351,CVE-2014-4345,"  krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,
             j++;
             last = i + 1;
 
            if (i < n_key_data - 1)
                currkvno = key_data[i + 1].key_data_kvno;
         }
     }
     ret[num_versions] = NULL;",Off-by-one error in the krb5_encode_krbsecretkey function in plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in the LDAP KDB module in kadmind in MIT Kerberos 5 (aka krb5) 1.6.x through 1.11.x before 1.11.6 and 1.12.x before 1.12.2 allows remote authenticated users to cause a denial of service (buffer overflow) or possibly execute arbitrary code via a series of *cpw -keepold* commands.
352,CVE-2014-4344,"  acc_ctx_cont(OM_uint32 *minstat,
 
 	ptr = bufstart = buf->value;
 #define REMAIN (buf->length - (ptr - bufstart))
	if (REMAIN == 0 || REMAIN > INT_MAX)
 		return GSS_S_DEFECTIVE_TOKEN;
 
 	/*",The acc_ctx_cont function in the SPNEGO acceptor in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.5.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty continuation token at a certain point during a SPNEGO negotiation.
353,CVE-2014-4343,"  init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,
 	OM_uint32 tmpmin;
 	size_t i;
 
 	gss_delete_sec_context(&tmpmin, &sc->ctx_handle,
 			       GSS_C_NO_BUFFER);
 ","Double free vulnerability in the init_ctx_reselect function in the SPNEGO initiator in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.10.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via network traffic that appears to come from an intended acceptor, but specifies a security mechanism different from the one proposed by the initiator."
354,CVE-2014-4342,"  kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,
     int conflen = 0;
     int signalg;
     int sealalg;
    int bad_pad = 0;
     gss_buffer_desc token;
     krb5_checksum cksum;
     krb5_checksum md5cksum;
  kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,
     krb5_ui_4 seqnum;
     OM_uint32 retval;
     size_t sumlen;
    size_t padlen;
     krb5_keyusage sign_usage = KG_USAGE_SIGN;
 
     if (toktype == KG_TOK_SEAL_MSG) {
         message_buffer->length = 0;
         message_buffer->value = NULL;
     }
 
      
 
    if (ctx->seq == NULL) {
         
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

    if ((bodysize < 22) || (ptr[4] != 0xff) || (ptr[5] != 0xff)) {
         *minor_status = 0;
         return GSS_S_DEFECTIVE_TOKEN;
     }
 
    signalg = ptr[0] + (ptr[1]<<8);
    sealalg = ptr[2] + (ptr[3]<<8);

     if ((toktype != KG_TOK_SEAL_MSG) &&
         (sealalg != 0xffff)) {
         *minor_status = 0;
  kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,
         return GSS_S_DEFECTIVE_TOKEN;
     }
 
    if ((size_t)bodysize < 14 + cksum_len) {
        *minor_status = 0;
        return GSS_S_DEFECTIVE_TOKEN;
    }

      
 
     if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,
  kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,
         plainlen = tmsglen;
 
         conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);
        if (tmsglen < conflen) {
            if (sealalg != 0xffff)
                xfree(plain);
            *minor_status = 0;
            return(GSS_S_DEFECTIVE_TOKEN);
        }
        padlen = plain[tmsglen - 1];
        if (tmsglen - conflen < padlen) {
             
            padlen = 0;
            bad_pad = 1;
        }
        token.length = tmsglen - conflen - padlen;
 
         if (token.length) {
             if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {
  kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,
 
      
 
    if (code || bad_pad) {
         if (toktype == KG_TOK_SEAL_MSG)
             gssalloc_free(token.value);
         *minor_status = 0;","MIT Kerberos 5 (aka krb5) 1.7.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (buffer over-read or NULL pointer dereference, and application crash) by injecting invalid tokens into a GSSAPI application session."
355,CVE-2014-4157,"  static inline struct thread_info *current_thread_info(void)
 #define _TIF_SYSCALL_TRACEPOINT	(1<<TIF_SYSCALL_TRACEPOINT)
 
 #define _TIF_WORK_SYSCALL_ENTRY	(_TIF_NOHZ | _TIF_SYSCALL_TRACE |	\
				 _TIF_SYSCALL_AUDIT | \
				 _TIF_SYSCALL_TRACEPOINT | _TIF_SECCOMP)
 
  
 #define _TIF_WORK_SYSCALL_EXIT	(_TIF_NOHZ | _TIF_SYSCALL_TRACE |	\","arch/mips/include/asm/thread_info.h in the Linux kernel before 3.14.8 on the MIPS platform does not configure _TIF_SECCOMP checks on the fast system-call path, which allows local users to bypass intended PR_SET_SECCOMP restrictions by executing a crafted application without invoking a trace or audit subsystem."
356,CVE-2014-4049,"  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 				
 				while (ll < dlen) {
 					n = cp[ll];
					if ((ll + n) >= dlen) {
						 
						n = dlen - (ll + 1);
					}
 					memcpy(tp + ll , cp + ll + 1, n);
 					add_next_index_stringl(entries, cp + ll + 1, n, 1);
 					ll = ll + n + 1;","Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function."
357,CVE-2014-4027,"  static void rd_detach_hba(struct se_hba *hba)
 	hba->hba_ptr = NULL;
 }
 
static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 sg_table_count)
 {
 	struct page *pg;
 	struct scatterlist *sg;
	u32 i, j, page_count = 0, sg_per_table;
 
	for (i = 0; i < sg_table_count; i++) {
 		sg = sg_table[i].sg_table;
 		sg_per_table = sg_table[i].rd_sg_count;
 
  static void rd_release_device_space(struct rd_dev *rd_dev)
 				page_count++;
 			}
 		}
 		kfree(sg);
 	}
 
	kfree(sg_table);
	return page_count;
}

static void rd_release_device_space(struct rd_dev *rd_dev)
{
	u32 page_count;

	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
		return;

	page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,
					  rd_dev->sg_table_count);

 	pr_debug(""CORE_RD[%u] - Released device space for Ramdisk""
 		"" Device ID: %u, pages %u in %u tables total bytes %lu\n"",
 		rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
 		rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);
 
 	rd_dev->sg_table_array = NULL;
 	rd_dev->sg_table_count = 0;
 }
  static void rd_release_device_space(struct rd_dev *rd_dev)
  *
  *
  */
static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
				 u32 total_sg_needed, unsigned char init_payload)
 {
	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	struct page *pg;
 	struct scatterlist *sg;
	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
  static int rd_build_device_space(struct rd_dev *rd_dev)
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;

			p = kmap(pg);
			memset(p, init_payload, PAGE_SIZE);
			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
	return 0;
}

static int rd_build_device_space(struct rd_dev *rd_dev)
{
	struct rd_dev_sg_table *sg_table;
	u32 sg_tables, total_sg_needed;
	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
				sizeof(struct scatterlist));
	int rc;

	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
		       rd_dev->rd_page_count);
		return -EINVAL;
	}

	 
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;

	total_sg_needed = rd_dev->rd_page_count;

	sg_tables = (total_sg_needed / max_sg_per_table) + 1;

	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
		       "" scatterlist tables\n"");
		return -ENOMEM;
	}

	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;

	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
	if (rc)
		return rc;

 	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
		 rd_dev->sg_table_count);
 
 	return 0;
 }","The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator."
358,CVE-2014-4014,"  int inode_change_ok(const struct inode *inode, struct iattr *attr)
 	if ((ia_valid & ATTR_UID) &&
 	    (!uid_eq(current_fsuid(), inode->i_uid) ||
 	     !uid_eq(attr->ia_uid, inode->i_uid)) &&
	    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))
 		return -EPERM;
 
 	 
 	if ((ia_valid & ATTR_GID) &&
 	    (!uid_eq(current_fsuid(), inode->i_uid) ||
 	    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&
	    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))
 		return -EPERM;
 
 	 
  int inode_change_ok(const struct inode *inode, struct iattr *attr)
 		 
 		if (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :
 				inode->i_gid) &&
		    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
 			attr->ia_mode &= ~S_ISGID;
 	}
 
  void setattr_copy(struct inode *inode, const struct iattr *attr)
 		umode_t mode = attr->ia_mode;
 
 		if (!in_group_p(inode->i_gid) &&
		    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
 			mode &= ~S_ISGID;
 		inode->i_mode = mode;
 	}","The capabilities implementation in the Linux kernel before 3.14.8 does not properly consider that namespaces are inapplicable to inodes, which allows local users to bypass intended chmod restrictions by first creating a user namespace, as demonstrated by setting the setgid bit on a file with group ownership of root."
359,CVE-2014-3980,"  _fep_open_control_socket (Fep *fep)
   memset (&sun, 0, sizeof(sun));
   sun.sun_family = AF_UNIX;
 
   memcpy (sun.sun_path, path, strlen (path));
   sun_len = sizeof (struct sockaddr_un);
 
   if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)
     {","libfep 0.0.5 before 0.1.0 does not properly use UNIX domain sockets in the abstract namespace, which allows local users to gain privileges via unspecified vectors."
360,CVE-2014-3971,"  namespace mongo {
         }
         else {
             std::string srvSubjectName = getSSLManager()->getServerSubjectName();
            
            size_t srvClusterIdPos = srvSubjectName.find("",OU="");
            size_t peerClusterIdPos = subjectName.find("",OU="");
 
            std::string srvClusterId = srvClusterIdPos != std::string::npos ? 
                srvSubjectName.substr(srvClusterIdPos) : """";
            std::string peerClusterId = peerClusterIdPos != std::string::npos ? 
                subjectName.substr(peerClusterIdPos) : """";
 
              
             int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); 
            if (srvClusterId == peerClusterId && !srvClusterId.empty()) {
                 if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||
                     clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {
                     return Status(ErrorCodes::AuthenticationFailed, ""The provided certificate "" ",The CmdAuthenticate::_authenticateX509 function in db/commands/authentication_commands.cpp in mongod in MongoDB 2.6.x before 2.6.2 allows remote attackers to cause a denial of service (daemon crash) by attempting authentication with an invalid X.509 client certificate.
361,CVE-2014-3690,"  struct vcpu_vmx {
 		int           gs_ldt_reload_needed;
 		int           fs_reload_needed;
 		u64           msr_host_bndcfgs;
		unsigned long vmcs_host_cr4;	 
 	} host_state;
 	struct {
 		int vm86_active;
  static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
 	u32 low32, high32;
 	unsigned long tmpl;
 	struct desc_ptr dt;
	unsigned long cr4;
 
 	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);   
 	vmcs_writel(HOST_CR3, read_cr3());   
 
	 
	cr4 = read_cr4();
	vmcs_writel(HOST_CR4, cr4);			 
	vmx->host_state.vmcs_host_cr4 = cr4;

 	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);   
 #ifdef CONFIG_X86_64
 	 
 	if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
  static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 	if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))
 		vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);
 
	cr4 = read_cr4();
	if (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {
		vmcs_writel(HOST_CR4, cr4);
		vmx->host_state.vmcs_host_cr4 = cr4;
	}

 	/* When single-stepping over STI and MOV SS, we must clear the
 	 * corresponding interruptibility bits in the guest state. Otherwise
 	 * vmentry fails as it then expects bit 14 (BS) in pending debug","arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel before 3.17.2 on Intel processors does not ensure that the value in the CR4 control register remains the same after a VM entry, which allows host OS users to kill arbitrary processes or cause a denial of service (system disruption) by leveraging /dev/kvm access, as demonstrated by PR_SET_TSC prctl calls within a modified copy of QEMU."
362,CVE-2014-3688,"  struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)
 		} else {
 			 
 			ch = (sctp_chunkhdr_t *) chunk->chunk_end;
 			 
			skb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);
			 
 		}
 	}
 
  struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)
 	skb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));
 	chunk->subh.v = NULL;  
 
	if (chunk->chunk_end + sizeof(sctp_chunkhdr_t) <
	    skb_tail_pointer(chunk->skb)) {
 		 
 		chunk->singleton = 0;
 	} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {
		 
		chunk->pdiscard = 1;
		chunk->chunk_end = skb_tail_pointer(chunk->skb);
 	} else {
 		/* We are at the end of the packet, so mark the chunk
 		 * in case we need to send a SACK.","The SCTP implementation in the Linux kernel before 3.17.4 allows remote attackers to cause a denial of service (memory consumption) by triggering a large number of chunks in an association's output queue, as demonstrated by ASCONF probes, related to net/sctp/inqueue.c and net/sctp/sm_statefuns.c."
363,CVE-2014-3687,"  static inline void sctp_assoc_pending_pmtu(struct sock *sk, struct sctp_associat
 	asoc->pmtu_pending = 0;
 }
 
static inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)
{
	return !list_empty(&chunk->list);
}

 /* Walk through a list of TLV parameters.  Don't trust the
  * individual parameter lengths and instead depend on
  * the chunk length to indicate when to stop.  Make sure",The sctp_assoc_lookup_asconf_ack function in net/sctp/associola.c in the SCTP implementation in the Linux kernel through 3.17.2 allows remote attackers to cause a denial of service (panic) via duplicate ASCONF chunks that trigger an incorrect uncork within the side-effect interpreter.
364,CVE-2014-3673,"  struct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *,
 					      int, __be16);
 struct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,
 					     union sctp_addr *addr);
bool sctp_verify_asconf(const struct sctp_association *asoc,
			struct sctp_chunk *chunk, bool addr_param_needed,
			struct sctp_paramhdr **errp);
 struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,
 				       struct sctp_chunk *asconf);
 int sctp_process_asconf_ack(struct sctp_association *asoc,","The SCTP implementation in the Linux kernel through 3.17.2 allows remote attackers to cause a denial of service (system crash) via a malformed ASCONF chunk, related to net/sctp/sm_make_chunk.c and net/sctp/sm_statefuns.c."
365,CVE-2014-3647,"  static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 
  
 static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				     u16 selector, int seg, u8 cpl,
				     bool in_task_switch,
				     struct desc_struct *desc)
 {
 	struct desc_struct seg_desc, old_desc;
 	u8 dpl, rpl;
  static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 	}
 load:
 	ctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);
	if (desc)
		*desc = seg_desc;
 	return X86EMUL_CONTINUE;
 exception:
 	return emulate_exception(ctxt, err_vec, err_code, true);
  static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				   u16 selector, int seg)
 {
 	u8 cpl = ctxt->ops->cpl(ctxt);
	return __load_segment_descriptor(ctxt, selector, seg, cpl, false, NULL);
 }
 
 static void write_register_operand(struct operand *op)
  static int em_iret(struct x86_emulate_ctxt *ctxt)
 static int em_jmp_far(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
	unsigned short sel, old_sel;
	struct desc_struct old_desc, new_desc;
	const struct x86_emulate_ops *ops = ctxt->ops;
	u8 cpl = ctxt->ops->cpl(ctxt);

	 
	if (ctxt->mode == X86EMUL_MODE_PROT64)
		ops->get_segment(ctxt, &old_sel, &old_desc, NULL,
				 VCPU_SREG_CS);
 
 	memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);
 
	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,
				       &new_desc);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 
	rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);
	if (rc != X86EMUL_CONTINUE) {
		WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);
		 
		ops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);
		return rc;
	}
	return rc;
 }
 
 static int em_grp45(struct x86_emulate_ctxt *ctxt)
  static int em_ret(struct x86_emulate_ctxt *ctxt)
 static int em_ret_far(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
	unsigned long eip, cs;
	u16 old_cs;
 	int cpl = ctxt->ops->cpl(ctxt);
	struct desc_struct old_desc, new_desc;
	const struct x86_emulate_ops *ops = ctxt->ops;

	if (ctxt->mode == X86EMUL_MODE_PROT64)
		ops->get_segment(ctxt, &old_cs, &old_desc, NULL,
				 VCPU_SREG_CS);
 
	rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 	rc = emulate_pop(ctxt, &cs, ctxt->op_bytes);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 	 
 	if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)
 		return X86EMUL_UNHANDLEABLE;
	rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, 0, false,
				       &new_desc);
	if (rc != X86EMUL_CONTINUE)
		return rc;
	rc = assign_eip_far(ctxt, eip, new_desc.l);
	if (rc != X86EMUL_CONTINUE) {
		WARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);
		ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);
	}
 	return rc;
 }
 
  static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,
 	 * Now load segment descriptors. If fault happens at this stage
 	 * it is handled in a context of new task
 	 */
	ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
 
  static int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,
 	 * Now load segment descriptors. If fault happenes at this stage
 	 * it is handled in a context of new task
 	 */
	ret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,
					cpl, true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
	ret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,
					true, NULL);
 	if (ret != X86EMUL_CONTINUE)
 		return ret;
 
  static int em_call_far(struct x86_emulate_ctxt *ctxt)
 	u16 sel, old_cs;
 	ulong old_eip;
 	int rc;
	struct desc_struct old_desc, new_desc;
	const struct x86_emulate_ops *ops = ctxt->ops;
	int cpl = ctxt->ops->cpl(ctxt);
 
 	old_eip = ctxt->_eip;
	ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);
 
 	memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);
	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,
				       &new_desc);
	if (rc != X86EMUL_CONTINUE)
 		return X86EMUL_CONTINUE;
 
	rc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);
	if (rc != X86EMUL_CONTINUE)
		goto fail;
 
 	ctxt->src.val = old_cs;
 	rc = em_push(ctxt);
 	if (rc != X86EMUL_CONTINUE)
		goto fail;
 
 	ctxt->src.val = old_eip;
	rc = em_push(ctxt);
	 
	if (rc != X86EMUL_CONTINUE)
		goto fail;
	return rc;
fail:
	ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);
	return rc;

 }
 
 static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)","arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel through 3.17.2 does not properly perform RIP changes, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application."
366,CVE-2014-3646," 
 #define EXIT_REASON_EPT_MISCONFIG       49
 #define EXIT_REASON_INVEPT              50
 #define EXIT_REASON_PREEMPTION_TIMER    52
#define EXIT_REASON_INVVPID             53
 #define EXIT_REASON_WBINVD              54
 #define EXIT_REASON_XSETBV              55
 #define EXIT_REASON_APIC_WRITE          56
 
 	{ EXIT_REASON_EOI_INDUCED,           ""EOI_INDUCED"" }, \
 	{ EXIT_REASON_INVALID_STATE,         ""INVALID_STATE"" }, \
 	{ EXIT_REASON_INVD,                  ""INVD"" }, \
	{ EXIT_REASON_INVVPID,               ""INVVPID"" }, \
 	{ EXIT_REASON_INVPCID,               ""INVPCID"" }
 
 #endif  ","arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel through 3.17.2 does not have an exit handler for the INVVPID instruction, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application."
367,CVE-2014-3645,"  enum vmcs_field {
 #define VMX_EPT_EXTENT_INDIVIDUAL_ADDR		0
 #define VMX_EPT_EXTENT_CONTEXT			1
 #define VMX_EPT_EXTENT_GLOBAL			2
#define VMX_EPT_EXTENT_SHIFT			24
 
 #define VMX_EPT_EXECUTE_ONLY_BIT		(1ull)
 #define VMX_EPT_PAGE_WALK_4_BIT			(1ull << 6)
 #define VMX_EPTP_UC_BIT				(1ull << 8)
 #define VMX_EPTP_WB_BIT				(1ull << 14)
 #define VMX_EPT_2MB_PAGE_BIT			(1ull << 16)
 #define VMX_EPT_1GB_PAGE_BIT			(1ull << 17)
#define VMX_EPT_INVEPT_BIT			(1ull << 20)
 #define VMX_EPT_AD_BIT				    (1ull << 21)
 #define VMX_EPT_EXTENT_CONTEXT_BIT		(1ull << 25)
 #define VMX_EPT_EXTENT_GLOBAL_BIT		(1ull << 26)","arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel before 3.12 does not have an exit handler for the INVEPT instruction, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application."
368,CVE-2014-3631,"  int assoc_array_gc(struct assoc_array *array,
 		shortcut = assoc_array_ptr_to_shortcut(ptr);
 		slot = shortcut->parent_slot;
 		cursor = shortcut->back_pointer;
		if (!cursor)
			goto gc_complete;
 	} else {
 		slot = node->parent_slot;
 		cursor = ptr;
 	}
	BUG_ON(!cursor);
 	node = assoc_array_ptr_to_node(cursor);
 	slot++;
 	goto continue_node;","The assoc_array_gc function in the associative-array implementation in lib/assoc_array.c in the Linux kernel before 3.16.3 does not properly implement garbage collection, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via multiple *keyctl newring* operations followed by a *keyctl timeout* operation."
369,CVE-2014-3611,"  void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)
 		return;
 
 	timer = &pit->pit_state.timer;
	mutex_lock(&pit->pit_state.lock);
 	if (hrtimer_cancel(timer))
 		hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
	mutex_unlock(&pit->pit_state.lock);
 }
 
 static void destroy_pit_timer(struct kvm_pit *pit)",Race condition in the __kvm_migrate_pit_timer function in arch/x86/kvm/i8254.c in the KVM subsystem in the Linux kernel through 3.17.2 allows guest OS users to cause a denial of service (host OS crash) by leveraging incorrect PIT emulation.
370,CVE-2014-3610,"  static inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)
 	kvm_queue_exception_e(vcpu, GP_VECTOR, error_code);
 }
 
static inline u64 get_canonical(u64 la)
{
	return ((int64_t)la << 16) >> 16;
}

static inline bool is_noncanonical_address(u64 la)
{
#ifdef CONFIG_X86_64
	return get_canonical(la) != la;
#else
	return false;
#endif
}

 #define TSS_IOPB_BASE_OFFSET 0x66
 #define TSS_BASE_SIZE 0x68
 #define TSS_IOPB_SIZE (65536 / 8)","The WRMSR processing functionality in the KVM subsystem in the Linux kernel through 3.17.2 does not properly handle the writing of a non-canonical address to a model-specific register, which allows guest OS users to cause a denial of service (host OS crash) by leveraging guest OS privileges, related to the wrmsr_interception function in arch/x86/kvm/svm.c and the handle_wrmsr function in arch/x86/kvm/vmx.c."
371,CVE-2014-3601,"  static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
 	return pfn;
 }
 
static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)
{
	unsigned long i;

	for (i = 0; i < npages; ++i)
		kvm_release_pfn_clean(pfn + i);
}

 int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 {
 	gfn_t gfn, end_gfn;
  int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 		if (r) {
 			printk(KERN_ERR ""kvm_iommu_map_address:""
 			       ""iommu failed to map pfn=%llx\n"", pfn);
			kvm_unpin_pages(kvm, pfn, page_size);
 			goto unmap_pages;
 		}
 
  int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
 	return 0;
 
 unmap_pages:
	kvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);
 	return r;
 }
 
  int kvm_iommu_map_guest(struct kvm *kvm)
 	return r;
 }
 
 static void kvm_iommu_put_pages(struct kvm *kvm,
 				gfn_t base_gfn, unsigned long npages)
 {","The kvm_iommu_map_pages function in virt/kvm/iommu.c in the Linux kernel through 3.16.1 miscalculates the number of pages during the handling of a mapping failure, which allows guest OS users to (1) cause a denial of service (host OS memory corruption) or possibly have unspecified other impact by triggering a large gfn value or (2) cause a denial of service (host OS memory consumption) by triggering a small gfn value that leads to permanently pinned pages."
372,CVE-2014-3597,"  PHP_FUNCTION(dns_check_record)
 
 #if HAVE_FULL_DNS_FUNCS
 
#define CHECKCP(n) do { \
	if (cp + n > end) { \
		return NULL; \
	} \
} while (0)

  
static u_char *php_parserr(u_char *cp, u_char *end, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)
 {
 	u_short type, class, dlen;
 	u_long ttl;
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 
 	*subarray = NULL;
 
	n = dn_expand(answer->qb2, end, cp, name, sizeof(name) - 2);
 	if (n < 0) {
 		return NULL;
 	}
 	cp += n;
 
	CHECKCP(10);
 	GETSHORT(type, cp);
 	GETSHORT(class, cp);
 	GETLONG(ttl, cp);
 	GETSHORT(dlen, cp);
	CHECKCP(dlen);
 	if (type_to_fetch != T_ANY && type != type_to_fetch) {
 		cp += dlen;
 		return cp;
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 
 	switch (type) {
 		case DNS_T_A:
			CHECKCP(4);
 			add_assoc_string(*subarray, ""type"", ""A"", 1);
 			snprintf(name, sizeof(name), ""%d.%d.%d.%d"", cp[0], cp[1], cp[2], cp[3]);
 			add_assoc_string(*subarray, ""ip"", name, 1);
 			cp += dlen;
 			break;
 		case DNS_T_MX:
			CHECKCP(2);
 			add_assoc_string(*subarray, ""type"", ""MX"", 1);
 			GETSHORT(n, cp);
 			add_assoc_long(*subarray, ""pri"", n);
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 			if (type == DNS_T_PTR) {
 				add_assoc_string(*subarray, ""type"", ""PTR"", 1);
 			}
			n = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);
 			if (n < 0) {
 				return NULL;
 			}
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 		case DNS_T_HINFO:
 			 
 			add_assoc_string(*subarray, ""type"", ""HINFO"", 1);
			CHECKCP(1);
 			n = *cp & 0xFF;
 			cp++;
			CHECKCP(n);
 			add_assoc_stringl(*subarray, ""cpu"", (char*)cp, n, 1);
 			cp += n;
			CHECKCP(1);
 			n = *cp & 0xFF;
 			cp++;
			CHECKCP(n);
 			add_assoc_stringl(*subarray, ""os"", (char*)cp, n, 1);
 			cp += n;
 			break;
 		case DNS_T_TXT:
 			{
				int l1 = 0, l2 = 0;
 				zval *entries = NULL;
 
 				add_assoc_string(*subarray, ""type"", ""TXT"", 1);
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 				MAKE_STD_ZVAL(entries);
 				array_init(entries);
 				
				while (l1 < dlen) {
					n = cp[l1];
					if ((l1 + n) >= dlen) {
 						 
						n = dlen - (l1 + 1);
					}
					if (n) {
						memcpy(tp + l2 , cp + l1 + 1, n);
						add_next_index_stringl(entries, cp + l1 + 1, n, 1);
 					}
					l1 = l1 + n + 1;
					l2 = l2 + n;
 				}
				tp[l2] = '\0';
 				cp += dlen;
 
				add_assoc_stringl(*subarray, ""txt"", tp, l2, 0);
 				add_assoc_zval(*subarray, ""entries"", entries);
 			}
 			break;
 		case DNS_T_SOA:
 			add_assoc_string(*subarray, ""type"", ""SOA"", 1);
			n = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);
 			if (n < 0) {
 				return NULL;
 			}
 			cp += n;
 			add_assoc_string(*subarray, ""mname"", name, 1);
			n = dn_expand(answer->qb2, end, cp, name, (sizeof name) -2);
 			if (n < 0) {
 				return NULL;
 			}
 			cp += n;
 			add_assoc_string(*subarray, ""rname"", name, 1);
			CHECKCP(5*4);
 			GETLONG(n, cp);
 			add_assoc_long(*subarray, ""serial"", n);
 			GETLONG(n, cp);
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 			break;
 		case DNS_T_AAAA:
 			tp = (u_char*)name;
			CHECKCP(8*2);
 			for(i=0; i < 8; i++) {
 				GETSHORT(s, cp);
 				if (s != 0) {
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 		case DNS_T_A6:
 			p = cp;
 			add_assoc_string(*subarray, ""type"", ""A6"", 1);
			CHECKCP(1);
 			n = ((int)cp[0]) & 0xFF;
 			cp++;
 			add_assoc_long(*subarray, ""masklen"", n);
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 				cp++;
 			}
 			for (i = (n + 8) / 16; i < 8; i++) {
				CHECKCP(2);
 				GETSHORT(s, cp);
 				if (s != 0) {
 					if (tp > (u_char *)name) {
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 			tp[0] = '\0';
 			add_assoc_string(*subarray, ""ipv6"", name, 1);
 			if (cp < p + dlen) {
				n = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);
 				if (n < 0) {
 					return NULL;
 				}
  static u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int
 			}
 			break;
 		case DNS_T_SRV:
			CHECKCP(3*2);
 			add_assoc_string(*subarray, ""type"", ""SRV"", 1);
 			GETSHORT(n, cp);
 			add_assoc_long(*subarray, ""pri"", n);
 			GETSHORT(n, cp);
 			add_assoc_long(*subarray, ""weight"", n);
 			GETSHORT(n, cp);
 			add_assoc_long(*subarray, ""port"", n);
			n = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);
 			if (n < 0) {
 				return NULL;
 			}
 			cp += n;
 			add_assoc_string(*subarray, ""target"", name, 1);
 			break;
 		case DNS_T_NAPTR:
			CHECKCP(2*2);
 			add_assoc_string(*subarray, ""type"", ""NAPTR"", 1);
 			GETSHORT(n, cp);
 			add_assoc_long(*subarray, ""order"", n);
 			GETSHORT(n, cp);
 			add_assoc_long(*subarray, ""pref"", n);

			CHECKCP(1);
 			n = (cp[0] & 0xFF);
			cp++;
			CHECKCP(n);
			add_assoc_stringl(*subarray, ""flags"", (char*)cp, n, 1);
 			cp += n;

			CHECKCP(1);
 			n = (cp[0] & 0xFF);
			cp++;
			CHECKCP(n);
			add_assoc_stringl(*subarray, ""services"", (char*)cp, n, 1);
 			cp += n;

			CHECKCP(1);
 			n = (cp[0] & 0xFF);
			cp++;
			CHECKCP(n);
			add_assoc_stringl(*subarray, ""regex"", (char*)cp, n, 1);
 			cp += n;

			n = dn_expand(answer->qb2, end, cp, name, (sizeof name) - 2);
 			if (n < 0) {
 				return NULL;
 			}
  PHP_FUNCTION(dns_get_record)
 			while (an-- && cp && cp < end) {
 				zval *retval;
 
				cp = php_parserr(cp, end, &answer, type_to_fetch, store_results, raw, &retval);
 				if (retval != NULL && store_results) {
 					add_next_index_zval(return_value, retval);
 				}
  PHP_FUNCTION(dns_get_record)
 				while (ns-- > 0 && cp && cp < end) {
 					zval *retval = NULL;
 
					cp = php_parserr(cp, end, &answer, DNS_T_ANY, authns != NULL, raw, &retval);
 					if (retval != NULL) {
 						add_next_index_zval(authns, retval);
 					}
  PHP_FUNCTION(dns_get_record)
 				while (ar-- > 0 && cp && cp < end) {
 					zval *retval = NULL;
 
					cp = php_parserr(cp, end, &answer, DNS_T_ANY, 1, raw, &retval);
 					if (retval != NULL) {
 						add_next_index_zval(addtl, retval);
 					}","Multiple buffer overflows in the php_parserr function in ext/standard/dns.c in PHP before 5.4.32 and 5.5.x before 5.5.16 allow remote DNS servers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted DNS record, related to the dns_get_record function and the dn_expand function.  NOTE: this issue exists because of an incomplete fix for CVE-2014-4049."
373,CVE-2014-3535,"  static inline const char *netdev_name(const struct net_device *dev)
 	return dev->name;
 }
 
extern int netdev_printk(const char *level, const struct net_device *dev,
			 const char *format, ...)
	__attribute__ ((format (printf, 3, 4)));
extern int netdev_emerg(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
extern int netdev_alert(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
extern int netdev_crit(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
extern int netdev_err(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
extern int netdev_warn(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
extern int netdev_notice(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
extern int netdev_info(const struct net_device *dev, const char *format, ...)
	__attribute__ ((format (printf, 2, 3)));
 
 #if defined(DEBUG)
 #define netdev_dbg(__dev, format, args...)			\","include/linux/netdevice.h in the Linux kernel before 2.6.36 incorrectly uses macros for netdev_printk and its related logging implementation, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) by sending invalid packets to a VxLAN interface."
374,CVE-2014-3534,"  static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)
 			unsigned long mask = PSW_MASK_USER;
 
 			mask |= is_ri_task(child) ? PSW_MASK_RI : 0;
			if ((data ^ PSW_USER_BITS) & ~mask)
				 
				return -EINVAL;
			if ((data & PSW_MASK_ASC) == PSW_ASC_HOME)
				 
 				return -EINVAL;
 			if ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))
				 
 				return -EINVAL;
 		}
 		*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;
  static int __poke_user_compat(struct task_struct *child,
 
 			mask |= is_ri_task(child) ? PSW32_MASK_RI : 0;
 			 
			if ((tmp ^ PSW32_USER_BITS) & ~mask)
 				 
 				return -EINVAL;
			if ((data & PSW32_MASK_ASC) == PSW32_ASC_HOME)
				 
				return -EINVAL;
 			regs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |
 				(regs->psw.mask & PSW_MASK_BA) |
 				(__u64)(tmp & mask) << 32;","arch/s390/kernel/ptrace.c in the Linux kernel before 3.15.8 on the s390 platform does not properly restrict address-space control operations in PTRACE_POKEUSR_AREA requests, which allows local users to obtain read and write access to kernel memory locations, and consequently gain privileges, via a crafted application that makes a ptrace system call."
375,CVE-2014-3487," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.62 2014/06/04 17:26:07 christos Exp $"")
 #endif
 
 #include <assert.h>
  cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
		size_t tail = (i << 1) + 1;
		if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),
		    __LINE__) == -1)
			goto out;
		size_t ofs = CDF_GETUINT32(p, tail);
 		q = (const uint8_t *)(const void *)
 		    ((const char *)(const void *)p + ofs
 		    - 2 * sizeof(uint32_t));","The cdf_read_property_info function in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, does not properly validate a stream offset, which allows remote attackers to cause a denial of service (application crash) via a crafted CDF file."
376,CVE-2014-3480," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.60 2014/05/21 13:04:38 christos Exp $"")
 #endif
 
 #include <assert.h>
  size_t
 cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)
 {
 	size_t i, j;
	cdf_secid_t maxsector = (cdf_secid_t)((sat->sat_len * size)
	    / sizeof(maxsector));
 
 	DPRINTF((""Chain:""));
 	for (j = i = 0; sid >= 0; i++, j++) {
  cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)
 			errno = EFTYPE;
 			return (size_t)-1;
 		}
		if (sid >= maxsector) {
			DPRINTF((""Sector %d >= %d\n"", sid, maxsector));
 			errno = EFTYPE;
 			return (size_t)-1;
 		}","The cdf_count_chain function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, does not properly validate sector-count data, which allows remote attackers to cause a denial of service (application crash) via a crafted CDF file."
377,CVE-2014-3479," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.61 2014/06/04 17:23:19 christos Exp $"")
 #endif
 
 #include <assert.h>
  cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,
 {
 	const char *b = (const char *)sst->sst_tab;
 	const char *e = ((const char *)p) + tail;
	size_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?
	    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);
 	(void)&line;
	if (e >= b && (size_t)(e - b) <= ss * sst->sst_len)
 		return 0;
 	DPRINTF((""%d: offset begin %p < end %p || %"" SIZE_T_FORMAT ""u""
 	    "" > %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""
 	    SIZE_T_FORMAT ""u]\n"", line, b, e, (size_t)(e - b),
	    ss * sst->sst_len, ss, sst->sst_len));
 	errno = EFTYPE;
 	return -1;
 }","The cdf_check_stream_offset function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, relies on incorrect sector-size data, which allows remote attackers to cause a denial of service (application crash) via a crafted stream offset in a CDF file."
378,CVE-2014-3478," 
 #include ""file.h""
 
 #ifndef	lint
FILE_RCSID(""@(#)$File: softmagic.c,v 1.190 2014/06/03 19:01:34 christos Exp $"")
 #endif	 
 
 #include ""magic.h""
  mconvert(struct magic_set *ms, struct magic *m, int flip)
 		return 1;
 	}
 	case FILE_PSTRING: {
		size_t sz = file_pstring_length_size(m);
		char *ptr1 = p->s, *ptr2 = ptr1 + sz;
 		size_t len = file_pstring_get_length(m, ptr1);
		if (len >= sizeof(p->s)) {
			  
			len = sizeof(p->s) - sz;
		}
 		while (len--)
 			*ptr1++ = *ptr2++;
 		*ptr1 = '\0';","Buffer overflow in the mconvert function in softmagic.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (application crash) via a crafted Pascal string in a FILE_PSTRING conversion."
379,CVE-2014-3186,"  static int picolcd_raw_event(struct hid_device *hdev,
 	if (!data)
 		return 1;
 
	if (size > 64) {
		hid_warn(hdev, ""invalid size value (%d) for picolcd raw event\n"",
				size);
		return 0;
	}

 	if (report->id == REPORT_KEY_STATE) {
 		if (data->input_keys)
 			ret = picolcd_raw_keypad(data, report, raw_data+1, size-1);","Buffer overflow in the picolcd_raw_event function in devices/hid/hid-picolcd_core.c in the PicoLCD HID device driver in the Linux kernel through 3.16.3, as used in Android on Nexus 7 devices, allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that sends a large report."
380,CVE-2014-3185,"  static void command_port_read_callback(struct urb *urb)
 		dev_dbg(&urb->dev->dev, ""%s - command_info is NULL, exiting.\n"", __func__);
 		return;
 	}
	if (!urb->actual_length) {
		dev_dbg(&urb->dev->dev, ""%s - empty response, exiting.\n"", __func__);
		return;
	}
 	if (status) {
 		dev_dbg(&urb->dev->dev, ""%s - nonzero urb status: %d\n"", __func__, status);
 		if (status != -ENOENT)
  static void command_port_read_callback(struct urb *urb)
 		 
 		dev_dbg(&urb->dev->dev, ""%s - event received\n"", __func__);
	} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) &&
		(urb->actual_length - 1 <= sizeof(command_info->result_buffer))) {
 		memcpy(command_info->result_buffer, &data[1],
 						urb->actual_length - 1);
 		command_info->command_finished = WHITEHEAT_CMD_COMPLETE;",Multiple buffer overflows in the command_port_read_callback function in drivers/usb/serial/whiteheat.c in the Whiteheat USB Serial Driver in the Linux kernel before 3.16.2 allow physically proximate attackers to execute arbitrary code or cause a denial of service (memory corruption and system crash) via a crafted device that provides a large amount of (1) EHCI or (2) XHCI data associated with a bulk response.
381,CVE-2014-3184," 
 static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;","The report_fixup functions in the HID subsystem in the Linux kernel before 3.16.2 might allow physically proximate attackers to cause a denial of service (out-of-bounds write) via a crafted device that provides a small report descriptor, related to (1) drivers/hid/hid-cherry.c, (2) drivers/hid/hid-kye.c, (3) drivers/hid/hid-lg.c, (4) drivers/hid/hid-monterey.c, (5) drivers/hid/hid-petalynx.c, and (6) drivers/hid/hid-sunplus.c."
382,CVE-2014-3183,"  static int logi_dj_ll_raw_request(struct hid_device *hid,
 	if (!out_buf)
 		return -ENOMEM;
 
	if (count > DJREPORT_SHORT_LENGTH - 2)
 		count = DJREPORT_SHORT_LENGTH - 2;
 
 	out_buf[0] = REPORT_ID_DJ_SHORT;",Heap-based buffer overflow in the logi_dj_ll_raw_request function in drivers/hid/hid-logitech-dj.c in the Linux kernel before 3.16.2 allows physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that specifies a large report size for an LED report.
383,CVE-2014-3182,"  static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
 		return;
 	}
 
 	if (djrcv_dev->paired_dj_devices[dj_report->device_index]) {
 		 
 		dbg_hid(""%s: device is already known\n"", __func__);
  static int logi_dj_raw_event(struct hid_device *hdev,
 	 * device (via hid_input_report() ) and return 1 so hid-core does not do
 	 * anything else with it.
 	 */
	if ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||
	    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {
		dev_err(&hdev->dev, ""%s: invalid device index:%d\n"",
				__func__, dj_report->device_index);
		return false;
	}
 
 	spin_lock_irqsave(&djrcv_dev->lock, flags);
 	if (dj_report->report_id == REPORT_ID_DJ_SHORT) {",Array index error in the logi_dj_raw_event function in drivers/hid/hid-logitech-dj.c in the Linux kernel before 3.16.2 allows physically proximate attackers to execute arbitrary code or cause a denial of service (invalid kfree) via a crafted device that provides a malformed REPORT_TYPE_NOTIF_DEVICE_UNPAIRED value.
384,CVE-2014-3181,"  static int magicmouse_raw_event(struct hid_device *hdev,
 		if (size < 4 || ((size - 4) % 9) != 0)
 			return 0;
 		npoints = (size - 4) / 9;
		if (npoints > 15) {
			hid_warn(hdev, ""invalid size value (%d) for TRACKPAD_REPORT_ID\n"",
					size);
			return 0;
		}
 		msc->ntouches = 0;
 		for (ii = 0; ii < npoints; ii++)
 			magicmouse_emit_touch(msc, ii, data + ii * 9 + 4);
  static int magicmouse_raw_event(struct hid_device *hdev,
 		if (size < 6 || ((size - 6) % 8) != 0)
 			return 0;
 		npoints = (size - 6) / 8;
		if (npoints > 15) {
			hid_warn(hdev, ""invalid size value (%d) for MOUSE_REPORT_ID\n"",
					size);
			return 0;
		}
 		msc->ntouches = 0;
 		for (ii = 0; ii < npoints; ii++)
 			magicmouse_emit_touch(msc, ii, data + ii * 8 + 6);",Multiple stack-based buffer overflows in the magicmouse_raw_event function in drivers/hid/hid-magicmouse.c in the Magic Mouse HID driver in the Linux kernel through 3.16.3 allow physically proximate attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted device that provides a large amount of (1) EHCI or (2) XHCI data associated with an event.
385,CVE-2014-3158,"  getword(f, word, newlinep, filename)
 	     
	    if (len < MAXWORDLEN) {
 		word[len] = value;
		++len;
	    }
 
 	    if (!got)
 		c = getc(f);
  getword(f, word, newlinep, filename)
 	 
	if (len < MAXWORDLEN) {
 	    word[len] = c;
	    ++len;
	}
 
 	c = getc(f);
     }","Integer overflow in the getword function in options.c in pppd in Paul's PPP Package (ppp) before 2.4.7 allows attackers to *access privileged options* via a long word in an options file, which triggers a heap-based buffer overflow that *[corrupts] security-relevant variables.*"
386,CVE-2014-3153,"  static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	struct futex_q *this, *next;
 
 	if (requeue_pi) {
		 
		if (uaddr1 == uaddr2)
			return -EINVAL;

 		 
	if (requeue_pi && match_futex(&key1, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	hb1 = hash_futex(&key1);
 	hb2 = hash_futex(&key2);
 
  static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	if (ret)
 		goto out_key2;
 
	 
	if (match_futex(&q.key, &key2)) {
		ret = -EINVAL;
		goto out_put_keys;
	}

 	 
 	futex_wait_queue_me(hb, &q, to);
 ","The futex_requeue function in kernel/futex.c in the Linux kernel through 3.14.5 does not ensure that calls have two different futex addresses, which allows local users to gain privileges via a crafted FUTEX_REQUEUE command that facilitates unsafe waiter modification."
387,CVE-2014-3145,"  static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
 	if (skb_is_nonlinear(skb))
 		return 0;
 
	if (skb->len < sizeof(struct nlattr))
		return 0;

 	if (A > skb->len - sizeof(struct nlattr))
 		return 0;
 
  static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
 	if (skb_is_nonlinear(skb))
 		return 0;
 
	if (skb->len < sizeof(struct nlattr))
		return 0;

 	if (A > skb->len - sizeof(struct nlattr))
 		return 0;
 
 	nla = (struct nlattr *) &skb->data[A];
	if (nla->nla_len > skb->len - A)
 		return 0;
 
 	nla = nla_find_nested(nla, X);","The BPF_S_ANC_NLATTR_NEST extension implementation in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 uses the reverse order in a certain subtraction, which allows local users to cause a denial of service (over-read and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr_nest function before the vulnerability was announced."
388,CVE-2014-3122,"  void clear_page_mlock(struct page *page)
  */
 void mlock_vma_page(struct page *page)
 {
	 
 	BUG_ON(!PageLocked(page));
 
 	if (!TestSetPageMlocked(page)) {
  unsigned int munlock_vma_page(struct page *page)
 	unsigned int nr_pages;
 	struct zone *zone = page_zone(page);
 
	 
 	BUG_ON(!PageLocked(page));
 
 	/*","The try_to_unmap_cluster function in mm/rmap.c in the Linux kernel before 3.14.3 does not properly consider which pages must be locked, which allows local users to cause a denial of service (system crash) by triggering a memory-usage pattern that requires removal of page-table mappings."
389,CVE-2014-2889,"  cond_branch:			f_offset = addrs[i + filter[i].jf] - addrs[i];
 					break;
 				}
 				if (filter[i].jt != 0) {
					if (filter[i].jf && f_offset)
						t_offset += is_near(f_offset) ? 2 : 5;
 					EMIT_COND_JMP(t_op, t_offset);
 					if (filter[i].jf)
 						EMIT_JMP(f_offset);","Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump."
390,CVE-2014-2739,"  static void cm_init_av_for_response(struct cm_port *port, struct ib_wc *wc,
 			   grh, &av->ah_attr);
 }
 
 static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)
 {
 	struct cm_device *cm_dev;","The cma_req_handler function in drivers/infiniband/core/cma.c in the Linux kernel 3.14.x through 3.14.1 attempts to resolve an RDMA over Converged Ethernet (aka RoCE) address that is properly resolved within a different module, which allows remote attackers to cause a denial of service (incorrect pointer dereference and system crash) via crafted network traffic."
391,CVE-2014-2706,"  struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 	rcu_read_unlock();
 
 	spin_lock_init(&sta->lock);
	spin_lock_init(&sta->ps_lock);
 	INIT_WORK(&sta->drv_unblock_wk, sta_unblock);
 	INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
 	mutex_init(&sta->ampdu_mlme.mtx);
  void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
 
 	skb_queue_head_init(&pending);
 
	 
	spin_lock(&sta->ps_lock);
 	 
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
 		int count = skb_queue_len(&pending), tmp;
  void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
 	}
 
 	ieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);
	spin_unlock(&sta->ps_lock);
 
 	 
 	if (!ieee80211_smps_is_restrictive(sta->known_smps_mode,","Race condition in the mac80211 subsystem in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via network traffic that improperly interacts with the WLAN_STA_PS_STA state (aka power-save mode), related to sta_info.c and tx.c."
392,CVE-2014-2673,"  int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 	flush_altivec_to_thread(src);
 	flush_vsx_to_thread(src);
 	flush_spe_to_thread(src);
	 
	__switch_to_tm(src);
	tm_recheckpoint_new_task(src);
 
 	*dst = *src;
 ","The arch_dup_task_struct function in the Transactional Memory (TM) implementation in arch/powerpc/kernel/process.c in the Linux kernel before 3.13.7 on the powerpc platform does not properly interact with the clone and fork system calls, which allows local users to cause a denial of service (Program Check and system crash) via certain instructions that are executed with the processor in the Transactional state."
393,CVE-2014-2672,"  void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
 	for (tidno = 0, tid = &an->tid[tidno];
 	     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {
 
 		ac = tid->ac;
 		txq = ac->txq;
 
 		ath_txq_lock(sc, txq);
 
		if (!tid->sched) {
			ath_txq_unlock(sc, txq);
			continue;
		}

 		buffered = ath_tid_has_buffered(tid);
 
 		tid->sched = false;",Race condition in the ath_tx_aggr_sleep function in drivers/net/wireless/ath/ath9k/xmit.c in the Linux kernel before 3.13.7 allows remote attackers to cause a denial of service (system crash) via a large amount of network traffic that triggers certain list deletions.
394,CVE-2014-2669,"  typedef struct
 } HStore;
 
  
 #define HS_FLAG_NEWVERSION 0x80000000
 
 #define HS_COUNT(hsp_) ((hsp_)->size_ & 0x0FFFFFFF)
 #define HS_SETCOUNT(hsp_,c_) ((hsp_)->size_ = (c_) | HS_FLAG_NEWVERSION)
 
 
 
 #define HSHRDSIZE	(sizeof(HStore))
 #define CALCDATASIZE(x, lenstr) ( (x) * 2 * sizeof(HEntry) + HSHRDSIZE + (lenstr) )
 ","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
395,CVE-2014-2567,"  bool OpenConnectionTask::handleStateHelper(const Imap::Responses::State *const r
     {
         switch (resp->kind) {
         case PREAUTH:
            if (model->m_startTls) {
                 
                 
                 
                 
                 
                logout(tr(""Configuration requires sending STARTTLS, but the IMAP server greets us with PREAUTH. ""
                          ""Encryption cannot be established. If this configuration worked previously, someone ""
                          ""is after your data and they are pretty smart.""));
                return true;
            }
              
             if (model->accessParser(parser).capabilitiesFresh) {
                  ",The OpenConnectionTask::handleStateHelper function in Imap/Tasks/OpenConnectionTask.cpp in Trojita before 0.4.1 allows man-in-the-middle attackers to trigger use of cleartext for saving a message into a (1) sent or (2) draft folder via a PREAUTH response that prevents later use of the STARTTLS command.
396,CVE-2014-2523,"  static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
 	const char *msg;
 	u_int8_t state;
 
	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
 	BUG_ON(dh == NULL);
 
 	state = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];
  static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,
 	u_int8_t type, old_state, new_state;
 	enum ct_dccp_roles role;
 
	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
 	BUG_ON(dh == NULL);
 	type = dh->dccph_type;
 
  static int dccp_error(struct net *net, struct nf_conn *tmpl,
 	unsigned int cscov;
 	const char *msg;
 
	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
 	if (dh == NULL) {
 		msg = ""nf_ct_dccp: short packet "";
 		goto out_invalid;","net/netfilter/nf_conntrack_proto_dccp.c in the Linux kernel through 3.13.6 uses a DCCP header pointer incorrectly, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a DCCP packet that triggers a call to the (1) dccp_new, (2) dccp_packet, or (3) dccp_error function."
397,CVE-2014-2270," 
 #include ""file.h""
 
 #ifndef	lint
FILE_RCSID(""@(#)$File: softmagic.c,v 1.171 2014/01/08 22:02:06 christos Exp $"")
 #endif	 
 
 #include ""magic.h""
  private void cvt_16(union VALUETYPE *, const struct magic *);
 private void cvt_32(union VALUETYPE *, const struct magic *);
 private void cvt_64(union VALUETYPE *, const struct magic *);
 
#define OFFSET_OOB(n, o, i)	((n) < (o) || (i) >= ((n) - (o)))
  
 	switch (m->type) {
 	case FILE_BYTE:
		if (OFFSET_OOB(nbytes, offset, 1))
 			return 0;
 		break;
 
 	case FILE_SHORT:
 	case FILE_BESHORT:
 	case FILE_LESHORT:
		if (OFFSET_OOB(nbytes, offset, 2))
 			return 0;
 		break;
 
  mget(struct magic_set *ms, const unsigned char *s, struct magic *m,
 	case FILE_FLOAT:
 	case FILE_BEFLOAT:
 	case FILE_LEFLOAT:
		if (OFFSET_OOB(nbytes, offset, 4))
 			return 0;
 		break;
 
 	case FILE_DOUBLE:
 	case FILE_BEDOUBLE:
 	case FILE_LEDOUBLE:
		if (OFFSET_OOB(nbytes, offset, 8))
 			return 0;
 		break;
 
 	case FILE_STRING:
 	case FILE_PSTRING:
 	case FILE_SEARCH:
		if (OFFSET_OOB(nbytes, offset, m->vallen))
 			return 0;
 		break;
 
 	case FILE_REGEX:
		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		break;
 
 	case FILE_INDIRECT:
		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		sbuf = ms->o.buf;
 		soffset = ms->offset;
  mget(struct magic_set *ms, const unsigned char *s, struct magic *m,
 		return rv;
 
 	case FILE_USE:
		if (OFFSET_OOB(nbytes, offset, 0))
 			return 0;
 		sbuf = m->value.s;
 		if (*sbuf == '^') {",softmagic.c in file before 5.17 and libmagic allows context-dependent attackers to cause a denial of service (out-of-bounds memory access and crash) via crafted offsets in the softmagic of a PE executable.
398,CVE-2014-2209," 
 #include <sys/prctl.h>
 #include <sys/types.h>
 #include <pwd.h>
#include <grp.h>
 
 namespace HPHP {
  
  bool Capability::ChangeUnixUser(uid_t uid) {
       return false;
     }
 
    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {
      Logger::Error(""unable to drop supplementary group privs: %s"",
                    folly::errnoStr(errno).c_str());
      return false;
    }

     if (pw->pw_gid == 0 || setgid(pw->pw_gid) < 0) {
       Logger::Error(""unable to drop gid privs: %s"",
                     folly::errnoStr(errno).c_str());","Facebook HipHop Virtual Machine (HHVM) before 3.1.0 does not drop supplemental group memberships within hphp/util/capability.cpp and hphp/util/light-process.cpp, which allows remote attackers to bypass intended access restrictions by leveraging group permissions for a file or directory."
399,CVE-2014-2208,"  namespace HPHP {
  
  
 
 Mutex LightProcess::s_mutex;
 
 static bool send_fd(int afdt_fd, int fd) {
   afdt_error_t err;
   errno = 0;
  static void close_fds(const std::vector<int> &fds) {
   }
 }
 
static void lwp_write(FILE *fout, const std::string &buf) {
  size_t len = buf.length();
  fwrite(&len, sizeof(len), 1, fout);
  fwrite(buf.c_str(), sizeof(buf[0]), len, fout);
  fflush(fout);
}

static void lwp_write_int32(FILE *fout, int32_t d) {
  fwrite(&d, sizeof(d), 1, fout);
  fflush(fout);
}

static void lwp_write_int64(FILE *fout, int64_t d) {
  fwrite(&d, sizeof(d), 1, fout);
  fflush(fout);
}

static void lwp_read(FILE *fin, std::string &buf) {
  size_t len;
  fread(&len, sizeof(len), 1, fin);
  char *buffer = (char *)malloc(len + 1);
  fread(buffer, sizeof(*buffer), len, fin);
  buffer[len] = '\0';
  buf = std::string(buffer);
  free(buffer);
}

static void lwp_read_int32(FILE *fin, int32_t &d) {
  fread(&d, sizeof(d), 1, fin);
}

static void lwp_read_int64(FILE *fin, int64_t &d) {
  fread(&d, sizeof(d), 1, fin);
}

  
  
 
 static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {
  std::string buf;
  std::string cwd;
 
  lwp_read(fin, buf);
   bool read_only = (buf[0] == 'r');
 
  lwp_read(fin, buf);
 
   std::string old_cwd = Process::GetCurrentDirectory();
  lwp_read(fin, cwd);

   if (old_cwd != cwd) {
    if (chdir(cwd.c_str())) {
        
        
      Logger::Warning(""Light Process failed chdir to %s."", cwd.c_str());
     }
   }
 
  FILE *f = buf[0] ? ::popen(buf.c_str(), read_only ? ""r"" : ""w"") : nullptr;
 
   if (old_cwd != cwd && chdir(old_cwd.c_str())) {
      
  static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {
   if (f == nullptr) {
     Logger::Error(""Light process failed popen: %d (%s)."", errno,
                   folly::errnoStr(errno).c_str());
    lwp_write(fout, ""error"");
   } else {
    lwp_write(fout, ""success"");
    lwp_write_int64(fout, (int64_t)f);
     int fd = fileno(f);
     send_fd(afdt_fd, fd);
   }
 }
 
 static void do_pclose(FILE *fin, FILE *fout) {
   int64_t fptr = 0;
  lwp_read_int64(fin, fptr);
   FILE *f = (FILE *)fptr;
   int ret = ::pclose(f);
 
  lwp_write_int32(fout, ret);
   if (ret < 0) {
    lwp_write_int32(fout, errno);
   }
   fflush(fout);
 }
 
 static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {
  std::string cmd;
  lwp_read(fin, cmd);
 
  std::string cwd;
  lwp_read(fin, cwd);
 
  std::string buf;
   int env_size = 0;
   std::vector<std::string> env;
  lwp_read_int32(fin, env_size);
   for (int i = 0; i < env_size; i++) {
    lwp_read(fin, buf);
     env.push_back(buf);
   }
 
   int pipe_size = 0;
  lwp_read_int32(fin, pipe_size);
   std::vector<int> pvals;
   for (int i = 0; i < pipe_size; i++) {
     int fd_value;
    lwp_read_int32(fin, fd_value);
     pvals.push_back(fd_value);
   }
 
   std::vector<int> pkeys;
   for (int i = 0; i < pipe_size; i++) {
     int fd = recv_fd(afdt_fd);
     if (fd < 0) {
      lwp_write(fout, ""error"");
      lwp_write_int32(fout, EPROTO);
       fflush(fout);
       close_fds(pkeys);
       return;
     }
     pkeys.push_back(fd);
   }
 
   
  if (cmd.length() == 0) {
    lwp_write(fout, ""error"");
    lwp_write_int32(fout, ENOENT);
    return;
  }

    
   pid_t child = fork();
   if (child == 0) {
     for (int i = 0; i < pipe_size; i++) {
       dup2(pkeys[i], pvals[i]);
     }
    if (cwd.length() > 0 && chdir(cwd.c_str())) {
        
        
     }
     if (!env.empty()) {
       char **envp = build_envp(env);
      execle(""/bin/sh"", ""sh"", ""-c"", cmd.c_str(), nullptr, envp);
       free(envp);
     } else {
      execl(""/bin/sh"", ""sh"", ""-c"", cmd.c_str(), nullptr);
     }
     _exit(127);
   } else if (child > 0) {
      
    lwp_write(fout, ""success"");
    lwp_write_int64(fout, (int64_t)child);
     fflush(fout);
   } else {
      
    lwp_write(fout, ""error"");
    lwp_write_int32(fout, errno);
     fflush(fout);
   }
 
  static void kill_handler(int sig) {
 }
 
 static void do_waitpid(FILE *fin, FILE *fout) {
   int64_t p = -1;
   int options = 0;
   int timeout = 0;
  lwp_read_int64(fin, p);
  lwp_read_int32(fin, options);
  lwp_read_int32(fin, timeout);

   pid_t pid = (pid_t)p;
   int stat;
   if (timeout > 0) {
     waited = pid;
     signal(SIGALRM, kill_handler);
     alarm(timeout);
   }

   pid_t ret = ::waitpid(pid, &stat, options);
   alarm(0);  
   waited = 0;
  lwp_write_int64(fout, ret);
  lwp_write_int32(fout, stat);
   if (ret < 0) {
    lwp_write_int32(fout, errno);
   }
   fflush(fout);
 }
 
 static void do_change_user(FILE *fin, FILE *fout) {
  std::string uname;
  lwp_read(fin, uname);
  if (uname.length() > 0) {
    struct passwd *pw = getpwnam(uname.c_str());
     if (pw) {
       if (pw->pw_gid) {
         setgid(pw->pw_gid);
  void LightProcess::Close() {
 void LightProcess::closeShadow() {
   Lock lock(m_procMutex);
   if (m_shadowProcess) {
    lwp_write(m_fout, ""exit"");
     fflush(m_fout);
     fclose(m_fin);
     fclose(m_fout);
  void LightProcess::runShadow(int fdin, int fdout) {
   FILE *fin = fdopen(fdin, ""r"");
   FILE *fout = fdopen(fdout, ""w"");
 
  std::string buf;
 
   pollfd pfd[1];
   pfd[0].fd = fdin;
  void LightProcess::runShadow(int fdin, int fdout) {
       continue;
     }
     if (pfd[0].revents & POLLIN) {
      lwp_read(fin, buf);
      if (buf == ""exit"") {
         Logger::Info(""LightProcess exiting upon request"");
         break;
      } else if (buf == ""popen"") {
         do_popen(fin, fout, m_afdt_fd);
      } else if (buf == ""pclose"") {
         do_pclose(fin, fout);
      } else if (buf == ""proc_open"") {
         do_proc_open(fin, fout, m_afdt_fd);
      } else if (buf == ""waitpid"") {
         do_waitpid(fin, fout);
      } else if (buf == ""change_user"") {
         do_change_user(fin, fout);
       } else if (buf[0]) {
        Logger::Info(""LightProcess got invalid command: %.20s"", buf.c_str());
       }
     } else if (pfd[0].revents & POLLHUP) {
        
  FILE *LightProcess::LightPopenImpl(const char *cmd, const char *type,
   int id = GetId();
   Lock lock(g_procs[id].m_procMutex);
 
  FILE *fout = g_procs[id].m_fout;
  lwp_write(fout, ""popen"");
  lwp_write(fout, type);
  lwp_write(fout, cmd);
  lwp_write(fout, cwd ? cwd : """");
  fflush(fout);
 
  std::string buf;
  FILE *fin = g_procs[id].m_fin;
  lwp_read(fin, buf);
  if (buf == ""error"") {
     return nullptr;
   }
 
   int64_t fptr = 0;
  lwp_read_int64(fin, fptr);
   if (!fptr) {
     Logger::Error(""Light process failed to return the file pointer."");
     return nullptr;
  int LightProcess::pclose(FILE *f) {
   int64_t f2 = it->second;
   g_procs[id].m_popenMap.erase((int64_t)f);
   fclose(f);
 
  lwp_write(g_procs[id].m_fout, ""pclose"");
  lwp_write_int64(g_procs[id].m_fout, f2);

   int ret = -1;
  lwp_read_int32(g_procs[id].m_fin, ret);
   if (ret < 0) {
    lwp_read_int32(g_procs[id].m_fin, errno);
   }
   return ret;
 }
  pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,
   always_assert(Available());
   always_assert(created.size() == desired.size());
 
  FILE *fout = g_procs[id].m_fout;
  lwp_write(fout, ""proc_open"");
  lwp_write(fout, cmd);
  lwp_write(fout, cwd ? cwd : """");
  lwp_write_int32(fout, (int)env.size());
   for (unsigned int i = 0; i < env.size(); i++) {
    lwp_write(fout, env[i]);
   }
 
  lwp_write_int32(fout, (int)created.size());
   for (unsigned int i = 0; i < desired.size(); i++) {
    lwp_write_int32(fout, desired[i]);
   }
  fflush(fout);

   bool error_send = false;
   int save_errno = 0;
   for (unsigned int i = 0; i < created.size(); i++) {
  pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,
     }
   }
 
  std::string buf;
  FILE *fin = g_procs[id].m_fin;
  lwp_read(fin, buf);
  if (buf == ""error"") {
    lwp_read_int32(fin, errno);
     if (error_send) {
        
        
       errno = save_errno;
     }
     return -1;
   }
  always_assert(buf == ""success"");
   int64_t pid = -1;
  lwp_read_int64(fin, pid);
  always_assert(pid);
   return (pid_t)pid;
 }
 
  pid_t LightProcess::waitpid(pid_t pid, int *stat_loc, int options,
   int id = GetId();
   Lock lock(g_procs[id].m_procMutex);
 
  FILE *fout = g_procs[id].m_fout;
  lwp_write(fout, ""waitpid"");
  lwp_write_int64(fout, (int64_t)pid);
  lwp_write_int32(fout, options);
  lwp_write_int32(fout, timeout);
   fflush(g_procs[id].m_fout);
 
   int64_t ret;
   int stat;
  FILE *fin = g_procs[id].m_fin;
  lwp_read_int64(fin, ret);
  lwp_read_int32(fin, stat);

   *stat_loc = stat;
   if (ret < 0) {
    lwp_read_int32(fin, errno);
   }
   return (pid_t)ret;
 }
  void LightProcess::ChangeUser(const std::string &username) {
   if (username.empty()) return;
   for (int i = 0; i < g_procsCount; i++) {
     Lock lock(g_procs[i].m_procMutex);
    FILE *fout = g_procs[i].m_fout;
    lwp_write(fout, ""change_user"");
    lwp_write(fout, username);
    fflush(fout);
   }
 }
 ",CRLF injection vulnerability in the LightProcess protocol implementation in hphp/util/light-process.cpp in Facebook HipHop Virtual Machine (HHVM) before 2.4.2 allows remote attackers to execute arbitrary commands by entering a n (newline) character before the end of a string.
400,CVE-2014-2038,"  static bool nfs_write_pageuptodate(struct page *page, struct inode *inode)
  * extend the write to cover the entire page in order to avoid fragmentation
  * inefficiencies.
  *
 * If the file is opened for synchronous writes then we can just skip the rest
 * of the checks.
  */
 static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)
 {
 	if (file->f_flags & O_DSYNC)
 		return 0;
	if (!nfs_write_pageuptodate(page, inode))
		return 0;
 	if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))
 		return 1;
	if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&
 			inode->i_flock->fl_end == OFFSET_MAX &&
			inode->i_flock->fl_type != F_RDLCK))
 		return 1;
 	return 0;
 }","The nfs_can_extend_write function in fs/nfs/write.c in the Linux kernel before 3.13.3 relies on a write delegation to extend a write operation without a certain up-to-date verification, which allows local users to obtain sensitive information from kernel memory in opportunistic circumstances by writing to a file in an NFS filesystem and then reading the same file."
401,CVE-2014-1874,"  static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 	struct context context;
 	int rc = 0;
 
	 
	if (!scontext_len)
		return -EINVAL;

 	if (!ss_initialized) {
 		int i;
 ",The security_context_to_sid_core function in security/selinux/ss/services.c in the Linux kernel before 3.13.4 allows local users to cause a denial of service (system crash) by leveraging the CAP_MAC_ADMIN capability to set a zero-length security context.
402,CVE-2014-1739,"  static long media_device_enum_entities(struct media_device *mdev,
 	struct media_entity *ent;
 	struct media_entity_desc u_ent;
 
	memset(&u_ent, 0, sizeof(u_ent));
 	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
 		return -EFAULT;
 ","The media_device_enum_entities function in drivers/media/media-device.c in the Linux kernel before 3.14.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging /dev/media0 read access for a MEDIA_IOC_ENUM_ENTITIES ioctl call."
403,CVE-2014-1738,"  static int raw_cmd_copyout(int cmd, void __user *param,
 	int ret;
 
 	while (ptr) {
		struct floppy_raw_cmd cmd = *ptr;
		cmd.next = NULL;
		cmd.kernel_data = NULL;
		ret = copy_to_user(param, &cmd, sizeof(cmd));
 		if (ret)
 			return -EFAULT;
 		param += sizeof(struct floppy_raw_cmd);","The raw_cmd_copyout function in drivers/block/floppy.c in the Linux kernel through 3.14.3 does not properly restrict access to certain pointers during processing of an FDRAWCMD ioctl call, which allows local users to obtain sensitive information from kernel heap memory by leveraging write access to a /dev/fd device."
404,CVE-2014-1737,"  static int raw_cmd_copyin(int cmd, void __user *param,
 		return -ENOMEM;
 	*rcmd = ptr;
 	ret = copy_from_user(ptr, param, sizeof(*ptr));
 	ptr->next = NULL;
 	ptr->buffer_length = 0;
	ptr->kernel_data = NULL;
	if (ret)
		return -EFAULT;
 	param += sizeof(struct floppy_raw_cmd);
 	if (ptr->cmd_count > 33)
 			/* the command may now also take up the space
  static int raw_cmd_copyin(int cmd, void __user *param,
 	for (i = 0; i < 16; i++)
 		ptr->reply[i] = 0;
 	ptr->resultcode = 0;
 
 	if (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
 		if (ptr->length <= 0)","The raw_cmd_copyin function in drivers/block/floppy.c in the Linux kernel through 3.14.3 does not properly handle error conditions during processing of an FDRAWCMD ioctl call, which allows local users to trigger kfree operations and gain privileges by leveraging write access to a /dev/fd device."
405,CVE-2014-1690,"  static unsigned int help(struct sk_buff *skb,
 			 struct nf_conntrack_expect *exp)
 {
 	char buffer[sizeof(""4294967296 65635"")];
	struct nf_conn *ct = exp->master;
	union nf_inet_addr newaddr;
 	u_int16_t port;
 	unsigned int ret;
 
 	 
	newaddr = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3;

 	exp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;
 	exp->dir = IP_CT_DIR_REPLY;
 	exp->expectfn = nf_nat_follow_master;
  static unsigned int help(struct sk_buff *skb,
 	}
 
 	if (port == 0) {
		nf_ct_helper_log(skb, ct, ""all ports in use"");
 		return NF_DROP;
 	}
 
	 
	 
	snprintf(buffer, sizeof(buffer), ""%u %u"", ntohl(newaddr.ip), port);
	pr_debug(""nf_nat_irc: inserting '%s' == %pI4, port %u\n"",
		 buffer, &newaddr.ip, port);

	ret = nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff, matchoff,
				       matchlen, buffer, strlen(buffer));
 	if (ret != NF_ACCEPT) {
		nf_ct_helper_log(skb, ct, ""cannot mangle packet"");
 		nf_ct_unexpect_related(exp);
 	}

 	return ret;
 }
 ",The help function in net/netfilter/nf_nat_irc.c in the Linux kernel before 3.12.8 allows remote attackers to obtain sensitive information from kernel memory by establishing an IRC DCC session in which incorrect packet data is transmitted during use of the NAT mangle feature.
406,CVE-2014-1446,"  static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		break;
 
 	case SIOCYAMGCFG:
		memset(&yi, 0, sizeof(yi));
 		yi.cfg.mask = 0xffffffff;
 		yi.cfg.iobase = yp->iobase;
 		yi.cfg.irq = yp->irq;","The yam_ioctl function in drivers/net/hamradio/yam.c in the Linux kernel before 3.12.8 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability for an SIOCYAMGCFG ioctl call."
407,CVE-2014-1445,"  static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 			ifr->ifr_settings.size = size;  
 			return -ENOBUFS;
 		}
		memset(&line, 0, sizeof(line));
 		line.clock_type = get_status(port)->clocking;
 		line.clock_rate = 0;
 		line.loopback = 0;","The wanxl_ioctl function in drivers/net/wan/wanxl.c in the Linux kernel before 3.11.7 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via an ioctl call."
408,CVE-2014-1444,"  fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,
 	}
 
 	i = port->index;
	memset(&sync, 0, sizeof(sync));
 	sync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);
 	 
 	sync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==","The fst_get_iface function in drivers/net/wan/farsync.c in the Linux kernel before 3.11.7 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability for an SIOCWANDEV ioctl call."
409,CVE-2014-1439,"  void c_LibXMLError::t___construct() {
  
  
 
static xmlParserInputBufferPtr
hphp_libxml_input_buffer(const char *URI, xmlCharEncoding enc);

 class xmlErrorVec : public std::vector<xmlError> {
 public:
   ~xmlErrorVec() {
  class LibXmlErrors : public RequestEventHandler {
   virtual void requestInit() {
     m_use_error = false;
     m_errors.reset();
    m_entity_loader_disabled = false;
    xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer);
   }
   virtual void requestShutdown() {
     m_use_error = false;
     m_errors.reset();
   }
 
  bool m_entity_loader_disabled;
   bool m_use_error;
   xmlErrorVec m_errors;
 };
  bool f_libxml_use_internal_errors(CVarRef use_errors  ) {
 }
 
 static xmlParserInputBufferPtr
hphp_libxml_input_buffer(const char *URI, xmlCharEncoding enc) {
  if (s_libxml_errors->m_entity_loader_disabled) {
    return nullptr;
  }
  return __xmlParserInputBufferCreateFilename(URI, enc);
 }
 
 bool f_libxml_disable_entity_loader(bool disable  ) {
  bool old = s_libxml_errors->m_entity_loader_disabled;
 
  s_libxml_errors->m_entity_loader_disabled = disable;

  return old;
 }
 
  ","The libxml_disable_entity_loader function in runtime/ext/ext_simplexml.cpp in HipHop Virtual Machine for PHP (HHVM) before 2.4.0 and 2.3.x before 2.3.3 does not properly disable a certain libxml handler, which allows remote attackers to conduct XML External Entity (XXE) attacks."
410,CVE-2014-1438,"  static inline int restore_fpu_checking(struct task_struct *tsk)
 	 
	if (unlikely(static_cpu_has(X86_FEATURE_FXSAVE_LEAK))) {
		asm volatile(
			""fnclex\n\t""
			""emms\n\t""
			""fildl %P[addr]""	 
			: : [addr] ""m"" (tsk->thread.fpu.has_fpu));
	}
 
 	return fpu_restore_checking(&tsk->thread.fpu);
 }","The restore_fpu_checking function in arch/x86/include/asm/fpu-internal.h in the Linux kernel before 3.12.8 on the AMD K7 and K8 platforms does not clear pending exceptions before proceeding to an EMMS instruction, which allows local users to cause a denial of service (task kill) or possibly gain privileges via a crafted application."
411,CVE-2014-0791,"  BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)
 
 	Stream_Read_UINT32(s, scopeCount);  
 
        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)
                return FALSE;   

 	scopeList->count = scopeCount;
 	scopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);
 ",Integer overflow in the license_read_scope_list function in libfreerdp/core/license.c in FreeRDP through 1.0.2 allows remote RDP servers to cause a denial of service (application crash) or possibly have unspecified other impact via a large ScopeCount value in a Scope List in a Server License Request packet.
412,CVE-2014-0749,"  int disrsi_(
   if (dis_umaxd == 0)
     disiui_();
 
  if (count >= dis_umaxd)
    {
    if (count > dis_umaxd)
      goto overflow;

    if (memcmp(scratch, dis_umax, dis_umaxd) > 0)
      goto overflow;
    }

   switch (c = (*dis_getc)(stream))
     {
 ",Stack-based buffer overflow in lib/Libdis/disrsi_.c in Terascale Open-Source Resource and Queue Manager (aka TORQUE Resource Manager) 2.5.x through 2.5.13 allows remote attackers to execute arbitrary code via a large count value.
413,CVE-2014-0238," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.59 2014/05/14 23:22:48 christos Exp $"")
 #endif
 
 #include <assert.h>
  cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
 		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
 		if (inp[i].pi_type & CDF_VECTOR) {
 			nelements = CDF_GETUINT32(q, 1);
			if (nelements == 0) {
				DPRINTF((""CDF_VECTOR with nelements == 0\n""));
				goto out;
			}
 			o = 2;
 		} else {
 			nelements = 1;
  cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
 			}
 			DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"",
 			    nelements));
			for (j = 0; j < nelements && i < sh.sh_properties;
			    j++, i++)
			{
 				uint32_t l = CDF_GETUINT32(q, o);
 				inp[i].pi_str.s_len = l;
 				inp[i].pi_str.s_buf = (const char *)",The cdf_read_property_info function in cdf.c in the Fileinfo component in PHP before 5.4.29 and 5.5.x before 5.5.13 allows remote attackers to cause a denial of service (infinite loop or out-of-bounds memory access) via a vector that (1) has zero length or (2) is too long.
414,CVE-2014-0237," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.56 2014/05/05 16:11:21 christos Exp $"")
 #endif
 
 #include <assert.h>
  int
 cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,
     cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)
 {
	size_t maxcount;
 	const cdf_summary_info_header_t *si =
 	    CAST(const cdf_summary_info_header_t *, sst->sst_tab);
 	const cdf_section_declaration_t *sd =
  cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,
 	ssi->si_os = CDF_TOLE2(si->si_os);
 	ssi->si_class = si->si_class;
 	cdf_swap_class(&ssi->si_class);
	ssi->si_count = CDF_TOLE4(si->si_count);
 	*count = 0;
 	maxcount = 0;
 	*info = NULL;
	if (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,
	    count, &maxcount) == -1)
		return -1;
 	return 0;
 }
 ",The cdf_unpack_summary_info function in cdf.c in the Fileinfo component in PHP before 5.4.29 and 5.5.x before 5.5.13 allows remote attackers to cause a denial of service (performance degradation) by triggering many file_printf calls.
415,CVE-2014-0207," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.55 2014/02/27 23:26:17 christos Exp $"")
 #endif
 
 #include <assert.h>
  cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,
 	size_t ss = CDF_SHORT_SEC_SIZE(h);
 	size_t pos = CDF_SHORT_SEC_POS(h, id);
 	assert(ss == len);
	if (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {
 		DPRINTF((""Out of bounds read %"" SIZE_T_FORMAT ""u > %""
 		    SIZE_T_FORMAT ""u\n"",
		    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));
 		return -1;
 	}
 	(void)memcpy(((char *)buf) + offs,","The cdf_read_short_sector function in cdf.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted CDF file."
416,CVE-2014-0206,"  static long aio_read_events_ring(struct kioctx *ctx,
 	if (head == tail)
 		goto out;
 
	head %= ctx->nr_events;
	tail %= ctx->nr_events;

 	while (ret < nr) {
 		long avail;
 		struct io_event *ev;",Array index error in the aio_read_events_ring function in fs/aio.c in the Linux kernel through 3.15.1 allows local users to obtain sensitive information from kernel memory via a large head value.
417,CVE-2014-0205,"  static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)
 {
 	struct futex_hash_bucket *hb;
 
 	hb = hash_futex(&q->key);
 	q->lock_ptr = &hb->lock;
 
  static inline void
 queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
 {
 	spin_unlock(&hb->lock);
 }
 
  
	 
 	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);
 	if (ret)
 		goto out;
  static int futex_wait(u32 __user *uaddr, int fshared,
 
 	 
 	ret = 0;
	 
 	if (!unqueue_me(&q))
		goto out;
 	ret = -ETIMEDOUT;
 	if (to && !to->task)
		goto out;
 
 	 
	if (!signal_pending(current))
 		goto retry;
 
 	ret = -ERESTARTSYS;
 	if (!abs_time)
		goto out;
 
 	restart = &current_thread_info()->restart_block;
 	restart->fn = futex_wait_restart;
  static int futex_wait(u32 __user *uaddr, int fshared,
 
 	ret = -ERESTART_RESTARTBLOCK;
 
 out:
 	if (to) {
 		hrtimer_cancel(&to->timer);
  static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,
 	q.rt_waiter = &rt_waiter;
 	q.requeue_pi_key = &key2;
 
	 
 	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);
 	if (ret)
 		goto out_key2;
  static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,
 	 * In order for us to be here, we know our q.key == key2, and since
 	 * we took the hb->lock above, we also know that futex_requeue() has
 	 * completed and we no longer have to concern ourselves with a wakeup
	 * race with the atomic proxy lock acquisition by the requeue code. The
	 * futex_requeue dropped our key1 reference and incremented our key2
	 * reference count.
 	 */
 
 	 ","The futex_wait function in kernel/futex.c in the Linux kernel before 2.6.37 does not properly maintain a certain reference count during requeue operations, which allows local users to cause a denial of service (use-after-free and system crash) or possibly gain privileges via a crafted application that triggers a zero count."
418,CVE-2014-0203,"  static __always_inline int __do_follow_link(struct path *path, struct nameidata
 		dget(dentry);
 	}
 	mntget(path->mnt);
	nd->last_type = LAST_BIND;
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {","The __do_follow_link function in fs/namei.c in the Linux kernel before 2.6.33 does not properly handle the last pathname component during use of certain filesystems, which allows local users to cause a denial of service (incorrect free operations and system crash) via an open system call."
419,CVE-2014-0196,"  static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
 			if (tty->ops->flush_chars)
 				tty->ops->flush_chars(tty);
 		} else {
			struct n_tty_data *ldata = tty->disc_data;

 			while (nr > 0) {
				mutex_lock(&ldata->output_lock);
 				c = tty->ops->write(tty, b, nr);
				mutex_unlock(&ldata->output_lock);
 				if (c < 0) {
 					retval = c;
 					goto break_out;","The n_tty_write function in drivers/tty/n_tty.c in the Linux kernel through 3.14.3 does not properly manage tty driver access in the *LECHO & !OPOST* case, which allows local users to cause a denial of service (memory corruption and system crash) or gain privileges by triggering a race condition involving read and write operations with long strings."
420,CVE-2014-0131,"  struct sk_buff *skb_segment(struct sk_buff *head_skb,
 	skb_frag_t *frag = skb_shinfo(head_skb)->frags;
 	unsigned int mss = skb_shinfo(head_skb)->gso_size;
 	unsigned int doffset = head_skb->data - skb_mac_header(head_skb);
	struct sk_buff *frag_skb = head_skb;
 	unsigned int offset = doffset;
 	unsigned int tnl_hlen = skb_tnl_header_len(head_skb);
 	unsigned int headroom;
  struct sk_buff *skb_segment(struct sk_buff *head_skb,
 			i = 0;
 			nfrags = skb_shinfo(list_skb)->nr_frags;
 			frag = skb_shinfo(list_skb)->frags;
			frag_skb = list_skb;
 			pos += skb_headlen(list_skb);
 
 			while (pos < offset + len) {
  struct sk_buff *skb_segment(struct sk_buff *head_skb,
 				i = 0;
 				nfrags = skb_shinfo(list_skb)->nr_frags;
 				frag = skb_shinfo(list_skb)->frags;
				frag_skb = list_skb;
 
 				BUG_ON(!nfrags);
 
  struct sk_buff *skb_segment(struct sk_buff *head_skb,
 				goto err;
 			}
 
			if (unlikely(skb_orphan_frags(frag_skb, GFP_ATOMIC)))
				goto err;

 			*nskb_frag = *frag;
 			__skb_frag_ref(nskb_frag);
 			size = skb_frag_size(nskb_frag);",Use-after-free vulnerability in the skb_segment function in net/core/skbuff.c in the Linux kernel through 3.13.6 allows attackers to obtain sensitive information from kernel memory by leveraging the absence of a certain orphaning operation.
421,CVE-2014-0101,"  sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,
 		struct sctp_chunk auth;
 		sctp_ierror_t ret;
 
		 
		if (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {
			kfree_skb(chunk->auth_chunk);
			sctp_association_free(new_asoc);
			return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);
		}

 		 
 		auth.skb = chunk->auth_chunk;
 		auth.asoc = chunk->asoc;","The sctp_sf_do_5_1D_ce function in net/sctp/sm_statefuns.c in the Linux kernel through 3.13.6 does not validate certain auth_enable and auth_capable fields before making an sctp_sf_authenticate call, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via an SCTP handshake with a modified INIT chunk and a crafted AUTH chunk before a COOKIE_ECHO chunk."
422,CVE-2014-0077,"  static int get_rx_bufs(struct vhost_virtqueue *vq,
 	*iovcount = seg;
 	if (unlikely(log))
 		*log_num = nlogs;

	 
	if (unlikely(datalen > 0)) {
		r = UIO_MAXIOV + 1;
		goto err;
	}
 	return headcount;
 err:
 	vhost_discard_vq_desc(vq, headcount);
  static void handle_rx(struct vhost_net *net)
 		 
 		if (unlikely(headcount < 0))
 			break;
		 
		if (unlikely(headcount > UIO_MAXIOV)) {
			msg.msg_iovlen = 1;
			err = sock->ops->recvmsg(NULL, sock, &msg,
						 1, MSG_DONTWAIT | MSG_TRUNC);
			pr_debug(""Discarded rx packet: len %zd\n"", sock_len);
			continue;
		}
 		 
 		if (!headcount) {
 			if (unlikely(vhost_enable_notify(&net->dev, vq))) {","drivers/vhost/net.c in the Linux kernel before 3.13.10, when mergeable buffers are disabled, does not properly validate packet lengths, which allows guest OS users to cause a denial of service (memory corruption and host OS crash) or possibly gain privileges on the host OS via crafted packets, related to the handle_rx and get_rx_bufs functions."
423,CVE-2014-0069,"  cifs_iovec_write(struct file *file, const struct iovec *iov,
 		 unsigned long nr_segs, loff_t *poffset)
 {
 	unsigned long nr_pages, i;
	size_t bytes, copied, len, cur_len;
 	ssize_t total_written = 0;
 	loff_t offset;
 	struct iov_iter it;
  cifs_iovec_write(struct file *file, const struct iovec *iov,
 
 		save_len = cur_len;
 		for (i = 0; i < nr_pages; i++) {
			bytes = min_t(const size_t, cur_len, PAGE_SIZE);
 			copied = iov_iter_copy_from_user(wdata->pages[i], &it,
							 0, bytes);
 			cur_len -= copied;
 			iov_iter_advance(&it, copied);
			 
			if (copied < bytes)
				break;
 		}
 		cur_len = save_len - cur_len;
 
		 
		if (!cur_len) {
			for (i = 0; i < nr_pages; i++)
				put_page(wdata->pages[i]);
			kfree(wdata);
			rc = -EFAULT;
			break;
		}

		 
		for ( ; nr_pages > i + 1; nr_pages--)
			put_page(wdata->pages[nr_pages - 1]);

 		wdata->sync_mode = WB_SYNC_ALL;
 		wdata->nr_pages = nr_pages;
 		wdata->offset = (__u64)offset;","The cifs_iovec_write function in fs/cifs/file.c in the Linux kernel through 3.13.5 does not properly handle uncached write operations that copy fewer than the requested number of bytes, which allows local users to obtain sensitive information from kernel memory, cause a denial of service (memory corruption and system crash), or possibly gain privileges via a writev system call with a crafted pointer."
424,CVE-2014-0063,"  struct tzEntry;
 #define DTK_DATE_M		(DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))
 #define DTK_TIME_M		(DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)
 
 
#define MAXDATELEN		128
 
#define MAXDATEFIELDS	25
 
#define TOKMAXLEN		10
 
  
 typedef struct","Multiple stack-based buffer overflows in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to cause a denial of service (crash) or possibly execute arbitrary code via vectors related to an incorrect MAXDATELEN constant and datetime values involving (1) intervals, (2) timestamps, or (3) timezones, a different vulnerability than CVE-2014-0065."
425,CVE-2014-0049,"  static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
 		frag->len -= len;
 	}
 
	if (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {
 		vcpu->mmio_needed = 0;
 
 		 ",Buffer overflow in the complete_emulated_mmio function in arch/x86/kvm/x86.c in the Linux kernel before 3.13.6 allows guest OS users to execute arbitrary code on the host OS by leveraging a loop that triggers an invalid memory copy affecting certain cancel_work_item data.
426,CVE-2014-0038,"  asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,
 	if (flags & MSG_CMSG_COMPAT)
 		return -EINVAL;
 
 	if (timeout == NULL)
 		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 				      flags | MSG_CMSG_COMPAT, NULL);
 
	if (compat_get_timespec(&ktspec, timeout))
 		return -EFAULT;
 
 	datagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 				   flags | MSG_CMSG_COMPAT, &ktspec);
	if (datagrams > 0 && compat_put_timespec(&ktspec, timeout))
 		datagrams = -EFAULT;
 
 	return datagrams;","The compat_sys_recvmmsg function in net/compat.c in the Linux kernel before 3.13.2, when CONFIG_X86_X32 is enabled, allows local users to gain privileges via a recvmmsg system call with a crafted timeout pointer parameter."
427,CVE-2013-7348,"  static struct kioctx *ioctx_alloc(unsigned nr_events)
 err_cleanup:
 	aio_nr_sub(ctx->max_reqs);
 err:
 	free_percpu(ctx->cpu);
 	free_percpu(ctx->reqs.pcpu_count);
 	free_percpu(ctx->users.pcpu_count);",Double free vulnerability in the ioctx_alloc function in fs/aio.c in the Linux kernel before 3.12.4 allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via vectors involving an error condition in the aio_setup_ring function.
428,CVE-2013-7339,"  static int rds_ib_laddr_check(__be32 addr)
 	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);
 	 
	if (ret || !cm_id->device ||
	    cm_id->device->node_type != RDMA_NODE_IB_CA)
 		ret = -EADDRNOTAVAIL;
 
 	rdsdebug(""addr %pI4 ret %d node type %d\n"",",The rds_ib_laddr_check function in net/rds/ib.c in the Linux kernel before 3.12.8 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a bind system call for an RDS socket on a system that lacks RDS transports.
429,CVE-2013-7299,"  namespace tnt
                    break;
       }
 
      *headerdataPtr = '\0';
       return true;
     }
     else if (std::isspace(ch))
  namespace tnt
   void Messageheader::Parser::checkHeaderspace(unsigned chars) const
   {
     if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))
    {
      header.rawdata[sizeof(header.rawdata) - 1] = '\0';
       throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, ""header too large"");
    }
   }
 
   void Messageheader::Parser::reset()","framework/common/messageheaderparser.cpp in Tntnet before 2.2.1 allows remote attackers to obtain sensitive information via a header that ends in n instead of rn, which prevents a null terminator from being added and causes Tntnet to include headers from other requests."
430,CVE-2013-7294,"  static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,
 	}
 	reset_cur_state();
 	reset_globals();
 }
 
  
 	{
 		struct ikev2_ke *ke;
		char fromname[ADDRTOT_BUF];
		addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);

		if (!md->chain[ISAKMP_NEXT_v2KE]) {
			 
			if(md->chain[ISAKMP_NEXT_v2N]) {
				libreswan_log(""Received Notify(%d): %s"",
					md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,
					enum_name(&ikev2_notify_names,
						md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));
			}
			libreswan_log(
				""rejecting I1 from %s:%u, no KE payload present"",
				fromname, md->sender_port);
			return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
		}
 		ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;
 
 		st->st_oakley.group = lookup_group(ke->isak_group);
 		if (st->st_oakley.group == NULL) {
 			libreswan_log(
 				""rejecting I1 from %s:%u, invalid DH group=%u"",
 				fromname, md->sender_port,
 				ke->isak_group);
			return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
 		}
 	}
 
  static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,
 			release_md(ke->md);
 	}
 	reset_globals();
 }
 
 static stf_status ikev2_parent_inI1outR1_tail(
  static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,
 			release_md(dh->md);
 	}
 	reset_globals();
 }
 
 static void ikev2_padup_pre_encrypt(struct msg_digest *md,
  stf_status ikev2parent_inI2outR2(struct msg_digest *md)
 	 
 	if (!md->chain[ISAKMP_NEXT_v2E]) {
 		libreswan_log(""R2 state should receive an encrypted payload"");
		reset_globals();  
 		return STF_FATAL;
 	}
 
  static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,
 			release_md(dh->md);
 	}
 	reset_globals();
 }
 
 static stf_status ikev2_parent_inI2outR2_tail(",The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.
431,CVE-2013-7281,"  static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
 	if (saddr) {
 		saddr->family = AF_IEEE802154;
 		saddr->addr = mac_cb(skb)->sa;
 		*addr_len = sizeof(*saddr);
	}
 
 	if (flags & MSG_TRUNC)
 		copied = skb->len;","The dgram_recvmsg function in net/ieee802154/dgram.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel stack memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
432,CVE-2013-7271,"  static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;","The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
433,CVE-2013-7262,"  int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char
   if (!lp || !timestring || !timefield)
     return MS_FALSE;
 
  if( strchr(timestring,'\'') || strchr(timestring, '\\') ) {
     msSetError(MS_MISCERR, ""Invalid time filter."", ""msPostGISLayerSetTimeFilter()"");
     return MS_FALSE;
  }

    
   if (strstr(timestring, "","") == NULL &&
       strstr(timestring, ""/"") == NULL) {  ","SQL injection vulnerability in the msPostGISLayerSetTimeFilter function in mappostgis.c in MapServer before 6.4.1, when a WMS-Time service is used, allows remote attackers to execute arbitrary SQL commands via a crafted string in a PostGIS TIME filter."
434,CVE-2013-5705,"  apr_status_t modsecurity_tx_init(modsec_rec *msr) {
     if (msr->request_content_length == -1) {
          
         char *transfer_encoding = (char *)apr_table_get(msr->request_headers, ""Transfer-Encoding"");
        if ((transfer_encoding != NULL)&&(m_strcasestr(transfer_encoding, ""chunked"") != NULL)) {
             msr->reqbody_should_exist = 1;
             msr->reqbody_chunked = 1;
         }",apache2/modsecurity.c in ModSecurity before 2.7.6 allows remote attackers to bypass rules by using chunked transfer coding with a capitalized Chunked value in the Transfer-Encoding HTTP header.
435,CVE-2013-2182,"  int _mkp_stage_30(struct plugin *p,
     (void) cs;
 
     PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);

    if (mk_security_check_url(sr->uri_processed) < 0) {
         PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
         return MK_PLUGIN_RET_CLOSE_CONX;","The Mandril security plugin in Monkey HTTP Daemon (monkeyd) before 1.5.0 allows remote attackers to bypass access restrictions via a crafted URI, as demonstrated by an encoded forward slash."
436,CVE-2013-2130,"  class CWebAdminMod : public CModule {
 			CIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);
 
 			 
			if (!spSession->IsAdmin() && (!spSession->GetUser() || !pNetwork || spSession->GetUser() != pNetwork->GetUser())) {
 				return false;
 			}
 
  class CWebAdminMod : public CModule {
 			CIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);
 
 			 
			if (!spSession->IsAdmin() && (!spSession->GetUser() || !pNetwork || spSession->GetUser() != pNetwork->GetUser())) {
 				return false;
 			}
 
  class CWebAdminMod : public CModule {
 			CIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);
 
 			 
			if (!spSession->IsAdmin() && (!spSession->GetUser() || !pNetwork || spSession->GetUser() != pNetwork->GetUser())) {
 				return false;
 			}
 
  class CWebAdminMod : public CModule {
 			CIRCNetwork* pNetwork = SafeGetNetworkFromParam(WebSock);
 
 			 
			if (!spSession->IsAdmin() && (!spSession->GetUser() || !pNetwork || spSession->GetUser() != pNetwork->GetUser())) {
 				return false;
 			}
 ","ZNC 1.0 allows remote authenticated users to cause a denial of service (NULL pointer reference and crash) via a crafted request to the (1) editnetwork, (2) editchan, (3) addchan, or (4) delchan page in modules/webadmin.cpp."
437,CVE-2013-0250,"  static int init_nss_hash(struct crypto_instance *instance)
 	}
 
 	hash_param.type = siBuffer;
	hash_param.data = instance->private_key;
	hash_param.len = instance->private_key_len;
 
 	hash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);
 	if (hash_slot == NULL) {","The init_nss_hash function in exec/totemcrypto.c in Corosync 2.0 before 2.3 does not properly initialize the HMAC key, which allows remote attackers to cause a denial of service (crash) via a crafted packet."
438,CVE-2012-6657,"  int sock_setsockopt(struct socket *sock, int level, int optname,
 
 	case SO_KEEPALIVE:
 #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
 			tcp_set_keepalive(sk, valbool);
 #endif
 		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);","The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5.7 does not ensure that a keepalive action is associated with a stream socket, which allows local users to cause a denial of service (system crash) by leveraging the ability to create a raw socket."
439,CVE-2012-6647,"  int handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,
  * @uaddr2:	the pi futex we will take prior to returning to user-space
  *
  * The caller will wait on uaddr and will be requeued by futex_requeue() to
 * uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
 * on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
 * userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
 * without one, the pi logic would not know which task to boost/deboost, if
 * there was a need to.
  *
  * We call schedule in futex_wait_queue_me() when we enqueue and return there
  * via the following:
  static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 	struct futex_q q = futex_q_init;
 	int res, ret;
 
	if (uaddr == uaddr2)
		return -EINVAL;

 	if (!bitset)
 		return -EINVAL;
 ","The futex_wait_requeue_pi function in kernel/futex.c in the Linux kernel before 3.5.1 does not ensure that calls have two different futex addresses, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted FUTEX_WAIT_REQUEUE_PI command."
440,CVE-2012-6638,"  int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 			goto discard;
 
 		if (th->syn) {
			if (th->fin)
				goto discard;
 			if (icsk->icsk_af_ops->conn_request(sk, skb) < 0)
 				return 1;
 ","The tcp_rcv_state_process function in net/ipv4/tcp_input.c in the Linux kernel before 3.2.24 allows remote attackers to cause a denial of service (kernel resource consumption) via a flood of SYN+FIN TCP packets, a different vulnerability than CVE-2012-2663."
441,CVE-2011-3602,"  set_interface_var(const char *iface,
 	if (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))
 		return -1;
 
	 
	if (strstr(name, "".."") || strchr(name, '/'))
		return -1;

 	if (access(spath, F_OK) != 0)
 		return -1;
 ","Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files."
442,CVE-2011-3346,"  typedef struct SCSIDiskReq {
      
     uint64_t sector;
     uint32_t sector_count;
    uint32_t buflen;
     struct iovec iov;
     QEMUIOVector qiov;
     uint32_t status;
  struct SCSIDiskState
 };
 
 static int scsi_handle_rw_error(SCSIDiskReq *r, int error, int type);
static int scsi_disk_emulate_command(SCSIDiskReq *r);
 
 static void scsi_free_request(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
 
    if (r->iov.iov_base) {
        qemu_vfree(r->iov.iov_base);
    }
 }
 
  
  static void scsi_cancel_io(SCSIRequest *req)
 
 static uint32_t scsi_init_iovec(SCSIDiskReq *r)
 {
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    if (!r->iov.iov_base) {
        r->buflen = SCSI_DMA_BUF_SIZE;
        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);
    }
    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);
     qemu_iovec_init_external(&r->qiov, &r->iov, 1);
     return r->qiov.size / 512;
 }
  static void scsi_dma_restart_bh(void *opaque)
                 scsi_write_data(&r->req);
                 break;
             case SCSI_REQ_STATUS_RETRY_FLUSH:
                ret = scsi_disk_emulate_command(r);
                 if (ret == 0) {
                     scsi_req_complete(&r->req, GOOD);
                 }
  static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)
     return 0;
 }
 
static int scsi_disk_emulate_command(SCSIDiskReq *r)
 {
     SCSIRequest *req = &r->req;
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
     uint64_t nb_sectors;
    uint8_t *outbuf;
     int buflen = 0;
 
    if (!r->iov.iov_base) {
         
        if (req->cmd.xfer > 65536) {
            goto illegal_request;
        }
        r->buflen = MAX(4096, req->cmd.xfer);
        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);
    }

    outbuf = r->iov.iov_base;
     switch (req->cmd.buf[0]) {
     case TEST_UNIT_READY:
         if (s->tray_open || !bdrv_is_inserted(s->bs))
  static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
     int32_t len;
     uint8_t command;
     int rc;
 
     command = buf[0];
     DPRINTF(""Command: lun=%d tag=0x%x data=0x%02x"", req->lun, req->tag, buf[0]);
 
 #ifdef DEBUG_SCSI
  static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)
     case GET_CONFIGURATION:
     case SERVICE_ACTION_IN_16:
     case VERIFY_10:
        rc = scsi_disk_emulate_command(r);
         if (rc < 0) {
             return 0;
         }
  static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
     SCSIRequest *req;
 
     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
     return req;
 }
 ","Buffer overflow in hw/scsi-disk.c in the SCSI subsystem in QEMU before 0.15.2, as used by Xen, might allow local guest users with permission to access the CD-ROM to cause a denial of service (guest crash) via a crafted SAI READ CAPACITY SCSI command.  NOTE: this is only a vulnerability when root has manually modified certain permissions or ACLs."
443,CVE-2011-2909,"  static int do_devinfo_ioctl(struct comedi_device *dev,
 	 
 	devinfo.version_code = COMEDI_VERSION_CODE;
 	devinfo.n_subdevs = dev->n_subdevices;
	strlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);
	strlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);
 
 	if (read_subdev)
 		devinfo.read_subdevice = read_subdev - dev->subdevices;",The do_devinfo_ioctl function in drivers/staging/comedi/comedi_fops.c in the Linux kernel before 3.1 allows local users to obtain sensitive information from kernel memory via a copy of a short string.
444,CVE-2010-5313,"  EXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);
 
 static int handle_emulation_failure(struct kvm_vcpu *vcpu)
 {
	int r = EMULATE_DONE;

 	++vcpu->stat.insn_emulation_fail;
 	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
 	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
 }
 
 static bool reexecute_instruction(struct kvm_vcpu *vcpu, gva_t gva)","Race condition in arch/x86/kvm/x86.c in the Linux kernel before 2.6.38 allows L2 guest OS users to cause a denial of service (L1 guest OS crash) via a crafted instruction that triggers an L2 emulation failure report, a similar issue to CVE-2014-7842."
445,CVE-2015-8660,"  int ovl_setattr(struct dentry *dentry, struct iattr *attr)
 	if (err)
 		goto out;
 
	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

 		mutex_lock(&upperdentry->d_inode->i_mutex);
 		err = notify_change(upperdentry, attr, NULL);
 		mutex_unlock(&upperdentry->d_inode->i_mutex);
 	}
 	ovl_drop_write(dentry);
 out:","The ovl_setattr function in fs/overlayfs/inode.c in the Linux kernel through 4.3.3 attempts to merge distinct setattr operations, which allows local users to bypass intended access restrictions and modify the attributes of arbitrary overlay files via a crafted application."
446,CVE-2015-8569,"  static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,
 	struct pptp_opt *opt = &po->proto.pptp;
 	int error = 0;
 
	if (sockaddr_len < sizeof(struct sockaddr_pppox))
		return -EINVAL;

 	lock_sock(sk);
 
 	opt->src_addr = sp->sa_addr.pptp;
  static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,
 	struct flowi4 fl4;
 	int error = 0;
 
	if (sockaddr_len < sizeof(struct sockaddr_pppox))
		return -EINVAL;

 	if (sp->sa_protocol != PX_PROTO_PPTP)
 		return -EINVAL;
 ","The (1) pptp_bind and (2) pptp_connect functions in drivers/net/ppp/pptp.c in the Linux kernel through 4.3.3 do not verify an address length, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism via a crafted application."
447,CVE-2015-8543,"  struct sock {
 				sk_no_check_rx : 1,
 				sk_userlocks : 4,
 				sk_protocol  : 8,
#define SK_PROTOCOL_MAX U8_MAX
 				sk_type      : 16;
 	kmemcheck_bitfield_end(flags);
 	int			sk_wmem_queued;","The networking implementation in the Linux kernel through 4.3.3, as used in Android and other products, does not validate protocol identifiers for certain protocol families, which allows local users to cause a denial of service (NULL function pointer dereference and system crash) or possibly gain privileges by leveraging CLONE_NEWUSER support to execute a crafted SOCK_RAW application."
448,CVE-2015-8374,"  static int truncate_space_check(struct btrfs_trans_handle *trans,
 
 }
 
static int truncate_inline_extent(struct inode *inode,
				  struct btrfs_path *path,
				  struct btrfs_key *found_key,
				  const u64 item_end,
				  const u64 new_size)
{
	struct extent_buffer *leaf = path->nodes[0];
	int slot = path->slots[0];
	struct btrfs_file_extent_item *fi;
	u32 size = (u32)(new_size - found_key->offset);
	struct btrfs_root *root = BTRFS_I(inode)->root;

	fi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);

	if (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {
		loff_t offset = new_size;
		loff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);

		 
		btrfs_release_path(path);
		return btrfs_truncate_page(inode, offset, page_end - offset, 0);
	}

	btrfs_set_file_extent_ram_bytes(leaf, fi, size);
	size = btrfs_file_extent_calc_inline_size(size);
	btrfs_truncate_item(root, path, size, 1);

	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		inode_sub_bytes(inode, item_end + 1 - new_size);

	return 0;
}

  
 			if (!del_item &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
 
 				 
				if (btrfs_file_extent_compression(leaf, fi) !=
				    BTRFS_COMPRESS_NONE && pending_del_nr) {
					err = btrfs_del_items(trans, root, path,
							      pending_del_slot,
							      pending_del_nr);
					if (err) {
						btrfs_abort_transaction(trans,
									root,
									err);
						goto error;
					}
					pending_del_nr = 0;
				}

				err = truncate_inline_extent(inode, path,
							     &found_key,
							     item_end,
							     new_size);
				if (err) {
					btrfs_abort_transaction(trans,
								root, err);
					goto error;
				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:","fs/btrfs/inode.c in the Linux kernel before 4.3.3 mishandles compressed inline extents, which allows local users to obtain sensitive pre-truncation information from a file via a clone action."
449,CVE-2015-8215,"  int addrconf_sysctl_forward(struct ctl_table *ctl, int write,
 	return ret;
 }
 
static
int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,
			void __user *buffer, size_t *lenp, loff_t *ppos)
{
	struct inet6_dev *idev = ctl->extra1;
	int min_mtu = IPV6_MIN_MTU;
	struct ctl_table lctl;

	lctl = *ctl;
	lctl.extra1 = &min_mtu;
	lctl.extra2 = idev ? &idev->dev->mtu : NULL;

	return proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);
}

 static void dev_disable_change(struct inet6_dev *idev)
 {
 	struct netdev_notifier_info info;
  static struct addrconf_sysctl_table
 			.data		= &ipv6_devconf.mtu6,
 			.maxlen		= sizeof(int),
 			.mode		= 0644,
			.proc_handler	= addrconf_sysctl_mtu,
 		},
 		{
 			.procname	= ""accept_ra"",","net/ipv6/addrconf.c in the IPv6 stack in the Linux kernel before 4.0 does not validate attempted changes to the MTU value, which allows context-dependent attackers to cause a denial of service (packet loss) via a value that is (1) smaller than the minimum compliant value or (2) larger than the MTU of an interface, as demonstrated by a Router Advertisement (RA) message that is not validated by a daemon, a different vulnerability than CVE-2015-0272.  NOTE: the scope of CVE-2015-0272 is limited to the NetworkManager product."
450,CVE-2015-8104,"  static void init_vmcb(struct vcpu_svm *svm)
 	set_exception_intercept(svm, UD_VECTOR);
 	set_exception_intercept(svm, MC_VECTOR);
 	set_exception_intercept(svm, AC_VECTOR);
	set_exception_intercept(svm, DB_VECTOR);
 
 	set_intercept(svm, INTERCEPT_INTR);
 	set_intercept(svm, INTERCEPT_NMI);
  static void svm_set_segment(struct kvm_vcpu *vcpu,
 	mark_dirty(svm->vmcb, VMCB_SEG);
 }
 
static void update_bp_intercept(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
 
 	clr_exception_intercept(svm, BP_VECTOR);
 
 	if (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {
 		if (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
 			set_exception_intercept(svm, BP_VECTOR);
 	} else
  static int db_interception(struct vcpu_svm *svm)
 		if (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))
 			svm->vmcb->save.rflags &=
 				~(X86_EFLAGS_TF | X86_EFLAGS_RF);
 	}
 
 	if (svm->vcpu.guest_debug &
  static void enable_nmi_window(struct kvm_vcpu *vcpu)
 	 */
 	svm->nmi_singlestep = true;
 	svm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);
 }
 
 static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)
  static struct kvm_x86_ops svm_x86_ops = {
 	.vcpu_load = svm_vcpu_load,
 	.vcpu_put = svm_vcpu_put,
 
	.update_db_bp_intercept = update_bp_intercept,
 	.get_msr = svm_get_msr,
 	.set_msr = svm_set_msr,
 	.get_segment_base = svm_get_segment_base,","The KVM subsystem in the Linux kernel through 4.2.6, and Xen 4.3.x through 4.6.x, allows guest OS users to cause a denial of service (host OS panic or hang) by triggering many #DB (aka Debug) exceptions, related to svm.c."
451,CVE-2015-7990,"  static struct rds_connection *__rds_conn_create(struct net *net,
 		}
 	}
 
 	conn->c_trans = trans;
 
 	ret = trans->conn_alloc(conn, gfp);",Race condition in the rds_sendmsg function in net/rds/sendmsg.c in the Linux kernel before 4.3.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6937.
452,CVE-2015-7885,"  long dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 		spin_lock_irqsave(&dgnc_global_lock, flags);
 
		memset(&ddi, 0, sizeof(ddi));
 		ddi.dinfo_nboards = dgnc_NumBoards;
 		sprintf(ddi.dinfo_version, ""%s"", DG_PART);
 ","The dgnc_mgmt_ioctl function in drivers/staging/dgnc/dgnc_mgmt.c in the Linux kernel through 4.3.3 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory via a crafted application."
453,CVE-2015-7884,"  static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
		memset(&vblank, 0, sizeof(vblank));
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;","The vivid_fb_ioctl function in drivers/media/platform/vivid/vivid-osd.c in the Linux kernel through 4.3.3 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel memory via a crafted application."
454,CVE-2015-7872,"  static noinline void key_gc_unused_keys(struct list_head *keys)
 		kdebug(""- %u"", key->serial);
 		key_check(key);
 
		 
		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
		    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&
		    key->type->destroy)
 			key->type->destroy(key);
 
 		security_key_free(key);",The key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 4.2.6 allows local users to cause a denial of service (OOPS) via crafted keyctl commands.
455,CVE-2015-7613,"  static int newque(struct ipc_namespace *ns, struct ipc_params *params)
 		return retval;
 	}
 
 	msq->q_stime = msq->q_rtime = 0;
 	msq->q_ctime = get_seconds();
 	msq->q_cbytes = msq->q_qnum = 0;
  static int newque(struct ipc_namespace *ns, struct ipc_params *params)
 	INIT_LIST_HEAD(&msq->q_receivers);
 	INIT_LIST_HEAD(&msq->q_senders);
 
	 
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}

 	ipc_unlock_object(&msq->q_perm);
 	rcu_read_unlock();
 ","Race condition in the IPC object implementation in the Linux kernel through 4.2.3 allows local users to gain privileges by triggering an ipc_addid call that leads to uid and gid comparisons against uninitialized data, related to msg.c, shm.c, and util.c."
456,CVE-2015-7509,"  int ext4_orphan_add(handle_t *handle, struct inode *inode)
 	struct ext4_iloc iloc;
 	int err = 0, rc;
 
	if (!EXT4_SB(sb)->s_journal)
 		return 0;
 
 	mutex_lock(&EXT4_SB(sb)->s_orphan_lock);
  int ext4_orphan_del(handle_t *handle, struct inode *inode)
 	struct ext4_iloc iloc;
 	int err = 0;
 
	if (!EXT4_SB(inode->i_sb)->s_journal)
 		return 0;
 
 	mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);
  int ext4_orphan_del(handle_t *handle, struct inode *inode)
 	 * transaction handle with which to update the orphan list on
 	 * disk, but we still need to remove the inode from the linked
 	 * list in memory. */
	if (!handle)
 		goto out;
 
 	err = ext4_reserve_inode_write(handle, inode, &iloc);","fs/ext4/namei.c in the Linux kernel before 3.7 allows physically proximate attackers to cause a denial of service (system crash) via a crafted no-journal filesystem, a related issue to CVE-2013-2015."
457,CVE-2015-6937,"  static struct rds_connection *__rds_conn_create(struct net *net,
 		}
 	}
 
	if (trans == NULL) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(-ENODEV);
		goto out;
	}

 	conn->c_trans = trans;
 
 	ret = trans->conn_alloc(conn, gfp);",The __rds_conn_create function in net/rds/connection.c in the Linux kernel through 4.2.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.
458,CVE-2015-6564,"  mm_answer_pam_respond(int sock, Buffer *m)
 int
 mm_answer_pam_free_ctx(int sock, Buffer *m)
 {
	int r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;
 
 	debug3(""%s"", __func__);
 	(sshpam_device.free_ctx)(sshpam_ctxt);
	sshpam_ctxt = sshpam_authok = NULL;
 	buffer_clear(m);
 	mm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);
 	auth_method = ""keyboard-interactive"";
 	auth_submethod = ""pam"";
	return r;
 }
 #endif
 ",Use-after-free vulnerability in the mm_answer_pam_free_ctx function in monitor.c in sshd in OpenSSH before 7.0 on non-OpenBSD platforms might allow local users to gain privileges by leveraging control of the sshd uid to send an unexpectedly early MONITOR_REQ_PAM_FREE_CTX request.
459,CVE-2015-6563,"  extern KbdintDevice sshpam_device;
 int
 mm_answer_pam_init_ctx(int sock, Buffer *m)
 {
 	debug3(""%s"", __func__);
 	sshpam_ctxt = (sshpam_device.init_ctx)(authctxt);
 	sshpam_authok = NULL;
 	buffer_clear(m);","The monitor component in sshd in OpenSSH before 7.0 on non-OpenBSD platforms accepts extraneous username data in MONITOR_REQ_PAM_INIT_CTX requests, which allows local users to conduct impersonation attacks by leveraging any SSH login access in conjunction with control of the sshd uid to send a crafted MONITOR_REQ_PWNAM request, related to monitor.c and monitor_wrap.c."
460,CVE-2015-6526,"  static void perf_callchain_user_64(struct perf_callchain_entry *entry,
 	sp = regs->gpr[1];
 	perf_callchain_store(entry, next_ip);
 
	while (entry->nr < PERF_MAX_STACK_DEPTH) {
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))
 			return;",The perf_callchain_user_64 function in arch/powerpc/perf/callchain.c in the Linux kernel before 4.0.2 on ppc64 platforms allows local users to cause a denial of service (infinite loop) via a deep 64-bit userspace backtrace.
461,CVE-2015-6520,"  static void start_daemon()
 
 	 
 	uint16_t desired_port = g_options.desired_port;
	struct tcp_sock_t *tcp_socket = NULL, *tcp6_socket = NULL;
	for (;;) {
		tcp_socket = tcp_open(desired_port);
		tcp6_socket = tcp6_open(desired_port);
		if (tcp_socket || tcp6_socket || g_options.only_desired_port)
			break;
 		 
 		desired_port ++;
 		 
  static void start_daemon()
 			 
 			 
 			desired_port = 49152;
		NOTE(""Access to desired port failed, trying alternative port %d"", desired_port);
 	}
	if (tcp_socket == NULL && tcp6_socket == NULL)
 		goto cleanup_tcp;
 
	uint16_t real_port;
	if (tcp_socket)
	  real_port = tcp_port_number_get(tcp_socket);
	else
	  real_port = tcp_port_number_get(tcp6_socket);
 	if (desired_port != 0 && g_options.only_desired_port == 1 &&
 	    desired_port != real_port) {
 		ERR(""Received port number did not match requested port number.""
  static void start_daemon()
 	printf(""%u|"", real_port);
 	fflush(stdout);
 
	NOTE(""Port: %d, IPv4 %savailable, IPv6 %savailable"",
	     real_port, tcp_socket ? """" : ""not "", tcp6_socket ? """" : ""not "");

 	 
 	uint16_t pid;
 	if (!g_options.nofork_mode && (pid = fork()) > 0) {
  static void start_daemon()
 		}
 
 		args->usb_sock = usb_sock;

		 
		 
		args->tcp = tcp_conn_select(tcp_socket, tcp6_socket);
 		if (args->tcp == NULL) {
 			ERR(""Failed to open tcp connection"");
 			goto cleanup_thread;
  static void start_daemon()
 cleanup_tcp:
 	if (tcp_socket!= NULL)
 		tcp_close(tcp_socket);
	if (tcp6_socket!= NULL)
		tcp_close(tcp6_socket);
 cleanup_usb:
 	if (usb_sock != NULL)
 		usb_close(usb_sock);","IPPUSBXD before 1.22 listens on all interfaces, which allows remote attackers to obtain access to USB connected printers via a direct request."
462,CVE-2015-6252,"  long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)
 		}
 		if (eventfp != d->log_file) {
 			filep = d->log_file;
			d->log_file = eventfp;
 			ctx = d->log_ctx;
 			d->log_ctx = eventfp ?
 				eventfd_ctx_fileget(eventfp) : NULL;",The vhost_dev_ioctl function in drivers/vhost/vhost.c in the Linux kernel before 4.1.5 allows local users to cause a denial of service (memory consumption) via a VHOST_SET_LOG_FD ioctl call that triggers permanent file-descriptor allocation.
463,CVE-2015-6031," 
 
  
 
 
 void IGDstartelt(void * d, const char * name, int l)
 {
 	struct IGDdatas * datas = (struct IGDdatas *)d;
	if(l >= MINIUPNPC_URL_MAXSIZE)
		l = MINIUPNPC_URL_MAXSIZE-1;
	memcpy(datas->cureltname, name, l);
 	datas->cureltname[l] = '\0';
 	datas->level++;
 	if( (l==7) && !memcmp(name, ""service"", l) ) {",Buffer overflow in the IGDstartelt function in igd_desc_parse.c in the MiniUPnP client (aka MiniUPnPc) before 1.9.20150917 allows remote UPNP servers to cause a denial of service (application crash) and possibly execute arbitrary code via an *oversized* XML element name.
464,CVE-2015-5707,"  sg_start_req(Sg_request *srp, unsigned char *cmd)
 			md->from_user = 0;
 	}
 
	if (unlikely(iov_count > MAX_UIOVEC))
		return -EINVAL;

 	if (iov_count) {
 		int size = sizeof(struct iovec) * iov_count;
 		struct iovec *iov;",Integer overflow in the sg_start_req function in drivers/scsi/sg.c in the Linux kernel 2.6.x through 4.x before 4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large iov_count value in a write request.
465,CVE-2015-5706,"  static struct file *path_openat(int dfd, struct filename *pathname,
 
 	if (unlikely(file->f_flags & __O_TMPFILE)) {
 		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);
		goto out2;
 	}
 
 	error = path_init(dfd, pathname, flags, nd);
  static struct file *path_openat(int dfd, struct filename *pathname,
 	}
 out:
 	path_cleanup(nd);
out2:
 	if (!(opened & FILE_OPENED)) {
 		BUG_ON(!error);
 		put_filp(file);",Use-after-free vulnerability in the path_openat function in fs/namei.c in the Linux kernel 3.x and 4.x before 4.0.4 allows local users to cause a denial of service or possibly have unspecified other impact via O_TMPFILE filesystem operations that leverage a duplicate cleanup operation.
466,CVE-2015-5697,"  static int get_bitmap_file(struct mddev *mddev, void __user * arg)
 	char *ptr;
 	int err;
 
	file = kzalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
 		return -ENOMEM;
 ","The get_bitmap_file function in drivers/md/md.c in the Linux kernel before 4.1.6 does not initialize a certain bitmap data structure, which allows local users to obtain sensitive information from kernel memory via a GET_BITMAP_FILE ioctl call."
467,CVE-2015-5685,"  namespace libtorrent
 					if (e)
 						TORRENT_FAIL_BDECODE(e);
 
					 
					const ptrdiff_t buff_size = end - start - 1;
					if (len > buff_size)
 						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
 
 					if (len < 0)
  namespace libtorrent
 					start = parse_int(start, end, ':', len, e);
 					if (e)
 						TORRENT_FAIL_BDECODE(e);

					 
					const ptrdiff_t buff_size = end - start - 1;
					if (len > buff_size)
 						TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
 					if (len < 0)
 						TORRENT_FAIL_BDECODE(bdecode_errors::overflow);
 
 					++start;
					if (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);
 					top->construct_string(start, int(len));
 					stack.pop_back();
 					start += len;","The lazy_bdecode function in BitTorrent DHT bootstrap server (bootstrap-dht ) allows remote attackers to execute arbitrary code via a crafted packet, related to *improper indexing.*"
468,CVE-2015-5366,"  int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 	}
 	unlock_sock_fast(sk, slow);
 
	 
	cond_resched();
 	msg->msg_flags &= ~MSG_TRUNC;
 	goto try_again;
 }","The (1) udp_recvmsg and (2) udpv6_recvmsg functions in the Linux kernel before 4.0.6 provide inappropriate -EAGAIN return values, which allows remote attackers to cause a denial of service (EPOLLET epoll application read outage) via an incorrect checksum in a UDP packet, a different vulnerability than CVE-2015-5364."
469,CVE-2015-5307," 
 	{ SVM_EXIT_EXCP_BASE + UD_VECTOR,       ""UD excp"" }, \
 	{ SVM_EXIT_EXCP_BASE + PF_VECTOR,       ""PF excp"" }, \
 	{ SVM_EXIT_EXCP_BASE + NM_VECTOR,       ""NM excp"" }, \
	{ SVM_EXIT_EXCP_BASE + AC_VECTOR,       ""AC excp"" }, \
 	{ SVM_EXIT_EXCP_BASE + MC_VECTOR,       ""MC excp"" }, \
 	{ SVM_EXIT_INTR,        ""interrupt"" }, \
 	{ SVM_EXIT_NMI,         ""nmi"" }, \","The KVM subsystem in the Linux kernel through 4.2.6, and Xen 4.3.x through 4.6.x, allows guest OS users to cause a denial of service (host OS panic or hang) by triggering many #AC (aka Alignment Check) exceptions, related to svm.c and vmx.c."
470,CVE-2015-5302,"  static void save_text_if_changed(const char *name, const char *new_value)
 
  
         dd_close(dd);
     }
 }
 
  static void tv_details_row_activated(
         load_text_to_text_view(GTK_TEXT_VIEW(textview), item_name);
 
         if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_OK)
        {
             save_text_from_text_view(GTK_TEXT_VIEW(textview), item_name);
            problem_data_reload_from_dump_dir();
            update_gui_state_from_problem_data(  0);
        }
 
         gtk_widget_destroy(textview);
         gtk_widget_destroy(scrolled);
  static void on_page_prepare(GtkNotebook *assistant, GtkWidget *page, gpointer us
      * these tabs will be lost */
     save_items_from_notepad();
     save_text_from_text_view(g_tv_comment, FILENAME_COMMENT);
    problem_data_reload_from_dump_dir();
    update_gui_state_from_problem_data(  0);
 
     if (pages[PAGENO_SUMMARY].page_widget == page)
     {","libreport 2.0.7 before 2.6.3 only saves changes to the first file when editing a crash report, which allows remote attackers to obtain sensitive information via unspecified vectors related to the (1) backtrace, (2) cmdline, (3) environ, (4) open_fds, (5) maps, (6) smaps, (7) hostname, (8) remote, (9) ks.cfg, or (10) anaconda-tb file attachment included in a Red Hat Bugzilla bug report."
471,CVE-2015-5287,"  int main(int argc, char** argv)
         if (snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash) >= sizeof(path))
             error_msg_and_die(""Error saving '%s': truncated long file path"", path);
 
        unlink(path);
        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {","The abrt-hook-ccpp help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users with certain permissions to gain privileges via a symlink attack on a file with a predictable name, as demonstrated by /var/tmp/abrt/abrt-hax-coredump or /var/spool/abrt/abrt-hax-coredump."
472,CVE-2015-5283,"  static void sctp_v4_del_protocol(void)
 	unregister_inetaddr_notifier(&sctp_inetaddr_notifier);
 }
 
static int __net_init sctp_defaults_init(struct net *net)
 {
 	int status;
 
  static int __net_init sctp_net_init(struct net *net)
 
 	sctp_dbg_objcnt_init(net);
 
 	 
 	INIT_LIST_HEAD(&net->sctp.local_addr_list);
 	spin_lock_init(&net->sctp.local_addr_lock);
  static int __net_init sctp_net_init(struct net *net)
 
 	return 0;
 
 err_init_proc:
 	cleanup_sctp_mibs(net);
 err_init_mibs:
  static int __net_init sctp_net_init(struct net *net)
 	return status;
 }
 
static void __net_exit sctp_defaults_exit(struct net *net)
 {
 	 
 	sctp_free_addr_wq(net);
 	sctp_free_local_addr_list(net);
 
 	sctp_dbg_objcnt_exit(net);
 
 	sctp_proc_exit(net);
 	cleanup_sctp_mibs(net);
 	sctp_sysctl_net_unregister(net);
 }
 
static struct pernet_operations sctp_defaults_ops = {
	.init = sctp_defaults_init,
	.exit = sctp_defaults_exit,
};

static int __net_init sctp_ctrlsock_init(struct net *net)
{
	int status;

	 
	status = sctp_ctl_sock_init(net);
	if (status)
		pr_err(""Failed to initialize the SCTP control sock\n"");

	return status;
}

static void __net_init sctp_ctrlsock_exit(struct net *net)
{
	 
	inet_ctl_sock_destroy(net->sctp.ctl_sock);
}

static struct pernet_operations sctp_ctrlsock_ops = {
	.init = sctp_ctrlsock_init,
	.exit = sctp_ctrlsock_exit,
 };
 
  
  static __init int sctp_init(void)
 	sctp_v4_pf_init();
 	sctp_v6_pf_init();
 
	status = register_pernet_subsys(&sctp_defaults_ops);
	if (status)
		goto err_register_defaults;
 
	status = sctp_v4_protosw_init();
 	if (status)
 		goto err_protosw_init;
 
 	status = sctp_v6_protosw_init();
 	if (status)
 		goto err_v6_protosw_init;
 
	status = register_pernet_subsys(&sctp_ctrlsock_ops);
 	if (status)
		goto err_register_ctrlsock;
 
 	status = sctp_v4_add_protocol();
 	if (status)
  static __init int sctp_init(void)
 err_v6_add_protocol:
 	sctp_v4_del_protocol();
 err_add_protocol:
	unregister_pernet_subsys(&sctp_ctrlsock_ops);
err_register_ctrlsock:
 	sctp_v6_protosw_exit();
 err_v6_protosw_init:
 	sctp_v4_protosw_exit();
 err_protosw_init:
	unregister_pernet_subsys(&sctp_defaults_ops);
err_register_defaults:
 	sctp_v4_pf_exit();
 	sctp_v6_pf_exit();
 	sctp_sysctl_unregister();
  static __exit void sctp_exit(void)
 	sctp_v6_del_protocol();
 	sctp_v4_del_protocol();
 
	unregister_pernet_subsys(&sctp_ctrlsock_ops);
 
 	 
 	sctp_v6_protosw_exit();
 	sctp_v4_protosw_exit();
 
	unregister_pernet_subsys(&sctp_defaults_ops);

 	 
 	sctp_v6_pf_exit();
 	sctp_v4_pf_exit();","The sctp_init function in net/sctp/protocol.c in the Linux kernel before 4.2.3 has an incorrect sequence of protocol-initialization steps, which allows local users to cause a denial of service (panic or memory corruption) by creating SCTP sockets before all of the steps have finished."
473,CVE-2015-5257,"  static int  whiteheat_firmware_download(struct usb_serial *serial,
 static int  whiteheat_firmware_attach(struct usb_serial *serial);
 
  
static int whiteheat_probe(struct usb_serial *serial,
				const struct usb_device_id *id);
 static int  whiteheat_attach(struct usb_serial *serial);
 static void whiteheat_release(struct usb_serial *serial);
 static int  whiteheat_port_probe(struct usb_serial_port *port);
  static struct usb_serial_driver whiteheat_device = {
 	.description =		""Connect Tech - WhiteHEAT"",
 	.id_table =		id_table_std,
 	.num_ports =		4,
	.probe =		whiteheat_probe,
 	.attach =		whiteheat_attach,
 	.release =		whiteheat_release,
 	.port_probe =		whiteheat_port_probe,
  static int whiteheat_firmware_attach(struct usb_serial *serial)
  

static int whiteheat_probe(struct usb_serial *serial,
				const struct usb_device_id *id)
{
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor *endpoint;
	size_t num_bulk_in = 0;
	size_t num_bulk_out = 0;
	size_t min_num_bulk;
	unsigned int i;

	iface_desc = serial->interface->cur_altsetting;

	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
		endpoint = &iface_desc->endpoint[i].desc;
		if (usb_endpoint_is_bulk_in(endpoint))
			++num_bulk_in;
		if (usb_endpoint_is_bulk_out(endpoint))
			++num_bulk_out;
	}

	min_num_bulk = COMMAND_PORT + 1;
	if (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)
		return -ENODEV;

	return 0;
}

 static int whiteheat_attach(struct usb_serial *serial)
 {
 	struct usb_serial_port *command_port;",drivers/usb/serial/whiteheat.c in the Linux kernel before 4.2.4 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact via a crafted USB device.  NOTE: this ID was incorrectly used for an Apache Cordova issue that has the correct ID of CVE-2015-8320.
474,CVE-2015-5156,"  static int virtnet_probe(struct virtio_device *vdev)
 	 
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {
 		 
		dev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;
 		if (csum)
			dev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;
 
 		if (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {
 			dev->hw_features |= NETIF_F_TSO | NETIF_F_UFO","The virtnet_probe function in drivers/net/virtio_net.c in the Linux kernel before 4.2 attempts to support a FRAGLIST feature without proper memory allocation, which allows guest OS users to cause a denial of service (buffer overflow and memory corruption) via a crafted sequence of fragmented packets."
475,CVE-2015-4700,"  void bpf_int_jit_compile(struct bpf_prog *prog)
 	}
 	ctx.cleanup_addr = proglen;
 
	 
	for (pass = 0; pass < 10 || image; pass++) {
 		proglen = do_jit(prog, addrs, image, oldproglen, &ctx);
 		if (proglen <= 0) {
 			image = NULL;",The bpf_int_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 4.0.6 allows local users to cause a denial of service (system crash) by creating a packet filter and then loading crafted BPF instructions that trigger late convergence by the JIT compiler.
476,CVE-2015-4692,"  static inline bool kvm_apic_vid_enabled(struct kvm *kvm)
 
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
	return kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;
 }
 
 static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)",The kvm_apic_has_events function in arch/x86/kvm/lapic.h in the Linux kernel through 4.1.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by leveraging /dev/kvm access for an ioctl call.
477,CVE-2015-4335,"  static void f_parser (lua_State *L, void *ud) {
   struct SParser *p = cast(struct SParser *, ud);
   int c = luaZ_lookahead(p->z);
   luaC_checkGC(L);
  tf = (luaY_parser)(L, p->z,
                                                              &p->buff, p->name);
   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));
   cl->l.p = tf;",Redis before 2.8.21 and 3.x before 3.0.2 allows remote attackers to execute arbitrary Lua bytecode via the eval command.
478,CVE-2015-4167,"  static int udf_read_inode(struct inode *inode, bool hidden_inode)
 	}
 	inode->i_generation = iinfo->i_unique;
 
	 
	if (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)
		goto out;
	 
	if (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)
		goto out;
 	 
 	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
 		/*","The udf_read_inode function in fs/udf/inode.c in the Linux kernel before 3.19.1 does not validate certain length values, which allows local users to cause a denial of service (incorrect data representation or integer overflow, and OOPS) via a crafted UDF filesystem."
479,CVE-2015-4036,"  vhost_scsi_send_evt(struct vhost_scsi *vs,
 		 * lun[4-7] need to be zero according to virtio-scsi spec.
 		 */
 		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt;
 		if (lun->unpacked_lun >= 256)
 			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
 		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
  vhost_scsi_make_tpg(struct se_wwn *wwn,
 			struct vhost_scsi_tport, tport_wwn);
 
 	struct vhost_scsi_tpg *tpg;
	u16 tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);",Array index error in the tcm_vhost_make_tpg function in drivers/vhost/scsi.c in the Linux kernel before 4.0 might allow guest OS users to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted VHOST_SCSI_SET_ENDPOINT ioctl call.  NOTE: the affected function was renamed to vhost_scsi_make_tpg before the vulnerability was announced.
480,CVE-2015-4003,"  static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			int n;
			if (!body->unit_size)
				break;
			n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,",The oz_usb_handle_ep_data function in drivers/staging/ozwpan/ozusbsvc1.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via a crafted packet.
481,CVE-2015-4002,"  void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)
 	case OZ_GET_DESC_RSP: {
 			struct oz_get_desc_rsp *body =
 				(struct oz_get_desc_rsp *)usb_hdr;
			u16 offs, total_size;
			u8 data_len;

			if (elt->length < sizeof(struct oz_get_desc_rsp) - 1)
				break;
			data_len = elt->length -
					(sizeof(struct oz_get_desc_rsp) - 1);
			offs = le16_to_cpu(get_unaligned(&body->offset));
			total_size =
 				le16_to_cpu(get_unaligned(&body->total_size));
 			oz_dbg(ON, ""USB_REQ_GET_DESCRIPTOR - cnf\n"");
 			oz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,","drivers/staging/ozwpan/ozusbsvc1.c in the OZWPAN driver in the Linux kernel through 4.0.5 does not ensure that certain length values are sufficiently large, which allows remote attackers to cause a denial of service (system crash or large loop) or possibly execute arbitrary code via a crafted packet, related to the (1) oz_usb_rx and (2) oz_usb_handle_ep_data functions."
482,CVE-2015-4001,"  void oz_hcd_pd_reset(void *hpd, void *hport)
  
void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,
			u8 length, u16 offset, u16 total_size)
 {
 	struct oz_port *port = hport;
 	struct urb *urb;
  void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,
 	if (!urb)
 		return;
 	if (status == 0) {
		unsigned int copy_len;
		unsigned int required_size = urb->transfer_buffer_length;
 
 		if (required_size > total_size)
 			required_size = total_size;",Integer signedness error in the oz_hcd_get_desc_cnf function in drivers/staging/ozwpan/ozhcd.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted packet.
483,CVE-2015-3885,"  struct jhead {
 
 int CLASS ljpeg_start (struct jhead *jh, int info_only)
 {
  int c, tag;
  ushort len;
   uchar data[0x10000];
   const uchar *dp;
 ","Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable."
484,CVE-2015-3636,"  void ping_unhash(struct sock *sk)
 	if (sk_hashed(sk)) {
 		write_lock_bh(&ping_table.lock);
 		hlist_nulls_del(&sk->sk_nulls_node);
		sk_nulls_node_init(&sk->sk_nulls_node);
 		sock_put(sk);
 		isk->inet_num = 0;
 		isk->inet_sport = 0;","The ping_unhash function in net/ipv4/ping.c in the Linux kernel before 4.0.3 does not initialize a certain list data structure during an unhash operation, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) by leveraging the ability to make a SOCK_DGRAM socket system call for the IPPROTO_ICMP or IPPROTO_ICMPV6 protocol, and then making a connect system call after a disconnect."
485,CVE-2015-3417,"  void ff_h264_free_tables(H264Context *h, int free_rbsp)
     if (free_rbsp && h->DPB) {
         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
             ff_h264_unref_picture(h, &h->DPB[i]);
        memset(h->delayed_pic, 0, sizeof(h->delayed_pic));
         av_freep(&h->DPB);
     } else if (h->DPB) {
         for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)","Use-after-free vulnerability in the ff_h264_free_tables function in libavcodec/h264.c in FFmpeg before 2.3.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted H.264 data in an MP4 file, as demonstrated by an HTML VIDEO element that references H.264 data."
486,CVE-2015-3339,"  static void check_unsafe_exec(struct linux_binprm *bprm)
 	spin_unlock(&p->fs->lock);
 }
 
static void bprm_fill_uid(struct linux_binprm *bprm)
{
	struct inode *inode;
	unsigned int mode;
	kuid_t uid;
	kgid_t gid;

	 
	bprm->cred->euid = current_euid();
	bprm->cred->egid = current_egid();

	if (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)
		return;

	if (task_no_new_privs(current))
		return;

	inode = file_inode(bprm->file);
	mode = READ_ONCE(inode->i_mode);
	if (!(mode & (S_ISUID|S_ISGID)))
		return;

	 
	mutex_lock(&inode->i_mutex);

	 
	mode = inode->i_mode;
	uid = inode->i_uid;
	gid = inode->i_gid;
	mutex_unlock(&inode->i_mutex);

	 
	if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||
		 !kgid_has_mapping(bprm->cred->user_ns, gid))
		return;

	if (mode & S_ISUID) {
		bprm->per_clear |= PER_CLEAR_ON_SETID;
		bprm->cred->euid = uid;
	}

	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
		bprm->per_clear |= PER_CLEAR_ON_SETID;
		bprm->cred->egid = gid;
	}
}

  
 int prepare_binprm(struct linux_binprm *bprm)
 {
 	int retval;
 
	bprm_fill_uid(bprm);
 
 	 
 	retval = security_bprm_set_creds(bprm);","Race condition in the prepare_binprm function in fs/exec.c in the Linux kernel before 3.19.6 allows local users to gain privileges by executing a setuid program at a time instant when a chown to root is in progress, and the ownership is changed but the setuid bit is not yet stripped."
487,CVE-2015-3331,"  static int __driver_rfc4106_decrypt(struct aead_request *req)
 		src = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);
 		if (!src)
 			return -ENOMEM;
		assoc = (src + req->cryptlen);
 		scatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);
 		scatterwalk_map_and_copy(assoc, req->assoc, 0,
 			req->assoclen, 0);
  static int __driver_rfc4106_decrypt(struct aead_request *req)
 		scatterwalk_done(&src_sg_walk, 0, 0);
 		scatterwalk_done(&assoc_sg_walk, 0, 0);
 	} else {
		scatterwalk_map_and_copy(dst, req->dst, 0, tempCipherLen, 1);
 		kfree(src);
 	}
 	return retval;","The __driver_rfc4106_decrypt function in arch/x86/crypto/aesni-intel_glue.c in the Linux kernel before 3.19.3 does not properly determine the memory locations used for encrypted data, which allows context-dependent attackers to cause a denial of service (buffer overflow and system crash) or possibly execute arbitrary code by triggering a crypto API call, as demonstrated by use of a libkcapi test program with an AF_ALG(aead) socket."
488,CVE-2015-3214,"  static int pit_ioport_read(struct kvm_io_device *this,
 		return -EOPNOTSUPP;
 
 	addr &= KVM_PIT_CHANNEL_MASK;
	if (addr == 3)
		return 0;

 	s = &pit_state->channels[addr];
 
 	mutex_lock(&pit_state->lock);","The pit_ioport_read in i8254.c in the Linux kernel before 2.6.33 and QEMU before 2.3.1 does not distinguish between read lengths and write lengths, which might allow guest OS users to execute arbitrary code on the host OS by triggering use of an invalid index."
489,CVE-2015-3212,"  struct netns_sctp {
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
	 
 	spinlock_t addr_wq_lock;
 
 	 ","Race condition in net/sctp/socket.c in the Linux kernel before 4.1.2 allows local users to cause a denial of service (list corruption and panic) via a rapid series of system calls related to sockets, as demonstrated by setsockopt calls."
490,CVE-2015-3185," 
  * 20150222.0 (2.5.0-dev)  ssl pre_handshake hook now indicates proxy|client
  * 20150222.1 (2.5.0-dev)  Add keep_alive_timeout_set to server_rec
  * 20150222.2 (2.5.0-dev)  Add response code 418 as per RFC2324/RFC7168
 * 20150222.3 (2.5.0-dev)  Add ap_some_authn_required, ap_force_authn hook.
 *                         Deprecate broken ap_some_auth_required.
  */
 
 #define MODULE_MAGIC_COOKIE 0x41503235UL  
 
 #ifndef MODULE_MAGIC_NUMBER_MAJOR
 #define MODULE_MAGIC_NUMBER_MAJOR 20150222
 #endif
#define MODULE_MAGIC_NUMBER_MINOR 3                  
 
 /**
  * Determine if the server's current MODULE_MAGIC_NUMBER is at least a","The ap_some_auth_required function in server/request.c in the Apache HTTP Server 2.4.x before 2.4.14 does not consider that a Require directive may be associated with an authorization setting rather than an authentication setting, which allows remote attackers to bypass intended access restrictions in opportunistic circumstances by leveraging the presence of a module that relies on the 2.2 API behavior."
491,CVE-2015-2925,"  static int __nd_alloc_stack(struct nameidata *nd)
 	return 0;
 }
 
 
static bool path_connected(const struct path *path)
{
	struct vfsmount *mnt = path->mnt;

	 
	if (mnt->mnt_root == mnt->mnt_sb->s_root)
		return true;

	return is_subdir(path->dentry, mnt->mnt_root);
}

 static inline int nd_alloc_stack(struct nameidata *nd)
 {
 	if (likely(nd->depth != EMBEDDED_LEVELS))
  static int follow_dotdot_rcu(struct nameidata *nd)
 				return -ECHILD;
 			nd->path.dentry = parent;
 			nd->seq = seq;
			if (unlikely(!path_connected(&nd->path)))
				return -ENOENT;
 			break;
 		} else {
 			struct mount *mnt = real_mount(nd->path.mnt);
  static void follow_mount(struct path *path)
 	}
 }
 
static int follow_dotdot(struct nameidata *nd)
 {
 	if (!nd->root.mnt)
 		set_root(nd);
  static void follow_dotdot(struct nameidata *nd)
 			 
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
			if (unlikely(!path_connected(&nd->path)))
				return -ENOENT;
 			break;
 		}
 		if (!follow_up(&nd->path))
 			break;
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
	return 0;
 }
 
 /*
  static inline int handle_dots(struct nameidata *nd, int type)
 		if (nd->flags & LOOKUP_RCU) {
 			return follow_dotdot_rcu(nd);
 		} else
			return follow_dotdot(nd);
 	}
 	return 0;
 }","The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a *double-chroot attack.*"
492,CVE-2015-2922,"  static void ndisc_router_discovery(struct sk_buff *skb)
 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (ra_msg->icmph.icmp6_hop_limit) {
		 
		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {
			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
		} else {
			ND_PRINTK(2, warn, ""RA: Got route advertisement with lower hop_limit than current\n"");
		}
 		if (rt)
 			dst_metric_set(&rt->dst, RTAX_HOPLIMIT,
 				       ra_msg->icmph.icmp6_hop_limit);",The ndisc_router_discovery function in net/ipv6/ndisc.c in the Neighbor Discovery (ND) protocol implementation in the IPv6 stack in the Linux kernel before 3.19.6 allows remote attackers to reconfigure a hop-limit setting via a small hop_limit value in a Router Advertisement (RA) message.
493,CVE-2015-2831,"  static int checksoftirq(int force){
 
 
 static char *get_pid_environ_val(pid_t pid,char *val){
  int temp_size = 500;
  char *temp = malloc(temp_size);
  
   int i=0;
   int foundit=0;
   FILE *fp;
  static char *get_pid_environ_val(pid_t pid,char *val){
 
   
   for(;;){
    
    if (i >= temp_size) {
      temp_size *= 2;
      temp = realloc(temp, temp_size);
    }
      
     temp[i]=fgetc(fp);    
 
     if(foundit==1 && (temp[i]==0 || temp[i]=='\0' || temp[i]==EOF)){",Buffer overflow in das_watchdog 0.9.0 allows local users to execute arbitrary code with root privileges via a large string in the XAUTHORITY environment variable.
494,CVE-2015-2779,"  CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)
     connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),
         network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));
 
    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),
        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));

     connect(this, SIGNAL(putRawLine(const QByteArray &)),
         network(), SLOT(putRawLine(const QByteArray &)));
 }",Stack consumption vulnerability in the message splitting functionality in Quassel before 0.12-rc1 allows remote attackers to cause a denial of service (uncontrolled recursion) via a crafted massage.
495,CVE-2015-2698,"  OM_uint32 KRB5_CALLCONV
 iakerb_gss_export_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t interprocess_token);

OM_uint32 KRB5_CALLCONV
iakerb_gss_import_sec_context(OM_uint32 *minor_status,
                              const gss_buffer_t interprocess_token,
                              gss_ctx_id_t *context_handle);
 #endif  
 
 OM_uint32 KRB5_CALLCONV","The iakerb_gss_export_sec_context function in lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) 1.14 pre-release 2015-09-14 improperly accesses a certain pointer, which allows remote authenticated users to cause a denial of service (memory corruption) or possibly have unspecified other impact by interacting with an application that calls the gss_export_sec_context function.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2015-2696."
496,CVE-2015-2697,"  build_principal_va(krb5_context context, krb5_principal princ,
     data = malloc(size * sizeof(krb5_data));
     if (!data) { retval = ENOMEM; }
 
    if (!retval)
        r = k5memdup0(realm, rlen, &retval);
 
     while (!retval && (component = va_arg(ap, char *))) {
         if (count == size) {",The build_principal_va function in lib/krb5/krb/bld_princ.c in MIT Kerberos 5 (aka krb5) before 1.14 allows remote authenticated users to cause a denial of service (out-of-bounds read and KDC crash) via an initial '0' character in a long realm field within a TGS request.
497,CVE-2015-2696,"  OM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext
 );
 #endif  
 
OM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid
(OM_uint32*,        
 const gss_ctx_id_t,
  
 const gss_OID,     
 gss_buffer_set_t*  
);

OM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option
(OM_uint32*,        
 gss_ctx_id_t*,     
 const gss_OID,     
 const gss_buffer_t 
);

 OM_uint32 KRB5_CALLCONV krb5_gss_process_context_token
 (OM_uint32*,        
  gss_ctx_id_t,      
  OM_uint32 KRB5_CALLCONV
 krb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,
                      gss_cred_id_t *cred_handle);
 
OM_uint32 KRB5_CALLCONV
iakerb_gss_process_context_token(OM_uint32 *minor_status,
                                 const gss_ctx_id_t context_handle,
                                 const gss_buffer_t token_buffer);

OM_uint32 KRB5_CALLCONV
iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                        OM_uint32 *time_rec);

OM_uint32 KRB5_CALLCONV
iakerb_gss_inquire_context(OM_uint32 *minor_status,
                           gss_ctx_id_t context_handle, gss_name_t *src_name,
                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,
                           gss_OID *mech_type, OM_uint32 *ctx_flags,
                           int *locally_initiated, int *opened);

OM_uint32 KRB5_CALLCONV
iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                   gss_qop_t qop_req, gss_buffer_t message_buffer,
                   gss_buffer_t message_token);

OM_uint32 KRB5_CALLCONV
iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,
                       int iov_count);

OM_uint32 KRB5_CALLCONV
iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,
                              gss_ctx_id_t context_handle, gss_qop_t qop_req,
                              gss_iov_buffer_desc *iov, int iov_count);

OM_uint32 KRB5_CALLCONV
iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,
                      gss_qop_t *qop_state);

OM_uint32 KRB5_CALLCONV
iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
                          int iov_count);

OM_uint32 KRB5_CALLCONV
iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                int conf_req_flag, gss_qop_t qop_req,
                gss_buffer_t input_message_buffer, int *conf_state,
                gss_buffer_t output_message_buffer);

OM_uint32 KRB5_CALLCONV
iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,
                    gss_iov_buffer_desc *iov, int iov_count);

OM_uint32 KRB5_CALLCONV
iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,
                           gss_ctx_id_t context_handle, int conf_req_flag,
                           gss_qop_t qop_req, int *conf_state,
                           gss_iov_buffer_desc *iov, int iov_count);

OM_uint32 KRB5_CALLCONV
iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                  gss_buffer_t input_message_buffer,
                  gss_buffer_t output_message_buffer, int *conf_state,
                  gss_qop_t *qop_state);

OM_uint32 KRB5_CALLCONV
iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                      int *conf_state, gss_qop_t *qop_state,
                      gss_iov_buffer_desc *iov, int iov_count);

OM_uint32 KRB5_CALLCONV
iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,
                           gss_ctx_id_t context_handle, int conf_req_flag,
                           gss_qop_t qop_req, OM_uint32 req_output_size,
                           OM_uint32 *max_input_size);

#ifndef LEAN_CLIENT
OM_uint32 KRB5_CALLCONV
iakerb_gss_export_sec_context(OM_uint32 *minor_status,
                              gss_ctx_id_t *context_handle,
                              gss_buffer_t interprocess_token);
#endif  

OM_uint32 KRB5_CALLCONV
iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,
                                      const gss_ctx_id_t context_handle,
                                      const gss_OID desired_object,
                                      gss_buffer_set_t *data_set);

OM_uint32 KRB5_CALLCONV
iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,
                                  gss_ctx_id_t *context_handle,
                                  const gss_OID desired_object,
                                  const gss_buffer_t value);

OM_uint32 KRB5_CALLCONV
iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
                         int prf_key, const gss_buffer_t prf_in,
                         ssize_t desired_output_len, gss_buffer_t prf_out);

  
 #define CRED_EXPORT_MAGIC ""K5C1""","lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call."
498,CVE-2015-2695,"  typedef struct {
 	int firstpass;
 	int mech_complete;
 	int nego_done;
	int initiate;
	int opened;
 	OM_uint32 ctx_flags;
 	gss_name_t internal_name;
 	gss_OID actual_mech;","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
499,CVE-2015-2694,"  static krb5_preauthtype otp_pa_type_list[] =
 struct request_state {
     krb5_kdcpreauth_verify_respond_fn respond;
     void *arg;
    krb5_enc_tkt_part *enc_tkt_reply;
 };
 
 static krb5_error_code
  on_response(void *data, krb5_error_code retval, otp_response response)
     if (retval == 0 && response != otp_response_success)
         retval = KRB5_PREAUTH_FAILED;
 
    if (retval == 0)
        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;

     rs.respond(rs.arg, retval, NULL, NULL, NULL);
 }
 
  otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,
     krb5_data d, plaintext;
     char *config;
 
      
     armor_key = cb->fast_armor(context, rock);
     if (armor_key == NULL) {
  otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,
         goto error;
     }
 
     
     rs = k5alloc(sizeof(struct request_state), &retval);
     if (rs == NULL)
         goto error;
     rs->arg = arg;
     rs->respond = respond;
    rs->enc_tkt_reply = enc_tkt_reply;
 
      
     retval = cb->get_string(context, rock, ""otp"", &config);","The kdcpreauth modules in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.2 do not properly track whether a client's request has been validated, which allows remote attackers to bypass an intended preauthentication requirement by providing (1) zero bytes of data or (2) an arbitrary realm name, related to plugins/preauth/otp/main.c and plugins/preauth/pkinit/pkinit_srv.c."
500,CVE-2015-2666,"  get_matching_model_microcode(int cpu, unsigned long start,
 	unsigned int mc_saved_count = mc_saved_data->mc_saved_count;
 	int i;
 
	while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) {
 		mc_header = (struct microcode_header_intel *)ucode_ptr;
 
 		mc_size = get_totalsize(mc_header);",Stack-based buffer overflow in the get_matching_model_microcode function in arch/x86/kernel/cpu/microcode/intel_early.c in the Linux kernel before 4.0 allows context-dependent attackers to gain privileges by constructing a crafted microcode header and leveraging root privileges for write access to the initrd.
501,CVE-2015-2150," 
 #include ""conf_space.h""
 #include ""conf_space_quirks.h""
 
bool permissive;
 module_param(permissive, bool, 0644);
 
 /* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,","Xen 3.3.x through 4.5.x and the Linux kernel through 3.19.1 do not properly restrict access to PCI command registers, which might allow local guest OS users to cause a denial of service (non-maskable interrupt and host crash) by disabling the (1) memory or (2) I/O decoding for a PCI Express device and then accessing the device, which triggers an Unsupported Request (UR) response."
502,CVE-2015-2141,"  Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const
 	DoQuickSanityCheck();
 	ModularArithmetic modn(m_n);
 	Integer r, rInv;

	 
	do {
 		r.Randomize(rng, Integer::One(), m_n - Integer::One());
		 
		 
		r = modn.Square(r);
 		rInv = modn.MultiplicativeInverse(r);
 	} while (rInv.IsZero());

 	Integer re = modn.Square(r);
 	re = modn.Multiply(re, x);			 
 ","The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack."
503,CVE-2015-2042,"  static struct ctl_table rds_sysctl_rds_table[] = {
 	{
 		.procname	= ""max_unacked_packets"",
 		.data		= &rds_sysctl_max_unacked_packets,
		.maxlen         = sizeof(int),
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
 	{
 		.procname	= ""max_unacked_bytes"",
 		.data		= &rds_sysctl_max_unacked_bytes,
		.maxlen         = sizeof(int),
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},","net/rds/sysctl.c in the Linux kernel before 3.19 uses an incorrect data type in a sysctl table, which allows local users to obtain potentially sensitive information from kernel memory or possibly have unspecified other impact by accessing a sysctl entry."
504,CVE-2015-2041,"  static struct ctl_table llc2_timeout_table[] = {
 	{
 		.procname	= ""ack"",
 		.data		= &sysctl_llc2_ack_timeout,
		.maxlen		= sizeof(sysctl_llc2_ack_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= ""busy"",
 		.data		= &sysctl_llc2_busy_timeout,
		.maxlen		= sizeof(sysctl_llc2_busy_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= ""p"",
 		.data		= &sysctl_llc2_p_timeout,
		.maxlen		= sizeof(sysctl_llc2_p_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= ""rej"",
 		.data		= &sysctl_llc2_rej_timeout,
		.maxlen		= sizeof(sysctl_llc2_rej_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},","net/llc/sysctl_net_llc.c in the Linux kernel before 3.19 uses an incorrect data type in a sysctl table, which allows local users to obtain potentially sensitive information from kernel memory or possibly have unspecified other impact by accessing a sysctl entry."
505,CVE-2015-1867,"  __xml_acl_post_process(xmlNode * xml)
 
     if(is_set(p->flags, xpf_created)) {
         xmlAttr *xIter = NULL;
        char *path = xml_get_path(xml);
 
         
 
         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {
             const char *prop_name = (const char *)xIter->name;
 
            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, ""/""XML_CIB_TAG_ACLS""/"") == NULL) {
                  
                 continue;
 
  __xml_acl_post_process(xmlNode * xml)
                 break;
 
             } else {
                 crm_trace(""Cannot add new node %s at %s"", crm_element_name(xml), path);
 
                 if(xml != xmlDocGetRootElement(xml->doc)) {
  __xml_acl_post_process(xmlNode * xml)
                 return;
             }
         }
        free(path);
     }
 
     while (cIter != NULL) {","Pacemaker before 1.1.13 does not properly evaluate added nodes, which allows remote read-only users to gain privileges via an acl command."
506,CVE-2015-1805,"  void pipe_wait(struct pipe_inode_info *pipe)
 	pipe_lock(pipe);
 }
 
 static void anon_pipe_buf_release(struct pipe_inode_info *pipe,
 				  struct pipe_buffer *buf)
 {
  static inline int is_packetized(struct file *file)
 }
 
 static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	struct file *filp = iocb->ki_filp;
 	struct pipe_inode_info *pipe = filp->private_data;
	ssize_t ret = 0;
	int do_wakeup = 0;
	size_t total_len = iov_iter_count(from);
 	ssize_t chars;
 
 	 
 	if (unlikely(total_len == 0))
 		return 0;
 
 	__pipe_lock(pipe);
 
 	if (!pipe->readers) {
  pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 		int offset = buf->offset + buf->len;
 
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
			int error = ops->confirm(pipe, buf);
 			if (error)
 				goto out;
 
			ret = copy_page_from_iter(buf->page, offset, chars, from);
			if (unlikely(ret < chars)) {
				error = -EFAULT;
 				goto out;
 			}
			do_wakeup = 1;
 			buf->len += chars;
 			ret = chars;
			if (!iov_iter_count(from))
 				goto out;
 		}
 	}
  pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			int newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);
 			struct pipe_buffer *buf = pipe->bufs + newbuf;
 			struct page *page = pipe->tmp_page;
			int copied;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
  pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			 * FIXME! Is this really true?
 			 */
 			do_wakeup = 1;
			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
			if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
 				if (!ret)
					ret = -EFAULT;
 				break;
 			}
			ret += copied;
 
 			 
 			buf->page = page;
 			buf->ops = &anon_pipe_buf_ops;
 			buf->offset = 0;
			buf->len = copied;
 			buf->flags = 0;
 			if (is_packetized(filp)) {
 				buf->ops = &packet_pipe_buf_ops;
  pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			pipe->nrbufs = ++bufs;
 			pipe->tmp_page = NULL;
 
			if (!iov_iter_count(from))
 				break;
 		}
 		if (bufs < pipe->buffers)
  const struct file_operations pipefifo_fops = {
 	.llseek		= no_llseek,
 	.read		= new_sync_read,
 	.read_iter	= pipe_read,
	.write		= new_sync_write,
	.write_iter	= pipe_write,
 	.poll		= pipe_poll,
 	.unlocked_ioctl	= pipe_ioctl,
 	.release	= pipe_release,","The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*"
507,CVE-2015-1792," 
 #include ""cms_lcl.h""
 #include ""asn1_locl.h""
 
static BIO *cms_get_text_bio(BIO *out, unsigned int flags)
 	{
	BIO *rbio;
 	if (out == NULL)
		rbio = BIO_new(BIO_s_null());
 	else if (flags & CMS_TEXT)
 		{
		rbio = BIO_new(BIO_s_mem());
		BIO_set_mem_eof_return(rbio, 0);
 		}
 	else
		rbio = out;
	return rbio;
	}

static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)
	{
	unsigned char buf[4096];
	int r = 0, i;
	BIO *tmpout;

	tmpout = cms_get_text_bio(out, flags);
 
 	if(!tmpout)
 		{
  static void do_free_upto(BIO *f, BIO *upto)
 			BIO_free(f);
 			f = tbio;
 			}
		while (f && f != upto);
 		}
 	else
 		BIO_free_all(f);
  int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
 	STACK_OF(X509_CRL) *crls = NULL;
 	X509 *signer;
 	int i, scount = 0, ret = 0;
	BIO *cmsbio = NULL, *tmpin = NULL, *tmpout = NULL;
 
 	if (!dcont && !check_content(cms))
 		return 0;
  int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
 		}
 	else
 		tmpin = dcont;
	 
	if (!(flags & SMIME_BINARY) && dcont)
		{
		 
		tmpout = cms_get_text_bio(out, flags);
		if(!tmpout)
			{
			CMSerr(CMS_F_CMS_VERIFY,ERR_R_MALLOC_FAILURE);
			goto err;
			}
		cmsbio = CMS_dataInit(cms, tmpout);
		if (!cmsbio)
			goto err;
		 
		SMIME_crlf_copy(dcont, cmsbio, flags & ~SMIME_TEXT);
 
		if(flags & CMS_TEXT)
			{
			if (!SMIME_text(tmpout, out))
				{
				CMSerr(CMS_F_CMS_VERIFY,CMS_R_SMIME_TEXT_ERROR);
				goto err;
				}
			}
		}
	else
		{
		cmsbio=CMS_dataInit(cms, tmpin);
		if (!cmsbio)
			goto err;
 
		if (!cms_copy_content(out, cmsbio, flags))
			goto err;
 
		}
 	if (!(flags & CMS_NO_CONTENT_VERIFY))
 		{
 		for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)
  int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
 	ret = 1;
 
 	err:
	if (!(flags & SMIME_BINARY) && dcont)
		{
		do_free_upto(cmsbio, tmpout);
		if (tmpin != dcont)
			BIO_free(tmpin);
		}
 	else
		{

		if (dcont && (tmpin == dcont))
			do_free_upto(cmsbio, dcont);
		else
			BIO_free_all(cmsbio);
		}

	if (tmpout && out != tmpout)
		BIO_free_all(tmpout);
 
 	if (cms_certs)
 		sk_X509_pop_free(cms_certs, X509_free);","The do_free_upto function in crypto/cms/cms_smime.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b allows remote attackers to cause a denial of service (infinite loop) via vectors that trigger a NULL value of a BIO data structure, as demonstrated by an unrecognized X.660 OID for a hash function."
508,CVE-2015-1791,"  void ERR_load_SSL_strings(void);
 # define SSL_F_SSL_READ                                   223
 # define SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT                320
 # define SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT                321
# define SSL_F_SSL_SESSION_DUP                            348
 # define SSL_F_SSL_SESSION_NEW                            189
 # define SSL_F_SSL_SESSION_PRINT_FP                       190
 # define SSL_F_SSL_SESSION_SET1_ID_CONTEXT                312","Race condition in the ssl3_get_new_session_ticket function in ssl/s3_clnt.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b, when used for a multi-threaded client, allows remote attackers to cause a denial of service (double free and application crash) or possibly have unspecified other impact by providing a NewSessionTicket during an attempt to reuse a ticket that had been obtained earlier."
509,CVE-2015-1790,"  BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
 
     switch (i) {
     case NID_pkcs7_signed:
         
         data_body = PKCS7_get_octet_string(p7->d.sign->contents);
         if (!PKCS7_is_detached(p7) && data_body == NULL) {
             PKCS7err(PKCS7_F_PKCS7_DATADECODE,
  BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
     case NID_pkcs7_signedAndEnveloped:
         rsk = p7->d.signed_and_enveloped->recipientinfo;
         md_sk = p7->d.signed_and_enveloped->md_algs;
         
         data_body = p7->d.signed_and_enveloped->enc_data->enc_data;
         enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;
         evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);
  BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
     case NID_pkcs7_enveloped:
         rsk = p7->d.enveloped->recipientinfo;
         enc_alg = p7->d.enveloped->enc_data->algorithm;
         
         data_body = p7->d.enveloped->enc_data->enc_data;
         evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);
         if (evp_cipher == NULL) {
  BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
         goto err;
     }
 
     
    if (data_body == NULL && in_bio == NULL) {
        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
        goto err;
    }

      
     if (md_sk != NULL) {
         for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {
  BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
             BIO_push(out, etmp);
         etmp = NULL;
     }
    if (in_bio != NULL) {
         bio = in_bio;
     } else {
         if (data_body->length > 0)","The PKCS7_dataDecodefunction in crypto/pkcs7/pk7_doit.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a PKCS#7 blob that uses ASN.1 encoding and lacks inner EncryptedContent data."
510,CVE-2015-1789,"  int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
     ASN1_TIME atm;
     long offset;
     char buff1[24], buff2[24], *p;
    int i, j, remaining;
 
     p = buff1;
    remaining = ctm->length;
     str = (char *)ctm->data;
     
     if (ctm->type == V_ASN1_UTCTIME) {
         
        int min_length = sizeof(""YYMMDDHHMMZ"") - 1;
        int max_length = sizeof(""YYMMDDHHMMSS+hhmm"") - 1;
        if (remaining < min_length || remaining > max_length)
             return 0;
         memcpy(p, str, 10);
         p += 10;
         str += 10;
        remaining -= 10;
     } else {
         
        int min_length = sizeof(""YYYYMMDDHHMMZ"") - 1;
        int max_length = sizeof(""YYYYMMDDHHMMSS.fff+hhmm"") - 1;
        if (remaining < min_length || remaining > max_length)
             return 0;
         memcpy(p, str, 12);
         p += 12;
         str += 12;
        remaining -= 12;
     }
 
     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {
         *(p++) = '0';
         *(p++) = '0';
     } else {
         
        if (remaining < 2)
            return 0;
         *(p++) = *(str++);
         *(p++) = *(str++);
        remaining -= 2;
         
        if (remaining && *str == '.') {
             str++;
            remaining--;
            for (i = 0; i < 3 && remaining; i++, str++, remaining--) {
                if (*str < '0' || *str > '9')
                    break;
            }
         }
 
     }
     *(p++) = 'Z';
     *(p++) = '\0';
 
     
    if (!remaining)
        return 0;
    if (*str == 'Z') {
        if (remaining != 1)
            return 0;
         offset = 0;
    } else {
         
         if ((*str != '+') && (*str != '-'))
             return 0;
         
        if (remaining != 5)
            return 0;
        if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||
            str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')
            return 0;
         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;
         offset += (str[3] - '0') * 10 + (str[4] - '0');
         if (*str == '-')","The X509_cmp_time function in crypto/x509/x509_vfy.c in OpenSSL before 0.9.8zg, 1.0.0 before 1.0.0s, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted length field in ASN1_TIME data, as demonstrated by an attack against a server that supports client authentication with a custom verification callback."
511,CVE-2015-1788,"  int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
     }
 # else
     {
        int i;
        int ubits = BN_num_bits(u);
        int vbits = BN_num_bits(v);  
        int top = p->top;
         BN_ULONG *udp, *bdp, *vdp, *cdp;
 
         bn_wexpand(u, top);
  int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
                 ubits--;
             }
 
            if (ubits <= BN_BITS2) {
                if (udp[0] == 0)  
                    goto err;
                if (udp[0] == 1)
                    break;
            }
 
             if (ubits < vbits) {
                 i = ubits;","The BN_GF2m_mod_inv function in crypto/bn/bn_gf2m.c in OpenSSL before 0.9.8s, 1.0.0 before 1.0.0e, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b does not properly handle ECParameters structures in which the curve is over a malformed binary polynomial field, which allows remote attackers to cause a denial of service (infinite loop) via a session that uses an Elliptic Curve algorithm, as demonstrated by an attack against a server that supports client authentication."
512,CVE-2015-1593,"  struct va_alignment __read_mostly va_align = {
 	.flags = -1,
 };
 
static unsigned long stack_maxrandom_size(void)
 {
	unsigned long max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;","The stack randomization feature in the Linux kernel before 3.19.1 on 64-bit platforms uses incorrect data types for the results of bitwise left-shift operations, which makes it easier for attackers to bypass the ASLR protection mechanism by predicting the address of the top of the stack, related to the randomize_stack_top function in fs/binfmt_elf.c and the stack_maxrandom_size function in arch/x86/mm/mmap.c."
513,CVE-2015-1465,"  struct inet_skb_parm {
 	struct ip_options	opt;		 
 	unsigned char		flags;
 
#define IPSKB_FORWARDED		BIT(0)
#define IPSKB_XFRM_TUNNEL_SIZE	BIT(1)
#define IPSKB_XFRM_TRANSFORMED	BIT(2)
#define IPSKB_FRAG_COMPLETE	BIT(3)
#define IPSKB_REROUTED		BIT(4)
#define IPSKB_DOREDIRECT	BIT(5)
 
 	u16			frag_max_size;
 };","The IPv4 implementation in the Linux kernel before 3.18.8 does not properly consider the length of the Read-Copy Update (RCU) grace period for redirecting lookups in the absence of caching, which allows remote attackers to cause a denial of service (memory consumption or system crash) via a flood of packets."
514,CVE-2015-1421,"  void sctp_assoc_update(struct sctp_association *asoc,
 	asoc->peer.peer_hmacs = new->peer.peer_hmacs;
 	new->peer.peer_hmacs = NULL;
 
 	sctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);
 }
 ",Use-after-free vulnerability in the sctp_assoc_update function in net/sctp/associola.c in the Linux kernel before 3.18.8 allows remote attackers to cause a denial of service (slab corruption and panic) or possibly have unspecified other impact by triggering an INIT collision that leads to improper handling of shared-key data.
515,CVE-2015-1344,"  static void pid_from_ns_wrapper(int sock, pid_t tpid)
 	goto loop;
 }
 
 
bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)
{
	FILE *f;
	char line[400];

	sprintf(line, ""/proc/%d/uid_map"", pid);
	if ((f = fopen(line, ""r"")) == NULL) {
		return false;
	}

	*answer = convert_id_to_ns(f, uid);
	fclose(f);

	if (*answer == -1)
		return false;
	return true;
}

 
void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)
{
	char line[400];
	uid_t u;
	gid_t g;
	FILE *f;

	*uid = -1;
	*gid = -1;
	sprintf(line, ""/proc/%d/status"", pid);
	if ((f = fopen(line, ""r"")) == NULL) {
		fprintf(stderr, ""Error opening %s: %s\n"", line, strerror(errno));
		return;
	}
	while (fgets(line, 400, f)) {
		if (strncmp(line, ""Uid:"", 4) == 0) {
			if (sscanf(line+4, ""%u"", &u) != 1) {
				fprintf(stderr, ""bad uid line for pid %u\n"", pid);
				fclose(f);
				return;
			}
			*uid = u;
		} else if (strncmp(line, ""Gid:"", 4) == 0) {
			if (sscanf(line+4, ""%u"", &g) != 1) {
				fprintf(stderr, ""bad gid line for pid %u\n"", pid);
				fclose(f);
				return;
			}
			*gid = g;
		}
	}
	fclose(f);
}

 
bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)
{
	uid_t v_uid, tmpuid;
	gid_t v_gid;

	if (r == v)
		return true;
	if (r_uid == 0)
		return true;
	get_pid_creds(v, &v_uid, &v_gid);
	if (r_uid == v_uid)
		return true;
	if (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0
			&& hostuid_to_ns(v_uid, r, &tmpuid))
		return true;
	return false;
}

static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,
		const char *file, const char *buf)
 {
 	int sock[2] = {-1, -1};
 	pid_t qpid, cpid = -1;
  static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const
 
 		if (recv_creds(sock[0], &cred, &v)) {
 			if (v == '0') {
				if (!may_move_pid(tpid, tuid, cred.pid)) {
					fail = true;
					break;
				}
 				if (fprintf(pids_file, ""%d"", (int) cred.pid) < 0)
 					fail = true;
 			}
  int cg_write(const char *path, const char *buf, size_t size, off_t offset,
 			strcmp(f->file, ""/cgroup.procs"") == 0 ||
 			strcmp(f->file, ""cgroup.procs"") == 0)
 		 
		r = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);
 	else
 		r = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);
 ","The do_write_pids function in lxcfs.c in LXCFS before 0.12 does not properly check permissions, which allows local users to gain privileges by writing a pid to the tasks file."
516,CVE-2015-1334," 
 
 lxc_log_define(lxc_attach, lxc);
 
int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {
	int labelfd = -1;
	int ret = 0;
	const char* name;
	char* command = NULL;

	name = lsm_name();

	if (strcmp(name, ""nop"") == 0)
		goto out;

	if (strcmp(name, ""none"") == 0)
		goto out;

	 
	if (strcmp(name, ""AppArmor"") == 0)
		on_exec = 0;

	if (on_exec) {
		labelfd = openat(procfd, ""self/attr/exec"", O_RDWR);
	}
	else {
		labelfd = openat(procfd, ""self/attr/current"", O_RDWR);
	}

	if (labelfd < 0) {
		SYSERROR(""Unable to open LSM label"");
		ret = -1;
		goto out;
	}

	if (strcmp(name, ""AppArmor"") == 0) {
		int size;

		command = malloc(strlen(lsm_label) + strlen(""changeprofile "") + 1);
		if (!command) {
			SYSERROR(""Failed to write apparmor profile"");
			ret = -1;
			goto out;
		}

		size = sprintf(command, ""changeprofile %s"", lsm_label);
		if (size < 0) {
			SYSERROR(""Failed to write apparmor profile"");
			ret = -1;
			goto out;
		}

		if (write(labelfd, command, size + 1) < 0) {
			SYSERROR(""Unable to set LSM label"");
			ret = -1;
			goto out;
		}
	}
	else if (strcmp(name, ""SELinux"") == 0) {
		if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {
			SYSERROR(""Unable to set LSM label"");
			ret = -1;
			goto out;
		}
	}
	else {
		ERROR(""Unable to restore label for unknown LSM: %s"", name);
		ret = -1;
		goto out;
	}

out:
	free(command);

	if (labelfd != -1)
		close(labelfd);

	return ret;
}

 static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)
 {
 	struct lxc_proc_context_info *info = calloc(1, sizeof(*info));
  struct attach_clone_payload {
 	struct lxc_proc_context_info* init_ctx;
 	lxc_attach_exec_t exec_function;
 	void* exec_payload;
	int procfd;
 };
 
 static int attach_child_main(void* data);
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
	int procfd;
 	signed long personality;
 
 	if (!options)
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 		rexit(-1);
 	}
 
	procfd = open(""/proc"", O_DIRECTORY | O_RDONLY);
	if (procfd < 0) {
		SYSERROR(""Unable to open /proc"");
		shutdown(ipc_sockets[1], SHUT_RDWR);
		rexit(-1);
	}

 	 
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 			.options = options,
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
			.exec_payload = exec_payload,
			.procfd = procfd
 		};
 		 
	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
 		int on_exec;
 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
 			rexit(-1);
 		}
 	}
  static int attach_child_main(void* data)
 		}
 	}
 
	 
	close(procfd);

 	 
 	rexit(payload->exec_function(payload->exec_payload));
 }","attach.c in LXC 1.1.2 and earlier uses the proc filesystem in a container, which allows local container users to escape AppArmor or SELinux confinement by mounting a proc filesystem with a crafted (1) AppArmor profile or (2) SELinux label."
517,CVE-2015-1333,"  void __key_link_end(struct key *keyring,
 	if (index_key->type == &key_type_keyring)
 		up_write(&keyring_serialise_link_sem);
 
	if (edit) {
		if (!edit->dead_leaf) {
			key_payload_reserve(keyring,
				keyring->datalen - KEYQUOTA_LINK_BYTES);
		}
 		assoc_array_cancel_edit(edit);
 	}
 	up_write(&keyring->sem);",Memory leak in the __key_link_end function in security/keys/keyring.c in the Linux kernel before 4.1.4 allows local users to cause a denial of service (memory consumption) via many add_key system calls that refer to existing keys.
518,CVE-2015-1331,"  static char *lxclock_name(const char *p, const char *n)
 	char *rundir;
 
 	 
 
	 
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
  static char *lxclock_name(const char *p, const char *n)
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;",lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.
519,CVE-2015-1191,"  local void process(char *path)
                  "" (use -f to force)"");
     }
     else {
        char *to = g.inf, *sufx = """";
        size_t pre = 0;

         
        if (g.decode) {
             
            if ((g.headis & 1) != 0 && g.hname != NULL) {
                pre = justname(g.inf) - g.inf;
                to = justname(g.hname);
                len = strlen(to);
            }
             
            else if (strcmp(to + len, "".tgz"") == 0)
                sufx = "".tar"";
         }
        else
             
            sufx = g.sufx;
 
          
        g.outf = MALLOC(pre + len + strlen(sufx) + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
        memcpy(g.outf, g.inf, pre);
        memcpy(g.outf + pre, to, len);
        strcpy(g.outf + pre + len, sufx);
         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                              (g.force ? 0 : O_EXCL), 0600);
 
          
         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.
520,CVE-2015-0856,"  namespace SDDM {
             env.insert(QStringLiteral(""XDG_VTNR""), QString::number(m_display->terminalId()));
             env.insert(QStringLiteral(""XDG_SESSION_CLASS""), QStringLiteral(""greeter""));
             env.insert(QStringLiteral(""XDG_SESSION_TYPE""), m_display->sessionType());

             
             
            env.insert(QStringLiteral(""KDE_DEBUG""), QStringLiteral(""1""));
             m_auth->insertEnvironment(env);
 
              ","daemon/Greeter.cpp in sddm before 0.13.0 does not properly disable the KDE crash handler, which allows local users to gain privileges by crashing a greeter when using certain themes, as demonstrated by the plasma-workspace breeze theme."
521,CVE-2015-0823," 
 
 #define DROP_THIS_TABLE(...) \
   do { \
     OTS_FAILURE_MSG_(file, TABLE_NAME "": "" __VA_ARGS__); \
     OTS_FAILURE_MSG(""Table discarded""); \
    delete file->gasp; \
    file->gasp = 0; \
   } while (0)
 
 namespace ots {","Multiple use-after-free vulnerabilities in OpenType Sanitiser, as used in Mozilla Firefox before 36.0, might allow remote attackers to trigger problematic Developer Console information or possibly have unspecified other impact by leveraging incorrect macro expansion, related to the ots::ots_gasp_parse function."
522,CVE-2015-0278,"  static void uv__process_child_init(const uv_process_options_t* options,
     _exit(127);
   }
 
  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
     
    SAVE_ERRNO(setgroups(0, NULL));
  }

   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {
     uv__write_int(error_fd, -errno);
     perror(""setgid()"");","libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors."
523,CVE-2015-0275,"  static long ext4_zero_range(struct file *file, loff_t offset,
 	else
 		max_blocks -= lblk;
 
 	mutex_lock(&inode->i_mutex);
 
 	 
 	}
 
	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
	if (mode & FALLOC_FL_KEEP_SIZE)
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;

	 
	if (partial_begin || partial_end) {
		ret = ext4_alloc_file_blocks(file,
				round_down(offset, 1 << blkbits) >> blkbits,
				(round_up((offset + len), 1 << blkbits) -
				 round_down(offset, 1 << blkbits)) >> blkbits,
				new_size, flags, mode);
		if (ret)
			goto out_mutex;

	}

	 
 	if (max_blocks > 0) {
		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
			  EXT4_EX_NOCACHE);
 
 		 
 		truncate_pagecache_range(inode, start, end - 1);",The ext4_zero_range function in fs/ext4/extents.c in the Linux kernel before 4.1 allows local users to cause a denial of service (BUG) via a crafted fallocate zero-range request.
524,CVE-2015-0274,"  xfs_attr_calc_size(
 		 * Out of line attribute, cannot double split, but
 		 * make room for the attribute value itself.
 		 */
		uint	dblocks = xfs_attr3_rmt_blocks(mp, valuelen);
 		nblks += dblocks;
 		nblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);
 	}
  xfs_attr_leaf_addname(xfs_da_args_t *args)
 
 		trace_xfs_attr_leaf_replace(args);
 
		 
 		args->op_flags |= XFS_DA_OP_RENAME;	 
 		args->blkno2 = args->blkno;		 
 		args->index2 = args->index;
 		args->rmtblkno2 = args->rmtblkno;
 		args->rmtblkcnt2 = args->rmtblkcnt;
		args->rmtvaluelen2 = args->rmtvaluelen;

		 
		args->rmtblkno = 0;
		args->rmtblkcnt = 0;
		args->rmtvaluelen = 0;
 	}
 
 	 
 		args->op_flags |= XFS_DA_OP_RENAME;	 
 		args->blkno2 = args->blkno;		 
 		args->index2 = args->index;
 		args->rmtblkno2 = args->rmtblkno;
 		args->rmtblkcnt2 = args->rmtblkcnt;
		args->rmtvaluelen2 = args->rmtvaluelen;

		 
 		args->rmtblkno = 0;
 		args->rmtblkcnt = 0;
		args->rmtvaluelen = 0;
 	}
 
 	retval = xfs_attr3_leaf_add(blk->bp, state->args);
  xfs_attr_node_addname(xfs_da_args_t *args)
 		args->blkno = args->blkno2;
 		args->rmtblkno = args->rmtblkno2;
 		args->rmtblkcnt = args->rmtblkcnt2;
		args->rmtvaluelen = args->rmtvaluelen2;
 		if (args->rmtblkno) {
 			error = xfs_attr_rmtval_remove(args);
 			if (error)","The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access."
525,CVE-2015-0239,"  static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	 * Not recognized on AMD in compat mode (but is recognized in legacy
 	 * mode).
 	 */
	if ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)
 	    && !vendor_intel(ctxt))
 		return emulate_ud(ctxt);
 
  static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	setup_syscalls_segments(ctxt, &cs, &ss);
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);
	if ((msr_data & 0xfffc) == 0x0)
		return emulate_gp(ctxt, 0);
 
 	ctxt->eflags &= ~(EFLG_VM | EFLG_IF);
	cs_sel = (u16)msr_data & ~SELECTOR_RPL_MASK;
 	ss_sel = cs_sel + 8;
	if (efer & EFER_LMA) {
 		cs.d = 0;
 		cs.l = 1;
 	}
  static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);
	ctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);
	*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :
							      (u32)msr_data;
 
 	return X86EMUL_CONTINUE;
 }","The em_sysenter function in arch/x86/kvm/emulate.c in the Linux kernel before 3.18.5, when the guest OS lacks SYSENTER MSR initialization, allows guest OS users to gain guest OS privileges or cause a denial of service (guest OS crash) by triggering use of a 16-bit code segment for emulation of a SYSENTER instruction."
526,CVE-2015-0206,"  dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
 	 
 	if (pqueue_size(queue->q) >= 100)
 		return 0;

 	rdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));
 	item = pitem_new(priority, rdata);
 	if (rdata == NULL || item == NULL)
  dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
 	if (!ssl3_setup_buffers(s))
 		{
 		SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
		if (rdata->rbuf.buf != NULL)
			OPENSSL_free(rdata->rbuf.buf);
 		OPENSSL_free(rdata);
 		pitem_free(item);
		return(-1);
 		}
 
 	 
 	if (pqueue_insert(queue->q, item) == NULL)
 		{
 		SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
		if (rdata->rbuf.buf != NULL)
			OPENSSL_free(rdata->rbuf.buf);
 		OPENSSL_free(rdata);
 		pitem_free(item);
		return(-1);
 		}
 
 	return(1);
  dtls1_process_buffered_records(SSL *s)
             dtls1_get_unprocessed_record(s);
             if ( ! dtls1_process_record(s))
                 return(0);
            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),
                s->s3->rrec.seq_num)<0)
                return -1;
             }
         }
 
  printf(""\n"");
 
 	 
 	s->packet_length=0;
 	return(1);
 
 f_err:
  int dtls1_get_record(SSL *s)
 
 	 
	if(dtls1_process_buffered_records(s)<0)
		return -1;
 
 	 
 	if (dtls1_get_processed_record(s))
  int dtls1_get_record(SSL *s)
 		{
 		if ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)
 			{
			if(dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num)<0)
				return -1;
			dtls1_record_bitmap_update(s, bitmap); 
 			}
 		rr->length = 0;
 		s->packet_length = 0;
  int dtls1_get_record(SSL *s)
 		s->packet_length = 0;   
 		goto again;    
 		}
	dtls1_record_bitmap_update(s, bitmap); 
 
 	return(1);
 
  int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
 		 * buffer the application data for later processing rather
 		 * than dropping the connection.
 		 */
		if(dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num)<0)
			{
			SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
			return -1;
			}
 		rr->length = 0;
 		goto start;
 		}","Memory leak in the dtls1_buffer_record function in d1_pkt.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate records for the next epoch, leading to failure of replay detection."
527,CVE-2015-0205,"  int ssl3_get_cert_verify(SSL *s)
 	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
 		{
 		s->s3->tmp.reuse_message=1;
		if (peer != NULL)
 			{
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);","The ssl3_get_cert_verify function in s3_srvr.c in OpenSSL 1.0.0 before 1.0.0p and 1.0.1 before 1.0.1k accepts client authentication with a Diffie-Hellman (DH) certificate without requiring a CertificateVerify message, which allows remote attackers to obtain access without knowledge of a private key via crafted TLS Handshake Protocol traffic to a server that recognizes a Certification Authority with DH support."
528,CVE-2014-9756," 
 /*
** Copyright (C) 2002-2014 Erik de Castro Lopo <erikd@mega-nerd.com>
 ** Copyright (C) 2003 Ross Bencina <rbencina@iprimus.com.au>
 **
 ** This program is free software; you can redistribute it and/or modify
  psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf
 {	sf_count_t total = 0 ;
 	ssize_t	count ;
 
	if (bytes == 0 || items == 0)
		return 0 ;

 	if (psf->virtual_io)
 		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;
 ",The psf_fwrite function in file_io.c in libsndfile allows attackers to cause a denial of service (divide-by-zero error and application crash) via unspecified vectors related to the headindex variable.
529,CVE-2014-9731,"  static int udf_readdir(struct file *file, struct dir_context *ctx)
 			continue;
 		}
 
		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
					UDF_NAME_LEN);
 		if (!flen)
 			continue;
 ","The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c."
530,CVE-2014-9730,"  static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 	tolen--;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
		elen += sizeof(struct pathComponent);
 		switch (pc->componentType) {
 		case 1:
 			 
			if (pc->lengthComponentIdent > 0) {
				elen += pc->lengthComponentIdent;
 				break;
			}
 			 
 		case 2:
 			if (tolen == 0)
  static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 			 
 			break;
 		case 5:
			elen += pc->lengthComponentIdent;
			if (elen > fromlen)
				return -EIO;
 			comp_len = udf_get_filename(sb, pc->componentIdent,
 						    pc->lengthComponentIdent,
 						    p, tolen);
  static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 			tolen--;
 			break;
 		}
 	}
 	if (p > to + 1)
 		p[-1] = '\0';","The udf_pc_to_char function in fs/udf/symlink.c in the Linux kernel before 3.18.2 relies on component lengths that are unused, which allows local users to cause a denial of service (system crash) via a crafted UDF filesystem image."
531,CVE-2014-9729,"  static int udf_read_inode(struct inode *inode, bool hidden_inode)
 	}
 	inode->i_generation = iinfo->i_unique;
 
	 
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		 
		if (iinfo->i_lenAlloc != inode->i_size)
			goto out;
		 
		if (inode->i_size > inode->i_sb->s_blocksize -
					udf_file_entry_alloc_offset(inode))
			goto out;
	}

 	switch (fe->icbTag.fileType) {
 	case ICBTAG_FILE_TYPE_DIRECTORY:
 		inode->i_op = &udf_dir_inode_operations;","The udf_read_inode function in fs/udf/inode.c in the Linux kernel before 3.18.2 does not ensure a certain data-structure size consistency, which allows local users to cause a denial of service (system crash) via a crafted UDF filesystem image."
532,CVE-2014-9728,"  static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 	tolen--;
 	while (elen < fromlen) {
 		pc = (struct pathComponent *)(from + elen);
		elen += sizeof(struct pathComponent);
 		switch (pc->componentType) {
 		case 1:
 			 
			if (pc->lengthComponentIdent > 0) {
				elen += pc->lengthComponentIdent;
 				break;
			}
 			 
 		case 2:
 			if (tolen == 0)
  static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 			 
 			break;
 		case 5:
			elen += pc->lengthComponentIdent;
			if (elen > fromlen)
				return -EIO;
 			comp_len = udf_get_filename(sb, pc->componentIdent,
 						    pc->lengthComponentIdent,
 						    p, tolen);
  static int udf_pc_to_char(struct super_block *sb, unsigned char *from,
 			tolen--;
 			break;
 		}
 	}
 	if (p > to + 1)
 		p[-1] = '\0';","The UDF filesystem implementation in the Linux kernel before 3.18.2 does not validate certain lengths, which allows local users to cause a denial of service (buffer over-read and system crash) via a crafted filesystem image, related to fs/udf/inode.c and fs/udf/symlink.c."
533,CVE-2014-9715,"  enum nf_ct_ext_id {
  
 struct nf_ct_ext {
 	struct rcu_head rcu;
	u16 offset[NF_CT_EXT_NUM];
	u16 len;
 	char data[0];
 };
 ","include/net/netfilter/nf_conntrack_extend.h in the netfilter subsystem in the Linux kernel before 3.14.5 uses an insufficiently large data type for certain extension data, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via outbound network traffic that triggers extension loading, as demonstrated by configuring a PPTP tunnel in a NAT environment."
534,CVE-2014-9714,"  bool WddxPacket::recursiveAddVar(const String& varName,
 
   std::string varType = getDataTypeString(varVariant.getType()).data();
   if (!getWddxEncoded(varType, """", varName, false).empty()) {
    std::string varValue;
     if (varType.compare(""boolean"") == 0) {
       varValue = varVariant.toBoolean() ? ""true"" : ""false"";
    } else {
      varValue = StringUtil::HtmlEncode(varVariant.toString(),
                                        StringUtil::QuoteStyle::Double,
                                        ""UTF-8"", false, false).toCppString();
     }
     m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);
     return true;",Cross-site scripting (XSS) vulnerability in the WddxPacket::recursiveAddVar function in HHVM (aka the HipHop Virtual Machine) before 3.5.0 allows remote attackers to inject arbitrary web script or HTML via a crafted string to the wddx_serialize_value function.
535,CVE-2014-9710,"  int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root
 	 */
 	if (!p->leave_spinning)
 		btrfs_set_path_blocking(p);
	if (ret < 0 && !p->skip_release_on_error)
 		btrfs_release_path(p);
 	return ret;
 }","The Btrfs implementation in the Linux kernel before 3.19 does not ensure that the visible xattr state is consistent with a requested replacement, which allows local users to bypass intended ACL settings and gain privileges via standard filesystem operations (1) during an xattr-replacement time window, related to a race condition, or (2) after an xattr-replacement attempt that fails because the data does not fit."
536,CVE-2014-9707,"  PUBLIC int websUrlParse(char *url, char **buf, char **protocol, char **host, cha
  */
 PUBLIC bool websValid(Webs *wp);
 
 
PUBLIC char *websValidateUriPath(char *uri);

 /**
     Write a set of standard response headers
     @param wp Webs request object","EmbedThis GoAhead 3.0.0 through 3.4.1 does not properly handle path segments starting with a . (dot), which allows remote attackers to conduct directory traversal attacks, cause a denial of service (heap-based buffer overflow and crash), or possibly execute arbitrary code via a crafted URI."
537,CVE-2014-9683,"  ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,
 			break;
 		case 2:
 			dst[dst_byte_offset++] |= (src_byte);
 			current_bit_offset = 0;
 			break;
 		}",Off-by-one error in the ecryptfs_decode_from_filename function in fs/ecryptfs/crypto.c in the eCryptfs subsystem in the Linux kernel before 3.18.2 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted filename.
538,CVE-2014-9653," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.114 2014/12/11 14:19:36 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,
 	 * Loop through all the program headers.
 	 */
 	for ( ; num; num--) {
		if (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {
 			file_badread(ms);
 			return -1;
 		}
  doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
 	uint64_t cap_hw1 = 0;	 
 	uint64_t cap_sf1 = 0;	 
 	char name[50];
	ssize_t namesize;
 
 	if (size != xsh_sizeof) {
 		if (file_printf(ms, "", corrupted section header size"") == -1)
  doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
 	}
 
 	 
	if (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) < (ssize_t)xsh_sizeof) {
 		file_badread(ms);
 		return -1;
 	}
 	name_off = xsh_offset;
 
 	for ( ; num; num--) {
 		 
		if ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {
 			file_badread(ms);
 			return -1;
 		}
		name[namesize] = '\0';
 		if (strcmp(name, "".debug_info"") == 0)
 			stripped = 0;
 
		if (pread(fd, xsh_addr, xsh_sizeof, off) < (ssize_t)xsh_sizeof) {
 			file_badread(ms);
 			return -1;
 		}
  doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
 				    "" for note"");
 				return -1;
 			}
			if (pread(fd, nbuf, xsh_size, xsh_offset) < (ssize_t)xsh_size) {
 				file_badread(ms);
 				free(nbuf);
 				return -1;
  dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,
 	}
 
   	for ( ; num; num--) {
		if (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {
 			file_badread(ms);
 			return -1;
 		}","readelf.c in file before 5.22, as used in the Fileinfo component in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5, does not consider that pread calls sometimes read only a subset of the available data, which allows remote attackers to cause a denial of service (uninitialized memory access) or possibly have unspecified other impact via a crafted ELF file."
539,CVE-2014-9652," 
 #include ""file.h""
 
 #ifndef	lint
FILE_RCSID(""@(#)$File: softmagic.c,v 1.196 2014/11/07 15:24:14 christos Exp $"")
 #endif	 
 
 #include ""magic.h""
  mconvert(struct magic_set *ms, struct magic *m, int flip)
 		size_t sz = file_pstring_length_size(m);
 		char *ptr1 = p->s, *ptr2 = ptr1 + sz;
 		size_t len = file_pstring_get_length(m, ptr1);
		sz = sizeof(p->s) - sz;  
		if (len >= sz) {
 			  
			len = sz;
 		}
 		while (len--)
 			*ptr1++ = *ptr2++;","The mconvert function in softmagic.c in file before 5.21, as used in the Fileinfo component in PHP before 5.4.37, 5.5.x before 5.5.21, and 5.6.x before 5.6.5, does not properly handle a certain string-length field during a copy of a truncated version of a Pascal string, which might allow remote attackers to cause a denial of service (out-of-bounds memory access and application crash) via a crafted file."
540,CVE-2014-9644," 
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
#include <linux/crypto.h>
 #include <asm/i387.h>
 
 struct crypto_fpu_ctx {
  void __exit crypto_fpu_exit(void)
 {
 	crypto_unregister_template(&crypto_fpu_tmpl);
 }

MODULE_ALIAS_CRYPTO(""fpu"");","The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a parenthesized module template expression in the salg_name field, as demonstrated by the vfat(aes) expression, a different vulnerability than CVE-2013-7421."
541,CVE-2014-9621," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.116 2014/12/16 23:18:40 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,
 	}
 
 	if (namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0) {
		if (descsz > 100)
			descsz = 100;
 		switch (xnh_type) {
 	    	case NT_NETBSD_VERSION:
 			return size;
 		case NT_NETBSD_MARCH:
 			if (*flags & FLAGS_DID_NETBSD_MARCH)
 				return size;
			*flags |= FLAGS_DID_NETBSD_MARCH;
			if (file_printf(ms, "", compiled for: %.*s"",
			    (int)descsz, (const char *)&nbuf[doff]) == -1)
 				return size;
 			break;
 		case NT_NETBSD_CMODEL:
 			if (*flags & FLAGS_DID_NETBSD_CMODEL)
 				return size;
			*flags |= FLAGS_DID_NETBSD_CMODEL;
 			if (file_printf(ms, "", compiler model: %.*s"",
 			    (int)descsz, (const char *)&nbuf[doff]) == -1)
 				return size;
 			break;
 		default:
 			if (*flags & FLAGS_DID_NETBSD_UNKNOWN)
 				return size;
			*flags |= FLAGS_DID_NETBSD_UNKNOWN;
 			if (file_printf(ms, "", note=%u"", xnh_type) == -1)
 				return size;
 			break;",The ELF parser in file 5.16 through 5.21 allows remote attackers to cause a denial of service via a long string.
542,CVE-2014-9584,"  parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			rs.cont_size = isonum_733(rr->u.CE.size);
 			break;
 		case SIG('E', 'R'):
			 
			if (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)
				goto out;
 			ISOFS_SB(inode->i_sb)->s_rock = 1;
 			printk(KERN_DEBUG ""ISO 9660 Extensions: "");
 			{","The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel before 3.18.2 does not validate a length value in the Extensions Reference (ER) System Use Field, which allows local users to obtain sensitive information from kernel memory via a crafted iso9660 image."
543,CVE-2014-9529,"  static noinline void key_gc_unused_keys(struct list_head *keys)
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
 		 
 		if (key->type->destroy)
 			key->type->destroy(key);
 
		key_user_put(key->user);

 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING",Race condition in the key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 3.18.2 allows local users to cause a denial of service (memory corruption or panic) or possibly have unspecified other impact via keyctl commands that trigger access to a key structure member during garbage collection of a key.
544,CVE-2014-9496,"  sd2_parse_rsrc_fork (SF_PRIVATE *psf)
 
 	rsrc.type_offset = rsrc.map_offset + 30 ;
 
	if (rsrc.map_offset + 28 > rsrc.rsrc_len)
	{	psf_log_printf (psf, ""Bad map offset.\n"") ;
		goto parse_rsrc_fork_cleanup ;
		} ;

 	rsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;
 	if (rsrc.type_count < 1)
 	{	psf_log_printf (psf, ""Bad type count.\n"") ;
  sd2_parse_rsrc_fork (SF_PRIVATE *psf)
 
 	rsrc.str_index = -1 ;
 	for (k = 0 ; k < rsrc.type_count ; k ++)
	{	if (rsrc.type_offset + k * 8 > rsrc.rsrc_len)
		{	psf_log_printf (psf, ""Bad rsrc marker.\n"") ;
			goto parse_rsrc_fork_cleanup ;
			} ;

		marker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;
 
 		if (marker == STR_MARKER)
 		{	rsrc.str_index = k ;","The sd2_parse_rsrc_fork function in sd2.c in libsndfile allows attackers to have unspecified impact via vectors related to a (1) map offset or (2) rsrc marker, which triggers an out-of-bounds read."
545,CVE-2014-9491,"  devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,
 		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
 	}
 
	ptr = strchr(ptr + 1, '/');
	if (ptr == NULL)
		return (ENOENT);
	ptr++;
 	rw_exit(&sdvp->sdev_contents);
 	sdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);
 	rw_enter(&sdvp->sdev_contents, RW_READER);","The devzvol_readdir function in illumos does not check the return value of a strchr call, which allows remote attackers to cause a denial of service (NULL pointer dereference and panic) via unspecified vectors."
546,CVE-2014-9428,"  batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)
 	kfree(entry);
 
 	 
	if (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {
 		kfree_skb(skb_out);
 		skb_out = NULL;
 		goto free;","The batadv_frag_merge_packets function in net/batman-adv/fragmentation.c in the B.A.T.M.A.N. implementation in the Linux kernel through 3.18.1 uses an incorrect length field during a calculation of an amount of memory, which allows remote attackers to cause a denial of service (mesh-node system crash) via fragmented packets."
547,CVE-2014-9423,"  do {								\
  */
 typedef struct gss_union_ctx_id_struct {
 	struct gss_union_ctx_id_struct *loopback;
 	gss_OID			mech_type;
 	gss_ctx_id_t		internal_ctx_id;
 } gss_union_ctx_id_desc, *gss_union_ctx_id_t;","The svcauth_gss_accept_sec_context function in lib/rpc/svc_auth_gss.c in MIT Kerberos 5 (aka krb5) 1.11.x through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 transmits uninitialized interposer data to clients, which allows remote attackers to obtain sensitive information from process heap memory by sniffing the network for data in a handle field."
548,CVE-2014-9422," 
  *
  */
 
#include <k5-int.h>
 #include <gssrpc/rpc.h>
 #include <gssapi/gssapi_krb5.h>  
 #include <syslog.h>
  check_rpcsec_auth(struct svc_req *rqstp)
      c1 = krb5_princ_component(kctx, princ, 0);
      c2 = krb5_princ_component(kctx, princ, 1);
      realm = krb5_princ_realm(kctx, princ);
     success = data_eq_string(*realm, handle->params.realm) &&
	     data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");
 
 fail_princ:
      if (!success) {","The check_rpcsec_auth function in kadmin/server/kadm_rpc_svc.c in kadmind in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 allows remote authenticated users to bypass a kadmin/* authorization check and obtain administrative access by leveraging access to a two-component principal with an initial *kadmind* substring, as demonstrated by a *ka/x* principal."
549,CVE-2014-9421,"  bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)
 	       free(tl);
 	       tl = tl2;
 	  }
	  *tl_data_head = NULL;
 	  break;
 
      case XDR_ENCODE:
  xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)
     case XDR_FREE:
 	if(*objp != NULL)
 	    krb5_free_principal(context, *objp);
	*objp = NULL;
 	break;
     }
     return TRUE;","The auth_gssapi_unwrap_data function in lib/rpc/auth_gssapi_misc.c in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 does not properly handle partial XDR deserialization, which allows remote authenticated users to cause a denial of service (use-after-free and double free, and daemon crash) or possibly execute arbitrary code via malformed XDR data, as demonstrated by data sent to kadmind."
550,CVE-2014-8275,"  int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
 
 	if (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)
 		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
 		return -1;
 		}
 ","OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not enforce certain constraints on certificate data, which allows remote attackers to defeat a fingerprint-based certificate-blacklist protection mechanism by including crafted data within a certificate's unsigned portion, related to crypto/asn1/a_verify.c, crypto/dsa/dsa_asn1.c, crypto/ecdsa/ecs_vrf.c, and crypto/x509/x_all.c."
551,CVE-2014-8176,"  static void dtls1_clear_queues(SSL *s)
 
 	while ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)
 		{
		rdata = (DTLS1_RECORD_DATA *) item->data;
		if (rdata->rbuf.buf)
			{
			OPENSSL_free(rdata->rbuf.buf);
			}
		OPENSSL_free(item->data);
 		pitem_free(item);
 		}
 	}","The dtls1_clear_queues function in ssl/d1_lib.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h frees data structures without considering that application data can arrive between a ChangeCipherSpec message and a Finished message, which allows remote DTLS peers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via unexpected application data."
552,CVE-2014-8173,"  static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 	barrier();
 #endif
	if (pmd_none(pmdval) || pmd_trans_huge(pmdval))
 		return 1;
 	if (unlikely(pmd_bad(pmdval))) {
		pmd_clear_bad(pmd);
 		return 1;
 	}
 	return 0;","The pmd_none_or_trans_huge_or_clear_bad function in include/asm-generic/pgtable.h in the Linux kernel before 3.13 on NUMA systems does not properly determine whether a Page Middle Directory (PMD) entry is a transparent huge-table entry, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted MADV_WILLNEED madvise system call that leverages the absence of a page-table lock."
553,CVE-2014-8172,"  struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
  
 static struct kmem_cache *filp_cachep __read_mostly;
 
  struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
  void fput(struct file *file)
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
  void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
  void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
 		file_free(file);
 	}
 }
 
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
  void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
 	percpu_counter_init(&nr_files, 0);
 } ","The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations."
554,CVE-2014-8160," 
 
 static unsigned int nf_ct_generic_timeout __read_mostly = 600*HZ;
 
static bool nf_generic_should_process(u8 proto)
{
	switch (proto) {
#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE
	case IPPROTO_SCTP:
		return false;
#endif
#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE
	case IPPROTO_DCCP:
		return false;
#endif
#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE
	case IPPROTO_GRE:
		return false;
#endif
#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE
	case IPPROTO_UDPLITE:
		return false;
#endif
	default:
		return true;
	}
}

 static inline struct nf_generic_net *generic_pernet(struct net *net)
 {
 	return &net->ct.nf_ct_proto.generic;
  static int generic_packet(struct nf_conn *ct,
 static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
	return nf_generic_should_process(nf_ct_protonum(ct));
 }
 
 #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)","net/netfilter/nf_conntrack_proto_generic.c in the Linux kernel before 3.18 generates incorrect conntrack entries during handling of certain iptables rule sets for the SCTP, DCCP, GRE, and UDP-Lite protocols, which allows remote attackers to bypass intended access restrictions via packets with disallowed port numbers."
555,CVE-2014-7822,"  const struct file_operations def_blk_fops = {
 	.compat_ioctl	= compat_blkdev_ioctl,
 #endif
 	.splice_read	= generic_file_splice_read,
	.splice_write	= iter_file_splice_write,
 };
 
 int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)","The implementation of certain splice_write file operations in the Linux kernel before 3.16 does not enforce a restriction on the maximum size of a single file, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted splice system call, as demonstrated by use of a file descriptor associated with an ext4 filesystem."
556,CVE-2014-5355,"  int main(argc, argv)
     }
 #endif
 
     
     retval = krb5_read_message(context, (krb5_pointer) &sock, &pname_data);
    if (retval || pname_data.length == 0 ||
        pname_data.data[pname_data.length - 1] != '\0') {
         com_err (""uu-server"", retval, ""reading pname"");
         return 2;
     }","MIT Kerberos 5 (aka krb5) through 1.13.1 incorrectly expects that a krb5_read_message data field is represented as a string ending with a '0' character, which allows remote attackers to (1) cause a denial of service (NULL pointer dereference) via a zero-byte version string or (2) cause a denial of service (out-of-bounds read) by omitting the '0' character, related to appl/user_user/server.c and lib/krb5/krb/recvauth.c."
557,CVE-2014-5352,"  krb5_gss_context_time(minor_status, context_handle, time_rec)
 
     ctx = (krb5_gss_ctx_id_rec *) context_handle;
 
    if (ctx->terminated || !ctx->established) {
         *minor_status = KG_CTX_INCOMPLETE;
         return(GSS_S_NO_CONTEXT);
     }","The krb5_gss_process_context_token function in lib/gssapi/krb5/process_context_token.c in the libgssapi_krb5 library in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 does not properly maintain security-context handles, which allows remote authenticated users to cause a denial of service (use-after-free and double free, and daemon crash) or possibly execute arbitrary code via crafted GSSAPI traffic, as demonstrated by traffic to kadmind."
558,CVE-2014-3571,"  int dtls1_get_record(SSL *s)
 		 * would be dropped unnecessarily.
 		 */
 		if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
		    s->packet_length > DTLS1_RT_HEADER_LENGTH &&
		    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&
 		    !dtls1_record_replay_check(s, bitmap))
 			{
 			rr->length = 0;","OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted DTLS message that is processed with a different read operation for the handshake header than for the handshake body, related to the dtls1_get_record function in d1_pkt.c and the ssl3_read_n function in s3_pkt.c."
559,CVE-2014-3148," 
 
 #include ""resp.h""
 #include ""ahttp.h""
#include ""pescape.h""
 
 strbuf
 http_error_t::make_body (int n, const str &si, const str &aux)
 {
   strbuf b;
   str ldesc;
  const str sdesc = xss_escape (http_status.get_desc (n, &ldesc));
   b << ""<html>\n""
     << "" <head>\n""
     << ""  <title>"" << n << "" "" << sdesc << ""</title>\n""
  http_error_t::make_body (int n, const str &si, const str &aux)
     << "" <h1>Error "" << n << "" "" << sdesc << ""</h1><br><br>\n""
     ;
   if (n == HTTP_NOT_FOUND && aux) {
    b << ""The file <tt>"" << xss_escape (aux)
       << ""</tt> was not found on this server.<br><br>\n\n"";
   }
   b << ""  <hr>\n""
    << ""  <i>"" << xss_escape (si) << ""</i>\n""
     << "" <br>\n""
     << "" </body>\n""
     << ""</html>\n""","Cross-site scripting (XSS) vulnerability in libahttp/err.c in OkCupid OKWS (OK Web Server) allows remote attackers to inject arbitrary web script or HTML via the PATH_INFO to a non-existent page, which is not properly handled in a 404 error page."
560,CVE-2013-7446,"  struct unix_sock {
 #define UNIX_GC_CANDIDATE	0
 #define UNIX_GC_MAYBE_CYCLE	1
 	struct socket_wq	peer_wq;
	wait_queue_t		peer_wake;
 };
 
 static inline struct unix_sock *unix_sk(const struct sock *sk)",Use-after-free vulnerability in net/unix/af_unix.c in the Linux kernel before 4.3.3 allows local users to bypass intended AF_UNIX socket permissions or cause a denial of service (panic) via crafted epoll_ctl calls.
561,CVE-2013-7441,"  void destroy_pid_t(gpointer data) {
 	g_free(data);
 }
 
static pid_t
spawn_child()
{
        pid_t pid;
        sigset_t newset;
        sigset_t oldset;

        sigemptyset(&newset);
        sigaddset(&newset, SIGCHLD);
        sigaddset(&newset, SIGTERM);
        sigprocmask(SIG_BLOCK, &newset, &oldset);
        pid = fork();
        if (pid < 0) {
                msg(LOG_ERR, ""Could not fork (%s)"", strerror(errno));
                goto out;
        }
        if (pid > 0) {  
                pid_t *pidp;

                pidp = g_malloc(sizeof(pid_t));
                *pidp = pid;
                g_hash_table_insert(children, pidp, pidp);
                goto out;
        }
         
        signal(SIGCHLD, SIG_DFL);
        signal(SIGTERM, SIG_DFL);
        signal(SIGHUP, SIG_DFL);
out:
        sigprocmask(SIG_SETMASK, &oldset, NULL);
        return pid;
}

static int
socket_accept(const int sock)
{
        struct sockaddr_storage addrin;
        socklen_t addrinlen = sizeof(addrin);
        int net;

        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);
        if (net < 0) {
                err_nonfatal(""Failed to accept socket connection: %m"");
        }

        return net;
}

static void
handle_modern_connection(GArray *const servers, const int sock)
{
        int net;
        pid_t pid;
        CLIENT *client = NULL;
        int sock_flags_old;
        int sock_flags_new;

        net = socket_accept(sock);
        if (net < 0)
                return;

        if (!dontfork) {
                pid = spawn_child();
                if (pid) {
                        if (pid > 0)
                                msg(LOG_INFO, ""Spawned a child process"");
                        if (pid < 0)
                                msg(LOG_ERR, ""Failed to spawn a child process"");
                        close(net);
                        return;
                }
                 
        }

        client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);
        if (!client) {
                msg(LOG_ERR, ""Modern initial negotiation failed"");
                goto handler_err;
        }

        if (client->server->max_connections > 0 &&
           g_hash_table_size(children) >= client->server->max_connections) {
                msg(LOG_ERR, ""Max connections (%d) reached"",
                    client->server->max_connections);
                goto handler_err;
        }

        sock_flags_old = fcntl(net, F_GETFL, 0);
        if (sock_flags_old == -1) {
                msg(LOG_ERR, ""Failed to get socket flags"");
                goto handler_err;
        }

        sock_flags_new = sock_flags_old & ~O_NONBLOCK;
        if (sock_flags_new != sock_flags_old &&
            fcntl(net, F_SETFL, sock_flags_new) == -1) {
                msg(LOG_ERR, ""Failed to set socket to blocking mode"");
                goto handler_err;
        }

        if (set_peername(net, client)) {
                msg(LOG_ERR, ""Failed to set peername"");
                goto handler_err;
        }

        if (!authorized_client(client)) {
                msg(LOG_INFO, ""Client '%s' is not authorized to access"",
                    client->clientname);
                goto handler_err;
        }

        if (!dontfork) {
                int i;

                 
                g_hash_table_destroy(children);
                children = NULL;
                for (i = 0; i < modernsocks->len; i++) {
                        close(g_array_index(modernsocks, int, i));
                }
                g_array_free(modernsocks, TRUE);

                 

                for (i = 0; i < servers->len; i++) {
                        const SERVER *const server = &g_array_index(servers, SERVER, i);
                        close(server->socket);
                }

                 
                g_array_free(servers, FALSE);
        }

        msg(LOG_INFO, ""Starting to serve"");
        serveconnection(client);
        exit(EXIT_SUCCESS);

handler_err:
        g_free(client);
        close(net);

        if (!dontfork) {
                exit(EXIT_FAILURE);
        }
}

 static void
 handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)
 {
  void serveloop(GArray* servers) {
 
 		memcpy(&rset, &mset, sizeof(fd_set));
 		if(select(max+1, &rset, NULL, NULL, NULL)>0) {
 
 			DEBUG(""accept, "");
 			for(i=0; i < modernsocks->len; i++) {
 				int sock = g_array_index(modernsocks, int, i);
 				if(!FD_ISSET(sock, &rset)) {
 					continue;
 				}
 
				handle_modern_connection(servers, sock);
 			}
 			for(i=0; i < servers->len; i++) {
				int net;
 				SERVER *serve;
 
 				serve=&(g_array_index(servers, SERVER, i));",The modern style negotiation in Network Block Device (nbd-server) 2.9.22 through 3.3 allows remote attackers to cause a denial of service (root process termination) by (1) closing the connection during negotiation or (2) specifying a name for a non-existent export.
562,CVE-2013-7421,"  module_exit(aes_fini);
 
 MODULE_DESCRIPTION(""Rijndael (AES) Cipher Algorithm (ASM)"");
 MODULE_LICENSE(""GPL"");
MODULE_ALIAS_CRYPTO(""aes"");
MODULE_ALIAS_CRYPTO(""aes-asm"");
 MODULE_AUTHOR(""David McCullough <ucdevel@gmail.com>"");","The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644."
563,CVE-2016-10088,"  bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
 
 	dprintk(""%s: write %Zd bytes\n"", bd->name, count);
 
	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
		return -EINVAL;

 	bsg_set_block(bd, file);
 
 	bytes_written = 0;","The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576."
564,CVE-2016-9919,"  static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,
 
 	if (__ipv6_addr_needs_scope_id(addr_type))
 		iif = skb->dev->ifindex;
	else {
		dst = skb_dst(skb);
		iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);
	}
 
 	/*
 	 *	Must not send error if the source does not uniquely","The icmp6_send function in net/ipv6/icmp.c in the Linux kernel through 4.8.12 omits a certain check of the dst data structure, which allows remote attackers to cause a denial of service (panic) via a fragmented IPv6 packet."
565,CVE-2016-9806,"  static int netlink_dump(struct sock *sk)
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
	struct module *module;
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;
  static int netlink_dump(struct sock *sk)
 		cb->done(cb);
 
 	nlk->cb_running = false;
	module = cb->module;
	skb = cb->skb;
 	mutex_unlock(nlk->cb_mutex);
	module_put(module);
	consume_skb(skb);
 	return 0;
 
 errout_skb:","Race condition in the netlink_dump function in net/netlink/af_netlink.c in the Linux kernel before 4.6.3 allows local users to cause a denial of service (double free) or possibly have unspecified other impact via a crafted application that makes sendmsg system calls, leading to a free operation associated with a new dump that started earlier than anticipated."
566,CVE-2016-9794,"  void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)
 		snd_timer_interrupt(substream->timer, 1);
 #endif
  _end:
 	kill_fasync(&runtime->fasync, SIGIO, POLL_IN);
	snd_pcm_stream_unlock_irqrestore(substream, flags);
 }
 
 EXPORT_SYMBOL(snd_pcm_period_elapsed);",Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.
567,CVE-2016-9793,"  int sock_setsockopt(struct socket *sock, int level, int optname,
 		val = min_t(u32, val, sysctl_wmem_max);
 set_sndbuf:
 		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);
 		 
 		sk->sk_write_space(sk);
 		break;
  int sock_setsockopt(struct socket *sock, int level, int optname,
 		 * returning the value we actually used in getsockopt
 		 * is the most desirable behavior.
 		 */
		sk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);
 		break;
 
 	case SO_RCVBUFFORCE:","The sock_setsockopt function in net/core/sock.c in the Linux kernel before 4.8.14 mishandles negative values of sk_sndbuf and sk_rcvbuf, which allows local users to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability for a crafted setsockopt system call with the (1) SO_SNDBUFFORCE or (2) SO_RCVBUFFORCE option."
568,CVE-2016-9777,"  static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)
 {
 	ioapic->rtc_status.pending_eoi = 0;
	bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);
 }
 
 static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);","KVM in the Linux kernel before 4.8.12, when I/O APIC is enabled, does not properly restrict the VCPU index, which allows guest OS users to gain host OS privileges or cause a denial of service (out-of-bounds array access and host OS crash) via a crafted interrupt request, related to arch/x86/kvm/ioapic.c and arch/x86/kvm/ioapic.h."
569,CVE-2016-9756,"  static int em_iret(struct x86_emulate_ctxt *ctxt)
 static int em_jmp_far(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
	unsigned short sel;
	struct desc_struct new_desc;
 	u8 cpl = ctxt->ops->cpl(ctxt);
 
 	memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);
 
 	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,
  static int em_jmp_far(struct x86_emulate_ctxt *ctxt)
 		return rc;
 
 	rc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);
	 
	if (rc != X86EMUL_CONTINUE)
		return X86EMUL_UNHANDLEABLE;

 	return rc;
 }
 
  static int em_ret_far(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
 	unsigned long eip, cs;
 	int cpl = ctxt->ops->cpl(ctxt);
	struct desc_struct new_desc;
 
 	rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);
 	if (rc != X86EMUL_CONTINUE)
  static int em_ret_far(struct x86_emulate_ctxt *ctxt)
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 	rc = assign_eip_far(ctxt, eip, &new_desc);
	 
	if (rc != X86EMUL_CONTINUE)
		return X86EMUL_UNHANDLEABLE;

 	return rc;
 }
 ","arch/x86/kvm/emulate.c in the Linux kernel before 4.8.12 does not properly initialize Code Segment (CS) in certain error cases, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
570,CVE-2016-9755,"  int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)
 	 
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug(""payload len = 0\n"");
		return 0;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
		return 0;
 
 	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
 		return -ENOMEM;","The netfilter subsystem in the Linux kernel before 4.9 mishandles IPv6 reassembly, which allows local users to cause a denial of service (integer overflow, out-of-bounds write, and GPF) or possibly have unspecified other impact via a crafted application that makes socket, connect, and writev system calls, related to net/ipv6/netfilter/nf_conntrack_reasm.c and net/ipv6/netfilter/nf_defrag_ipv6_hooks.c."
571,CVE-2016-9685,"  xfs_attr_shortform_list(xfs_attr_list_context_t *context)
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
		if (error) {
			kmem_free(sbuf);
 			return error;
		}
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
  xfs_attr3_leaf_list_int(
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp->i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&args);
				if (!retval)
					retval = context->put_listent(context,
							entry->flags,
							name_rmt->name,
							(int)name_rmt->namelen,
							valuelen,
							args.value);
 				kmem_free(args.value);
 			} else {
 				retval = context->put_listent(context,",Multiple memory leaks in error paths in fs/xfs/xfs_attr_list.c in the Linux kernel before 4.5.1 allow local users to cause a denial of service (memory consumption) via crafted XFS filesystem operations.
572,CVE-2016-9588,"  static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)
 	return vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;
 }
 
static inline bool is_nmi(u32 intr_info)
 {
 	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))
		== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);
 }
 
 static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,
  static int handle_exception(struct kvm_vcpu *vcpu)
 	if (is_machine_check(intr_info))
 		return handle_machine_check(vcpu);
 
	if (is_nmi(intr_info))
 		return 1;   
 
 	if (is_no_device(intr_info)) {
  static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)
 
 	switch (exit_reason) {
 	case EXIT_REASON_EXCEPTION_NMI:
		if (is_nmi(intr_info))
 			return false;
 		else if (is_page_fault(intr_info))
 			return enable_ept;
  static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)
 		kvm_machine_check();
 
 	 
	if (is_nmi(exit_intr_info)) {
 		kvm_before_handle_nmi(&vmx->vcpu);
 		asm(""int $2"");
 		kvm_after_handle_nmi(&vmx->vcpu);","arch/x86/kvm/vmx.c in the Linux kernel through 4.9 mismanages the #BP and #OF exceptions, which allows guest OS users to cause a denial of service (guest OS crash) by declining to handle an exception thrown by an L2 guest."
573,CVE-2016-9576,"  int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
 	struct iov_iter i;
 	int ret;
 
	if (!iter_is_iovec(iter))
		goto fail;

 	if (map_data)
 		copy = true;
 	else if (iov_iter_alignment(iter) & align)
  int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,
 
 unmap_rq:
 	__blk_rq_unmap_user(bio);
fail:
 	rq->bio = NULL;
 	return -EINVAL;
 }","The blk_rq_map_user_iov function in block/blk-map.c in the Linux kernel before 4.8.14 does not properly restrict the type of iterator, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device."
574,CVE-2016-9555,"  sctp_disposition_t sctp_sf_ootb(struct net *net,
 			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
 						  commands);
 
		 
		ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
		if (ch_end > skb_tail_pointer(skb))
			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
						  commands);

 		 
  sctp_disposition_t sctp_sf_ootb(struct net *net,
 			}
 		}
 
 		ch = (sctp_chunkhdr_t *) ch_end;
 	} while (ch_end < skb_tail_pointer(skb));
 ","The sctp_sf_ootb function in net/sctp/sm_statefuns.c in the Linux kernel before 4.8.8 lacks chunk-length checking for the first chunk, which allows remote attackers to cause a denial of service (out-of-bounds slab access) or possibly have unspecified other impact via crafted SCTP data."
575,CVE-2016-9442,"  Strgrow(Str x)
 {
     char *old = x->ptr;
     int newlen;
    newlen = x->area_size * 6 / 5;
    if (newlen == x->area_size)
 	newlen += 2;
     x->ptr = GC_MALLOC_ATOMIC(newlen);
     x->area_size = newlen;",An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause memory corruption in certain conditions via a crafted HTML page.
576,CVE-2016-9313," 
  * 2 of the Licence, or (at your option) any later version.
  */
 
#define pr_fmt(fmt) ""big_key: ""fmt
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/file.h>
  long big_key_read(const struct key *key, char __user *buffer, size_t buflen)
  */
 static int __init big_key_init(void)
 {
	struct crypto_skcipher *cipher;
	struct crypto_rng *rng;
	int ret;
 
	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(rng)) {
		pr_err(""Can't alloc rng: %ld\n"", PTR_ERR(rng));
		return PTR_ERR(rng);
 	}
 
	big_key_rng = rng;

 	 
	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
	if (ret) {
		pr_err(""Can't reset rng: %d\n"", ret);
		goto error_rng;
	}
 
 	 
	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(cipher)) {
		ret = PTR_ERR(cipher);
		pr_err(""Can't alloc crypto: %d\n"", ret);
		goto error_rng;
	}

	big_key_skcipher = cipher;

	ret = register_key_type(&key_type_big_key);
	if (ret < 0) {
		pr_err(""Can't register type: %d\n"", ret);
		goto error_cipher;
 	}
 
 	return 0;
 
error_cipher:
	crypto_free_skcipher(big_key_skcipher);
error_rng:
 	crypto_free_rng(big_key_rng);
 	return ret;
 }
 
late_initcall(big_key_init);","security/keys/big_key.c in the Linux kernel before 4.8.7 mishandles unsuccessful crypto registration in conjunction with successful key-type registration, which allows local users to cause a denial of service (NULL pointer dereference and panic) or possibly have unspecified other impact via a crafted application that uses the big_key data type."
577,CVE-2016-9191,"  static int proc_sys_readdir(struct file *file, struct dir_context *ctx)
 	ctl_dir = container_of(head, struct ctl_dir, header);
 
 	if (!dir_emit_dots(file, ctx))
		goto out;
 
 	pos = 2;
 
  static int proc_sys_readdir(struct file *file, struct dir_context *ctx)
 			break;
 		}
 	}
out:
 	sysctl_head_finish(head);
 	return 0;
 }","The cgroup offline implementation in the Linux kernel through 4.8.11 mishandles certain drain operations, which allows local users to cause a denial of service (system hang) by leveraging access to a container environment for executing a crafted application, as demonstrated by trinity."
578,CVE-2016-9178,"  do {									\
 #define __get_user_asm_ex(x, addr, itype, rtype, ltype)			\
 	asm volatile(""1:	mov""itype"" %1,%""rtype""0\n""		\
 		     ""2:\n""						\
		     "".section .fixup,\""ax\""\n""				\
                     ""3:xor""itype"" %""rtype""0,%""rtype""0\n""		\
		     ""  jmp 2b\n""					\
		     "".previous\n""					\
		     _ASM_EXTABLE_EX(1b, 3b)				\
 		     : ltype(x) : ""m"" (__m(addr)))
 
 #define __put_user_nocheck(x, ptr, size)			\","The __get_user_asm_ex macro in arch/x86/include/asm/uaccess.h in the Linux kernel before 4.7.5 does not initialize a certain integer variable, which allows local users to obtain sensitive information from kernel stack memory by triggering failure of a get_user_ex call."
579,CVE-2016-9120,"  static void ion_handle_get(struct ion_handle *handle)
 	kref_get(&handle->ref);
 }
 
static int ion_handle_put_nolock(struct ion_handle *handle)
{
	int ret;

	ret = kref_put(&handle->ref, ion_handle_destroy);

	return ret;
}

int ion_handle_put(struct ion_handle *handle)
 {
 	struct ion_client *client = handle->client;
 	int ret;
 
 	mutex_lock(&client->lock);
	ret = ion_handle_put_nolock(handle);
 	mutex_unlock(&client->lock);
 
 	return ret;
  static struct ion_handle *ion_handle_lookup(struct ion_client *client,
 	return ERR_PTR(-EINVAL);
 }
 
static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,
 						int id)
 {
 	struct ion_handle *handle;
 
 	handle = idr_find(&client->idr, id);
 	if (handle)
 		ion_handle_get(handle);
 
 	return handle ? handle : ERR_PTR(-EINVAL);
 }
 
struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
						int id)
{
	struct ion_handle *handle;

	mutex_lock(&client->lock);
	handle = ion_handle_get_by_id_nolock(client, id);
	mutex_unlock(&client->lock);

	return handle;
}

 static bool ion_handle_validate(struct ion_client *client,
 				struct ion_handle *handle)
 {
  struct ion_handle *ion_alloc(struct ion_client *client, size_t len,
 }
 EXPORT_SYMBOL(ion_alloc);
 
static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)
 {
 	bool valid_handle;
 
 	BUG_ON(client != handle->client);
 
 	valid_handle = ion_handle_validate(client, handle);
 
 	if (!valid_handle) {
 		WARN(1, ""%s: invalid handle passed to free.\n"", __func__);
 		return;
 	}
	ion_handle_put_nolock(handle);
}

void ion_free(struct ion_client *client, struct ion_handle *handle)
{
	BUG_ON(client != handle->client);

	mutex_lock(&client->lock);
	ion_free_nolock(client, handle);
 	mutex_unlock(&client->lock);
 }
 EXPORT_SYMBOL(ion_free);
 
  static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	{
 		struct ion_handle *handle;
 
		mutex_lock(&client->lock);
		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);
		if (IS_ERR(handle)) {
			mutex_unlock(&client->lock);
 			return PTR_ERR(handle);
		}
		ion_free_nolock(client, handle);
		ion_handle_put_nolock(handle);
		mutex_unlock(&client->lock);
 		break;
 	}
 	case ION_IOC_SHARE:",Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.
580,CVE-2016-9084,"  static long vfio_pci_ioctl(void *device_data,
 
 	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
 		struct vfio_irq_set hdr;
		size_t size;
 		u8 *data = NULL;
		int max, ret = 0;
 
 		minsz = offsetofend(struct vfio_irq_set, count);
 
 		if (copy_from_user(&hdr, (void __user *)arg, minsz))
 			return -EFAULT;
 
 		if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
		    hdr.count >= (U32_MAX - hdr.start) ||
 		    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
 				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
 			return -EINVAL;
 
		max = vfio_pci_get_irq_count(vdev, hdr.index);
		if (hdr.start >= max || hdr.start + hdr.count > max)
			return -EINVAL;
 
		switch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {
		case VFIO_IRQ_SET_DATA_NONE:
			size = 0;
			break;
		case VFIO_IRQ_SET_DATA_BOOL:
			size = sizeof(uint8_t);
			break;
		case VFIO_IRQ_SET_DATA_EVENTFD:
			size = sizeof(int32_t);
			break;
		default:
			return -EINVAL;
		}
 
		if (size) {
			if (hdr.argsz - minsz < hdr.count * size)
 				return -EINVAL;
 
 			data = memdup_user((void __user *)(arg + minsz),","drivers/vfio/pci/vfio_pci_intrs.c in the Linux kernel through 4.8.11 misuses the kzalloc function, which allows local users to cause a denial of service (integer overflow) or have unspecified other impact by leveraging access to a vfio PCI device file."
581,CVE-2016-8858," 
 
 /*
  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
  *
  kex_input_kexinit(int type, u_int32_t seq, void *ctxt)
 	if (kex == NULL)
 		return SSH_ERR_INVALID_ARGUMENT;
 
	ssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);
 	ptr = sshpkt_ptr(ssh, &dlen);
 	if ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)
 		return r;",** DISPUTED ** The kex_input_kexinit function in kex.c in OpenSSH 6.x and 7.x through 7.3 allows remote attackers to cause a denial of service (memory consumption) by sending many duplicate KEXINIT requests.  NOTE: a third party reports that *OpenSSH upstream does not consider this as a security issue.*
582,CVE-2016-8666,"  struct napi_gro_cb {
 	 
 	u8	same_flow:1;
 
	 
	u8	encap_mark:1;
 
 	 
 	u8	csum_valid:1;","The IP stack in the Linux kernel before 4.6 allows remote attackers to cause a denial of service (stack consumption and panic) or possibly have unspecified other impact by triggering use of the GRO path for packets with tunnel stacking, as demonstrated by interleaved IPv4 headers and GRE headers, a related issue to CVE-2016-7039."
583,CVE-2016-8658,"  brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 				(u8 *)&settings->beacon.head[ie_offset],
 				settings->beacon.head_len - ie_offset,
 				WLAN_EID_SSID);
		if (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)
 			return -EINVAL;
 
 		memcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);",Stack-based buffer overflow in the brcmf_cfg80211_start_ap function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.7.5 allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a long SSID Information Element in a command to a Netlink socket.
584,CVE-2016-8655,"  packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 		switch (val) {
 		case TPACKET_V1:
 		case TPACKET_V2:
 		case TPACKET_V3:
			break;
 		default:
 			return -EINVAL;
 		}
		lock_sock(sk);
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {
			ret = -EBUSY;
		} else {
			po->tp_version = val;
			ret = 0;
		}
		release_sock(sk);
		return ret;
 	}
 	case PACKET_RESERVE:
 	{
  static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
 	 
 	struct tpacket_req *req = &req_u->req;
 
	lock_sock(sk);
 	 
 	if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {
 		net_warn_ratelimited(""Tx-ring is not supported.\n"");
  static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
 			goto out;
 	}
 
 
 	 
 	spin_lock(&po->bind_lock);
  static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
 		if (!tx_ring)
 			prb_shutdown_retire_blk_timer(po, rb_queue);
 	}
 
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req->tp_block_nr);
 out:
	release_sock(sk);
 	return err;
 }
 ","Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions."
585,CVE-2016-8650,"  int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)
 	if (!esize) {
 		 
 		res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;
		if (res->nlimbs) {
			if (mpi_resize(res, 1) < 0)
				goto enomem;
			rp = res->d;
			rp[0] = 1;
		}
 		res->sign = 0;
 		goto leave;
 	}","The mpi_powm function in lib/mpi/mpi-pow.c in the Linux kernel through 4.8.11 does not ensure that memory is allocated for limb data, which allows local users to cause a denial of service (stack memory corruption and panic) via an add_key system call for an RSA key with a zero exponent."
586,CVE-2016-8646,"  static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
	bool more;
 	int err;
 
	lock_sock(sk);
	more = ctx->more;
	err = more ? crypto_ahash_export(req, state) : 0;
	release_sock(sk);

 	if (err)
 		return err;
 
  static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2->private;
	ctx2->more = more;

	if (!more)
		return err;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {",The hash_accept function in crypto/algif_hash.c in the Linux kernel before 4.3.6 allows local users to cause a denial of service (OOPS) by attempting to trigger use of in-kernel hash algorithms for a socket that has received zero bytes of data.
587,CVE-2016-8645,"  static inline void tcp_prequeue_init(struct tcp_sock *tp)
 
 bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
 bool tcp_add_backlog(struct sock *sk, struct sk_buff *skb);
int tcp_filter(struct sock *sk, struct sk_buff *skb);
 
 #undef STATE_TRACE
 ","The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c."
588,CVE-2016-8633,"  static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	int retval;
 	u16 ether_type;
 
	if (len <= RFC2374_UNFRAG_HDR_SIZE)
		return 0;

 	hdr.w0 = be32_to_cpu(buf[0]);
 	lf = fwnet_get_hdr_lf(&hdr);
 	if (lf == RFC2374_HDR_UNFRAG) {
  static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);
 	}

 	 

	if (len <= RFC2374_FRAG_HDR_SIZE)
		return 0;

 	hdr.w1 = ntohl(buf[1]);
 	buf += 2;
 	len -= RFC2374_FRAG_HDR_SIZE;
  static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,
 	datagram_label = fwnet_get_hdr_dgl(&hdr);
 	dg_size = fwnet_get_hdr_dg_size(&hdr);  
 
	if (fg_off + len > dg_size)
		return 0;

 	spin_lock_irqsave(&dev->lock, flags);
 
 	peer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);
  static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,
 	fw_send_response(card, r, rcode);
 }
 
static int gasp_source_id(__be32 *p)
{
	return be32_to_cpu(p[0]) >> 16;
}

static u32 gasp_specifier_id(__be32 *p)
{
	return (be32_to_cpu(p[0]) & 0xffff) << 8 |
	       (be32_to_cpu(p[1]) & 0xff000000) >> 24;
}

static u32 gasp_version(__be32 *p)
{
	return be32_to_cpu(p[1]) & 0xffffff;
}

 static void fwnet_receive_broadcast(struct fw_iso_context *context,
 		u32 cycle, size_t header_length, void *header, void *data)
 {
  static void fwnet_receive_broadcast(struct fw_iso_context *context,
 	__be32 *buf_ptr;
 	int retval;
 	u32 length;
 	unsigned long offset;
 	unsigned long flags;
 
  static void fwnet_receive_broadcast(struct fw_iso_context *context,
 
 	spin_unlock_irqrestore(&dev->lock, flags);
 
	if (length > IEEE1394_GASP_HDR_SIZE &&
	    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&
	    (gasp_version(buf_ptr) == RFC2734_SW_VERSION
 #if IS_ENABLED(CONFIG_IPV6)
	     || gasp_version(buf_ptr) == RFC3146_SW_VERSION
 #endif
	    ))
		fwnet_incoming_packet(dev, buf_ptr + 2,
				      length - IEEE1394_GASP_HDR_SIZE,
				      gasp_source_id(buf_ptr),
 				      context->card->generation, true);
 
 	packet.payload_length = dev->rcv_buffer_size;
 	packet.interrupt = 1;","drivers/firewire/net.c in the Linux kernel before 4.8.7, in certain unusual hardware configurations, allows remote attackers to execute arbitrary code via crafted fragmented packets."
589,CVE-2016-8630,"  int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)
 	 
 	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);
 
	if (ctxt->rip_relative && likely(ctxt->memopp))
 		ctxt->memopp->addr.mem.ea = address_mask(ctxt,
 					ctxt->memopp->addr.mem.ea + ctxt->_eip);
 ","The x86_decode_insn function in arch/x86/kvm/emulate.c in the Linux kernel before 4.8.7, when KVM is enabled, allows local users to cause a denial of service (host OS crash) via a certain use of a ModR/M byte in an undefined instruction."
590,CVE-2016-8339,"  void loadServerConfigFromString(char *config) {
             unsigned long long hard, soft;
             int soft_seconds;
 
            if (class == -1 || class == CLIENT_TYPE_MASTER) {
                err = ""Unrecognized client limit class: the user specified ""
                ""an invalid one, or 'master' which has no buffer limits."";
                 goto loaderr;
             }
             hard = memtoll(argv[2],NULL);
  void configSetCommand(client *c) {
             long val;
 
             if ((j % 4) == 0) {
                int class = getClientTypeByName(v[j]);
                if (class == -1 || class == CLIENT_TYPE_MASTER) {
                     sdsfreesplitres(v,vlen);
                     goto badfmt;
                 }",A buffer overflow in Redis 3.2.x prior to 3.2.4 causes arbitrary code execution when a crafted command is sent. An out of bounds write vulnerability exists in the handling of the client-output-buffer-limit option during the CONFIG SET command for the Redis data structure store. A crafted CONFIG SET command can lead to an out of bounds write potentially resulting in code execution.
591,CVE-2016-7917,"  static void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,
 		nlh = nlmsg_hdr(skb);
 		err = 0;
 
		if (nlh->nlmsg_len < NLMSG_HDRLEN ||
		    skb->len < nlh->nlmsg_len ||
		    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {
			nfnl_err_reset(&err_list);
			status |= NFNL_BATCH_FAILURE;
			goto done;
 		}
 
 		 ","The nfnetlink_rcv_batch function in net/netfilter/nfnetlink.c in the Linux kernel before 4.5 does not check whether a batch message's length field is large enough, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (infinite loop or out-of-bounds read) by leveraging the CAP_NET_ADMIN capability."
592,CVE-2016-7916,"  static ssize_t environ_read(struct file *file, char __user *buf,
 	struct mm_struct *mm = file->private_data;
 	unsigned long env_start, env_end;
 
	 
	if (!mm || !mm->env_end)
 		return 0;
 
 	page = (char *)__get_free_page(GFP_TEMPORARY);",Race condition in the environ_read function in fs/proc/base.c in the Linux kernel before 4.5.4 allows local users to obtain sensitive information from kernel memory by reading a /proc/*/environ file during a process-setup time interval in which environment-variable copying is incomplete.
593,CVE-2016-7915,"  static void hid_input_field(struct hid_device *hid, struct hid_field *field,
 		 
 		if (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&
 		    value[n] >= min && value[n] <= max &&
		    value[n] - min < field->maxusage &&
 		    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
 			goto exit;
 	}
  static void hid_input_field(struct hid_device *hid, struct hid_field *field,
 		}
 
 		if (field->value[n] >= min && field->value[n] <= max
			&& field->value[n] - min < field->maxusage
 			&& field->usage[field->value[n] - min].hid
 			&& search(value, field->value[n], count))
 				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);
 
 		if (value[n] >= min && value[n] <= max
			&& value[n] - min < field->maxusage
 			&& field->usage[value[n] - min].hid
 			&& search(field->value, value[n], count))
 				hid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);","The hid_input_field function in drivers/hid/hid-core.c in the Linux kernel before 4.6 allows physically proximate attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) by connecting a device, as demonstrated by a Logitech DJ receiver."
594,CVE-2016-7914,"  static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
 			free_slot = i;
 			continue;
 		}
		if (assoc_array_ptr_is_leaf(ptr) &&
		    ops->compare_object(assoc_array_ptr_to_leaf(ptr),
					index_key)) {
 			pr_devel(""replace in slot %d\n"", i);
 			edit->leaf_p = &node->slots[i];
 			edit->dead_leaf = node->slots[i];","The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.5.3 does not check whether a slot is a leaf, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (invalid pointer dereference and out-of-bounds read) via an application that uses associative-array data structures, as demonstrated by the keyutils test suite."
595,CVE-2016-7913,"  static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)
 	 * in order to avoid troubles during device release.
 	 */
 	kfree(priv->ctrl.fname);
	priv->ctrl.fname = NULL;
 	memcpy(&priv->ctrl, p, sizeof(priv->ctrl));
 	if (p->fname) {
 		priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);
 		if (priv->ctrl.fname == NULL)
			return -ENOMEM;
 	}
 
 	/*",The xc2028_set_config function in drivers/media/tuners/tuner-xc2028.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) via vectors involving omission of the firmware name from a certain data structure.
596,CVE-2016-7912,"  static void ffs_user_copy_worker(struct work_struct *work)
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
  static void ffs_user_copy_worker(struct work_struct *work)
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);",Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.
597,CVE-2016-7911,"  static int get_task_ioprio(struct task_struct *p)
 	if (ret)
 		goto out;
 	ret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);
	task_lock(p);
 	if (p->io_context)
 		ret = p->io_context->ioprio;
	task_unlock(p);
 out:
 	return ret;
 }",Race condition in the get_task_ioprio function in block/ioprio.c in the Linux kernel before 4.6.6 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted ioprio_get system call.
598,CVE-2016-7910,"  static void disk_seqf_stop(struct seq_file *seqf, void *v)
 	if (iter) {
 		class_dev_iter_exit(iter);
 		kfree(iter);
		seqf->private = NULL;
 	}
 }
 ",Use-after-free vulnerability in the disk_seqf_stop function in block/genhd.c in the Linux kernel before 4.7.1 allows local users to gain privileges by leveraging the execution of a certain stop operation even if the corresponding start operation had failed.
599,CVE-2016-7568,"  BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 		quality = 80;
 	}
 
	if (overflow2(gdImageSX(im), 4)) {
		return;
	}

	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
		return;
	}

 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
 		return;","Integer overflow in the gdImageWebpCtx function in gd_webp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP through 7.0.11, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted imagewebp and imagedestroy calls."
600,CVE-2016-7425,"  static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,
 	}
 	case ARCMSR_MESSAGE_WRITE_WQBUFFER: {
 		unsigned char *ver_addr;
		uint32_t user_len;
		int32_t cnt2end;
 		uint8_t *pQbuffer, *ptmpuserbuffer;
 		ver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);
 		if (!ver_addr) {
  static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,
 		}
 		ptmpuserbuffer = ver_addr;
 		user_len = pcmdmessagefld->cmdmessage.Length;
		if (user_len > ARCMSR_API_DATA_BUFLEN) {
			retvalue = ARCMSR_MESSAGE_FAIL;
			kfree(ver_addr);
			goto message_out;
		}
 		memcpy(ptmpuserbuffer,
 			pcmdmessagefld->messagedatabuffer, user_len);
 		spin_lock_irqsave(&acb->wqbuffer_lock, flags);","The arcmsr_iop_message_xfer function in drivers/scsi/arcmsr/arcmsr_hba.c in the Linux kernel through 4.8.2 does not restrict a certain length field, which allows local users to gain privileges or cause a denial of service (heap-based buffer overflow) via an ARCMSR_MESSAGE_WRITE_WQBUFFER control code."
601,CVE-2016-7417,"  static zval **spl_array_get_dimension_ptr_ptr(int check_inherited, zval *object,
 	long index;
 	HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
 
	if (!offset || !ht) {
 		return &EG(uninitialized_zval_ptr);
 	}
 
  static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *o
 		HashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
 
 		switch(Z_TYPE_P(offset)) {
			case IS_STRING:
 				if (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {
 					if (check_empty == 2) {
 						return 1;
  static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *o
 
 			case IS_DOUBLE:
 			case IS_RESOURCE:
			case IS_BOOL:
 			case IS_LONG:
 				if (offset->type == IS_DOUBLE) {
 					index = (long)Z_DVAL_P(offset);
  SPL_METHOD(Array, unserialize)
 		intern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;
 		zval_ptr_dtor(&intern->array);
 		ALLOC_INIT_ZVAL(intern->array);
		if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)
				|| (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {
			zval_ptr_dtor(&intern->array);
 			goto outexcept;
 		}
 		var_push_dtor(&var_hash, &intern->array);","ext/spl/spl_array.c in PHP before 5.6.26 and 7.x before 7.0.11 proceeds with SplArray unserialization without validating a return value and data type, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data."
602,CVE-2016-7416,"  PHP_FUNCTION( msgfmt_format_message )
 		RETURN_FALSE;
 	}
 
	INTL_CHECK_LOCALE_LEN(slocale_len);

 	msgformat_data_init(&mfo->mf_data TSRMLS_CC);
 
 	if(pattern && pattern_len) {","ext/intl/msgformat/msgformat_format.c in PHP before 5.6.26 and 7.x before 7.0.11 does not properly restrict the locale length provided to the Locale class in the ICU library, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a MessageFormatter::formatMessage call with a long first argument."
603,CVE-2016-7412,"  php_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer,
 	zend_uchar * p = row_buffer->ptr;
 	size_t data_size = row_buffer->app;
 	zend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1;  
	const zend_uchar * const packet_end = (zend_uchar*) row_buffer->ptr + data_size;
 
 	DBG_ENTER(""php_mysqlnd_rowp_read_text_protocol_aux"");
 
  php_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer,
 		 
 		zend_uchar *this_field_len_pos = p;
 		 
		const unsigned long len = php_mysqlnd_net_field_length(&p);
 
		if (len != MYSQLND_NULL_LENGTH && ((p + len) > packet_end)) {
			php_error_docref(NULL, E_WARNING, ""Malformed server packet. Field length pointing ""MYSQLND_SZ_T_SPEC
											  "" bytes after end of packet"", (p + len) - packet_end - 1);
			DBG_RETURN(FAIL);
		}
 		if (copy_data == FALSE && current_field > start_field && last_field_was_string) {
 			/*
 			  Normal queries:","ext/mysqlnd/mysqlnd_wireprotocol.c in PHP before 5.6.26 and 7.x before 7.0.11 does not verify that a BIT field has the UNSIGNED_FLAG flag, which allows remote MySQL servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted field metadata."
604,CVE-2016-7411,"  ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle,
 					} zend_end_try();
 				}
 			}

 			 
 			obj = &EG(objects_store).object_buckets[handle].bucket.obj;
 
  ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)
 {
 	zend_object_handle handle = Z_OBJ_HANDLE_P(zobject);
 	zend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];

	obj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);
 	obj_bucket->destructor_called = 1;
 }
 ","ext/standard/var_unserializer.re in PHP before 5.6.26 mishandles object-deserialization failures, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via an unserialize call that references a partially constructed object."
605,CVE-2016-7163,"  opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,
 	l_current_pi = l_pi;
 
 	 
	 
	l_current_pi->include = 00;
	if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))
	{
		l_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));
	}

 	if
 		(!l_current_pi->include)
 	{","Integer overflow in the opj_pi_create_decode function in pi.c in OpenJPEG allows remote attackers to execute arbitrary code via a crafted JP2 file, which triggers an out-of-bounds read or write."
606,CVE-2016-7143,"  m_authenticate(struct Client *client_p, struct Client *source_p,
 		return 0;
 	}
 
	if (*parv[1] == ':' || strchr(parv[1], ' '))
	{
		exit_client(client_p, client_p, client_p, ""Malformed AUTHENTICATE"");
		return 0;
	}

 	saslserv_p = find_named_client(ConfigFileEntry.sasl_service);
 	if (saslserv_p == NULL || !IsService(saslserv_p))
 	{",The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.
607,CVE-2016-7142,"  class CommandAuthenticate : public Command
 		: Command(Creator, ""AUTHENTICATE"", 1), authExt(ext), cap(Cap)
 	{
 		works_before_reg = true;
		allow_empty_last_param = false;
 	}
 
 	CmdResult Handle (const std::vector<std::string>& parameters, User *user)
  class CommandAuthenticate : public Command
 			if (!cap.ext.get(user))
 				return CMD_FAILURE;
 
			if (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')
				return CMD_FAILURE;

 			SaslAuthenticator *sasl = authExt.get(user);
 			if (!sasl)
 				authExt.set(user, new SaslAuthenticator(user, parameters[0]));","The m_sasl module in InspIRCd before 2.0.23, when used with a service that supports SASL_EXTERNAL authentication, allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted SASL message."
608,CVE-2016-7134,"  PHP_FUNCTION(curl_reset)
 PHP_FUNCTION(curl_escape)
 {
 	char       *str = NULL, *res = NULL;
	size_t     str_len = 0;
 	zval       *zid;
 	php_curl   *ch;
 
  PHP_FUNCTION(curl_escape)
 		RETURN_FALSE;
 	}
 
	if (ZEND_SIZE_T_INT_OVFL(str_len)) {
		RETURN_FALSE;
	}

 	if ((res = curl_easy_escape(ch->cp, str, str_len))) {
 		RETVAL_STRING(res);
 		curl_free(res);
  PHP_FUNCTION(curl_unescape)
 		RETURN_FALSE;
 	}
 
	if (ZEND_SIZE_T_INT_OVFL(str_len)) {
 		RETURN_FALSE;
 	}
 ","ext/curl/interface.c in PHP 7.x before 7.0.10 does not work around a libcurl integer overflow, which allows remote attackers to cause a denial of service (allocation error and heap-based buffer overflow) or possibly have unspecified other impact via a long string that is mishandled in a curl_escape call."
609,CVE-2016-7133,"  static void *zend_mm_realloc_heap(zend_mm_heap *heap, void *ptr, size_t size, si
 
 		ZEND_MM_CHECK(chunk->heap == heap, ""zend_mm_heap corrupted"");
 		if (info & ZEND_MM_IS_SRUN) {
			int old_bin_num = ZEND_MM_SRUN_BIN_NUM(info);
 			old_size = bin_data_size[old_bin_num];
			if (size <= ZEND_MM_MAX_SMALL_SIZE) {
				int bin_num = ZEND_MM_SMALL_SIZE_TO_BIN(size);
				if (old_bin_num == bin_num) {
 #if ZEND_DEBUG
					dbg = zend_mm_get_debug_info(heap, ptr);
					dbg->size = real_size;
					dbg->filename = __zend_filename;
					dbg->orig_filename = __zend_orig_filename;
					dbg->lineno = __zend_lineno;
					dbg->orig_lineno = __zend_orig_lineno;
 #endif
					return ptr;
				}
 			}
 		} else   {
 			ZEND_MM_CHECK(ZEND_MM_ALIGNED_OFFSET(page_offset, ZEND_MM_PAGE_SIZE) == 0, ""zend_mm_heap corrupted"");","Zend/zend_alloc.c in PHP 7.x before 7.0.10, when open_basedir is enabled, mishandles huge realloc operations, which allows remote attackers to cause a denial of service (integer overflow) or possibly have unspecified other impact via a long pathname."
610,CVE-2016-7128,"  static int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offse
 						fgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);
 						if (fgot < ImageInfo->Thumbnail.size) {
 							EXIF_ERRLOG_THUMBEOF(ImageInfo)
							efree(ImageInfo->Thumbnail.data);
							ImageInfo->Thumbnail.data = NULL;
						} else {
							exif_thumbnail_build(ImageInfo TSRMLS_CC);
 						}
 					}
 #ifdef EXIF_DEBUG
 					exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Read next IFD (THUMBNAIL) done"");","The exif_process_IFD_in_TIFF function in ext/exif/exif.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles the case of a thumbnail offset that exceeds the file size, which allows remote attackers to obtain sensitive information from process memory via a crafted TIFF image."
611,CVE-2016-7127,"  PHP_FUNCTION(imagegammacorrect)
 		return;
 	}
 
	if ( input <= 0.0 || output <= 0.0 ) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Gamma values should be positive"");
		RETURN_FALSE;
	}

 	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
 
 	if (gdImageTrueColor(im))	{","The imagegammacorrect function in ext/gd/gd.c in PHP before 5.6.25 and 7.x before 7.0.10 does not properly validate gamma values, which allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact by providing different signs for the second and third arguments."
612,CVE-2016-7126,"  static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int, int);
 
 #include ""gd_ctx.c""
 
 int overflow2(int a, int b);
 
  PHP_MINIT_FUNCTION(gd)
 	REGISTER_LONG_CONSTANT(""IMG_CROP_SIDES"", GD_CROP_SIDES, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT(""IMG_CROP_THRESHOLD"", GD_CROP_THRESHOLD, CONST_CS | CONST_PERSISTENT);
 

 	REGISTER_LONG_CONSTANT(""IMG_BELL"", GD_BELL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT(""IMG_BESSEL"", GD_BESSEL, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT(""IMG_BILINEAR_FIXED"", GD_BILINEAR_FIXED, CONST_CS | CONST_PERSISTENT);
  PHP_FUNCTION(imagetruecolortopalette)
 
 	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
 
	if (ncolors <= 0 || ncolors > INT_MAX) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Number of colors has to be greater than zero and no more than %d"", INT_MAX);
 		RETURN_FALSE;
 	}
	gdImageTrueColorToPalette(im, dither, (int)ncolors);
 
 	RETURN_TRUE;
 }
  static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int
 #endif  
 
 	PHP_GD_CHECK_OPEN_BASEDIR(fontname, ""Invalid font filename"");

 #ifdef HAVE_GD_FREETYPE
 	if (extended) {
 		error = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);
  static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )
 	int x, y;
 	float x_ratio, y_ratio;
     long ignore_warning;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pplll"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {
 		return;
 	}
  PHP_FUNCTION(imageaffinematrixget)
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Missing y position"");
 				RETURN_FALSE;
 			}

 			if (type == GD_AFFINE_TRANSLATE) {
 				res = gdAffineTranslate(affine, x, y);
 			} else {","The imagetruecolortopalette function in ext/gd/gd.c in PHP before 5.6.25 and 7.x before 7.0.10 does not properly validate the number of colors, which allows remote attackers to cause a denial of service (select_colors allocation error and out-of-bounds write) or possibly have unspecified other impact via a large value in the third argument."
613,CVE-2016-7125,"  PS_SERIALIZER_DECODE_FUNC(php_binary)  
 	int namelen;
 	int has_value;
 	php_unserialize_data_t var_hash;
	int skip = 0;
 
 	PHP_VAR_UNSERIALIZE_INIT(var_hash);
 
 	for (p = val; p < endptr; ) {
 		zval **tmp;
		skip = 0;
 		namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
 
 		if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
  PS_SERIALIZER_DECODE_FUNC(php_binary)  
 
 		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
 			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				skip = 1;
 			}
 		}
 
 		if (has_value) {
 			ALLOC_INIT_ZVAL(current);
 			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				if (!skip) {
					php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
				}
 			} else {
 				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 				return FAILURE;
 			}
 			var_push_dtor_no_addref(&var_hash, &current);
 		}
		if (!skip) {
			PS_ADD_VARL(name, namelen);
		}
 		efree(name);
 	}
 
  PS_SERIALIZER_DECODE_FUNC(php)  
 	int namelen;
 	int has_value;
 	php_unserialize_data_t var_hash;
	int skip = 0;
 
 	PHP_VAR_UNSERIALIZE_INIT(var_hash);
 
  PS_SERIALIZER_DECODE_FUNC(php)  
 	while (p < endptr) {
 		zval **tmp;
 		q = p;
		skip = 0;
 		while (*q != PS_DELIMITER) {
 			if (++q >= endptr) goto break_outer_loop;
 		}
  PS_SERIALIZER_DECODE_FUNC(php)  
 
 		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
 			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				skip = 1;
 			}
 		}
 
 		if (has_value) {
 			ALLOC_INIT_ZVAL(current);
 			if (php_var_unserialize(&current, (const unsigned char **) &q, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				if (!skip) {
					php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
				}
 			} else {
 				var_push_dtor_no_addref(&var_hash, &current);
 				efree(name);
  PS_SERIALIZER_DECODE_FUNC(php)  
 			}
 			var_push_dtor_no_addref(&var_hash, &current);
 		}
		if (!skip) {
			PS_ADD_VARL(name, namelen);
		}
 skip:
 		efree(name);
 ","ext/session/session.c in PHP before 5.6.25 and 7.x before 7.0.10 skips invalid session names in a way that triggers incorrect parsing, which allows remote attackers to inject arbitrary-type session data by leveraging control of a session name, as demonstrated by object injection."
614,CVE-2016-7117,"  int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
 		cond_resched();
 	}
 
 	if (err == 0)
		goto out_put;
 
	if (datagrams == 0) {
		datagrams = err;
		goto out_put;
	}

	 
	if (err != -EAGAIN) {
 		 
		sock->sk->sk_err = -err;
 	}
out_put:
	fput_light(sock->file, fput_needed);
 
	return datagrams;
 }
 
 SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,",Use-after-free vulnerability in the __sys_recvmmsg function in net/socket.c in the Linux kernel before 4.5.2 allows remote attackers to execute arbitrary code via vectors involving a recvmmsg system call that is mishandled during error processing.
615,CVE-2016-7115,"  static char autologin_path[255];
 
 static int keepalive_counter = 0;
 
static unsigned char pass_salt[16];
 static char username[MT_MNDP_MAX_STRING_SIZE];
 static char password[MT_MNDP_MAX_STRING_SIZE];
 static char nonpriv_username[MT_MNDP_MAX_STRING_SIZE];
  static void send_auth(char *username, char *password) {
 	char *terminal = getenv(""TERM"");
 	char md5data[100];
 	unsigned char md5sum[17];
	int plen, act_pass_len;
 	md5_state_t state;
 
 #if defined(__linux__) && defined(_POSIX_MEMLOCK_RANGE)
 	mlock(md5data, sizeof(md5data));
 	mlock(md5sum, sizeof(md5data));
 #endif
 
	 
	act_pass_len = strnlen(password, 82);

 	 
 	md5data[0] = 0;
	memcpy(md5data + 1, password, act_pass_len);
	 
	memcpy(md5data + 1 + act_pass_len, pass_salt, 16);
 
 	 
 	md5_init(&state);
	md5_append(&state, (const md5_byte_t *)md5data, 1 + act_pass_len + 16);
 	md5_finish(&state, (md5_byte_t *)md5sum + 1);
 	md5sum[0] = 0;
 
  static int handle_packet(unsigned char *data, int data_len) {
 
 			 
 			if (cpkt.cptype == MT_CPTYPE_PASSSALT) {
				 
				if (cpkt.length != 16) {
					fprintf(stderr, _(""Invalid salt length: %d (instead of 16) received from server %s\n""), cpkt.length, ether_ntoa((struct ether_addr *)dstmac));
				}
				memcpy(pass_salt, cpkt.data, 16);
 				send_auth(username, password);
 			}
 ",Buffer overflow in the handle_packet function in mactelnet.c in the client in MAC-Telnet 0.4.3 and earlier allows remote TELNET servers to execute arbitrary code via a long string in an MT_CPTYPE_PASSSALT control packet.
616,CVE-2016-7097,"  static int v9fs_xattr_set_acl(const struct xattr_handler *handler,
 	switch (handler->flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
			struct iattr iattr;

			retval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);
			if (retval)
 				goto err_out;
				value = NULL;
				size = 0;
 			}
			iattr.ia_valid = ATTR_MODE;
			 
			v9fs_vfs_setattr_dotl(dentry, &iattr);
 		}
 		break;
 	case ACL_TYPE_DEFAULT:","The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions."
617,CVE-2016-6905,"  int read_image_tga( gdIOCtx *ctx, oTga *tga )
 	int buffer_caret = 0;
 	int bitmap_caret = 0;
 	int i = 0;
 	uint8_t encoded_pixels;
 
 	if(overflow2(tga->width, tga->height)) {
  int read_image_tga( gdIOCtx *ctx, oTga *tga )
 		while( bitmap_caret < image_block_size ) {
 			
 			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & !TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;
 
				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {
					gdFree( decompression_buffer );
					gdFree( conversion_buffer );
					return -1;
				}

				for (i = 0; i < encoded_pixels; i++) {
					memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);
					bitmap_caret += pixel_block_size;
 				}
 				buffer_caret += pixel_block_size;

 			} else {
 				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
 				buffer_caret++;
 
				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {
					gdFree( decompression_buffer );
					gdFree( conversion_buffer );
					return -1;
 				}

				memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);
				bitmap_caret += (encoded_pixels * pixel_block_size);
				buffer_caret += (encoded_pixels * pixel_block_size);
 			}
 		}
 		gdFree( decompression_buffer );",The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA image.
618,CVE-2016-6828,"  static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unli
 {
 	if (sk->sk_send_head == skb_unlinked)
 		sk->sk_send_head = NULL;
	if (tcp_sk(sk)->highest_sack == skb_unlinked)
		tcp_sk(sk)->highest_sack = NULL;
 }
 
 static inline void tcp_init_send_head(struct sock *sk)","The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option."
619,CVE-2016-6787,"  static void put_ctx(struct perf_event_context *ctx)
 	}
 }
 
 
static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)
{
	struct perf_event_context *ctx;

again:
	rcu_read_lock();
	ctx = ACCESS_ONCE(event->ctx);
	if (!atomic_inc_not_zero(&ctx->refcount)) {
		rcu_read_unlock();
		goto again;
	}
	rcu_read_unlock();

	mutex_lock(&ctx->mutex);
	if (event->ctx != ctx) {
		mutex_unlock(&ctx->mutex);
		put_ctx(ctx);
		goto again;
	}

	return ctx;
}

static void perf_event_ctx_unlock(struct perf_event *event,
				  struct perf_event_context *ctx)
{
	mutex_unlock(&ctx->mutex);
	put_ctx(ctx);
}

  
static void _perf_event_disable(struct perf_event *event)
 {
 	struct perf_event_context *ctx = event->ctx;
 	struct task_struct *task = ctx->task;
  void perf_event_disable(struct perf_event *event)
 	}
 	raw_spin_unlock_irq(&ctx->lock);
 }

 
void perf_event_disable(struct perf_event *event)
{
	struct perf_event_context *ctx;

	ctx = perf_event_ctx_lock(event);
	_perf_event_disable(event);
	perf_event_ctx_unlock(event, ctx);
}
 EXPORT_SYMBOL_GPL(perf_event_disable);
 
 static void perf_set_shadow_time(struct perf_event *event,
  static int __perf_event_enable(void *info)
  * perf_event_for_each_child or perf_event_for_each as described
  * for perf_event_disable.
  */
static void _perf_event_enable(struct perf_event *event)
 {
 	struct perf_event_context *ctx = event->ctx;
 	struct task_struct *task = ctx->task;
  void perf_event_enable(struct perf_event *event)
 out:
 	raw_spin_unlock_irq(&ctx->lock);
 }

 
void perf_event_enable(struct perf_event *event)
{
	struct perf_event_context *ctx;

	ctx = perf_event_ctx_lock(event);
	_perf_event_enable(event);
	perf_event_ctx_unlock(event, ctx);
}
 EXPORT_SYMBOL_GPL(perf_event_enable);
 
static int _perf_event_refresh(struct perf_event *event, int refresh)
 {
 	 
int perf_event_refresh(struct perf_event *event, int refresh)
{
	struct perf_event_context *ctx;
	int ret;

	ctx = perf_event_ctx_lock(event);
	ret = _perf_event_refresh(event, refresh);
	perf_event_ctx_unlock(event, ctx);

	return ret;
}
 EXPORT_SYMBOL_GPL(perf_event_refresh);
 
 static void ctx_sched_out(struct perf_event_context *ctx,
  static void perf_remove_from_owner(struct perf_event *event)
 	rcu_read_unlock();
 
 	if (owner) {
		 
		mutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);

 		 
		mutex_lock_double(&gctx->mutex, &ctx->mutex);
 
 		perf_remove_from_context(group_leader, false);
 
 		 
 		synchronize_rcu();

 		perf_install_in_context(ctx, group_leader, group_leader->cpu);
 		get_ctx(ctx);
 		list_for_each_entry(sibling, &group_leader->sibling_list,
  SYSCALL_DEFINE5(perf_event_open,
 
 	perf_install_in_context(ctx, event, event->cpu);
 	perf_unpin_context(ctx);

	if (move_group) {
		mutex_unlock(&gctx->mutex);
		put_ctx(gctx);
	}
 	mutex_unlock(&ctx->mutex);
 
 	put_online_cpus();
  void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)
 	src_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;
 	dst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;
 
	 
	mutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);
 	list_for_each_entry_safe(event, tmp, &src_ctx->event_list,
 				 event_entry) {
 		perf_remove_from_context(event, false);
 		unaccount_event_cpu(event, src_cpu);
 		put_ctx(src_ctx);
 		list_add(&event->migrate_entry, &events);
 	}
 
 	synchronize_rcu();
 
 	list_for_each_entry_safe(event, tmp, &events, migrate_entry) {
 		list_del(&event->migrate_entry);
 		if (event->state >= PERF_EVENT_STATE_OFF)
  void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)
 		get_ctx(dst_ctx);
 	}
 	mutex_unlock(&dst_ctx->mutex);
	mutex_unlock(&src_ctx->mutex);
 }
 EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);
 ","kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 31095224."
620,CVE-2016-6663," 
  ","Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table."
621,CVE-2016-6516,"  static long ioctl_file_dedupe_range(struct file *file, void __user *arg)
 		goto out;
 	}
 
	same->dest_count = count;
 	ret = vfs_dedupe_file_range(file, same);
 	if (ret)
 		goto out;","Race condition in the ioctl_file_dedupe_range function in fs/ioctl.c in the Linux kernel through 4.7 allows local users to cause a denial of service (heap-based buffer overflow) or possibly gain privileges by changing a certain count value, aka a *double fetch* vulnerability."
622,CVE-2016-6515," 
 
  
 #define TWO_WEEKS	(2L * 7 * DAY)	 
 
#define MAX_PASSWORD_LEN	1024

 void
 disable_forwarding(void)
 {
  auth_password(Authctxt *authctxt, const char *password)
 	static int expire_checked = 0;
 #endif
 
	if (strlen(password) > MAX_PASSWORD_LEN)
		return 0;

 #ifndef HAVE_CYGWIN
 	if (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)
 		ok = 0;","The auth_password function in auth-passwd.c in sshd in OpenSSH before 7.3 does not limit password lengths for password authentication, which allows remote attackers to cause a denial of service (crypt CPU consumption) via a long string."
623,CVE-2016-6491,"  static MagickBooleanType Get8BIMProperty(const Image *image,const char *key,
     if ((count & 0x01) == 0)
       (void) ReadPropertyByte(&info,&length);
     count=(ssize_t) ReadPropertyMSBLong(&info,&length);
    if ((count < 0) || ((size_t) count > length))
      {
        length=0; 
        continue;
      }
     if ((*name != '\0') && (*name != '#'))
       if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))
         {","Buffer overflow in the Get8BIMProperty function in MagickCore/property.c in ImageMagick before 6.9.5-4 and 7.x before 7.0.2-6 allows remote attackers to cause a denial of service (out-of-bounds read, memory leak, and crash) via a crafted image."
624,CVE-2016-6327,"  static int srpt_handle_cmd(struct srpt_rdma_ch *ch,
 	return -1;
 }
 
 static int srp_tmr_to_tcm(int fn)
 {
 	switch (fn) {
  static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
 	struct se_cmd *cmd;
 	struct se_session *sess = ch->sess;
 	uint64_t unpacked_lun;
 	int tcm_tmr;
 	int rc;
 
  static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,
 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx->cmd.tag = srp_tsk->tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,
 				       sizeof(srp_tsk->lun));
 	rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,
				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;",drivers/infiniband/ulp/srpt/ib_srpt.c in the Linux kernel before 4.5.1 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an ABORT_TASK command to abort a device write operation.
625,CVE-2016-6254,"  static int parse_packet (sockent_t *se,  
 				printed_ignore_warning = 1;
 			}
 			buffer = ((char *) buffer) + pkg_length;
			buffer_size -= (size_t) pkg_length;
 			continue;
 		}
 #endif  
  static int parse_packet (sockent_t *se,  
 				printed_ignore_warning = 1;
 			}
 			buffer = ((char *) buffer) + pkg_length;
			buffer_size -= (size_t) pkg_length;
 			continue;
 		}
 #endif  
  static int parse_packet (sockent_t *se,  
 			DEBUG (""network plugin: parse_packet: Unknown part""
 					"" type: 0x%04hx"", pkg_type);
 			buffer = ((char *) buffer) + pkg_length;
			buffer_size -= (size_t) pkg_length;
 		}
 	}  
 ",Heap-based buffer overflow in the parse_packet function in network.c in collectd before 5.4.3 and 5.x before 5.5.2 allows remote attackers to cause a denial of service (daemon crash) or possibly execute arbitrary code via a crafted network packet.
626,CVE-2016-6250,"  isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
 	unsigned char *p;
 	size_t l;
 	int r;
	size_t ffmax, parent_len;
 	static const struct archive_rb_tree_ops rb_ops = {
 		isoent_cmp_node_joliet, isoent_cmp_key_joliet
 	};
  isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
 	else
 		ffmax = 128;
 
	r = idr_start(a, idr, isoent->children.cnt, (int)ffmax, 6, 2, &rb_ops);
 	if (r < 0)
 		return (r);
 
  isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
 		int ext_off, noff, weight;
 		size_t lt;
 
		if ((l = np->file->basename_utf16.length) > ffmax)
 			l = ffmax;
 
 		p = malloc((l+1)*2);
  isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
 		 
		if (np->file->basename_utf16.length > ffmax) {
 			if (archive_strncpy_l(&iso9660->mbs,
 			    (const char *)np->identifier, l,
 				iso9660->sconv_from_utf16be) != 0 &&
  isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
 
 		 
		if (parent_len > 240
		    || np->mb_len > 240
		    || parent_len + np->mb_len > 240) {
 			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 			    ""The regulation of Joliet extensions;""
 			    "" A length of a full-pathname of `%s' is ""
  isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
 
 		 
		if (l == ffmax)
 			noff = ext_off - 6;
		else if (l == ffmax-2)
 			noff = ext_off - 4;
		else if (l == ffmax-4)
 			noff = ext_off - 2;
 		else
 			noff = ext_off;","Integer overflow in the ISO9660 writer in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) or execute arbitrary code via vectors related to verifying filename lengths when writing an ISO9660 archive, which trigger a buffer overflow."
627,CVE-2016-6214,"  BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)
 			if (tga->bits == TGA_BPP_24) {
 				*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);
 				bitmap_caret += 3;
			} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {
 				register int a = tga->bitmap[bitmap_caret + 3];
 
 				*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));
  int read_header_tga(gdIOCtx *ctx, oTga *tga)
 	printf(""wxh: %i %i\n"", tga->width, tga->height);
 #endif
 
	if (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)
		|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))
	{
		gd_error_ex(GD_WARNING, ""gd-tga: %u bits per pixel with %u alpha bits not supported\n"",
			tga->bits, tga->alphabits);
 		return -1;
 	}
 
 	tga->ident = NULL;",gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.
628,CVE-2016-6198,"  int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	bool new_is_dir = false;
 	unsigned max_links = new_dir->i_sb->s_max_links;
 
	 
	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);","The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c."
629,CVE-2016-6197,"  static int ovl_remove_upper(struct dentry *dentry, bool is_dir)
 {
 	struct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);
 	struct inode *dir = upperdir->d_inode;
	struct dentry *upper;
 	int err;
 
 	inode_lock_nested(dir, I_MUTEX_PARENT);
	upper = lookup_one_len(dentry->d_name.name, upperdir,
			       dentry->d_name.len);
	err = PTR_ERR(upper);
	if (IS_ERR(upper))
		goto out_unlock;

 	err = -ESTALE;
	if (upper == ovl_dentry_upper(dentry)) {
 		if (is_dir)
 			err = vfs_rmdir(dir, upper);
 		else
 			err = vfs_unlink(dir, upper, NULL);
 		ovl_dentry_version_inc(dentry->d_parent);
 	}
	dput(upper);
 
 	 
 	if (!err)
 		d_drop(dentry);
out_unlock:
 	inode_unlock(dir);
 
 	return err;
  static int ovl_rename2(struct inode *olddir, struct dentry *old,
 
 	trap = lock_rename(new_upperdir, old_upperdir);
 

	olddentry = lookup_one_len(old->d_name.name, old_upperdir,
				   old->d_name.len);
	err = PTR_ERR(olddentry);
	if (IS_ERR(olddentry))
		goto out_unlock;

	err = -ESTALE;
	if (olddentry != ovl_dentry_upper(old))
		goto out_dput_old;

	newdentry = lookup_one_len(new->d_name.name, new_upperdir,
				   new->d_name.len);
	err = PTR_ERR(newdentry);
	if (IS_ERR(newdentry))
		goto out_dput_old;

	err = -ESTALE;
	if (ovl_dentry_upper(new)) {
 		if (opaquedir) {
			if (newdentry != opaquedir)
				goto out_dput;
 		} else {
			if (newdentry != ovl_dentry_upper(new))
				goto out_dput;
 		}
 	} else {
 		new_create = true;
		if (!d_is_negative(newdentry) &&
		    (!new_opaque || !ovl_is_whiteout(newdentry)))
			goto out_dput;
 	}
 
 	if (olddentry == trap)
 		goto out_dput;
 	if (newdentry == trap)
  static int ovl_rename2(struct inode *olddir, struct dentry *old,
 
 out_dput:
 	dput(newdentry);
out_dput_old:
	dput(olddentry);
 out_unlock:
 	unlock_rename(new_upperdir, old_upperdir);
 out_revert_creds:","fs/overlayfs/dir.c in the OverlayFS filesystem implementation in the Linux kernel before 4.6 does not properly verify the upper dentry before proceeding with unlink and rename system-call processing, which allows local users to cause a denial of service (system crash) via a rename system call that specifies a self-hardlink."
630,CVE-2016-6187,"  static int apparmor_setprocattr(struct task_struct *task, char *name,
 {
 	struct common_audit_data sa;
 	struct apparmor_audit_data aad = {0,};
	char *command, *largs = NULL, *args = value;
 	size_t arg_size;
 	int error;
 
 	if (size == 0)
 		return -EINVAL;
 	 
 	if (current != task)
 		return -EACCES;
 
	 
	if (args[size - 1] != '\0') {
		 
		largs = args = kmalloc(size + 1, GFP_KERNEL);
		if (!args)
			return -ENOMEM;
		memcpy(args, value, size);
		args[size] = '\0';
	}

	error = -EINVAL;
 	args = strim(args);
 	command = strsep(&args, "" "");
 	if (!args)
		goto out;
 	args = skip_spaces(args);
 	if (!*args)
		goto out;
 
 	arg_size = size - (args - (char *) value);
 	if (strcmp(name, ""current"") == 0) {
  static int apparmor_setprocattr(struct task_struct *task, char *name,
 			goto fail;
 	} else
 		 
		goto fail;
 
 	if (!error)
 		error = size;
out:
	kfree(largs);
 	return error;
 
 fail:
  static int apparmor_setprocattr(struct task_struct *task, char *name,
 	aad.profile = aa_current_profile();
 	aad.op = OP_SETPROCATTR;
 	aad.info = name;
	aad.error = error = -EINVAL;
 	aa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);
	goto out;
 }
 
 static int apparmor_task_setrlimit(struct task_struct *task,","The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 4.6.5 does not validate the buffer size, which allows local users to gain privileges by triggering an AppArmor setprocattr hook."
631,CVE-2016-6156,"  static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)
 		goto exit;
 	}
 
	if (u_cmd.outsize != s_cmd->outsize ||
	    u_cmd.insize != s_cmd->insize) {
		ret = -EINVAL;
		goto exit;
	}

 	s_cmd->command += ec->cmd_offset;
 	ret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);
 	 
 	if (ret < 0)
 		goto exit;
 
	if (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))
 		ret = -EFAULT;
 exit:
 	kfree(s_cmd);","Race condition in the ec_device_ioctl_xcmd function in drivers/platform/chrome/cros_ec_dev.c in the Linux kernel before 4.7 allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a *double fetch* vulnerability."
632,CVE-2016-6136," 
 #include <linux/compat.h>
 #include <linux/ctype.h>
 #include <linux/string.h>
#include <linux/uaccess.h>
 #include <uapi/linux/limits.h>
 
 #include ""audit.h""
 
 #define AUDITSC_SUCCESS 1
 #define AUDITSC_FAILURE 2
 
 
 #define MAX_EXECVE_AUDIT_LEN 7500
 
  
  static int audit_log_pid_context(struct audit_context *context, pid_t pid,
 	return rc;
 }
 
static void audit_log_execve_info(struct audit_context *context,
				  struct audit_buffer **ab)
 {
	long len_max;
	long len_rem;
	long len_full;
	long len_buf;
	long len_abuf;
	long len_tmp;
	bool require_data;
	bool encode;
	unsigned int iter;
	unsigned int arg;
	char *buf_head;
	char *buf;
	const char __user *p = (const char __user *)current->mm->arg_start;

	 
	char abuf[96];

	 
	WARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);
	len_max = MAX_EXECVE_AUDIT_LEN;

	 
	buf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);
	if (!buf_head) {
		audit_panic(""out of memory for argv string"");
		return;
 	}
	buf = buf_head;
 
	audit_log_format(*ab, ""argc=%d"", context->execve.argc);

	len_rem = len_max;
	len_buf = 0;
	len_full = 0;
	require_data = true;
	encode = false;
	iter = 0;
	arg = 0;
 	do {
		 
		if (len_full == 0)
			len_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;

		 
		if (require_data) {
			 
			if (buf != buf_head) {
				memmove(buf_head, buf, len_buf);
				buf = buf_head;
			}

			 
			len_tmp = strncpy_from_user(&buf_head[len_buf], p,
						    len_max - len_buf);
			if (len_tmp == -EFAULT) {
				 
				send_sig(SIGKILL, current, 0);
				goto out;
			} else if (len_tmp == (len_max - len_buf)) {
				 
				require_data = true;
				 
				encode = true;
				len_full = len_full * 2;
				p += len_tmp;
			} else {
				require_data = false;
				if (!encode)
					encode = audit_string_contains_control(
								buf, len_tmp);
				 
				if (len_full < len_max)
					len_full = (encode ?
						    len_tmp * 2 : len_tmp);
				p += len_tmp + 1;
			}
			len_buf += len_tmp;
			buf_head[len_buf] = '\0';
 
			 
			len_abuf = (encode ? len_buf * 2 : len_buf + 2);
 		}
 
		 
		if (len_buf > 0) {
			 
			if ((sizeof(abuf) + 8) > len_rem) {
				len_rem = len_max;
				audit_log_end(*ab);
				*ab = audit_log_start(context,
						      GFP_KERNEL, AUDIT_EXECVE);
				if (!*ab)
					goto out;
			}
 
			 
			len_tmp = 0;
			if (require_data || (iter > 0) ||
			    ((len_abuf + sizeof(abuf)) > len_rem)) {
				if (iter == 0) {
					len_tmp += snprintf(&abuf[len_tmp],
							sizeof(abuf) - len_tmp,
							"" a%d_len=%lu"",
							arg, len_full);
				}
				len_tmp += snprintf(&abuf[len_tmp],
						    sizeof(abuf) - len_tmp,
						    "" a%d[%d]="", arg, iter++);
			} else
				len_tmp += snprintf(&abuf[len_tmp],
						    sizeof(abuf) - len_tmp,
						    "" a%d="", arg);
			WARN_ON(len_tmp >= sizeof(abuf));
			abuf[sizeof(abuf) - 1] = '\0';

			 
			audit_log_format(*ab, ""%s"", abuf);
			len_rem -= len_tmp;
			len_tmp = len_buf;
			if (encode) {
				if (len_abuf > len_rem)
					len_tmp = len_rem / 2;  
				audit_log_n_hex(*ab, buf, len_tmp);
				len_rem -= len_tmp * 2;
				len_abuf -= len_tmp * 2;
			} else {
				if (len_abuf > len_rem)
					len_tmp = len_rem - 2;  
				audit_log_n_string(*ab, buf, len_tmp);
				len_rem -= len_tmp + 2;
				 
				len_abuf -= len_tmp;
			}
			len_buf -= len_tmp;
			buf += len_tmp;
		}
 
		 
		if ((len_buf == 0) && !require_data) {
			arg++;
			iter = 0;
			len_full = 0;
			require_data = true;
			encode = false;
		}
	} while (arg < context->execve.argc);
 
	 
 
out:
	kfree(buf_head);
 }
 
 static void show_special(struct audit_context *context, int *call_panic)","Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a *double fetch* vulnerability."
633,CVE-2016-6130,"  static int sclp_ctl_ioctl_sccb(void __user *user_area)
 {
 	struct sclp_ctl_sccb ctl_sccb;
 	struct sccb_header *sccb;
	unsigned long copied;
 	int rc;
 
 	if (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))
  static int sclp_ctl_ioctl_sccb(void __user *user_area)
 	sccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);
 	if (!sccb)
 		return -ENOMEM;
	copied = PAGE_SIZE -
		copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), PAGE_SIZE);
	if (offsetof(struct sccb_header, length) +
	    sizeof(sccb->length) > copied || sccb->length > copied) {
 		rc = -EFAULT;
 		goto out_free;
 	}
	if (sccb->length < 8) {
		rc = -EINVAL;
 		goto out_free;
 	}
 	rc = sclp_sync_request(ctl_sccb.cmdw, sccb);","Race condition in the sclp_ctl_ioctl_sccb function in drivers/s390/char/sclp_ctl.c in the Linux kernel before 4.6 allows local users to obtain sensitive information from kernel memory by changing a certain length value, aka a *double fetch* vulnerability."
634,CVE-2016-6128," 
#include <stdio.h>
#include <stdlib.h>
#include ""gd.h""

#include ""gdtest.h""

int main()
{
	gdImagePtr im, exp;
	int error = 0;

	im = gdImageCreate(50, 50);

	if (!im) {
		gdTestErrorMsg(""gdImageCreate failed.\n"");
		return 1;
	}

	gdImageCropThreshold(im, 1337, 0);
	gdImageDestroy(im);
	 
	return 0;
}","The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index."
635,CVE-2016-5844,"  choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 		 
 		vd = &(iso9660->joliet);
 
	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
 	skipsize = __archive_read_consume(a, skipsize);
 	if (skipsize < 0)
 		return ((int)skipsize);
  choose_volume(struct archive_read *a, struct iso9660 *iso9660)
 	    && iso9660->seenJoliet) {
 		 
 		vd = &(iso9660->joliet);
		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
 		skipsize -= iso9660->current_position;
 		skipsize = __archive_read_consume(a, skipsize);
 		if (skipsize < 0)",Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.
636,CVE-2016-5829,"  static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd,
 					goto inval;
 			} else if (uref->usage_index >= field->report_count)
 				goto inval;
 		}
 
		if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&
		    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||
		     uref->usage_index + uref_multi->num_values > field->report_count))
			goto inval;

 		switch (cmd) {
 		case HIDIOCGUSAGE:
 			uref->value = field->value[uref->usage_index];",Multiple heap-based buffer overflows in the hiddev_ioctl_usage function in drivers/hid/usbhid/hiddev.c in the Linux kernel through 4.6.3 allow local users to cause a denial of service or possibly have unspecified other impact via a crafted (1) HIDIOCGUSAGES or (2) HIDIOCSUSAGES ioctl call.
637,CVE-2016-5770,"  static void spl_filesystem_object_free_storage(void *object TSRMLS_DC)  
 	if (intern->oth_handler && intern->oth_handler->dtor) {
 		intern->oth_handler->dtor(intern TSRMLS_CC);
 	}

 	zend_object_std_dtor(&intern->std TSRMLS_CC);

 	if (intern->_path) {
 		efree(intern->_path);
 	}
  static void spl_filesystem_object_free_storage(void *object TSRMLS_DC)  
 		}
 		if (intern->u.dir.sub_path) {
 			efree(intern->u.dir.sub_path);
		}
 		break;
 	case SPL_FS_FILE:
 		if (intern->u.file.stream) {
  static void spl_filesystem_object_free_storage(void *object TSRMLS_DC)  
 }  
 
  
  static int spl_filesystem_file_open(spl_filesystem_object *intern, int use_inclu
 	 
 	ZVAL_RESOURCE(&intern->u.file.zresource, php_stream_get_resource_id(intern->u.file.stream));
 	Z_SET_REFCOUNT(intern->u.file.zresource, 1);

 	intern->u.file.delimiter = ',';
 	intern->u.file.enclosure = '""';
 	intern->u.file.escape = '\\';
  static int spl_filesystem_file_open(spl_filesystem_object *intern, int use_inclu
 
  
  
 {
 	char *p1, *p2;

 	if (intern->file_name) {
 		efree(intern->file_name);
 	}
  void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path,
 	} else {
 		intern->_path_len = 0;
 	}

 	if (intern->_path) {
 		efree(intern->_path);
 	}
  static spl_filesystem_object * spl_filesystem_object_create_info(spl_filesystem_
 	} else {
 		spl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);
 	}

 	zend_restore_error_handling(&error_handling TSRMLS_CC);
 	return intern;
 }  
  static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 
 		return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);
 		Z_TYPE_P(return_value) = IS_OBJECT;

 		spl_filesystem_object_get_file_name(source TSRMLS_CC);
 
 		if (ce->constructor->common.scope != spl_ce_SplFileObject) {
  static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 			intern->file_name_len = source->file_name_len;
 			intern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);
 			intern->_path = estrndup(intern->_path, intern->_path_len);

 			intern->u.file.open_mode = ""r"";
 			intern->u.file.open_mode_len = 1;

			if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"",
					&intern->u.file.open_mode, &intern->u.file.open_mode_len,
 					&use_include_path, &intern->u.file.zcontext) == FAILURE) {
 				zend_restore_error_handling(&error_handling TSRMLS_CC);
 				intern->u.file.open_mode = NULL;
  static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 				Z_TYPE_P(return_value) = IS_NULL;
 				return NULL;
 			}

 			if (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {
 				zend_restore_error_handling(&error_handling TSRMLS_CC);
 				zval_dtor(return_value);
  static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_fil
 			}
 		}
 		break;
	case SPL_FS_DIR:
 		zend_restore_error_handling(&error_handling TSRMLS_CC);
 		zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Operation not supported"");
 		return NULL;
  static HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp T
 	if (intern->file_name) {
 		pnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, ""fileName"", sizeof(""fileName"")-1, &pnlen TSRMLS_CC);
 		spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);

 		if (path_len && path_len < intern->file_name_len) {
 			add_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);
 		} else {
  static HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp T
 zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC)  
 {
 	spl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);

 	if (fsobj->u.dir.entry.d_name[0] == '\0' && fsobj->orig_path == NULL) {
 		method = ""_bad_state_ex"";
 		method_len = sizeof(""_bad_state_ex"") - 1;
 		key = NULL;
 	}

 	return zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);
 }
  
  SPL_METHOD(DirectoryIterator, __construct)
 SPL_METHOD(DirectoryIterator, rewind)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(DirectoryIterator, rewind)
 SPL_METHOD(DirectoryIterator, key)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(DirectoryIterator, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	int skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(DirectoryIterator, seek)
 SPL_METHOD(DirectoryIterator, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileInfo, getPath)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	char *path;
 	int path_len;

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileInfo, getFilename)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	int path_len;

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
 
 	spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);

 	if (path_len && path_len < intern->file_name_len) {
 		RETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);
 	} else {
  SPL_METHOD(SplFileInfo, getFilename)
 SPL_METHOD(DirectoryIterator, getFilename)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileInfo, getBasename)
 
 	RETURN_STRINGL(fname, flen, 0);
 }
 
 
  
  SPL_METHOD(DirectoryIterator, getBasename)
 	char *suffix = 0, *fname;
 	int slen = 0;
 	size_t flen;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s"", &suffix, &slen) == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileInfo, getPathname)
 SPL_METHOD(FilesystemIterator, key)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(FilesystemIterator, key)
 SPL_METHOD(FilesystemIterator, current)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(FilesystemIterator, current)
 SPL_METHOD(DirectoryIterator, isDot)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(DirectoryIterator, isDot)
  
 SPL_METHOD(SplFileInfo, __construct)
  SPL_METHOD(SplFileInfo, __construct)
 	}
 
 	intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	spl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);
 
 	zend_restore_error_handling(&error_handling TSRMLS_CC);

 	 
 }
  
  SPL_METHOD(SplFileInfo, getLinkTarget)
 	int ret;
 	char buff[MAXPATHLEN];
 	zend_error_handling error_handling;

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileInfo, getRealPath)
 	char buff[MAXPATHLEN];
 	char *filename;
 	zend_error_handling error_handling;

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileInfo, getRealPath)
 	if (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {
 		spl_filesystem_object_get_file_name(intern TSRMLS_CC);
 	}

 	if (intern->orig_path) {
 		filename = intern->orig_path;
	} else {
 		filename = intern->file_name;
 	}
 
  SPL_METHOD(SplFileInfo, setFileClass)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = spl_ce_SplFileObject;
 	zend_error_handling error_handling;

 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
  SPL_METHOD(SplFileInfo, setInfoClass)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = spl_ce_SplFileInfo;
 	zend_error_handling error_handling;

 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
  SPL_METHOD(SplFileInfo, getFileInfo)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = intern->info_class;
 	zend_error_handling error_handling;

 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
  SPL_METHOD(SplFileInfo, getPathInfo)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	zend_class_entry *ce = intern->info_class;
 	zend_error_handling error_handling;

 	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
  SPL_METHOD(FilesystemIterator, rewind)
 SPL_METHOD(FilesystemIterator, getFlags)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(RecursiveDirectoryIterator, getChildren)
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	spl_filesystem_object *subdir;
 	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

 	spl_filesystem_object_get_file_name(intern TSRMLS_CC);
 
 	MAKE_STD_ZVAL(zflags);
  SPL_METHOD(RecursiveDirectoryIterator, getChildren)
 SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
 	char *sub_name;
 	int len;
 	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(GlobIterator, __construct)
 SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval
 		iterator->current = object;
 	}
 	zval_add_ref(&object);

 	return (zend_object_iterator*)iterator;
 }
  
  static int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC)
 static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)
 {
 	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;

 	*data = &iterator->current;
 }
  
  static void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *
 static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
 {
 	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);

 	object->u.dir.index++;
 	spl_filesystem_dir_read(object TSRMLS_CC);
 	if (object->file_name) {
  static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS
 static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
 {
 	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);

 	object->u.dir.index = 0;
 	if (object->u.dir.dirp) {
 		php_stream_rewinddir(object->u.dir.dirp);
  static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRML
 {
 	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
 	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);

 	object->u.dir.index++;
 	do {
 		spl_filesystem_dir_read(object TSRMLS_CC);
  static void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)
 {
 	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
 	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);

 	object->u.dir.index = 0;
 	if (object->u.dir.dirp) {
 		php_stream_rewinddir(object->u.dir.dirp);
  zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zva
 		iterator->intern.funcs = &spl_filesystem_tree_it_funcs;
 	}
 	zval_add_ref(&object);

 	return (zend_object_iterator*)iterator;
 }
  
  static int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TS
 
  
  
ZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0)
 	ZEND_ARG_INFO(0, file_name)
 ZEND_END_ARG_INFO()
 
  static const zend_function_entry spl_SplFileInfo_functions[] = {
 	PHP_FE_END
 };
 
ZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0)
 	ZEND_ARG_INFO(0, path)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0)
 	ZEND_ARG_INFO(0, position)
 ZEND_END_ARG_INFO();
 
  static const zend_function_entry spl_DirectoryIterator_functions[] = {
 	PHP_FE_END
 };
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1)
 	ZEND_ARG_INFO(0, path)
 	ZEND_ARG_INFO(0, flags)
 ZEND_END_ARG_INFO()
  static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TS
 	long line_add = (intern->u.file.current_line || intern->u.file.current_zval) ? 1 : 0;
 
 	spl_filesystem_file_free_line(intern TSRMLS_CC);

 	if (php_stream_eof(intern->u.file.stream)) {
 		if (!silent) {
 			zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Cannot read from file %s"", intern->file_name);
  static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TS
 			line_len = strcspn(buf, ""\r\n"");
 			buf[line_len] = '\0';
 		}

 		intern->u.file.current_line = buf;
 		intern->u.file.current_line_len = line_len;
 	}
  static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function
 	zval ***params = (zval***)safe_emalloc(num_args, sizeof(zval**), 0);
 
 	params[0] = &zresource_ptr;

 	if (arg2) {
 		params[1] = &arg2;
 	}
  static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function
 	fcic.object_ptr = NULL;
 
 	result = zend_call_function(&fci, &fcic TSRMLS_CC);

 	if (result == FAILURE) {
 		RETVAL_FALSE;
 	} else {
  static int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function
 static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC)  
 {
 	int ret = SUCCESS;

 	do {
 		ret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);
 	} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));

 	if (ret == SUCCESS) {
 		size_t buf_len = intern->u.file.current_line_len;
 		char *buf = estrndup(intern->u.file.current_line, buf_len);
  static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRML
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;

 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
  static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object
 		spl_filesystem_file_free_line(intern TSRMLS_CC);
 		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
 	}

 	return ret;
 }
  
  SPL_METHOD(SplFileObject, __construct)
 	intern->u.file.open_mode = NULL;
 	intern->u.file.open_mode_len = 0;
 
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|sbr!"",
 			&intern->file_name, &intern->file_name_len,
			&intern->u.file.open_mode, &intern->u.file.open_mode_len,
			&use_include_path, &intern->u.file.zcontext) == FAILURE) {
 		intern->u.file.open_mode = NULL;
 		intern->file_name = NULL;
 		zend_restore_error_handling(&error_handling TSRMLS_CC);
 		return;
 	}

 	if (intern->u.file.open_mode == NULL) {
 		intern->u.file.open_mode = ""r"";
 		intern->u.file.open_mode_len = 1;
  SPL_METHOD(SplTempFileObject, __construct)
 	intern->u.file.open_mode = ""wb"";
 	intern->u.file.open_mode_len = 1;
 	intern->u.file.zcontext = NULL;

 	if (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {
 		intern->_path_len = 0;
 		intern->_path = estrndup("""", 0);
  SPL_METHOD(SplTempFileObject, __construct)
 SPL_METHOD(SplFileObject, rewind)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, rewind)
 SPL_METHOD(SplFileObject, eof)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, eof)
 SPL_METHOD(SplFileObject, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, valid)
 SPL_METHOD(SplFileObject, fgets)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, fgets)
 SPL_METHOD(SplFileObject, current)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, current)
 SPL_METHOD(SplFileObject, key)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, key)
 SPL_METHOD(SplFileObject, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, setMaxLineLen)
 		zend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, ""Maximum line length must be greater than or equal zero"");
 		return;
 	}

 	intern->u.file.max_line_len = max_len;
 }  
 
  SPL_METHOD(SplFileObject, setMaxLineLen)
 SPL_METHOD(SplFileObject, getMaxLineLen)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, hasChildren)
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

 	RETURN_FALSE;
 }  
 
  SPL_METHOD(SplFileObject, fgetcsv)
 	char delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;
 	char *delim = NULL, *enclo = NULL, *esc = NULL;
 	int d_len = 0, e_len = 0, esc_len = 0;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sss"", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {
 		switch(ZEND_NUM_ARGS())
 		{
  SPL_METHOD(SplFileObject, fputcsv)
 	char *delim = NULL, *enclo = NULL, *esc = NULL;
 	int d_len = 0, e_len = 0, esc_len = 0, ret;
 	zval *fields = NULL;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""a|sss"", &fields, &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {
 		switch(ZEND_NUM_ARGS())
 		{
  SPL_METHOD(SplFileObject, setCsvControl)
 	char delimiter = ',', enclosure = '""', escape='\\';
 	char *delim = NULL, *enclo = NULL, *esc = NULL;
 	int d_len = 0, e_len = 0, esc_len = 0;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sss"", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {
 		switch(ZEND_NUM_ARGS())
 		{
  SPL_METHOD(SplFileObject, getCsvControl)
 	char delimiter[2], enclosure[2];
 
 	array_init(return_value);

 	delimiter[0] = intern->u.file.delimiter;
 	delimiter[1] = '\0';
 	enclosure[0] = intern->u.file.enclosure;
  SPL_METHOD(SplFileObject, fflush)
    Return current file position */
 SPL_METHOD(SplFileObject, ftell)
 {
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long ret = php_stream_tell(intern->u.file.stream);
 
 	if (ret == -1) {
  SPL_METHOD(SplFileObject, fread)
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than 0"");
 		RETURN_FALSE;
 	}
	if (length > INT_MAX) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be no more than %d"", INT_MAX);
		RETURN_FALSE;
	}
 
 	Z_STRVAL_P(return_value) = emalloc(length + 1);
 	Z_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);
  SPL_METHOD(SplFileObject, ftruncate)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long size;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &size) == FAILURE) {
 		return;
 	}
  SPL_METHOD(SplFileObject, ftruncate)
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't truncate file %s"", intern->file_name);
 		RETURN_FALSE;
 	}

 	RETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));
 }  
 
  SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;
 	}

 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);

 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
  ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)
 	ZEND_ARG_INFO(0, escape)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1)
 	ZEND_ARG_INFO(0, operation)
 	ZEND_ARG_INFO(1, wouldblock)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1)
 	ZEND_ARG_INFO(0, pos)
 	ZEND_ARG_INFO(0, whence)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0)
 	ZEND_ARG_INFO(0, allowable_tags)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1)
 	ZEND_ARG_INFO(0, format)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1)
 	ZEND_ARG_INFO(0, str)
 	ZEND_ARG_INFO(0, length)
 ZEND_END_ARG_INFO()
  ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fread, 0, 0, 1)
 	ZEND_ARG_INFO(0, length)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1)
 	ZEND_ARG_INFO(0, size)
 ZEND_END_ARG_INFO()
 
ZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1)
 	ZEND_ARG_INFO(0, line_pos)
 ZEND_END_ARG_INFO()
 
  PHP_MINIT_FUNCTION(spl_directory)
 
 	REGISTER_SPL_SUB_CLASS_EX(RecursiveDirectoryIterator, FilesystemIterator, spl_filesystem_object_new, spl_RecursiveDirectoryIterator_functions);
 	REGISTER_SPL_IMPLEMENTS(RecursiveDirectoryIterator, RecursiveIterator);

 	memcpy(&spl_filesystem_object_check_handlers, &spl_filesystem_object_handlers, sizeof(zend_object_handlers));
 	spl_filesystem_object_check_handlers.get_method = spl_filesystem_object_get_method_check;
 
  PHP_MINIT_FUNCTION(spl_directory)
 	REGISTER_SPL_CLASS_CONST_LONG(SplFileObject, ""READ_AHEAD"",    SPL_FILE_OBJECT_READ_AHEAD);
 	REGISTER_SPL_CLASS_CONST_LONG(SplFileObject, ""SKIP_EMPTY"",    SPL_FILE_OBJECT_SKIP_EMPTY);
 	REGISTER_SPL_CLASS_CONST_LONG(SplFileObject, ""READ_CSV"",      SPL_FILE_OBJECT_READ_CSV);

 	REGISTER_SPL_SUB_CLASS_EX(SplTempFileObject, SplFileObject, spl_filesystem_object_new_check, spl_SplTempFileObject_functions);
 	return SUCCESS;
 }","Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096."
638,CVE-2016-5769," 
 
 static int le_mcrypt;
 
typedef struct _php_mcrypt {
 	MCRYPT td;
 	zend_bool init;
 } php_mcrypt;
  ZEND_DECLARE_MODULE_GLOBALS(mcrypt)
 
 zend_module_entry mcrypt_module_entry = {
 	STANDARD_MODULE_HEADER,
	""mcrypt"",
 	mcrypt_functions,
 	PHP_MINIT(mcrypt), PHP_MSHUTDOWN(mcrypt),
 	NULL, NULL,
  ZEND_GET_MODULE(mcrypt)
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &mcryptind) == FAILURE) {			\
 		return;																\
 	}																						\
	ZEND_FETCH_RESOURCE (pm, php_mcrypt *, &mcryptind, -1, ""MCrypt"", le_mcrypt);
 
 #define MCRYPT_GET_MODE_DIR_ARGS(DIRECTORY)								\
 	char *dir = NULL;                                                   \
  PHP_INI_END()
 static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)  
 {
 	php_mcrypt *pm = (php_mcrypt *) rsrc->ptr;
	if (pm) {
 		mcrypt_generic_deinit(pm->td);
 		mcrypt_module_close(pm->td);
 		efree(pm);
  PHP_MINFO_FUNCTION(mcrypt)  
 	smart_str_free(&tmp1);
 	smart_str_free(&tmp2);
 	php_info_print_table_end();

 	DISPLAY_INI_ENTRIES();
 }
  
  PHP_FUNCTION(mcrypt_module_open)
 	int   mode_len,   mode_dir_len;
 	MCRYPT td;
 	php_mcrypt *pm;

 	if (zend_parse_parameters (ZEND_NUM_ARGS() TSRMLS_CC, ""ssss"",
 		&cipher, &cipher_len, &cipher_dir, &cipher_dir_len,
 		&mode,   &mode_len,   &mode_dir,   &mode_dir_len)) {
 		return;
 	}

 	td = mcrypt_module_open (
 		cipher,
 		cipher_dir_len > 0 ? cipher_dir : MCG(algorithms_dir),
		mode,
 		mode_dir_len > 0 ? mode_dir : MCG(modes_dir)
 	);
 
  PHP_FUNCTION(mcrypt_generic_init)
 	int max_key_size, key_size, iv_size;
 	php_mcrypt *pm;
 	int result = 0;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rss"", &mcryptind, &key, &key_len, &iv, &iv_len) == FAILURE) {
 		return;
 	}
  PHP_FUNCTION(mcrypt_generic)
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &mcryptind, &data, &data_len) == FAILURE) {
 		return;
 	}

 	ZEND_FETCH_RESOURCE(pm, php_mcrypt *, &mcryptind, -1, ""MCrypt"", le_mcrypt);
 	PHP_MCRYPT_INIT_CHECK
 
  PHP_FUNCTION(mcrypt_generic)
 	if (mcrypt_enc_is_block_mode(pm->td) == 1) {  
 		block_size = mcrypt_enc_get_block_size(pm->td);
 		data_size = (((data_len - 1) / block_size) + 1) * block_size;
		if (data_size <= 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Integer overflow in data size"");
			RETURN_FALSE;
		}
 		data_s = emalloc(data_size + 1);
 		memset(data_s, 0, data_size);
 		memcpy(data_s, data, data_len);
  PHP_FUNCTION(mcrypt_generic)
 		memset(data_s, 0, data_size);
 		memcpy(data_s, data, data_len);
 	}

 	mcrypt_generic(pm->td, data_s, data_size);
 	data_s[data_size] = '\0';
 
  PHP_FUNCTION(mdecrypt_generic)
 	php_mcrypt *pm;
 	char* data_s;
 	int block_size, data_size;

 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &mcryptind, &data, &data_len) == FAILURE) {
 		return;
 	}

 	ZEND_FETCH_RESOURCE(pm, php_mcrypt * , &mcryptind, -1, ""MCrypt"", le_mcrypt);
 	PHP_MCRYPT_INIT_CHECK
 
  PHP_FUNCTION(mdecrypt_generic)
 	if (mcrypt_enc_is_block_mode(pm->td) == 1) {  
 		block_size = mcrypt_enc_get_block_size(pm->td);
 		data_size = (((data_len - 1) / block_size) + 1) * block_size;
		if (data_size <= 0) {
			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Integer overflow in data size"");
			RETURN_FALSE;
		}
 		data_s = emalloc(data_size + 1);
 		memset(data_s, 0, data_size);
 		memcpy(data_s, data, data_len);
  PHP_FUNCTION(mdecrypt_generic)
 		memset(data_s, 0, data_size);
 		memcpy(data_s, data, data_len);
 	}

 	mdecrypt_generic(pm->td, data_s, data_size);
 
 	RETVAL_STRINGL(data_s, data_size, 1);
  PHP_FUNCTION(mcrypt_enc_get_supported_key_sizes)
 {
 	int i, count = 0;
 	int *key_sizes;

 	MCRYPT_GET_TD_ARG
 	array_init(return_value);
 
  PHP_FUNCTION(mcrypt_enc_is_block_algorithm)
 	MCRYPT_GET_TD_ARG
 
 	if (mcrypt_enc_is_block_algorithm(pm->td) == 1) {
		RETURN_TRUE
 	} else {
 		RETURN_FALSE
 	}
  PHP_FUNCTION(mcrypt_enc_get_modes_name)
 PHP_FUNCTION(mcrypt_module_self_test)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(algorithms_dir);

 	if (mcrypt_module_self_test(module, dir) == 0) {
 		RETURN_TRUE;
 	} else {
  PHP_FUNCTION(mcrypt_module_self_test)
 PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)

 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
  PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 PHP_FUNCTION(mcrypt_module_is_block_algorithm)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)

 	if (mcrypt_module_is_block_algorithm(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
  PHP_FUNCTION(mcrypt_module_is_block_algorithm)
 PHP_FUNCTION(mcrypt_module_is_block_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)

 	if (mcrypt_module_is_block_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
  PHP_FUNCTION(mcrypt_module_is_block_mode)
 PHP_FUNCTION(mcrypt_module_get_algo_block_size)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)

 	RETURN_LONG(mcrypt_module_get_algo_block_size(module, dir));
 }
  
  PHP_FUNCTION(mcrypt_module_get_algo_block_size)
 PHP_FUNCTION(mcrypt_module_get_algo_key_size)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(algorithms_dir);

 	RETURN_LONG(mcrypt_module_get_algo_key_size(module, dir));
 }
  
  PHP_FUNCTION(mcrypt_module_get_supported_key_sizes)
 {
 	int i, count = 0;
 	int *key_sizes;

 	MCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)
 	array_init(return_value);
 
  PHP_FUNCTION(mcrypt_list_algorithms)
 		&lib_dir, &lib_dir_len) == FAILURE) {
 		return;
 	}

 	array_init(return_value);
 	modules = mcrypt_list_algorithms(lib_dir, &count);
 
  PHP_FUNCTION(mcrypt_get_key_size)
 {
 	char *cipher;
 	char *module;
	int   cipher_len, module_len;
 	char *cipher_dir_string;
 	char *module_dir_string;
 	MCRYPT td;
  PHP_FUNCTION(mcrypt_get_key_size)
 		&cipher, &cipher_len, &module, &module_len) == FAILURE) {
 		return;
 	}

 	td = mcrypt_module_open(cipher, cipher_dir_string, module, module_dir_string);
 	if (td != MCRYPT_FAILED) {
 		RETVAL_LONG(mcrypt_enc_get_key_size(td));
  PHP_FUNCTION(mcrypt_get_block_size)
 {
 	char *cipher;
 	char *module;
	int   cipher_len, module_len;
 	char *cipher_dir_string;
 	char *module_dir_string;
 	MCRYPT td;
  PHP_FUNCTION(mcrypt_get_block_size)
 		&cipher, &cipher_len, &module, &module_len) == FAILURE) {
 		return;
 	}

 	td = mcrypt_module_open(cipher, cipher_dir_string, module, module_dir_string);
 	if (td != MCRYPT_FAILED) {
 		RETVAL_LONG(mcrypt_enc_get_block_size(td));
  PHP_FUNCTION(mcrypt_get_iv_size)
 {
 	char *cipher;
 	char *module;
	int   cipher_len, module_len;
 	char *cipher_dir_string;
 	char *module_dir_string;
 	MCRYPT td;
  PHP_FUNCTION(mcrypt_get_iv_size)
 		&cipher, &cipher_len, &module, &module_len) == FAILURE) {
 		return;
 	}

 	td = mcrypt_module_open(cipher, cipher_dir_string, module, module_dir_string);
 	if (td != MCRYPT_FAILED) {
 		RETVAL_LONG(mcrypt_enc_get_iv_size(td));
  static void php_mcrypt_do_crypt(char* cipher, const char *key, int key_len, cons
 	} else {  
 		use_key_length = max_key_length;  
 		for (i = 0; i < count; i++) {
			if (key_length_sizes[i] >= key_len &&
 				key_length_sizes[i] < use_key_length)
 			{
 				use_key_length = key_length_sizes[i];
  static void php_mcrypt_do_crypt(char* cipher, const char *key, int key_len, cons
 		memcpy(key_s, key, MIN(key_len, use_key_length));
 	}
 	mcrypt_free (key_length_sizes);

 	 
 	iv_s = NULL;
 	iv_size = mcrypt_enc_get_iv_size (td);

 	 
 	if (mcrypt_enc_mode_has_iv(td) == 1) {
 		if (argc == 5) {
  static void php_mcrypt_do_crypt(char* cipher, const char *key, int key_len, cons
 	} else {
 		mdecrypt_generic(td, data_s, data_size);
 	}

 	RETVAL_STRINGL(data_s, data_size, 1);
 
 	 
  PHP_FUNCTION(mcrypt_encrypt)
 	zval **mode;
 	char *cipher, *key, *data, *iv = NULL;
 	int cipher_len, key_len, data_len, iv_len = 0;

 	MCRYPT_GET_CRYPT_ARGS

 	convert_to_string_ex(mode);
 
 	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);
  PHP_FUNCTION(mcrypt_decrypt)
 	int cipher_len, key_len, data_len, iv_len = 0;
 
 	MCRYPT_GET_CRYPT_ARGS

 	convert_to_string_ex(mode);
 
 	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_DECRYPT, return_value TSRMLS_CC);
  PHP_FUNCTION(mcrypt_ecb)
 	zval **mode;
 	char *cipher, *key, *data, *iv = NULL;
 	int cipher_len, key_len, data_len, iv_len = 0;

 	MCRYPT_GET_CRYPT_ARGS
 
 	convert_to_long_ex(mode);
  PHP_FUNCTION(mcrypt_cfb)
 	zval **mode;
 	char *cipher, *key, *data, *iv = NULL;
 	int cipher_len, key_len, data_len, iv_len = 0;

 	MCRYPT_GET_CRYPT_ARGS
 
 	convert_to_long_ex(mode);
  PHP_FUNCTION(mcrypt_ofb)
 	zval **mode;
 	char *cipher, *key, *data, *iv = NULL;
 	int cipher_len, key_len, data_len, iv_len = 0;

 	MCRYPT_GET_CRYPT_ARGS
 
 	convert_to_long_ex(mode);
  PHP_FUNCTION(mcrypt_create_iv)
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Cannot create an IV with a size of less than 1 or greater than %d"", INT_MAX);
 		RETURN_FALSE;
 	}

 	iv = ecalloc(size + 1, 1);

 	if (source == RANDOM || source == URANDOM) {
 #if PHP_WIN32
 		 ","Multiple integer overflows in mcrypt.c in the mcrypt extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted length value, related to the (1) mcrypt_generic and (2) mdecrypt_generic functions."
639,CVE-2016-5768," 
 #include ""ext/standard/info.h""
 #include ""php_mbregex.h""
 #include ""mbstring.h""

 #include ""php_onig_compat.h""  
 #include <oniguruma.h>
 #undef UChar
  struct _zend_mb_regex_globals {
 #define MBREX(g) (MBSTRG(mb_regex_globals)->g)
 
  
static void php_mb_regex_free_cache(php_mb_regex_t **pre)
 {
 	onig_free(*pre);
 }
  static int _php_mb_regex_globals_ctor(zend_mb_regex_globals *pglobals TSRMLS_DC)
  
 
  
static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)
 {
 	zend_hash_destroy(&pglobals->ht_rc);
 }
  static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patl
 		retval = *rc;
 	}
 out:
	return retval;
 }
  
 
  static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'i';
 		}
		++len_req;
 	}
 
 	if ((option & ONIG_OPTION_EXTEND) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'x';
 		}
		++len_req;
 	}
 
 	if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==
  static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 			--len_left;
 			*(p++) = 'p';
 		}
		++len_req;
 	} else {
 		if ((option & ONIG_OPTION_MULTILINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 'm';
 			}
			++len_req;
 		}
 
 		if ((option & ONIG_OPTION_SINGLELINE) != 0) {
 			if (len_left > 0) {
 				--len_left;
 				*(p++) = 's';
 			}
			++len_req;
 		}
	}
 	if ((option & ONIG_OPTION_FIND_LONGEST) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'l';
 		}
		++len_req;
 	}
 	if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {
 		if (len_left > 0) {
 			--len_left;
 			*(p++) = 'n';
 		}
		++len_req;
 	}
 
 	c = 0;
  static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 		--len_left;
 		*(p++) = '\0';
 	}
	++len_req;
 	if (len < len_req) {
 		return len_req;
 	}
  static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionT
 
  
 static void
_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)
 {
 	int n;
 	char c;
	int optm = 0;
 
 	*syntax = ONIG_SYNTAX_RUBY;
 
  _php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, O
 					*syntax = ONIG_SYNTAX_POSIX_EXTENDED;
 					break;
 				case 'e':
					if (eval != NULL) *eval = 1;
 					break;
 				default:
 					break;
 			}
 		}
		if (option != NULL) *option|=optm;
 	}
 }
  
  static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	} else {
 		 
 		convert_to_long_ex(arg_pattern_zval);
		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
 		pat_buf[1] = '\0';
 
 		arg_pattern = pat_buf;
		arg_pattern_len = 1;
 	}
 	 
 	re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
  static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 					}
 				}
 			}

 			if (eval) {
 				zval v;
 				 
  static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				eval_buf.len = 0;
 				zval_dtor(&v);
 			} else if (is_callable) {
				zval *retval_ptr = NULL;
 				zval **args[1];
 				zval *subpats;
 				int i;

 				MAKE_STD_ZVAL(subpats);
 				array_init(subpats);

 				for (i = 0; i < regs->num_regs; i++) {
 					add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
				}

 				args[0] = &subpats;
 				 
 				smart_str_0(&eval_buf);

 				arg_replace_fci.param_count = 1;
 				arg_replace_fci.params = args;
 				arg_replace_fci.retval_ptr_ptr = &retval_ptr;
				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
 					convert_to_string_ex(&retval_ptr);
 					smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
 					eval_buf.len = 0;
 					zval_ptr_dtor(&retval_ptr);
 				} else {
 					if (!EG(exception)) {
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
 					}
  static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 				pos = (OnigUChar *)string + n;
 			} else {
 				if (pos < string_lim) {
					smart_str_appendl(&out_buf, pos, 1);
 				}
 				pos++;
 			}
  static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOp
 	smart_str_free(&eval_buf);
 
 	if (err <= -2) {
		smart_str_free(&out_buf);
 		RETVAL_FALSE;
 	} else {
 		smart_str_appendc(&out_buf, '\0');
  PHP_FUNCTION(mb_split)
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", &arg_pattern, &arg_pattern_len, &string, &string_len, &count) == FAILURE) {
 		RETURN_FALSE;
	}
 
 	if (count > 0) {
 		count--;
  PHP_FUNCTION(mb_ereg_search_init)
 	if (zend_parse_parameters(argc TSRMLS_CC, ""z|ss"", &arg_str, &arg_pattern, &arg_pattern_len, &arg_options, &arg_options_len) == FAILURE) {
 		return;
 	}

 	if (argc > 1 && arg_pattern_len == 0) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty pattern"");
 		RETURN_FALSE;
  PHP_FUNCTION(mb_ereg_search_setpos)
  
 
  
static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)
 {
 	if (prev_options != NULL) {
 		*prev_options = MBREX(regex_default_options);","Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception."
640,CVE-2016-5766,"  static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, in
 	if (gd2_compressed(*fmt)) {
 		nc = (*ncx) * (*ncy);
 		GD2_DBG(php_gd_error(""Reading %d chunk index entries"", nc));
		if (overflow2(sidx, nc)) {
			goto fail1;
		}
 		sidx = sizeof(t_chunk_info) * nc;
 		if (sidx <= 0) {
 			goto fail1;
 		}
 		cidx = gdCalloc(sidx, 1);
		if (cidx == NULL) {
			goto fail1;
		}

 		for (i = 0; i < nc; i++) {
 			if (gdGetInt(&cidx[i].offset, in) != 1) {
 				gdFree(cidx);","Integer overflow in the _gd2GetHeader function in gd_gd2.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via crafted chunk dimensions in an image."
641,CVE-2016-5728,"  static long vop_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 			ret = -EFAULT;
 			goto free_ret;
 		}
		 
		if (memcmp(&dd, dd_config, sizeof(dd))) {
			ret = -EINVAL;
			goto free_ret;
		}
 		mutex_lock(&vdev->vdev_mutex);
 		mutex_lock(&vi->vop_mutex);
 		ret = vop_virtio_add_device(vdev, dd_config);","Race condition in the vop_ioctl function in drivers/misc/mic/vop/vop_vringh.c in the MIC VOP driver in the Linux kernel before 4.6.1 allows local users to obtain sensitive information from kernel memory or cause a denial of service (memory corruption and system crash) by changing a certain header, aka a *double fetch* vulnerability."
642,CVE-2016-5696,"  int sysctl_tcp_adv_win_scale __read_mostly = 1;
 EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
 
  
int sysctl_tcp_challenge_ack_limit = 1000;
 
 int sysctl_tcp_stdurg __read_mostly;
 int sysctl_tcp_rfc1337 __read_mostly;
  static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
 	struct tcp_sock *tp = tcp_sk(sk);
	u32 count, now;
 
 	 
 	if (tcp_oow_rate_limited(sock_net(sk), skb,
 				 LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
 				 &tp->last_oow_ack_time))
 		return;
 
	 
 	now = jiffies / HZ;
 	if (now != challenge_timestamp) {
		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;

 		challenge_timestamp = now;
		WRITE_ONCE(challenge_count, half +
			   prandom_u32_max(sysctl_tcp_challenge_ack_limit));
 	}
	count = READ_ONCE(challenge_count);
	if (count > 0) {
		WRITE_ONCE(challenge_count, count - 1);
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}","net/ipv4/tcp_input.c in the Linux kernel before 4.7 does not properly determine the rate of challenge ACK segments, which makes it easier for remote attackers to hijack TCP sessions via a blind in-window attack."
643,CVE-2016-5427,"  uint8_t PacketReader::get8BitInt()
 string PacketReader::getLabel(unsigned int recurs)
 {
   string ret;
  size_t wirelength = 0;
   ret.reserve(40);
  getLabelFromContent(d_content, d_pos, ret, recurs++, wirelength);
   return ret;
 }
 
  string PacketReader::getText(bool multi)
 }
 
 
void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs, size_t& wirelength)
 {
   if(recurs > 100)  
     throw MOADNSException(""Loop"");
  void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t&
    
   for(;;) {
     unsigned char labellen=content.at(frompos++);
    wirelength++;
    if (wirelength > 255) {
      throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");
    }
 
     if(!labellen) {
       if(ret.empty())
  void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t&
 
       if(offset >= pos)
         throw MOADNSException(""forward reference during label decompression"");
       
      return getLabelFromContent(content, offset, ret, ++recurs, --wirelength);
     }
     else if(labellen > 63) 
       throw MOADNSException(""Overly long label during label decompression (""+lexical_cast<string>((unsigned int)labellen)+"")"");
     else {
      if (wirelength + labellen > 255) {
        throw MOADNSException(""Overly long DNS name (""+lexical_cast<string>(wirelength)+"")"");
      }
      wirelength += labellen;
        
       for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {
         if(content.at(frompos)=='.' || content.at(frompos)=='\\') {
           ret.append(1, '\\');","PowerDNS (aka pdns) Authoritative Server before 3.4.10 does not properly handle a . (dot) inside labels, which allows remote attackers to cause a denial of service (backend CPU consumption) via a crafted DNS query."
644,CVE-2016-5418,"  struct archive_write_disk {
 
 #define HFS_BLOCKS(s)	((s) >> 12)
 
static int	check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);
 static int	check_symlinks(struct archive_write_disk *);
 static int	create_filesystem_object(struct archive_write_disk *);
 static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);
 #if defined(HAVE_FCHDIR) && defined(PATH_MAX)
 static void	edit_deep_directories(struct archive_write_disk *ad);
 #endif
static int	cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);
 static int	cleanup_pathname(struct archive_write_disk *);
 static int	create_dir(struct archive_write_disk *, char *);
 static int	create_parent_dir(struct archive_write_disk *, char *);
  create_filesystem_object(struct archive_write_disk *a)
 	const char *linkname;
 	mode_t final_mode, mode;
 	int r;
	 
	char *linkname_copy;	 
	struct archive_string error_string;
	int error_number;
 
 	 
 	 
  create_filesystem_object(struct archive_write_disk *a)
 #if !HAVE_LINK
 		return (EPERM);
 #else
		archive_string_init(&error_string);
		linkname_copy = strdup(linkname);
		if (linkname_copy == NULL) {
		    return (EPERM);
		}
		 
		r = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);
		if (r != ARCHIVE_OK) {
			archive_set_error(&a->archive, error_number, ""%s"", error_string.s);
			free(linkname_copy);
			 
			return (EPERM);
		}
		r = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);
		if (r != ARCHIVE_OK) {
			archive_set_error(&a->archive, error_number, ""%s"", error_string.s);
			free(linkname_copy);
			 
			return (EPERM);
		}
		free(linkname_copy);
 		r = link(linkname, a->name) ? errno : 0;
 		 
  

 
 static int
check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)
 {
 #if !defined(HAVE_LSTAT)
 	 
 	(void)a;  
	(void)path;  
	(void)error_number;  
	(void)error_string;  
	(void)flags;  
 	return (ARCHIVE_OK);
 #else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
 	char c;
 	int r;
 	struct stat st;
	int restore_pwd;

	 
	if(path[0] == '\0')
	    return (ARCHIVE_OK);
 
 	 
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	 
 	 
	if(tail == path && tail[0] == '/')
		++tail;
	 
	while (!last) {
		 
		while (*tail == '/')
		    ++tail;
 		 
		while (*tail != '\0' && *tail != '/')
			++tail;
		 
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		 
		c = tail[0];
		tail[0] = '\0';
 		 
		r = lstat(head, &st);
 		if (r != 0) {
			tail[0] = c;
 			 
 			if (errno == ENOENT) {
 				break;
 			} else {
				if (error_number) *error_number = errno;
				if (error_string)
					archive_string_sprintf(error_string,
							""Could not stat %s"",
							path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					if (error_number) *error_number = errno;
					if (error_string)
						archive_string_sprintf(error_string,
								""Could not chdir %s"",
								path);
					res = (ARCHIVE_FATAL);
					break;
				}
				 
				head = tail + 1;
 			}
 		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
 				 
				if (unlink(head)) {
					tail[0] = c;
					if (error_number) *error_number = errno;
					if (error_string)
						archive_string_sprintf(error_string,
								""Could not remove symlink %s"",
								path);
					res = ARCHIVE_FAILED;
					break;
 				}
 				 
				tail[0] = c;
				 
 				 
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
 				 
				if (unlink(head) != 0) {
					tail[0] = c;
					if (error_number) *error_number = 0;
					if (error_string)
						archive_string_sprintf(error_string,
								""Cannot remove intervening symlink %s"",
								path);
					res = ARCHIVE_FAILED;
					break;
 				}
				tail[0] = c;
 			} else {
				tail[0] = c;
				if (error_number) *error_number = 0;
				if (error_string)
					archive_string_sprintf(error_string,
							""Cannot extract through symlink %s"",
							path);
				res = ARCHIVE_FAILED;
				break;
 			}
 		}
		 
		tail[0] = c;
		if (tail[0] != '\0')
			tail++;  
 	}
	 
	tail[0] = c;
#ifdef HAVE_FCHDIR
	 
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			if(error_number) *error_number = errno;
			if(error_string)
				archive_string_sprintf(error_string,
						""chdir() failure"");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	 
	return res;
 #endif
 }
 
 
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"", error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	 
	return rc;
}


 #if defined(__CYGWIN__)
  
 static int
cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)
 {
 	char *dest, *src;
 	char separator = '\0';
 
	dest = src = path;
 	if (*src == '\0') {
		if (error_number) *error_number = ARCHIVE_ERRNO_MISC;
		if (error_string)
		    archive_string_sprintf(error_string,
			    ""Invalid empty pathname"");
 		return (ARCHIVE_FAILED);
 	}
 
  cleanup_pathname(struct archive_write_disk *a)
 #endif
 	 
 	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			if (error_number) *error_number = ARCHIVE_ERRNO_MISC;
			if (error_string)
			    archive_string_sprintf(error_string,
				    ""Path is absolute"");
 			return (ARCHIVE_FAILED);
 		}
 
  cleanup_pathname(struct archive_write_disk *a)
 			} else if (src[1] == '.') {
 				if (src[2] == '/' || src[2] == '\0') {
 					 
					if (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						if (error_number) *error_number = ARCHIVE_ERRNO_MISC;
						if (error_string)
						    archive_string_sprintf(error_string,
							    ""Path contains '..'"");
 						return (ARCHIVE_FAILED);
 					}
 				}
  cleanup_pathname(struct archive_write_disk *a)
 	 * We've just copied zero or more path elements, not including the
 	 * final '/'.
 	 */
	if (dest == path) {
 		/*
 		 * Nothing got copied.  The path must have been something
 		 * like '.' or '/' or './' or '/./././. 
  cleanup_pathname(struct archive_write_disk *a)
 	return (ARCHIVE_OK);
 }
 
static int
cleanup_pathname(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"", error_string.s);
	}
	archive_string_free(&error_string);
	return rc;
}

 /*
  * Create the parent directory of the specified path, assuming path
  * is already in mutable storage.","The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file."
645,CVE-2016-5400,"  static int airspy_probe(struct usb_interface *intf,
 	if (ret) {
 		dev_err(s->dev, ""Failed to register as video device (%d)\n"",
 				ret);
		goto err_free_controls;
 	}
 	dev_info(s->dev, ""Registered as %s\n"",
 			video_device_node_name(&s->vdev));
  static int airspy_probe(struct usb_interface *intf,
 
 err_free_controls:
 	v4l2_ctrl_handler_free(&s->hdl);
 	v4l2_device_unregister(&s->v4l2_dev);
 err_free_mem:
 	kfree(s);",Memory leak in the airspy_probe function in drivers/media/usb/airspy/airspy.c in the airspy USB driver in the Linux kernel before 4.7 allows local users to cause a denial of service (memory consumption) via a crafted USB device that emulates many VFL_TYPE_SDR or VFL_TYPE_SUBDEV devices and performs many connect and disconnect operations.
646,CVE-2016-5361,"  static const struct state_microcode v1_state_microcode_table[] = {
 	{ STATE_MAIN_R0, STATE_MAIN_R1,
 	  SMF_ALL_AUTH | SMF_REPLY,
 	  P(SA), P(VID) | P(CR), PT(NONE),
	  EVENT_NULL, main_inI1_outR1 },
 
 	/* STATE_MAIN_I1: R1 --> I2
 	 * HDR, SA --> auth dependent
  static const struct state_microcode v1_state_microcode_table[] = {
 	{ STATE_AGGR_R0, STATE_AGGR_R1,
 	  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY,
 	  P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC), PT(NONE),
	  EVENT_NULL, aggr_inI1_outR1 },
 
 	/* STATE_AGGR_I1:
 	 * SMF_PSK_AUTH: HDR, SA, KE, Nr, IDir, HASH_R
  static const struct state_microcode v1_state_microcode_table[] = {
 	{ STATE_XAUTH_I0, STATE_XAUTH_I1,
 	  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,
 	  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),
	  EVENT_v1_RETRANSMIT, xauth_inI0 },
 
 	{ STATE_XAUTH_I1, STATE_MAIN_I4,
 	  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,
 	  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),
	  EVENT_v1_RETRANSMIT, xauth_inI1 },
 
 #undef P
 #undef PT","programs/pluto/ikev1.c in libreswan before 3.17 retransmits in initial-responder states, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed UDP packet. NOTE: the original behavior complies with the IKEv1 protocol, but has a required security update from the libreswan vendor; as of 2016-06-10, it is expected that several other IKEv1 implementations will have vendor-required security updates, with separate CVE IDs assigned to each."
647,CVE-2016-5359,"  parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,
 			 const wbxml_decoding *map)
 {
 	guint32     tvb_len  = tvb_reported_length (tvb);
	guint32     off      = offset, last_off;
 	guint32     len;
 	guint       str_len;
 	guint32     ent;
  parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,
 	tag_save_literal = NULL;                  
 
 	DebugLog((""parse_wbxml_tag_defined (level = %u, offset = %u)\n"", *level, offset));
	last_off = off;
 	while (off < tvb_len) {
 		peek = tvb_get_guint8 (tvb, off);
 		DebugLog((""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\n"", *level, peek, off, tvb_len));
  parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,
 				 
 			}
 		}  
		if (off < last_off) {
			THROW(ReportedBoundsError);
		}
		last_off = off;
 	}  
 	DebugLog((""STAG: level = %u, Return: len = %u (end of function body)\n"", *level, off - offset));
 	return (off - offset);
  parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,
 		 guint8 *codepage_stag, guint8 *codepage_attr)
 {
 	guint32     tvb_len             = tvb_reported_length (tvb);
	guint32     off                 = offset, last_off;
 	guint32     len;
 	guint       str_len;
 	guint32     ent;
  parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,
 	tag_save_literal = NULL;                  
 
 	DebugLog((""parse_wbxml_tag (level = %u, offset = %u)\n"", *level, offset));
	last_off = off;
 	while (off < tvb_len) {
 		peek = tvb_get_guint8 (tvb, off);
 		DebugLog((""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\n"", *level, peek, off, tvb_len));
  parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,
 				 
 			}
 		}  
		if (off < last_off) {
			THROW(ReportedBoundsError);
		}
		last_off = off;
 	}  
 	DebugLog((""STAG: level = %u, Return: len = %u (end of function body)\n"",
 		  *level, off - offset));
  parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,
 				    const wbxml_decoding *map)
 {
 	guint32     tvb_len = tvb_reported_length (tvb);
	guint32     off     = offset, last_off;
 	guint32     len;
 	guint       str_len;
 	guint32     ent;
  parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,
 	DebugLog((""parse_wbxml_attr_defined (level = %u, offset = %u)\n"",
 		  level, offset));
 	 
	last_off = off;
 	while (off < tvb_len) {
 		peek = tvb_get_guint8 (tvb, off);
 		DebugLog((""ATTR: (top of while) level = %3u, peek = 0x%02X, ""
  parse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb,
 				off++;
 			}
 		}
		if (off < last_off) {
			THROW(ReportedBoundsError);
		}
		last_off = off;
 	}  
 	DebugLog((""ATTR: level = %u, Return: len = %u (end of function body)\n"",
 		  level, off - offset));
  parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,
 			    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr)
 {
 	guint32 tvb_len = tvb_reported_length (tvb);
	guint32 off     = offset, last_off;
 	guint32 len;
 	guint   str_len;
 	guint32 ent;
  parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,
 
 	DebugLog((""parse_wbxml_attr (level = %u, offset = %u)\n"", level, offset));
 	 
	last_off = off;
 	while (off < tvb_len) {
 		peek = tvb_get_guint8 (tvb, off);
 		DebugLog((""ATTR: (top of while) level = %3u, peek = 0x%02X, ""
  parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,
 				off++;
 			}
 		}
		if (off < last_off) {
			THROW(ReportedBoundsError);
		}
		last_off = off;
 	}  
 	DebugLog((""ATTR: level = %u, Return: len = %u (end of function body)\n"",
 		  level, off - offset));","epan/dissectors/packet-wbxml.c in the WBXML dissector in Wireshark 1.12.x before 1.12.12 mishandles offsets, which allows remote attackers to cause a denial of service (integer overflow and infinite loop) via a crafted packet."
648,CVE-2016-5358,"  dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 	tvbuff_t *next_tvb;
 	int offset = 0;
 	guint32 pkt_len, rectype, dlt;
	int wtap_encap;
	struct eth_phdr eth;
	void *phdr;
 
 	col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PKTAP"");
 	col_clear(pinfo->cinfo, COL_INFO);
  dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 
 	if (rectype == PKT_REC_PACKET) {
 		next_tvb = tvb_new_subset_remaining(tvb, pkt_len);
		wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);
		switch (wtap_encap) {

		case WTAP_ENCAP_ETHERNET:
			eth.fcs_len = -1;     
			phdr = &eth;
			break;

		default:
			phdr = NULL;
			break;
		}
		dissector_try_uint_new(wtap_encap_dissector_table,
		    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);
 	}
 }
 ","epan/dissectors/packet-pktap.c in the Ethernet dissector in Wireshark 2.x before 2.0.4 mishandles the packet-header data type, which allows remote attackers to cause a denial of service (application crash) via a crafted packet."
649,CVE-2016-5357,"  static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,
 static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,
 	struct wtap_pkthdr *phdr, Buffer *buf,
 	int *err, gchar **err_info);
static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,
	Buffer* buf, char *line, int *err, gchar **err_info);
 static int parse_single_hex_dump_line(char* rec, guint8 *buf,
 	guint byte_offset);
 
  static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,
     gint64 *data_offset)
 {
 	gint64		offset;
 	char		line[NETSCREEN_LINE_LENGTH];
 
 	 
 	offset = netscreen_seek_next_packet(wth, err, err_info, line);
 	if (offset < 0)
 		return FALSE;
 
	 
	if (!parse_netscreen_packet(wth->fh, &wth->phdr,
	    wth->frame_buffer, line, err, err_info))
 		return FALSE;
 
 	 
static gboolean
parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,
    char *line, int *err, gchar **err_info)
 {
	int		sec;
	int		dsec;
	char		cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];
	char		direction[2];
	guint		pkt_len;
	char		cap_src[13];
	char		cap_dst[13];
	guint8		*pd;
	gchar		*p;
	int		n, i = 0;
	guint		offset = 0;
	gchar		dststr[13];
 
 	phdr->rec_type = REC_TYPE_PACKET;
 	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
 
	if (sscanf(line, ""%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/"",
 		   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""netscreen: Can't parse packet-header"");
 		return -1;
 	}
	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
		 
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf(""netscreen: File has %u-byte packet, bigger than maximum of %u"",
		    pkt_len, WTAP_MAX_PACKET_SIZE);
		return FALSE;
	}
 
	 
 
 	phdr->ts.secs  = sec;
 	phdr->ts.nsecs = dsec * 100000000;
 	phdr->len = pkt_len;
 
 	 
	ws_buffer_assure_space(buf, pkt_len);
 	pd = ws_buffer_start_ptr(buf);
 
 	while(1) {
  parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,
 		 
		if (n == -1) {
 			*err = WTAP_ERR_BAD_FILE;
 			*err_info = g_strdup(""netscreen: cannot parse hex-data"");
 			return FALSE;
  parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,
 		 
		if (offset > pkt_len) {
 			*err = WTAP_ERR_BAD_FILE;
 			*err_info = g_strdup(""netscreen: too much hex-data"");
 			return FALSE;","wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
650,CVE-2016-5356,"  parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 {
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	int	num_items_scanned;
	int	yy, mm, dd, hr, min, sec, csec, pkt_len;
 	int	pro, off, pri, rm, error;
 	guint	code1, code2;
 	char	if_name[COSINE_MAX_IF_NAME_LEN] = """", direction[6] = """";
  parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 		   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {
 		 
 		num_items_scanned = sscanf(line,
		   ""%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]"",
 			&yy, &mm, &dd, &hr, &min, &sec, &csec,
 				   direction, if_name, &pkt_len,
 				   &pro, &off, &pri, &rm, &error,
  parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 	} else {
 		 
 		num_items_scanned = sscanf(line,
		   ""%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]"",
 				   direction, if_name, &pkt_len,
 				   &pro, &off, &pri, &rm, &error,
 				   &code1, &code2);
  parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 		}
 		yy = mm = dd = hr = min = sec = csec = 0;
 	}
	if (pkt_len < 0) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""cosine: packet header has a negative packet length"");
		return FALSE;
	}
 	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
 		/*
 		 * Probably a corrupt capture file; don't blow up trying","wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
651,CVE-2016-5355,"  parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	char	line[TOSHIBA_LINE_LENGTH];
 	int	num_items_scanned;
	int	pkt_len, pktnum, hr, min, sec, csec;
 	char	channel[10], direction[10];
 	int	i, hex_lines;
 	guint8	*pd;
  parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 
 	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
 
	num_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);
 	if (num_items_scanned != 1) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
 		return FALSE;
 	}
	if (pkt_len < 0) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: packet header has a negative packet length"");
		return FALSE;
	}
 	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
 		/*
 		 * Probably a corrupt capture file; don't blow up trying","wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
652,CVE-2016-5354,"  dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)
     if (!u3v_conv_info) {
         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);
         usb_conv_info->class_data = u3v_conv_info;
        usb_conv_info->class_data_type = USB_CONV_U3V;
    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {
         
        return 0;
     }
 
     prefix = tvb_get_letohl(tvb, 0);","The USB subsystem in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles class types, which allows remote attackers to cause a denial of service (application crash) via a crafted packet."
653,CVE-2016-5353,"  fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,
 
                                  
                                  
                                c_t = (tvb_get_bits8(tvb, tb_bit_off , 4) + 1) % 0xf;     
                                macinf->lchid[j+chan] = c_t;
 
                                macinf->content[j+chan] = lchId_type_table[c_t];     
                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t];     
                             }
                         } else {
                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);","epan/dissectors/packet-umts_fp.c in the UMTS FP dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the reserved C/T value, which allows remote attackers to cause a denial of service (application crash) via a crafted packet."
654,CVE-2016-5352,"  AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_
         }
     }
 
    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||
        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||
        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {
         return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
     }
 ","epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 2.x before 2.0.4 mishandles certain length values, which allows remote attackers to cause a denial of service (application crash) via a crafted packet."
655,CVE-2016-5351,"  static INT AirPDcapScanForKeys(
 
          
         bodyLength=pntoh16(data+offset+2);
        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) {  
             AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""EAPOL body too short"", AIRPDCAP_DEBUG_LEVEL_3);
             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
         }","epan/crypt/airpdcap.c in the IEEE 802.11 dissector in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles the lack of an EAPOL_RSN_KEY, which allows remote attackers to cause a denial of service (application crash) via a crafted packet."
656,CVE-2016-5350,"  dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,
 
 	 
 
	remaining = tvb_reported_length_remaining(tvb, offset);
 	if (remaining <= 0) {
 		if (data)
 			*data = g_strdup("""");
  dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset > 0 && offset < end_offset) {
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
	}
 
 	return offset;
 }","epan/dissectors/packet-dcerpc-spoolss.c in the SPOOLS component in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles unexpected offsets, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet."
657,CVE-2016-5244,"  void rds_inc_info_copy(struct rds_incoming *inc,
 		minfo.fport = inc->i_hdr.h_dport;
 	}
 
	minfo.flags = 0;

 	rds_info_copy(iter, &minfo, sizeof(minfo));
 }","The rds_inc_info_copy function in net/rds/recv.c in the Linux kernel through 4.6.3 does not initialize a certain structure member, which allows remote attackers to obtain sensitive information from kernel stack memory by reading an RDS message."
658,CVE-2016-5243,"  static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,
 
 	link_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);
 	link_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));
	nla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),
		    TIPC_MAX_LINK_NAME);
 
 	return tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,
 			    &link_info, sizeof(link_info));","The tipc_nl_compat_link_dump function in net/tipc/netlink_compat.c in the Linux kernel through 4.6.3 does not properly copy a certain string, which allows local users to obtain sensitive information from kernel stack memory by reading a Netlink message."
659,CVE-2016-5195,"  static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_TRIED	0x800	 
 #define FOLL_MLOCK	0x1000	 
 #define FOLL_REMOTE	0x2000	 
#define FOLL_COW	0x4000	 
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);","Race condition in mm/gup.c in the Linux kernel 2.x through 4.x before 4.8.3 allows local users to gain privileges by leveraging incorrect handling of a copy-on-write (COW) feature to write to a read-only memory mapping, as exploited in the wild in October 2016, aka *Dirty COW.*"
660,CVE-2016-5157,"  static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,
 	l_tx0 = l_cp->tx0 + p * l_cp->tdx;  
 	l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);
 	l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx), l_image->x1);
	 
	if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {
		opj_event_msg(manager, EVT_ERROR, ""Tile X coordinates are not supported\n"");
		return OPJ_FALSE;
	}
 	l_ty0 = l_cp->ty0 + q * l_cp->tdy;  
 	l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);
 	l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy), l_image->y1);
	 
	if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {
		opj_event_msg(manager, EVT_ERROR, ""Tile Y coordinates are not supported\n"");
		return OPJ_FALSE;
	}
	
 
 	 
 	if (l_tccp->numresolutions == 0) {","Heap-based buffer overflow in the opj_dwt_interleave_v function in dwt.c in OpenJPEG, as used in PDFium in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to execute arbitrary code via crafted coordinate values in JPEG 2000 data."
661,CVE-2016-5116,"  BGD_DECLARE(gdImagePtr) gdImageCreateFromXbm(FILE * fd)
  
 static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)
 {
	char buf[1024];
 	int len;
 	va_list args;
 
  static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)
 }
  
 
 
#define gdCtxPuts(out, s) out->putBuf(out, s, strlen(s))

  
 BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)
 {
  BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC
 		}
 	}
 
	 

	 
	gdCtxPuts(out, ""#define "");
	gdCtxPuts(out, name);
	gdCtxPuts(out, ""_width "");
	gdCtxPrintf(out, ""%d\n"", gdImageSX(image));

	 
	gdCtxPuts(out, ""#define "");
	gdCtxPuts(out, name);
	gdCtxPuts(out, ""_height "");
	gdCtxPrintf(out, ""%d\n"", gdImageSY(image));

	 
	gdCtxPuts(out, ""static unsigned char "");
	gdCtxPuts(out, name);
	gdCtxPuts(out, ""_bits[] = {\n  "");
 
 	free(name);
 
  BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC
 			if ((b == 128) || (x == sx && y == sy)) {
 				b = 1;
 				if (p) {
					gdCtxPuts(out, "", "");
 					if (!(p%12)) {
						gdCtxPuts(out, ""\n  "");
 						p = 12;
 					}
 				}
  BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOC
 			}
 		}
 	}
	gdCtxPuts(out, ""};\n"");
 }
  ","gd_xbm.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in certain custom PHP 5.5.x configurations, allows context-dependent attackers to obtain sensitive information from process memory or cause a denial of service (stack-based buffer under-read and application crash) via a long name."
662,CVE-2016-5114,"  int fpm_log_write(char *log_format)  
 				b += len2;
 				len += len2;
 			}
			if (len >= FPM_LOG_BUFFER) {
				zlog(ZLOG_NOTICE, ""the log buffer is full (%d). The access log request has been truncated."", FPM_LOG_BUFFER);
				len = FPM_LOG_BUFFER;
				break;
			}
 			continue;
 		}
 ","sapi/fpm/fpm/fpm_log.c in PHP before 5.5.31, 5.6.x before 5.6.17, and 7.x before 7.0.2 misinterprets the semantics of the snprintf return value, which allows attackers to obtain sensitive information from process memory or cause a denial of service (out-of-bounds read and buffer overflow) via a long string, as demonstrated by a long URI in a configuration with custom REQUEST_URI logging."
663,CVE-2016-5104,"  int socket_create(uint16_t port)
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
  int socket_accept(int fd, uint16_t port)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	addr.sin_port = htons(port);
 
 	addr_len = sizeof(addr);",The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.
664,CVE-2016-5096,"  PHPAPI PHP_FUNCTION(fread)
 		RETURN_FALSE;
 	}
 
	if (len > INT_MAX) {
		 
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be no more than %d"", INT_MAX);
		RETURN_FALSE;
	}

 	Z_STRVAL_P(return_value) = emalloc(len + 1);
 	Z_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);
 ",Integer overflow in the fread function in ext/standard/file.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer in the second argument.
665,CVE-2016-5094,"  static inline unsigned int get_next_char(
 					else
 						MB_FAILURE(pos, 4);
 				}

 				this_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);
 				if (this_char < 0x10000 || this_char > 0x10FFFF) {  
 					MB_FAILURE(pos, 4);
  static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)
 
 	if (charset_hint) {
 		int found = 0;

 		 
 		for (i = 0; charset_map[i].codeset; i++) {
 			if (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {
  static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned cod
 		return 0;
 
 	code_key = (unsigned short) code_key_a;

 	while (l <= h) {
 		m = l + (h - l) / 2;
 		if (code_key < m->un_code_point)
  static inline int map_from_unicode(unsigned code, enum entity_charset charset, u
 		 
 		if (code > 0xFF) {
 			return FAILURE;
		}
 		*res = code;
 		break;
 
  static inline int map_from_unicode(unsigned code, enum entity_charset charset, u
 			return FAILURE;
 		}
 		break;

 	case cs_8859_15:
 		if (code < 0xA4 || (code > 0xBE && code <= 0xFF)) {
 			*res = code;
  static inline int map_from_unicode(unsigned code, enum entity_charset charset, u
 	case cs_cp866:
 		table = unimap_cp866;
 		table_size = sizeof(unimap_cp866) / sizeof(*unimap_cp866);

 table_over_7F:
 		if (code <= 0x7F) {
 			*res = code;
  static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)
 	 * Not sure this is the relevant part for HTML 5, though. I opted to
 	 * disallow the characters that would result in a parse error when
 	 * preprocessing of the input stream. See also section 8.1.3.
	 *
 	 * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to
 	 * XHTML 1.0 the same rules as for XML 1.0.
 	 * See <http: 
  static inline int numeric_entity_is_allowed(unsigned uni_cp, int document_type)
  
 static inline int process_numeric_entity(const char **buf, unsigned *code_point)
 {
  static inline int process_numeric_entity(const char **buf, unsigned *code_point)
 
 	if (hexadecimal && (**buf != '\0'))
 		(*buf)++;

 	 
 	if ((hexadecimal && !isxdigit(**buf)) ||
  static void traverse_for_entities(
 				goto invalid_code;
 
 			 
 			if (!unicode_cp_is_allowed(code, doctype) ||
  static void traverse_for_entities(
 				}
 			}
 		}

 		assert(*next == ';');

 		if (((code == '\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||
 				(code == '""' && !(flags & ENT_HTML_QUOTE_DOUBLE)))
 				 )
  static void traverse_for_entities(
 			*(q++) = *p;
 		}
 	}

 	*q = '\0';
 	*retlen = (size_t)(q - ret);
 }
  static entity_table_opt determine_entity_table(int all, int doctype)
 	entity_table_opt retval = {NULL};
 
 	assert(!(doctype == ENT_HTML_DOC_XML1 && all));

 	if (all) {
 		retval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?
 			entity_ms_table_html5 : entity_ms_table_html4;
  PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_
 	if (retlen == 0) {
 		goto empty_source;
 	}

 	inverse_map = unescape_inverse_map(all, flags);

 	 
 	traverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);
 
empty_source:
 	*newlen = retlen;
 	return ret;
 }
  static inline void find_entity_for_char(
 {
 	unsigned stage1_idx = ENT_STAGE1_INDEX(k);
 	const entity_stage3_row *c;

 	if (stage1_idx > 0x1D) {
 		*entity     = NULL;
 		*entity_len = 0;
  static inline void find_entity_for_char(
 		if (!(*cursor < oldlen))
 			goto no_suitable_2nd;
 
		next_char = get_next_char(charset, old, oldlen, cursor, &status);
 
 		if (status == FAILURE)
 			goto no_suitable_2nd;
  static inline void find_entity_for_char(
 		*entity = (const unsigned char *)
 			c->data.multicodepoint_table[0].leading_entry.default_entity;
 		*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;
	}
 }
  
 
  PHPAPI char *php_escape_html_entities_ex(unsigned char *old, size_t oldlen, size
 
 	 
 	if (oldlen < 64) {
		maxlen = 128;
 	} else {
 		maxlen = 2 * oldlen;
 		if (maxlen < oldlen) {
  static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)
 	}
 
 	replaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);
	if (new_len > INT_MAX) {
		efree(replaced);
		RETURN_FALSE;
	}
 	RETVAL_STRINGL(replaced, (int)new_len, 0);
 }
  
  static inline void write_s3row_data(
 			} else {
 				spe_cp = uni_cp;
 			}

 			written_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);
 			memcpy(&entity[1], mcpr[i].normal_entry.entity, l);
 			entity[l + 1] = ';';
  PHP_FUNCTION(get_html_translation_table)
 	LIMIT_ALL(all, doctype, charset);
 
 	array_init(return_value);

 	entity_table = determine_entity_table(all, doctype);
 	if (all && !CHARSET_UNICODE_COMPAT(charset)) {
 		to_uni_table = enc_to_uni_index[charset];",Integer overflow in the php_html_entities function in ext/standard/html.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering a large output string from the htmlspecialchars function.
666,CVE-2016-5093,"  ZEND_EXTERN_MODULE_GLOBALS( intl )
 */
 static const char * const LOC_GRANDFATHERED[] = {
 	""art-lojban"",		""i-klingon"",		""i-lux"",			""i-navajo"",		""no-bok"",		""no-nyn"",
	""cel-gaulish"",		""en-GB-oed"",		""i-ami"",
	""i-bnn"",		""i-default"",		""i-enochian"",
	""i-mingo"",		""i-pwn"", 		""i-tao"",
 	""i-tay"",		""i-tsu"",		""sgn-BE-fr"",
 	""sgn-BE-nl"",		""sgn-CH-de"", 		""zh-cmn"",
  	""zh-cmn-Hans"", 		""zh-cmn-Hant"",		""zh-gan"" ,
 	""zh-guoyu"", 		""zh-hakka"", 		""zh-min"",
	""zh-min-nan"", 		""zh-wuu"", 		""zh-xiang"",
 	""zh-yue"",		NULL
 };
 
  
 static const int 		LOC_PREFERRED_GRANDFATHERED_LEN = 6;
 static const char * const 	LOC_PREFERRED_GRANDFATHERED[]  = {
 	""jbo"",			""tlh"",			""lb"",
	""nv"", 			""nb"",			""nn"",
 	NULL
 };
 
  static int16_t findOffset(const char* const* list, const char* key)
  
 
 static char* getPreferredTag(const char* gf_tag)
{
 	char* result = NULL;
 	int grOffset = 0;
 
  static char* getPreferredTag(const char* gf_tag)
 }
 
  
 static int getStrrtokenPos(char* str, int savedPos)
 {
 	int result =-1;
 	int i;

 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
 			 
  static int getStrrtokenPos(char* str, int savedPos)
  
 
  
  static int getSingletonPos(const char* str)
 	int result =-1;
 	int i=0;
 	int len = 0;

 	if( str && ((len=strlen(str))>0) ){
 		for( i=0; i<len ; i++){
 			if( isIDSeparator(*(str+i)) ){
  static int getSingletonPos(const char* str)
 				}
 			}
 		} 

 	}
 	return result;
 }
  PHP_NAMED_FUNCTION(zif_locale_get_default)
 PHP_NAMED_FUNCTION(zif_locale_set_default)
 {
 	char* locale_name = NULL;
	int   len=0;
 
 	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
 		&locale_name ,&len ) == FAILURE)
  PHP_NAMED_FUNCTION(zif_locale_set_default)
 		len = strlen(locale_name);
 	}
 
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);
 
 	RETURN_TRUE;
 }
  
 
  
  static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*
 			}
 		}
 
		singletonPos = getSingletonPos( loc_name );
 		if( singletonPos == 0){
 			 
  static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*
 	}  
 
 	if( mod_loc_name == NULL){
		mod_loc_name = estrdup(loc_name );
 	}
 
 	 
  static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*
 		if( U_FAILURE( status ) ) {
 			if( status == U_BUFFER_OVERFLOW_ERROR ) {
 				status = U_ZERO_ERROR;
				buflen++;  
 				continue;
 			}
 
  static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*
 * Gets the value from ICU , called when PHP userspace function is called
 * common code shared by get_primary_language,get_script or get_region or get_variant
 */
static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
 {
 
 	const char* loc_name        	= NULL;
  static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
 }
  
 
PHP_FUNCTION( locale_get_script )
 {
 	get_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  
 
PHP_FUNCTION( locale_get_region )
 {
 	get_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  
 
PHP_FUNCTION(locale_get_primary_language )
 {
 	get_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  
 
 
  
static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
 {
 	const char* loc_name        	= NULL;
 	int         loc_name_len    	= 0;
  static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME
 	intl_error_reset( NULL TSRMLS_CC );
 
 	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
		&loc_name, &loc_name_len ,
 		&disp_loc_name ,&disp_loc_name_len ) == FAILURE)
 	{
 		spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name );
  static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME
 	if( mod_loc_name==NULL ){
 		mod_loc_name = estrdup( loc_name );
 	}

 	 
 	if( !disp_loc_name){
 		disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));
  static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME
  
PHP_FUNCTION(locale_get_display_name)
 {
     get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  PHP_FUNCTION(locale_get_display_name)
  
PHP_FUNCTION(locale_get_display_language)
 {
     get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  PHP_FUNCTION(locale_get_display_language)
  
PHP_FUNCTION(locale_get_display_script)
 {
     get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  PHP_FUNCTION(locale_get_display_script)
  
PHP_FUNCTION(locale_get_display_region)
 {
     get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  PHP_FUNCTION(locale_get_display_region)
 * proto static string get_display_variant($locale, $in_locale = null)
 * gets the variant for the $locale in $in_locale or default_locale
 */
PHP_FUNCTION(locale_get_display_variant)
 {
     get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
 }
  PHP_FUNCTION(locale_get_display_variant)
    
 */
 PHP_FUNCTION( locale_get_keywords )
 {
     UEnumeration*   e        = NULL;
  PHP_FUNCTION( locale_get_keywords )
     const char*       	loc_name        = NULL;
     int        	 	loc_name_len    = 0;
 
 	char*	 	kw_value        = NULL;
  PHP_FUNCTION( locale_get_keywords )
 				kw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len+1 ,  &status );
 			} else if(!U_FAILURE(status)) {
 				kw_value = erealloc( kw_value , kw_value_len+1);
			}
 			if (U_FAILURE(status)) {
 	        		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, ""locale_get_keywords: Error encountered while getting the keyword  value for the  keyword"", 0 TSRMLS_CC );
 				if( kw_value){
  PHP_FUNCTION( locale_get_keywords )
 }
  
 
 PHP_FUNCTION(locale_canonicalize)
  PHP_FUNCTION(locale_canonicalize)
 }
  
 
 static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)
  static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_
 			 
 			return FAILURE;
 		}
		if(strcmp(key_name, LOC_LANG_TAG) != 0 &&
 		   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {
 			 
 			smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
  static void add_prefix(smart_str* loc_name, char* key_name)
 }
  
 
 static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)
  static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,
 
 		 
 		isFirstSubtag = 0;
		for( i=0 ; i< max_value; i++ ){
			snprintf( cur_key_name , 30, ""%s%d"", key_name , i);
 			if( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){
 				if( Z_TYPE_PP(ele_value)!= IS_STRING ){
 					 
  static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,
 
  
 static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)
  static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)
  
 
 #define RETURN_SMART_STR(s) smart_str_0((s)); RETURN_STRINGL((s)->c, (s)->len, 0)
 PHP_FUNCTION(locale_compose)
 {
  PHP_FUNCTION(locale_compose)
 		RETURN_FALSE;
 
 	 
	result = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);
 	if( result == SUCCESS){
 		RETURN_SMART_STR(loc_name);
 	}
  PHP_FUNCTION(locale_compose)
 	}
 
 	 
	result = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);
 	if( result == LOC_NOT_FOUND ){
 		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
 		""locale_compose: parameter array does not contain 'language' tag."", 0 TSRMLS_CC );
  PHP_FUNCTION(locale_compose)
 	}
 
 	 
	result = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);
 	if( !handleAppendResult( result, loc_name TSRMLS_CC)){
 		RETURN_FALSE;
 	}

 	 
 	result = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);
 	if( !handleAppendResult( result, loc_name TSRMLS_CC)){
 		RETURN_FALSE;
 	}
 
 	 
	result = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC);
 	if( !handleAppendResult( result, loc_name TSRMLS_CC)){
 		RETURN_FALSE;
 	}
  static char* get_private_subtags(const char* loc_name)
 {
 	char* 	result =NULL;
 	int 	singletonPos = 0;
	int 	len =0;
 	const char* 	mod_loc_name =NULL;
 
 	if( loc_name && (len = strlen(loc_name)>0 ) ){
		mod_loc_name = loc_name ;
 		len   = strlen(mod_loc_name);
 		while( (singletonPos = getSingletonPos(mod_loc_name))!= -1){
 
			if( singletonPos!=-1){
				if( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){
 					 
 					if( singletonPos + 2 ==  len){
 						 
  static char* get_private_subtags(const char* loc_name)
 
 		}  
 	}

 	return result;
 }
  
  static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name
 	} else {
 		key_value = get_icu_value_internal( loc_name , key_name , &result,1 );
 	}
	if( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||
 		( strcmp(key_name , LOC_VARIANT_TAG)==0) ){
 		if( result > 0 && key_value){
 			 
			token = php_strtok_r( key_value , DELIMITER ,&last_ptr);
 			if( cur_key_name ){
 				efree( cur_key_name);
 			}
 			cur_key_name = (char*)ecalloc( 25,  25);
			sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
 			add_assoc_string( hash_arr, cur_key_name , token ,TRUE );
 			 
 			while( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){
				sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
 				add_assoc_string( hash_arr, cur_key_name , token , TRUE );
 			}
  
 	if( key_value){
		efree(key_value);
 	}
 	return cur_result;
 }
  
 
 PHP_FUNCTION(locale_parse)
  PHP_FUNCTION(locale_get_all_variants)
 	char*	saved_ptr	= NULL;
 
 	intl_error_reset( NULL TSRMLS_CC );

 	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"",
 	&loc_name, &loc_name_len ) == FAILURE)
 	{
  PHP_FUNCTION(locale_get_all_variants)
 	array_init( return_value );
 
 	 
	if( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){
 		 
 	}
	else {
 	 
 		variant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);
 		if( result > 0 && variant){
 			 
			token = php_strtok_r( variant , DELIMITER , &saved_ptr);
 			add_next_index_stringl( return_value, token , strlen(token) ,TRUE );
 			 
 			while( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){
  PHP_FUNCTION(locale_get_all_variants)
 			efree( variant );
 		}
 	}

 
 }
  
  static int strToMatch(const char* str ,char *retstr)
  
 
  
  
  
 PHP_FUNCTION(locale_filter_matches)
 {
  PHP_FUNCTION(locale_filter_matches)
 	char*       	cur_lang_tag    = NULL;
 	char*       	cur_loc_range   = NULL;
 
	zend_bool 	boolCanonical 	= 0;
 	UErrorCode	status		= U_ZERO_ERROR;
 
 	intl_error_reset( NULL TSRMLS_CC );

 	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""ss|b"",
		&lang_tag, &lang_tag_len , &loc_range , &loc_range_len ,
 		&boolCanonical) == FAILURE)
 	{
 		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
  PHP_FUNCTION(locale_filter_matches)
 		 
 		can_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);
 		if( result ==0) {
			intl_error_set( NULL, status,
 				""locale_filter_matches : unable to canonicalize loc_range"" , 0 TSRMLS_CC );
 			RETURN_FALSE;
 		}
 
 		 
 		can_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);
 		if( result ==0) {
			intl_error_set( NULL, status,
 				""locale_filter_matches : unable to canonicalize lang_tag"" , 0 TSRMLS_CC );
 			RETURN_FALSE;
 		}
  PHP_FUNCTION(locale_filter_matches)
 
 		 
 		token 	= strstr( cur_lang_tag , cur_loc_range );

 		if( token && (token==cur_lang_tag) ){
 			 
 			chrcheck = token + (strlen(cur_loc_range));
			if( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){
 				if( cur_lang_tag){
 					efree( cur_lang_tag );
 				}
  PHP_FUNCTION(locale_filter_matches)
 	else{
 		 
 		cur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);

 		result = strToMatch( lang_tag , cur_lang_tag);
 		if( result == 0) {
 			efree( cur_lang_tag );
  PHP_FUNCTION(locale_filter_matches)
 
 		 
 		token 	= strstr( cur_lang_tag , cur_loc_range );

 		if( token && (token==cur_lang_tag) ){
 			 
 			chrcheck = token + (strlen(cur_loc_range));
			if( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){
 				if( cur_lang_tag){
 					efree( cur_lang_tag );
 				}
  PHP_FUNCTION(locale_filter_matches)
 static void array_cleanup( char* arr[] , int arr_size)
 {
 	int i=0;
	for( i=0; i< arr_size; i++ ){
 		if( arr[i*2] ){
 			efree( arr[i*2]);
 		}
  static void array_cleanup( char* arr[] , int arr_size)
 
 #define LOOKUP_CLEAN_RETURN(value)	array_cleanup(cur_arr, cur_arr_len); return (value)
  
 static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)
  static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca
 	for(zend_hash_internal_pointer_reset(hash_arr);
 		zend_hash_has_more_elements(hash_arr) == SUCCESS;
 		zend_hash_move_forward(hash_arr)) {

 		if (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {
 			 
 			continue;
  static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca
 			 
 			intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: locale array element is not a string"", 0 TSRMLS_CC);
 			LOOKUP_CLEAN_RETURN(NULL);
		}
 		cur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));
 		result = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);
 		if(result == 0) {
 			intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"", 0 TSRMLS_CC);
 			LOOKUP_CLEAN_RETURN(NULL);
 		}
 		cur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);
		cur_arr_len++ ;
 	}  
 
 	 
 	if(canonicalize) {
		for(i=0; i<cur_arr_len; i++) {
 			lang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);
 			if(result != 1 || lang_tag == NULL || !lang_tag[0]) {
 				if(lang_tag) {
  static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca
 				LOOKUP_CLEAN_RETURN(NULL);
 			}
 			cur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);
			result = strToMatch(lang_tag, cur_arr[i*2]);
 			efree(lang_tag);
 			if(result == 0) {
 				intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
  static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca
 		} else {
 			loc_range = can_loc_range;
 		}
	}
 
 	cur_loc_range = ecalloc(1, strlen(loc_range)+1);
 	 
	result = strToMatch(loc_range, cur_loc_range);
 	if(can_loc_range) {
 		efree(can_loc_range);
 	}
  static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca
 	 
 	saved_pos = strlen(cur_loc_range);
 	while(saved_pos > 0) {
		for(i=0; i< cur_arr_len; i++){
			if(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {
 				 
 				return_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);
 				efree(cur_loc_range);
  static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca
 }
  
 
  
  
 PHP_FUNCTION(locale_lookup)
 {
  PHP_FUNCTION(locale_lookup)
 
 	if( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {
 		RETURN_EMPTY_STRING();
	}

 	result = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);
 	if(result == NULL || result[0] == '\0') {
 		if( fallback_loc ) {
  PHP_FUNCTION(locale_accept_from_http)
 		""locale_accept_from_http: unable to parse input parameters"", 0 TSRMLS_CC );
 		RETURN_FALSE;
 	}

 	available = ures_openAvailableLocales(NULL, &status);
 	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to retrieve locale list"");
	len = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,
 						&outResult, http_accept, available, &status);
 	uenum_close(available);
 	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to find acceptable locale"");","The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call."
667,CVE-2016-5009,"  void Monitor::handle_command(MonOpRequestRef op)
     return;
   }
 
   
   
  if(!cmd_getval(g_ceph_context, cmdmap, ""prefix"", prefix)) {
    reply_command(op, -EINVAL, ""command prefix not found"", 0);
    return;
  }

   
  if (prefix.empty()) {
    reply_command(op, -EINVAL, ""command prefix must not be empty"", 0);
    return;
  }

   if (prefix == ""get_command_descriptions"") {
     bufferlist rdata;
     Formatter *f = Formatter::create(""json"");
  void Monitor::handle_command(MonOpRequestRef op)
   boost::scoped_ptr<Formatter> f(Formatter::create(format));
 
   get_str_vec(prefix, fullcmd);

   
   
   
  if (fullcmd.empty()) {
    reply_command(op, -EINVAL, ""command requires a prefix to be valid"", 0);
    return;
  }

   module = fullcmd[0];
 
    ",The handle_command function in mon/Monitor.cc in Ceph allows remote authenticated users to cause a denial of service (segmentation fault and ceph monitor crash) via an (1) empty or (2) crafted prefix.
668,CVE-2016-4998,"  static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 	int err;
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p\n"", e);
 		return -EINVAL;
 	}
  check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 
 	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
 	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
 		return -EINVAL;
 	}",The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.
669,CVE-2016-4997,"  void xt_unregister_match(struct xt_match *target);
 int xt_register_matches(struct xt_match *match, unsigned int n);
 void xt_unregister_matches(struct xt_match *match, unsigned int n);
 
int xt_check_entry_offsets(const void *base, const char *elems,
 			   unsigned int target_offset,
 			   unsigned int next_offset);
 
  void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 				unsigned int *size);
 int xt_compat_target_to_user(const struct xt_entry_target *t,
 			     void __user **dstptr, unsigned int *size);
int xt_compat_check_entry_offsets(const void *base, const char *elems,
 				  unsigned int target_offset,
 				  unsigned int next_offset);
 ",The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.
670,CVE-2016-4951,"  int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)
 		if (err)
 			return err;
 
		if (!attrs[TIPC_NLA_SOCK])
			return -EINVAL;

 		err = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,
 				       attrs[TIPC_NLA_SOCK],
 				       tipc_nl_sock_policy);","The tipc_nl_publ_dump function in net/tipc/socket.c in the Linux kernel through 4.6 does not verify socket existence, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a dumpit operation."
671,CVE-2016-4913,"  int get_rock_ridge_filename(struct iso_directory_record *de,
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
	char *p;
	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
  int get_rock_ridge_filename(struct iso_directory_record *de,
 					rr->u.NM.flags);
 				break;
 			}
			len = rr->len - 5;
			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
			p = memchr(rr->u.NM.name, '\0', len);
			if (unlikely(p))
				len = p - rr->u.NM.name;
			memcpy(retname + retnamlen, rr->u.NM.name, len);
			retnamlen += len;
			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);","The get_rock_ridge_filename function in fs/isofs/rock.c in the Linux kernel before 4.5.5 mishandles NM (aka alternate name) entries containing 0 characters, which allows local users to obtain sensitive information from kernel memory or possibly have unspecified other impact via a crafted isofs filesystem."
672,CVE-2016-4817,"  static const h2o_iovec_t SETTINGS_HOST_BIN = {H2O_STRLIT(""\x00\x00\x0c""      
     } else {
         close_connection_now(conn);
        return -1;
     }
    return 0;
 }
 
 void send_stream_error(h2o_http2_conn_t *conn, uint32_t stream_id, int errnum)
  static ssize_t expect_preface(h2o_http2_conn_t *conn, const uint8_t *src, size_t
     return CONNECTION_PREFACE.len;
 }
 
static int parse_input(h2o_http2_conn_t *conn)
 {
     size_t http2_max_concurrent_requests_per_connection = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection;
     int perform_early_exit = 0;
  static void parse_input(h2o_http2_conn_t *conn)
                 enqueue_goaway(conn, (int)ret,
                                err_desc != NULL ? (h2o_iovec_t){(char *)err_desc, strlen(err_desc)} : (h2o_iovec_t){});
             }
            return close_connection(conn);
         }
          
         h2o_buffer_consume(&conn->sock->input, ret);
     }
 
     if (!h2o_socket_is_reading(conn->sock))
         h2o_socket_read_start(conn->sock, on_read);
    return 0;
 
 EarlyExit:
     if (h2o_socket_is_reading(conn->sock))
         h2o_socket_read_stop(conn->sock);
    return 0;
 }
 
 static void on_read(h2o_socket_t *sock, int status)
  static void on_read(h2o_socket_t *sock, int status)
     }
 
     update_idle_timeout(conn);
    if (parse_input(conn) != 0)
        return;
 
      
     if (h2o_timeout_is_linked(&conn->_write.timeout_entry)) {","lib/http2/connection.c in H2O before 1.7.3 and 2.x before 2.0.0-beta5 mishandles HTTP/2 disconnection, which allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly execute arbitrary code via a crafted packet."
673,CVE-2016-4809,"  archive_read_format_cpio_read_header(struct archive_read *a,
 
 	 
 	if (archive_entry_filetype(entry) == AE_IFLNK) {
		if (cpio->entry_bytes_remaining > 1024 * 1024) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}
 		h = __archive_read_ahead(a,
 			(size_t)cpio->entry_bytes_remaining, NULL);
 		if (h == NULL)",The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.
674,CVE-2016-4805,"  int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
 
 	pch->ppp = NULL;
 	pch->chan = chan;
	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
  ppp_unregister_channel(struct ppp_channel *chan)
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
	put_net(pch->chan_net);
	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);","Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions."
675,CVE-2016-4804,"  static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)
 	   (unsigned long long)fs->fat_start,
 	   (unsigned long long)fs->fat_start / lss);
     printf(""%10d FATs, %d bit entries\n"", b->fats, fs->fat_bits);
    printf(""%10lld bytes per FAT (= %llu sectors)\n"", (long long)fs->fat_size,
	   (long long)fs->fat_size / lss);
     if (!fs->root_cluster) {
 	printf(""Root directory starts at byte %llu (sector %llu)\n"",
 	       (unsigned long long)fs->root_start,
  void read_boot(DOS_FS * fs)
     struct boot_sector b;
     unsigned total_sectors;
     unsigned short logical_sector_size, sectors;
    off_t fat_length;
     unsigned total_fat_entries;
     off_t data_size;
 
  void read_boot(DOS_FS * fs)
      
     fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,
 	    logical_sector_size);

     fat_length = le16toh(b.fat_length) ?
 	le16toh(b.fat_length) : le32toh(b.fat32_length);
    if (!fat_length)
	die(""FAT size is zero."");

     fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;
     fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *
 	logical_sector_size;
     fs->root_entries = GET_UNALIGNED_W(b.dir_entries);
     fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<
 							MSDOS_DIR_BITS,
 							logical_sector_size);

     data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;
    if (data_size < fs->cluster_size)
	die(""Filesystem has no space for any data clusters"");

     fs->data_clusters = data_size / fs->cluster_size;
     fs->root_cluster = 0;	 
     fs->fsinfo_start = 0;	 ","The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function."
676,CVE-2016-4581,"  static struct mount *next_group(struct mount *m, struct mount *origin)
 
  
 static struct user_namespace *user_ns;
static struct mount *last_dest, *first_source, *last_source, *dest_master;
 static struct mountpoint *mp;
 static struct hlist_head *list;
 
  static int propagate_one(struct mount *m)
 		type = CL_MAKE_SHARED;
 	} else {
 		struct mount *n, *p;
		bool done;
 		for (n = m; ; n = p) {
 			p = n->mnt_master;
			if (p == dest_master || IS_MNT_MARKED(p))
 				break;
 		}
		do {
			struct mount *parent = last_source->mnt_parent;
			if (last_source == first_source)
				break;
			done = parent->mnt_master == p;
			if (done && peers(n, parent))
				break;
			last_source = last_source->mnt_master;
		} while (!done);

 		type = CL_SLAVE;
 		 
 		if (IS_MNT_SHARED(m))
  int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,
 	 */
 	user_ns = current->nsproxy->mnt_ns->user_ns;
 	last_dest = dest_mnt;
	first_source = source_mnt;
 	last_source = source_mnt;
 	mp = dest_mp;
 	list = tree_list;","fs/pnode.c in the Linux kernel before 4.5.4 does not properly traverse a mount propagation tree in a certain case involving a slave mount, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted series of mount system calls."
677,CVE-2016-4580,"  int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
	memset(dte, 0, sizeof(*dte));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)","The x25_negotiate_facilities function in net/x25/x25_facilities.c in the Linux kernel before 4.5.5 does not properly initialize a certain data structure, which allows attackers to obtain sensitive information from kernel stack memory via an X.25 Call Request."
678,CVE-2016-4578,"  static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
		memset(&r1, 0, sizeof(r1));
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;
 		r1.val = resolution;","sound/core/timer.c in the Linux kernel through 4.6 does not initialize certain r1 data structures, which allows local users to obtain sensitive information from kernel stack memory via crafted use of the ALSA timer interface, related to the (1) snd_timer_user_ccallback and (2) snd_timer_user_tinterrupt functions."
679,CVE-2016-4569,"  static int snd_timer_user_params(struct file *file,
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu->tread) {
 			struct snd_timer_tread tread;
			memset(&tread, 0, sizeof(tread));
 			tread.event = SNDRV_TIMER_EVENT_EARLY;
 			tread.tstamp.tv_sec = 0;
 			tread.tstamp.tv_nsec = 0;","The snd_timer_user_params function in sound/core/timer.c in the Linux kernel through 4.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via crafted use of the ALSA timer interface."
680,CVE-2016-4568,"  static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer
 	return 0;
 }
 
static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)
{
	return __verify_planes_array(vb, pb);
}

 /**
  * __verify_length() - Verify that the bytesused value for each plane fits in
  * the plane length and that the data offset doesn't exceed the bytesused value.
  static int __fill_vb2_buffer(struct vb2_buffer *vb,
 }
 
 static const struct vb2_buf_ops v4l2_buf_ops = {
	.verify_planes_array	= __verify_planes_array_core,
 	.fill_user_buffer	= __fill_v4l2_buffer,
 	.fill_vb2_buffer	= __fill_vb2_buffer,
 	.copy_timestamp		= __copy_timestamp,",drivers/media/v4l2-core/videobuf2-v4l2.c in the Linux kernel before 4.5.3 allows local users to cause a denial of service (kernel memory write operation) or possibly have unspecified other impact via a crafted number of planes in a VIDIOC_DQBUF ioctl call.
681,CVE-2016-4565," 
 
 #include <asm/uaccess.h>
 
#include <rdma/ib.h>
 #include <rdma/ib_cm.h>
 #include <rdma/ib_user_cm.h>
 #include <rdma/ib_marshall.h>
  static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
		return -EACCES;

 	if (len < sizeof(hdr))
 		return -EINVAL;
 ","The InfiniBand (aka IB) stack in the Linux kernel before 4.5.3 incorrectly relies on the write system call, which allows local users to cause a denial of service (kernel memory write operation) or possibly have unspecified other impact via a uAPI interface."
682,CVE-2016-4558,"  void bpf_register_prog_type(struct bpf_prog_type_list *tl);
 void bpf_register_map_type(struct bpf_map_type_list *tl);
 
 struct bpf_prog *bpf_prog_get(u32 ufd);
struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog);
 void bpf_prog_put(struct bpf_prog *prog);
 void bpf_prog_put_rcu(struct bpf_prog *prog);
 
 struct bpf_map *bpf_map_get_with_uref(u32 ufd);
 struct bpf_map *__bpf_map_get(struct fd f);
struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref);
 void bpf_map_put_with_uref(struct bpf_map *map);
 void bpf_map_put(struct bpf_map *map);
 int bpf_map_precharge_memlock(u32 pages);","The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count."
683,CVE-2016-4557,"  static int replace_map_fd_with_map_ptr(struct verifier_env *env)
 			if (IS_ERR(map)) {
 				verbose(""fd %d is not pointing to valid bpf_map\n"",
 					insn->imm);
 				return PTR_ERR(map);
 			}
 ","The replace_map_fd_with_map_ptr function in kernel/bpf/verifier.c in the Linux kernel before 4.5.5 does not properly maintain an fd data structure, which allows local users to gain privileges or cause a denial of service (use-after-free) via crafted BPF instructions that reference an incorrect file descriptor."
684,CVE-2016-4486,"  static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,
 
 static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)
 {
	struct rtnl_link_ifmap map;

	memset(&map, 0, sizeof(map));
	map.mem_start   = dev->mem_start;
	map.mem_end     = dev->mem_end;
	map.base_addr   = dev->base_addr;
	map.irq         = dev->irq;
	map.dma         = dev->dma;
	map.port        = dev->if_port;

 	if (nla_put(skb, IFLA_MAP, sizeof(map), &map))
 		return -EMSGSIZE;
 ","The rtnl_fill_link_ifmap function in net/core/rtnetlink.c in the Linux kernel before 4.5.5 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory by reading a Netlink message."
685,CVE-2016-4485,"  static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
 	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
 		struct llc_pktinfo info;
 
		memset(&info, 0, sizeof(info));
 		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
 		llc_pdu_decode_dsap(skb, &info.lpi_sap);
 		llc_pdu_decode_da(skb, info.lpi_mac);","The llc_cmsg_rcv function in net/llc/af_llc.c in the Linux kernel before 4.5.5 does not initialize a certain data structure, which allows attackers to obtain sensitive information from kernel stack memory by reading a message."
686,CVE-2016-4482,"  static int proc_getdriver(struct usb_dev_state *ps, void __user *arg)
 
 static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
	struct usbdevfs_connectinfo ci;

	memset(&ci, 0, sizeof(ci));
	ci.devnum = ps->dev->devnum;
	ci.slow = ps->dev->speed == USB_SPEED_LOW;
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;","The proc_connectinfo function in drivers/usb/core/devio.c in the Linux kernel through 4.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted USBDEVFS_CONNECTINFO ioctl call."
687,CVE-2016-4478,"  void xmlrpc_char_encode(char *outbuffer, const char *s1)
 			s->append_char(s, c);
 		}
 	}
	s->append_char(s, 0);
 
	strncpy(outbuffer, s->str, XMLRPC_BUFSIZE);
 }
 
 static void xmlrpc_append_char_encode(mowgli_string_t *s, const char *s1)",Buffer overflow in the xmlrpc_char_encode function in modules/transport/xmlrpc/xmlrpclib.c in Atheme before 7.2.7 allows remote attackers to cause a denial of service via vectors related to XMLRPC response encoding.
688,CVE-2016-4470,"  int key_reject_and_link(struct key *key,
 
 	mutex_unlock(&key_construction_mutex);
 
	if (keyring && link_ret == 0)
 		__key_link_end(keyring, &key->index_key, edit);
 
 	 ","The key_reject_and_link function in security/keys/key.c in the Linux kernel through 4.6.3 does not ensure that a certain data structure is initialized, which allows local users to cause a denial of service (system crash) via vectors involving a crafted keyctl request2 command."
689,CVE-2016-4440,"  static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)
 
 	if (is_guest_mode(vcpu))
 		msr_bitmap = vmx_msr_bitmap_nested;
	else if (cpu_has_secondary_exec_ctrls() &&
		 (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &
		  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {
 		if (is_long_mode(vcpu))
 			msr_bitmap = vmx_msr_bitmap_longmode_x2apic;
 		else
  static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 
 	vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));
	if (cpu_has_secondary_exec_ctrls()) {
		if (kvm_vcpu_apicv_active(vcpu))
			vmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,
				      SECONDARY_EXEC_APIC_REGISTER_VIRT |
				      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
		else
			vmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,
					SECONDARY_EXEC_APIC_REGISTER_VIRT |
					SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);
	}

	if (cpu_has_vmx_msr_bitmap())
		vmx_set_msr_bitmap(vcpu);
 }
 
 static u32 vmx_exec_control(struct vcpu_vmx *vmx)
  static __init int hardware_setup(void)
 
 	set_bit(0, vmx_vpid_bitmap);  
 
	for (msr = 0x800; msr <= 0x8ff; msr++)
		vmx_disable_intercept_msr_read_x2apic(msr);

	 
	vmx_enable_intercept_msr_read_x2apic(0x802);
	 
	vmx_enable_intercept_msr_read_x2apic(0x839);
	 
	vmx_disable_intercept_msr_write_x2apic(0x808);
	 
	vmx_disable_intercept_msr_write_x2apic(0x80b);
	 
	vmx_disable_intercept_msr_write_x2apic(0x83f);
 
 	if (enable_ept) {
 		kvm_mmu_set_mask_ptes(0ull,","arch/x86/kvm/vmx.c in the Linux kernel through 4.6.3 mishandles the APICv on/off state, which allows guest OS users to obtain direct APIC MSR access on the host OS, and consequently cause a denial of service (host OS crash) or possibly execute arbitrary code on the host OS, via x2APIC mode."
690,CVE-2016-4425," 
    otherwise to 0. */
 #define JSON_HAVE_LOCALECONV 0
 
 
#define JSON_PARSER_MAX_DEPTH 2048

 #endif","Jansson 2.7 and earlier allows context-dependent attackers to cause a denial of service (deep recursion, stack consumption, and crash) via crafted JSON data."
691,CVE-2016-4414,"  RemotePeer *PeerFactory::createPeer(const ProtoList &protocols, AuthHandler *aut
         }
     }
 
    return nullptr;
 }",The onReadyRead function in core/coreauthhandler.cpp in Quassel before 0.12.4 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via invalid handshake data.
692,CVE-2016-4302,"  parse_codes(struct archive_read *a)
       rar->range_dec.Stream = &rar->bytein;
       __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);
 
      if (rar->dictionary_size == 0) {
	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid zero dictionary size"");
	      return (ARCHIVE_FATAL);
      }

       if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
         rar->dictionary_size, &g_szalloc))
       {",Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.
693,CVE-2016-4301,"  parse_device(dev_t *pdev, struct archive *a, char *val)
 				    ""Missing number"");
 				return ARCHIVE_WARN;
 			}
			if (argc >= MAX_PACK_ARGS) {
 				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 				    ""Too many arguments"");
 				return ARCHIVE_WARN;
 			}
			numbers[argc++] = (unsigned long)mtree_atol(&p);
 		}
 		if (argc < 2) {
 			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,",Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.
694,CVE-2016-4300,"  read_SubStreamsInfo(struct archive_read *a, struct _7z_substream_info *ss,
 				return (-1);
 			if (UMAX_ENTRY < f[i].numUnpackStreams)
 				return (-1);
			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
				return (-1);
			}
 			unpack_streams += (size_t)f[i].numUnpackStreams;
 		}
 		if ((p = header_bytes(a, 1)) == NULL)","Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow."
695,CVE-2016-3955,"  int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
 	if (!(size > 0))
 		return 0;
 
	if (size > urb->transfer_buffer_length) {
		 
		if (ud->side == USBIP_STUB) {
			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
			return 0;
		} else {
			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
			return -EPIPE;
		}
	}

 	ret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);
 	if (ret != size) {
 		dev_err(&urb->dev->dev, ""recv xbuf, %d\n"", ret);",The usbip_recv_xbuff function in drivers/usb/usbip/usbip_common.c in the Linux kernel before 4.5.3 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted length value in a USB/IP packet.
696,CVE-2016-3951,"  EXPORT_SYMBOL_GPL(cdc_ncm_select_altsetting);
 
 static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)
 {
 	 
 	if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)
 		return -ENODEV;
  static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)
 	 * Additionally, generic NCM devices are assumed to accept arbitrarily
 	 * placed NDP.
 	 */
	return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
 }
 
 static void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)
  static void cdc_ncm_status(struct usbnet *dev, struct urb *urb)
 
 static const struct driver_info cdc_ncm_info = {
 	.description = ""CDC NCM"",
	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
			| FLAG_LINK_INTR,
 	.bind = cdc_ncm_bind,
 	.unbind = cdc_ncm_unbind,
 	.manage_power = usbnet_manage_power,
  static const struct driver_info cdc_ncm_info = {
 static const struct driver_info wwan_info = {
 	.description = ""Mobile Broadband Network Device"",
 	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
			| FLAG_LINK_INTR | FLAG_WWAN,
 	.bind = cdc_ncm_bind,
 	.unbind = cdc_ncm_unbind,
 	.manage_power = usbnet_manage_power,
  static const struct driver_info wwan_info = {
 static const struct driver_info wwan_noarp_info = {
 	.description = ""Mobile Broadband Network Device (NO ARP)"",
 	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
			| FLAG_LINK_INTR | FLAG_WWAN | FLAG_NOARP,
 	.bind = cdc_ncm_bind,
 	.unbind = cdc_ncm_unbind,
 	.manage_power = usbnet_manage_power,",Double free vulnerability in drivers/net/usb/cdc_ncm.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (system crash) or possibly have unspecified other impact by inserting a USB device with an invalid USB descriptor.
697,CVE-2016-3841,"  struct ipv6_pinfo {
 	struct ipv6_ac_socklist	*ipv6_ac_list;
 	struct ipv6_fl_socklist __rcu *ipv6_fl_list;
 
	struct ipv6_txoptions __rcu	*opt;
 	struct sk_buff		*pktoptions;
 	struct sk_buff		*rxpmtu;
 	struct inet6_cork	cork;","The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call."
698,CVE-2016-3713,"  static bool msr_mtrr_valid(unsigned msr)
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
 	}
 	return false;
 }","The msr_mtrr_valid function in arch/x86/kvm/mtrr.c in the Linux kernel before 4.6.1 supports MSR 0x2f8, which allows guest OS users to read or write to the kvm_arch_vcpu data structure, and consequently obtain sensitive information or cause a denial of service (system crash), via a crafted ioctl call."
699,CVE-2016-3699,"  void __init setup_arch(char **cmdline_p)
 	 
 	setup_log_buf(1);
 
#ifdef CONFIG_EFI_SECURE_BOOT_SECURELEVEL
	if (boot_params.secure_boot) {
		set_securelevel(1);
	}
#endif

 	reserve_initrd();
 
 #if defined(CONFIG_ACPI) && defined(CONFIG_BLK_DEV_INITRD)
  void __init setup_arch(char **cmdline_p)
 
 	io_delay_init();
 
 	 ","The Linux kernel, as used in Red Hat Enterprise Linux 7.2 and Red Hat Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended Secure Boot restrictions and execute untrusted code by appending ACPI tables to the initrd."
700,CVE-2016-3698,"  static void *myzalloc(size_t size)
 }
 
 static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
		       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)
 {
 	struct sockaddr_in6 sin6;
	unsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];
 	struct iovec iovec;
 	struct msghdr msghdr;
 	struct cmsghdr *cmsghdr;
  static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
 	*ifindex = sin6.sin6_scope_id;
         for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
 	     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
		if (cmsghdr->cmsg_level != IPPROTO_IPV6)
			continue;

		switch(cmsghdr->cmsg_type) {
		case IPV6_PKTINFO:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
				struct in6_pktinfo *pktinfo;

				pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
				*ifindex = pktinfo->ipi6_ifindex;
			}
			break;
		case IPV6_HOPLIMIT:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {
				int *val;
 
				val = (int *) CMSG_DATA(cmsghdr);
				*hoplimit = *val;
			}
			break;
 		}
 	}
 	*addr = sin6.sin6_addr;
  static int ndp_sock_open(struct ndp *ndp)
 		goto close_sock;
 	}
 
	val = 1;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, ""Failed to setsockopt IPV6_RECVHOPLIMIT,."");
		err = -errno;
		goto close_sock;
	}

 	ndp->sock = sock;
 	return 0;
 close_sock:
  struct ndp_msg {
 	size_t				len;
 	struct in6_addr			addrto;
 	uint32_t			ifindex;
	int				hoplimit;
 	struct icmp6_hdr *		icmp6_hdr;
 	unsigned char *			opts_start;  
  static int ndp_sock_recv(struct ndp *ndp)
 
 	len = ndp_msg_payload_maxlen(msg);
 	err = myrecvfrom6(ndp->sock, msg->buf, &len, 0,
			  &msg->addrto, &msg->ifindex, &msg->hoplimit);
 	if (err) {
 		err(ndp, ""Failed to receive message"");
 		goto free_msg;
 	}
	dbg(ndp, ""rcvd from: %s, ifindex: %u, hoplimit: %d"",
		 str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);

	if (msg->hoplimit != 255) {
		warn(ndp, ""ignoring packet with bad hop limit (%d)"", msg->hoplimit);
		err = 0;
		goto free_msg;
	}
 
 	if (len < sizeof(*msg->icmp6_hdr)) {
 		warn(ndp, ""rcvd icmp6 packet too short (%luB)"", len);","libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network."
701,CVE-2016-3689,"  static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc
 
 	pcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,
 					 union_desc->bMasterInterface0);
	if (!pcu->ctrl_intf)
		return -EINVAL;
 
 	alt = pcu->ctrl_intf->cur_altsetting;
 	pcu->ep_ctrl = &alt->endpoint[0].desc;
 	pcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);
 
 	pcu->data_intf = usb_ifnum_to_if(pcu->udev,
 					 union_desc->bSlaveInterface0);
	if (!pcu->data_intf)
		return -EINVAL;
 
 	alt = pcu->data_intf->cur_altsetting;
 	if (alt->desc.bNumEndpoints != 2) {",The ims_pcu_parse_cdc_data function in drivers/input/misc/ims-pcu.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (system crash) via a USB device without both a master and a slave interface.
702,CVE-2016-3672,"  static unsigned long mmap_base(unsigned long rnd)
 	return PAGE_ALIGN(TASK_SIZE - gap - rnd);
 }
 
 /*
  * This function, called very early during the creation of a new
  * process VM image, sets up which VM layout function to use:
  void arch_pick_mmap_layout(struct mm_struct *mm)
 	if (current->flags & PF_RANDOMIZE)
 		random_factor = arch_mmap_rnd();
 
	mm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = mm->mmap_legacy_base;","The arch_pick_mmap_layout function in arch/x86/mm/mmap.c in the Linux kernel through 4.5.2 does not properly randomize the legacy base address, which makes it easier for local users to defeat the intended restrictions on the ADDR_NO_RANDOMIZE flag, and bypass the ASLR protection mechanism for a setuid or setgid program, by disabling stack-consumption resource limits."
703,CVE-2016-3156,"  static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 
 	ASSERT_RTNL();
 
	if (in_dev->dead)
		goto no_promotions;

 	 
  static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 			fib_del_ifaddr(ifa, ifa1);
 	}
 
no_promotions:
 	 
 
 	*ifap = ifa1->ifa_next;","The IPv4 implementation in the Linux kernel before 4.5.2 mishandles destruction of device objects, which allows guest OS users to cause a denial of service (host OS networking outage) by arranging for a large number of IP addresses."
704,CVE-2016-3140,"  static int digi_port_init(struct usb_serial_port *port, unsigned port_num)
 
 static int digi_startup(struct usb_serial *serial)
 {
	struct device *dev = &serial->interface->dev;
 	struct digi_serial *serial_priv;
 	int ret;
	int i;

	 
	if (serial->num_port_pointers < serial->type->num_ports + 1) {
		dev_err(dev, ""OOB endpoints missing\n"");
		return -ENODEV;
	}

	for (i = 0; i < serial->type->num_ports + 1 ; i++) {
		if (!serial->port[i]->read_urb) {
			dev_err(dev, ""bulk-in endpoint missing\n"");
			return -ENODEV;
		}
		if (!serial->port[i]->write_urb) {
			dev_err(dev, ""bulk-out endpoint missing\n"");
			return -ENODEV;
		}
	}
 
 	serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);
 	if (!serial_priv)",The digi_port_init function in drivers/usb/serial/digi_acceleport.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
705,CVE-2016-3138,"  static int acm_probe(struct usb_interface *intf,
 	if (quirks == NO_UNION_NORMAL) {
 		data_interface = usb_ifnum_to_if(usb_dev, 1);
 		control_interface = usb_ifnum_to_if(usb_dev, 0);
		 
		if (!data_interface || !control_interface)
			return -ENODEV;
 		goto skip_normal_probe;
 	}
 ",The acm_probe function in drivers/usb/class/cdc-acm.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both a control and a data endpoint descriptor.
706,CVE-2016-3137,"  static int cypress_generic_port_probe(struct usb_serial_port *port)
 	struct usb_serial *serial = port->serial;
 	struct cypress_private *priv;
 
	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
		dev_err(&port->dev, ""required endpoint is missing\n"");
		return -ENODEV;
	}

 	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
  static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	 
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,","drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions."
707,CVE-2016-3136,"  static void mct_u232_msr_to_state(struct usb_serial_port *port,
 
 static int mct_u232_port_probe(struct usb_serial_port *port)
 {
	struct usb_serial *serial = port->serial;
 	struct mct_u232_private *priv;
 
	 
	if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {
		dev_err(&port->dev, ""expected endpoint missing\n"");
		return -ENODEV;
	}

 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
 	 
	priv->read_urb = serial->port[1]->interrupt_in_urb;
 	priv->read_urb->context = port;
 
 	spin_lock_init(&priv->lock);",The mct_u232_msr_to_state function in drivers/usb/serial/mct_u232.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted USB device without two interrupt-in endpoint descriptors.
708,CVE-2016-3135,"  struct xt_table_info *xt_alloc_table_info(unsigned int size)
 	struct xt_table_info *info = NULL;
 	size_t sz = sizeof(*info) + size;
 
	if (sz < sizeof(*info))
		return NULL;

 	 
 	if ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)
 		return NULL;",Integer overflow in the xt_alloc_table_info function in net/netfilter/x_tables.c in the Linux kernel through 4.5.2 on 32-bit platforms allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.
709,CVE-2016-3134,"  unsigned int arpt_do_table(struct sk_buff *skb,
 }
 
  
static inline bool unconditional(const struct arpt_entry *e)
 {
 	static const struct arpt_arp uncond;
 
	return e->target_offset == sizeof(struct arpt_entry) &&
	       memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;
 }
 
  
			if ((unconditional(e) &&
 			     (strcmp(t->target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
			     t->verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t->target.u.user.name,
  static bool check_underflow(const struct arpt_entry *e)
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
	if (!unconditional(e))
 		return false;
 	t = arpt_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
  static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 			newinfo->hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
 				return -EINVAL;
 			}
 			newinfo->underflow[h] = underflows[h];","The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call."
710,CVE-2016-3120,"  validate_as_request(kdc_realm_t *kdc_active_realm,
         return(KDC_ERR_MUST_USE_USER2USER);
     }
 
    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {
         *status = ""ANONYMOUS NOT ALLOWED"";
         return(KDC_ERR_POLICY);
     }","The validate_as_request function in kdc_util.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.13.6 and 1.4.x before 1.14.3, when restrict_anonymous_to_tgt is enabled, uses an incorrect client data structure, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via an S4U2Self request."
711,CVE-2016-3119,"  process_db_args(krb5_context context, char **db_args, xargs_t *xargs,
     if (db_args) {
         for (i=0; db_args[i]; ++i) {
             arg = strtok_r(db_args[i], ""="", &arg_val);
            arg = (arg != NULL) ? arg : """";
             if (strcmp(arg, TKTPOLICY_ARG) == 0) {
                 dptr = &xargs->tktpolicydn;
             } else {","The process_db_args function in plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in the LDAP KDB module in kadmind in MIT Kerberos 5 (aka krb5) through 1.13.4 and 1.14.x through 1.14.1 mishandles the DB argument, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request to modify a principal."
712,CVE-2016-3078,"  static PHP_NAMED_FUNCTION(zif_zip_entry_read)
 	}
 
 	if (zr_rsrc->zf) {
		buffer = zend_string_safe_alloc(1, len, 0, 0);
 		n = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));
 		if (n > 0) {
 			ZSTR_VAL(buffer)[n] = '\0';
  static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type)  
 		RETURN_FALSE;
 	}
 
	buffer = zend_string_safe_alloc(1, len, 0, 0);
 	n = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));
 	if (n < 1) {
 		zend_string_free(buffer);",Multiple integer overflows in php_zip.c in the zip extension in PHP before 7.0.6 allow remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted call to (1) getFromIndex or (2) getFromName in the ZipArchive class.
713,CVE-2016-3070," 
 #include <linux/mempolicy.h>
 #include <linux/vmalloc.h>
 #include <linux/security.h>
#include <linux/backing-dev.h>
 #include <linux/syscalls.h>
 #include <linux/hugetlb.h>
 #include <linux/hugetlb_cgroup.h>
  int migrate_page_move_mapping(struct address_space *mapping,
 		struct buffer_head *head, enum migrate_mode mode,
 		int extra_count)
 {
	struct zone *oldzone, *newzone;
	int dirty;
 	int expected_count = 1 + extra_count;
 	void **pslot;
 
  int migrate_page_move_mapping(struct address_space *mapping,
 		return MIGRATEPAGE_SUCCESS;
 	}
 
	oldzone = page_zone(page);
	newzone = page_zone(newpage);

 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
  int migrate_page_move_mapping(struct address_space *mapping,
 		set_page_private(newpage, page_private(page));
 	}
 
	 
	dirty = PageDirty(page);
	if (dirty) {
		ClearPageDirty(page);
		SetPageDirty(newpage);
	}

 	radix_tree_replace_slot(pslot, newpage);
 
 	 
 	page_unfreeze_refs(page, expected_count - 1);
 
	spin_unlock(&mapping->tree_lock);
	 

 	 
	if (newzone != oldzone) {
		__dec_zone_state(oldzone, NR_FILE_PAGES);
		__inc_zone_state(newzone, NR_FILE_PAGES);
		if (PageSwapBacked(page) && !PageSwapCache(page)) {
			__dec_zone_state(oldzone, NR_SHMEM);
			__inc_zone_state(newzone, NR_SHMEM);
		}
		if (dirty && mapping_cap_account_dirty(mapping)) {
			__dec_zone_state(oldzone, NR_FILE_DIRTY);
			__inc_zone_state(newzone, NR_FILE_DIRTY);
		}
 	}
	local_irq_enable();
 
 	return MIGRATEPAGE_SUCCESS;
 }
  void migrate_page_copy(struct page *newpage, struct page *page)
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
	 
	if (PageDirty(page))
		SetPageDirty(newpage);
 
 	if (page_is_young(page))
 		set_page_young(newpage);","The trace_writeback_dirty_page implementation in include/trace/events/writeback.h in the Linux kernel before 4.4 improperly interacts with mm/migrate.c, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by triggering a certain page move."
714,CVE-2016-3062,"  static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     if (entries >= UINT_MAX / sizeof(*sc->drefs))
         return AVERROR_INVALIDDATA;
     av_free(sc->drefs);
    sc->drefs_count = 0;
     sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));
     if (!sc->drefs)
         return AVERROR(ENOMEM);",The mov_read_dref function in libavformat/mov.c in Libav before 11.7 and FFmpeg before 0.11 allows remote attackers to cause a denial of service (memory corruption) or execute arbitrary code via the entries value in a dref box in an MP4 file.
715,CVE-2016-2782,"  static int treo_attach(struct usb_serial *serial)
 		(serial->num_interrupt_in == 0))
 		return 0;
 
	if (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {
		dev_err(&serial->interface->dev, ""missing endpoints\n"");
		return -ENODEV;
	}

 	/*
 	* It appears that Treos and Kyoceras want to use the
 	* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,",The treo_attach function in drivers/usb/serial/visor.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by inserting a USB device that lacks a (1) bulk-in or (2) interrupt-in endpoint.
716,CVE-2016-2550," 
 #include <linux/mutex.h>
 #include <net/sock.h>
 
void unix_inflight(struct user_struct *user, struct file *fp);
void unix_notinflight(struct user_struct *user, struct file *fp);
 void unix_gc(void);
 void wait_for_unix_gc(void);
 struct sock *unix_get_socket(struct file *filp);",The Linux kernel before 4.5 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by leveraging incorrect tracking of descriptor ownership and sending each descriptor over a UNIX socket before closing it. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-4312.
717,CVE-2016-2549,"  static int snd_hrtimer_start(struct snd_timer *t)
 	struct snd_hrtimer *stime = t->private_data;
 
 	atomic_set(&stime->running, 0);
	hrtimer_try_to_cancel(&stime->hrt);
 	hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&stime->running, 1);
  static int snd_hrtimer_stop(struct snd_timer *t)
 {
 	struct snd_hrtimer *stime = t->private_data;
 	atomic_set(&stime->running, 0);
	hrtimer_try_to_cancel(&stime->hrt);
 	return 0;
 }
 ","sound/core/hrtimer.c in the Linux kernel before 4.4.1 does not prevent recursive callback access, which allows local users to cause a denial of service (deadlock) via a crafted ioctl call."
718,CVE-2016-2548,"  static void snd_timer_check_master(struct snd_timer_instance *master)
 		    slave->slave_id == master->slave_id) {
 			list_move_tail(&slave->open_list, &master->slave_list_head);
 			spin_lock_irq(&slave_active_lock);
			spin_lock(&master->timer->lock);
 			slave->master = master;
 			slave->timer = master->timer;
 			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&slave->active_list,
 					      &master->slave_active_head);
			spin_unlock(&master->timer->lock);
 			spin_unlock_irq(&slave_active_lock);
 		}
 	}
  int snd_timer_close(struct snd_timer_instance *timeri)
 		    timer->hw.close)
 			timer->hw.close(timer);
 		 
		spin_lock_irq(&slave_active_lock);
		spin_lock(&timer->lock);
 		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
 					 open_list) {
 			list_move_tail(&slave->open_list, &snd_timer_slave_list);
 			slave->master = NULL;
 			slave->timer = NULL;
			list_del_init(&slave->ack_list);
			list_del_init(&slave->active_list);
 		}
		spin_unlock(&timer->lock);
		spin_unlock_irq(&slave_active_lock);
 		mutex_unlock(&register_mutex);
 	}
  out:
  static int snd_timer_start_slave(struct snd_timer_instance *timeri)
 
 	spin_lock_irqsave(&slave_active_lock, flags);
 	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
	if (timeri->master && timeri->timer) {
		spin_lock(&timeri->timer->lock);
 		list_add_tail(&timeri->active_list,
 			      &timeri->master->slave_active_head);
		spin_unlock(&timeri->timer->lock);
	}
 	spin_unlock_irqrestore(&slave_active_lock, flags);
 	return 1;  
 }
  static int _snd_timer_stop(struct snd_timer_instance * timeri,
 		if (!keep_flag) {
 			spin_lock_irqsave(&slave_active_lock, flags);
 			timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
			list_del_init(&timeri->ack_list);
			list_del_init(&timeri->active_list);
 			spin_unlock_irqrestore(&slave_active_lock, flags);
 		}
 		goto __end;","sound/core/timer.c in the Linux kernel before 4.4.1 retains certain linked lists after a close or stop action, which allows local users to cause a denial of service (system crash) via a crafted ioctl call, related to the (1) snd_timer_close and (2) _snd_timer_stop functions."
719,CVE-2016-2546,"  struct snd_timer_user {
 	struct timespec tstamp;		 
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
	struct mutex ioctl_lock;
 };
 
  
  static int snd_timer_user_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->ioctl_lock);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
  static int snd_timer_user_release(struct inode *inode, struct file *file)
 	if (file->private_data) {
 		tu = file->private_data;
 		file->private_data = NULL;
		mutex_lock(&tu->ioctl_lock);
 		if (tu->timeri)
 			snd_timer_close(tu->timeri);
		mutex_unlock(&tu->ioctl_lock);
 		kfree(tu->queue);
 		kfree(tu->tqueue);
 		kfree(tu);
  static int snd_timer_user_tselect(struct file *file,
 	int err = 0;
 
 	tu = file->private_data;
 	if (tu->timeri) {
 		snd_timer_close(tu->timeri);
 		tu->timeri = NULL;
  static int snd_timer_user_tselect(struct file *file,
 	}
 
       __err:
 	return err;
 }
 
  enum {
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
  static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	{
 		int xarg;
 
		if (tu->timeri)	 
 			return -EBUSY;
		if (get_user(xarg, p))
 			return -EFAULT;
 		tu->tread = xarg ? 1 : 0;
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
  static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	return -ENOTTY;
 }
 
static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
				 unsigned long arg)
{
	struct snd_timer_user *tu = file->private_data;
	long ret;

	mutex_lock(&tu->ioctl_lock);
	ret = __snd_timer_user_ioctl(file, cmd, arg);
	mutex_unlock(&tu->ioctl_lock);
	return ret;
}

 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;","sound/core/timer.c in the Linux kernel before 4.4.1 uses an incorrect type of mutex, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call."
720,CVE-2016-2545,"  void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 		} else {
 			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer->running)
				list_del_init(&ti->active_list);
 		}
 		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
 		    (ti->flags & SNDRV_TIMER_IFLG_FAST))","The snd_timer_interrupt function in sound/core/timer.c in the Linux kernel before 4.4.1 does not properly maintain a certain linked list, which allows local users to cause a denial of service (race condition and system crash) via a crafted ioctl call."
721,CVE-2016-2544,"  static struct snd_seq_queue *queue_new(int owner, int locked)
 static void queue_delete(struct snd_seq_queue *q)
 {
 	 
	mutex_lock(&q->timer_mutex);
 	snd_seq_timer_stop(q->timer);
 	snd_seq_timer_close(q);
	mutex_unlock(&q->timer_mutex);
 	 
 	snd_use_lock_sync(&q->use_lock);
 	 ",Race condition in the queue_delete function in sound/core/seq/seq_queue.c in the Linux kernel before 4.4.1 allows local users to cause a denial of service (use-after-free and system crash) by making an ioctl call at a certain time.
722,CVE-2016-2543,"  static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
		if (client->type == USER_CLIENT && client->data.user.fifo)
 			snd_seq_fifo_clear(client->data.user.fifo);
 	}
 ","The snd_seq_ioctl_remove_events function in sound/core/seq/seq_clientmgr.c in the Linux kernel before 4.4.1 does not verify FIFO assignment before proceeding with FIFO clearing, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted ioctl call."
723,CVE-2016-2385,"  int encode_msg(struct sip_msg *msg,char *payload,int len)
 
    if(len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN)
       return -1;

    if(parse_headers(msg,HDR_EOH_F,0)<0){
       myerror=""in parse_headers"";
       goto error;
  int encode_msg(struct sip_msg *msg,char *payload,int len)
     
     
     

	if(len < j + msg->len + 1) {
   	   LM_ERR(""not enough space to encode sip message\n"");
   	   return -1;
	}
    memcpy(&payload[j],msg->buf,msg->len);
    LM_DBG(""msglen = %d,msg starts at %d\n"",msg->len,j);
    j=htons(j);",Heap-based buffer overflow in the encode_msg function in encode_msg.c in the SEAS module in Kamailio (formerly OpenSER and SER) before 4.3.5 allows remote attackers to cause a denial of service (memory corruption and process crash) or possibly execute arbitrary code via a large SIP packet.
724,CVE-2016-2384,"  int snd_usbmidi_create(struct snd_card *card,
 	else
 		err = snd_usbmidi_create_endpoints(umidi, endpoints);
 	if (err < 0) {
 		return err;
 	}
 ",Double free vulnerability in the snd_usbmidi_create function in sound/usb/midi.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (panic) or possibly have unspecified other impact via vectors involving an invalid USB descriptor.
725,CVE-2016-2383,"  static void adjust_branches(struct bpf_prog *prog, int pos, int delta)
 		 
 		if (i < pos && i + insn->off + 1 > pos)
 			insn->off += delta;
		else if (i > pos + delta && i + insn->off + 1 <= pos + delta)
 			insn->off -= delta;
 	}
 }","The adjust_branches function in kernel/bpf/verifier.c in the Linux kernel before 4.5 does not consider the delta in the backward-jump case, which allows local users to obtain sensitive information from kernel memory by creating a packet filter and then loading crafted BPF instructions."
726,CVE-2016-2324,"  static void show_commit(struct commit *commit, void *data)
 		index_commit_for_bitmap(commit);
 }
 
static void show_object(struct object *obj, const char *name, void *data)
 {
 	add_preferred_base_object(name);
 	add_object_entry(obj->oid.hash, obj->type, name, 0);
 	obj->flags |= OBJECT_ADDED;
 }
 
 static void show_edge(struct commit *commit)
  static int get_object_list_from_bitmap(struct rev_info *revs)
 }
 
 static void record_recent_object(struct object *obj,
				 const char *name,
 				 void *data)
 {
 	sha1_array_append(&recent_objects, obj->oid.hash);","Integer overflow in Git before 2.7.4 allows remote attackers to execute arbitrary code via a (1) long filename or (2) many nested trees, which triggers a heap-based buffer overflow."
727,CVE-2016-2315,"  char *strdup(const char *s1)
 {
 	char *s2 = 0;
 	if (s1) {
		size_t len = strlen(s1) + 1;
		s2 = malloc(len);
		memcpy(s2, s1, len);
 	}
 	return s2;
 }","revision.c in git before 2.7.4 uses an incorrect integer data type, which allows remote attackers to execute arbitrary code via a (1) long filename or (2) many nested trees, leading to a heap-based buffer overflow."
728,CVE-2016-2188,"  static int iowarrior_probe(struct usb_interface *interface,
 	iface_desc = interface->cur_altsetting;
 	dev->product_id = le16_to_cpu(udev->descriptor.idProduct);
 
	if (iface_desc->desc.bNumEndpoints < 1) {
		dev_err(&interface->dev, ""Invalid number of endpoints\n"");
		retval = -EINVAL;
		goto error;
	}

 	 
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 		endpoint = &iface_desc->endpoint[i].desc;",The iowarrior_probe function in drivers/usb/misc/iowarrior.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
729,CVE-2016-2187,"  static int gtco_probe(struct usb_interface *usbinterface,
 		goto err_free_buf;
 	}
 
	 
	if (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {
		dev_err(&usbinterface->dev,
			""Invalid number of endpoints\n"");
		error = -EINVAL;
		goto err_free_urb;
	}

 	 
 	if (usb_get_extra_descriptor(usbinterface->cur_altsetting,
				     HID_DEVICE_TYPE, &hid_desc) != 0) {
 		dev_err(&usbinterface->dev,
 			""Can't retrieve exta USB descriptor to get hid report descriptor length\n"");
 		error = -EIO;",The gtco_probe function in drivers/input/tablet/gtco.c in the Linux kernel through 4.5.2 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
730,CVE-2016-2186,"  static int powermate_probe(struct usb_interface *intf, const struct usb_device_i
 	int error = -ENOMEM;
 
 	interface = intf->cur_altsetting;
	if (interface->desc.bNumEndpoints < 1)
		return -EINVAL;

 	endpoint = &interface->endpoint[0].desc;
 	if (!usb_endpoint_is_int_in(endpoint))
 		return -EIO;",The powermate_probe function in drivers/input/misc/powermate.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
731,CVE-2016-2185,"  static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d
 
 	ar2->udev = udev;
 
	 
	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
		dev_err(&interface->dev,
			""%s(): interface 0 must have an endpoint\n"", __func__);
		r = -ENODEV;
		goto fail1;
	}
 	ar2->intf[0] = interface;
 	ar2->ep[0] = &alt->endpoint[0].desc;
 
	 
 	ar2->intf[1] = usb_ifnum_to_if(udev, 1);
	if ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {
		dev_err(&interface->dev, ""%s(): need 2 interfaces, found %d\n"",
			__func__, udev->actconfig->desc.bNumInterfaces);
		r = -ENODEV;
		goto fail1;
	}

 	r = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);
 	if (r)
 		goto fail1;

	 
 	alt = ar2->intf[1]->cur_altsetting;
	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
		dev_err(&interface->dev,
			""%s(): interface 1 must have an endpoint\n"", __func__);
		r = -ENODEV;
		goto fail2;
	}
 	ar2->ep[1] = &alt->endpoint[0].desc;
 
 	r = ati_remote2_urb_init(ar2);
 	if (r)
		goto fail3;
 
 	ar2->channel_mask = channel_mask;
 	ar2->mode_mask = mode_mask;
 
 	r = ati_remote2_setup(ar2, ar2->channel_mask);
 	if (r)
		goto fail3;
 
 	usb_make_path(udev, ar2->phys, sizeof(ar2->phys));
 	strlcat(ar2->phys, ""/input0"", sizeof(ar2->phys));
  static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d
 
 	r = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);
 	if (r)
		goto fail3;
 
 	r = ati_remote2_input_init(ar2);
 	if (r)
		goto fail4;
 
 	usb_set_intfdata(interface, ar2);
 
 	interface->needs_remote_wakeup = 1;
 
 	return 0;
 
 fail4:
 	sysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);
 fail3:
 	ati_remote2_urb_cleanup(ar2);
 fail2:
 	usb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);
  fail1:
 	kfree(ar2);",The ati_remote2_probe function in drivers/input/misc/ati_remote2.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
732,CVE-2016-2184,"  static int create_fixed_stream_quirk(struct snd_usb_audio *chip,
 	}
 	alts = &iface->altsetting[fp->altset_idx];
 	altsd = get_iface_desc(alts);
	if (altsd->bNumEndpoints < 1) {
		kfree(fp);
		kfree(rate_table);
		return -EINVAL;
	}

 	fp->protocol = altsd->bInterfaceProtocol;
 
 	if (fp->datainterval == 0)","The create_fixed_stream_quirk function in sound/usb/quirks.c in the snd-usb-audio driver in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference or double free, and system crash) via a crafted endpoints value in a USB device descriptor."
733,CVE-2016-2180,"  int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)
 {
     char obj_txt[128];
 
    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);
    BIO_printf(bio, ""%s\n"", obj_txt);
 
     return 1;
 }",The TS_OBJ_print_bio function in crypto/ts/ts_lib.c in the X.509 Public Key Infrastructure Time-Stamp Protocol (TSP) implementation in OpenSSL through 1.0.2h allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted time-stamp file that is mishandled by the *openssl ts* command.
734,CVE-2016-2143," 
 static inline int init_new_context(struct task_struct *tsk,
 				   struct mm_struct *mm)
 {
	spin_lock_init(&mm->context.list_lock);
	INIT_LIST_HEAD(&mm->context.pgtable_list);
	INIT_LIST_HEAD(&mm->context.gmap_list);
 	cpumask_clear(&mm->context.cpu_attach_mask);
 	atomic_set(&mm->context.attach_count, 0);
 	mm->context.flush_mm = 0;
 #ifdef CONFIG_PGSTE
 	mm->context.alloc_pgste = page_table_allocate_pgste;
 	mm->context.has_pgste = 0;
 	mm->context.use_skey = 0;
 #endif
	if (mm->context.asce_limit == 0) {
		 
		mm->context.asce_bits = _ASCE_TABLE_LENGTH |
			_ASCE_USER_BITS | _ASCE_TYPE_REGION3;
		mm->context.asce_limit = STACK_TOP_MAX;
	} else if (mm->context.asce_limit == (1UL << 31)) {
		mm_inc_nr_pmds(mm);
	}
 	crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));
 	return 0;
 }
  static inline void activate_mm(struct mm_struct *prev,
 static inline void arch_dup_mmap(struct mm_struct *oldmm,
 				 struct mm_struct *mm)
 {
 }
 
 static inline void arch_exit_mmap(struct mm_struct *mm)","The fork implementation in the Linux kernel before 4.5 on s390 platforms mishandles the case of four page-table levels, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted application, related to arch/s390/include/asm/mmu_context.h and arch/s390/include/asm/pgalloc.h."
735,CVE-2016-2117,"  static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	err = -EIO;
 
	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	 ","The atl2_probe function in drivers/net/ethernet/atheros/atlx/atl2.c in the Linux kernel through 4.5.2 incorrectly enables scatter/gather I/O, which allows remote attackers to obtain sensitive information from kernel memory by reading packet data."
736,CVE-2016-2085," 
 #include <linux/integrity.h>
 #include <linux/evm.h>
 #include <crypto/hash.h>
#include <crypto/algapi.h>
 #include ""evm.h""
 
 int evm_initialized;
  static enum integrity_status evm_verify_hmac(struct dentry *dentry,
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
		rc = crypto_memneq(xattr_data->digest, calc.digest,
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;","The evm_verify_hmac function in security/integrity/evm/evm_main.c in the Linux kernel before 4.5 does not properly copy data, which makes it easier for local users to forge MAC values via a timing side-channel attack."
737,CVE-2016-2070,"  static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,
 	int newly_acked_sacked = prior_unsacked -
 				 (tp->packets_out - tp->sacked_out);
 
	if (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))
		return;

 	tp->prr_delivered += newly_acked_sacked;
 	if (delta < 0) {
 		u64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +",The tcp_cwnd_reduction function in net/ipv4/tcp_input.c in the Linux kernel before 4.3.5 allows remote attackers to cause a denial of service (divide-by-zero error and system crash) via crafted TCP traffic.
738,CVE-2016-2069,"  static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
		 
 		load_cr3(next->pgd);

 		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 
 		 
  static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 			 * schedule, protecting us from simultaneous changes.
 			 */
 			cpumask_set_cpu(cpu, mm_cpumask(next));

 			 
 			load_cr3(next->pgd);
 			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);",Race condition in arch/x86/mm/tlb.c in the Linux kernel before 4.4.1 allows local users to gain privileges by triggering access to a paging structure by a different CPU.
739,CVE-2016-2053,"  int asn1_ber_decoder(const struct asn1_decoder *decoder,
 		unsigned char tmp;
 
 		 
		if ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||
		    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {
 			flags &= ~FLAG_LAST_MATCHED;
 			pc += asn1_op_lengths[op];
 			goto next_op;","The asn1_ber_decoder function in lib/asn1_decoder.c in the Linux kernel before 4.3 allows attackers to cause a denial of service (panic) via an ASN.1 BER file that lacks a public key, leading to mishandling by the public_key_verify_signature function in crypto/asymmetric_keys/public_key.c."
740,CVE-2016-2052,"  struct hb_ot_face_metrics_accelerator_t
 
     this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));
     if (unlikely (!this->num_advances ||
		  2 * (this->num_advances + this->num_metrics) > hb_blob_get_length (this->blob)))
     {
       this->num_metrics = this->num_advances = 0;
       hb_blob_destroy (this->blob);","Multiple unspecified vulnerabilities in HarfBuzz before 1.0.6, as used in Google Chrome before 48.0.2564.82, allow attackers to cause a denial of service or possibly have other impact via crafted data, as demonstrated by a buffer over-read resulting from an inverted length check in hb-ot-font.cc, a different issue than CVE-2015-8947."
741,CVE-2016-1904,"  PHPAPI zend_string *php_escape_shell_cmd(char *str)
 #endif
 
 
	cmd = zend_string_safe_alloc(2, l, 0, 0);
 
 	for (x = 0, y = 0; x < l; x++) {
 		int mb_len = php_mblen(str + x, (l - x));
  PHPAPI zend_string *php_escape_shell_arg(char *str)
 	size_t estimate = (4 * l) + 3;
 
 
	cmd = zend_string_safe_alloc(4, l, 2, 0);  
 
 #ifdef PHP_WIN32
 	ZSTR_VAL(cmd)[y++] = '""';","Multiple integer overflows in ext/standard/exec.c in PHP 7.x before 7.0.2 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a long string to the (1) php_escape_shell_cmd or (2) php_escape_shell_arg function, leading to a heap-based buffer overflow."
742,CVE-2016-1583," 
 #include <linux/slab.h>
 #include <linux/wait.h>
 #include <linux/mount.h>
#include <linux/file.h>
 #include ""ecryptfs_kernel.h""
 
 struct ecryptfs_open_req {
  int ecryptfs_privileged_open(struct file **lower_file,
 	flags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;
 	(*lower_file) = dentry_open(&req.path, flags, cred);
 	if (!IS_ERR(*lower_file))
		goto have_file;
 	if ((flags & O_ACCMODE) == O_RDONLY) {
 		rc = PTR_ERR((*lower_file));
 		goto out;
  int ecryptfs_privileged_open(struct file **lower_file,
 	mutex_unlock(&ecryptfs_kthread_ctl.mux);
 	wake_up(&ecryptfs_kthread_ctl.wait);
 	wait_for_completion(&req.done);
	if (IS_ERR(*lower_file)) {
 		rc = PTR_ERR(*lower_file);
		goto out;
	}
have_file:
	if ((*lower_file)->f_op->mmap == NULL) {
		fput(*lower_file);
		*lower_file = NULL;
		rc = -EMEDIUMTYPE;
	}
 out:
 	return rc;
 }","The ecryptfs_privileged_open function in fs/ecryptfs/kthread.c in the Linux kernel before 4.6.3 allows local users to gain privileges or cause a denial of service (stack memory consumption) via vectors involving crafted mmap calls for /proc pathnames, leading to recursive pagefault handling."
743,CVE-2016-1541,"  zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
 
 	switch(rsrc->compression) {
 	case 0:   
		if (rsrc->uncompressed_size != rsrc->compressed_size) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Malformed OS X metadata entry: inconsistent size"");
			return (ARCHIVE_FATAL);
		}
 #ifdef HAVE_ZLIB_H
 	case 8:  
 #endif
  zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
 		    (intmax_t)rsrc->uncompressed_size);
 		return (ARCHIVE_WARN);
 	}
	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Mac metadata is too large: %jd > 4M bytes"",
		    (intmax_t)rsrc->compressed_size);
		return (ARCHIVE_WARN);
	}
 
 	metadata = malloc((size_t)rsrc->uncompressed_size);
 	if (metadata == NULL) {
  zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
 			bytes_avail = remaining_bytes;
 		switch(rsrc->compression) {
 		case 0:   
			if ((size_t)bytes_avail > metadata_bytes)
				bytes_avail = metadata_bytes;
 			memcpy(mp, p, bytes_avail);
 			bytes_used = (size_t)bytes_avail;
 			metadata_bytes -= bytes_used;",Heap-based buffer overflow in the zip_read_mac_metadata function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to execute arbitrary code via crafted entry-size values in a ZIP archive.
744,CVE-2016-1237,"  static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
 		goto out;
 
 	inode = d_inode(fh->fh_dentry);
 
 	error = fh_want_write(fh);
 	if (error)
 		goto out_errno;
 
	fh_lock(fh);

	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
 	if (error)
		goto out_drop_lock;
	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
 	if (error)
		goto out_drop_lock;

	fh_unlock(fh);
 
 	fh_drop_write(fh);
 
  static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
 	posix_acl_release(argp->acl_access);
 	posix_acl_release(argp->acl_default);
 	return nfserr;
out_drop_lock:
	fh_unlock(fh);
 	fh_drop_write(fh);
 out_errno:
 	nfserr = nfserrno(error);","nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c."
745,CVE-2016-0823,"  static ssize_t pagemap_read(struct file *file, char __user *buf,
 
 static int pagemap_open(struct inode *inode, struct file *file)
 {
	 
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
 	pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about ""
 			""to stop being page-shift some time soon. See the ""
 			""linux/Documentation/vm/pagemap.txt for details.\n"");","The pagemap_open function in fs/proc/task_mmu.c in the Linux kernel before 3.19.3, as used in Android 6.0.1 before 2016-03-01, allows local users to obtain sensitive physical-address information by reading a pagemap file, aka Android internal bug 25739721."
746,CVE-2016-0821," 
  * under normal circumstances, used to verify that nobody uses
  * non-initialized list entries.
  */
#define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)
#define LIST_POISON2  ((void *) 0x200 + POISON_POINTER_DELTA)
 
  
 /*","The LIST_POISON feature in include/linux/poison.h in the Linux kernel before 4.3, as used in Android 6.0.1 before 2016-03-01, does not properly consider the relationship to the mmap_min_addr value, which makes it easier for attackers to bypass a poison-pointer protection mechanism by triggering the use of an uninitialized list entry, aka Android internal bug 26186802, a different vulnerability than CVE-2015-3636."
747,CVE-2016-0758,"  static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 
 	 
 	tag = data[dp++];
	if (tag == ASN1_EOC) {
 		 
 		if (data[dp++] != 0)
 			goto invalid_eoc;
  static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 
 	 
 	len = data[dp++];
	if (len <= 0x7f)
		goto check_length;
 
 	if (unlikely(len == ASN1_INDEFINITE_LENGTH)) {
 		 
  static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen
 	}
 
 	n = len - 0x80;
	if (unlikely(n > sizeof(len) - 1))
 		goto length_too_long;
 	if (unlikely(n > datalen - dp))
 		goto data_overrun_error;
	len = 0;
	for (; n > 0; n--) {
 		len <<= 8;
 		len |= data[dp++];
 	}
check_length:
	if (len > datalen - dp)
		goto data_overrun_error;
 	dp += len;
 	goto next_tag;
 ",Integer overflow in lib/asn1_decoder.c in the Linux kernel before 4.6 allows local users to gain privileges via crafted ASN.1 data.
748,CVE-2016-0728,"  long join_session_keyring(const char *name)
 		ret = PTR_ERR(keyring);
 		goto error2;
 	} else if (keyring == new->session_keyring) {
		key_put(keyring);
 		ret = 0;
 		goto error2;
 	}","The join_session_keyring function in security/keys/process_keys.c in the Linux kernel before 4.4.1 mishandles object references in a certain error case, which allows local users to gain privileges or cause a denial of service (integer overflow and use-after-free) via crafted keyctl commands."
749,CVE-2016-0723,"  static int tiocsetd(struct tty_struct *tty, int __user *p)
 	return ret;
 }
 
 

static int tiocgetd(struct tty_struct *tty, int __user *p)
{
	struct tty_ldisc *ld;
	int ret;

	ld = tty_ldisc_ref_wait(tty);
	ret = put_user(ld->ops->num, p);
	tty_ldisc_deref(ld);
	return ret;
}

 /**
  *	send_break	-	performed time break
  *	@tty: device to break on
  long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case TIOCGSID:
 		return tiocgsid(tty, real_tty, p);
 	case TIOCGETD:
		return tiocgetd(tty, p);
 	case TIOCSETD:
 		return tiocsetd(tty, p);
 	case TIOCVHANGUP:",Race condition in the tty_ioctl function in drivers/tty/tty_io.c in the Linux kernel through 4.4.1 allows local users to obtain sensitive information from kernel memory or cause a denial of service (use-after-free and system crash) by making a TIOCGETD ioctl call during processing of a TIOCSETD ioctl call.
750,CVE-2016-0546," 
  
     else
     {
      if (strlen(argv[i]) + 4 + 1 > FN_REFLEN)
      {
        fprintf(stderr, ""ERROR: argument is too long.\n"");
        return 1;
      }
       strcpy(plugin_name, argv[i]);
       strcpy(config_file, argv[i]);
       strcat(config_file, "".ini"");
  static int process_options(int argc, char *argv[], char *operation)
     if (opt_basedir[i-1] != FN_LIBCHAR || opt_basedir[i-1] != FN_LIBCHAR2)
     {
       char buff[FN_REFLEN];
      memset(buff, 0, sizeof(buff));
       
       strncpy(buff, opt_basedir, sizeof(buff) - 1);
 #ifdef __WIN__","Unspecified vulnerability in Oracle MySQL 5.5.46 and earlier, 5.6.27 and earlier, and 5.7.9 and MariaDB before 5.5.47, 10.0.x before 10.0.23, and 10.1.x before 10.1.10 allows local users to affect confidentiality, integrity, and availability via unknown vectors related to Client.  NOTE: the previous information is from the January 2016 CPU. Oracle has not commented on third-party claims that these are multiple buffer overflows in the mysqlshow tool that allow remote database servers to have unspecified impact via a long table or database name."
751,CVE-2015-8970,"  struct skcipher_sg_list {
 	struct scatterlist sg[0];
 };
 
struct skcipher_tfm {
	struct crypto_skcipher *skcipher;
	bool has_key;
};

 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
  static struct proto_ops algif_skcipher_ops = {
 
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
	struct skcipher_tfm *tfm;
	struct crypto_skcipher *skcipher;

	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
	if (!tfm)
		return ERR_PTR(-ENOMEM);

	skcipher = crypto_alloc_skcipher(name, type, mask);
	if (IS_ERR(skcipher)) {
		kfree(tfm);
		return ERR_CAST(skcipher);
	}

	tfm->skcipher = skcipher;

	return tfm;
 }
 
 static void skcipher_release(void *private)
 {
	struct skcipher_tfm *tfm = private;

	crypto_free_skcipher(tfm->skcipher);
	kfree(tfm);
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
	struct skcipher_tfm *tfm = private;
	int err;

	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
	tfm->has_key = !err;

	return err;
 }
 
 static void skcipher_wait(struct sock *sk)
  static int skcipher_accept_parent(void *private, struct sock *sk)
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
	struct skcipher_tfm *tfm = private;
	struct crypto_skcipher *skcipher = tfm->skcipher;
	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);

	if (!tfm->has_key)
		return -ENOKEY;
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
 			       GFP_KERNEL);
 	if (!ctx->iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
 
 	INIT_LIST_HEAD(&ctx->tsgl);
 	ctx->len = len;
  static int skcipher_accept_parent(void *private, struct sock *sk)
 
 	ask->private = ctx;
 
	skcipher_request_set_tfm(&ctx->req, skcipher);
 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				      af_alg_complete, &ctx->completion);
 ","crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c."
752,CVE-2015-8967,"  asmlinkage long sys_rt_sigreturn_wrapper(void);
  * The sys_call_table array must be 4K aligned to be accessible from
  * kernel/entry.S.
  */
void * const sys_call_table[__NR_syscalls] __aligned(4096) = {
 	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
 #include <asm/unistd.h>
 };","arch/arm64/kernel/sys.c in the Linux kernel before 4.0 allows local users to bypass the *strict page permissions* protection mechanism and modify the system-call table, and consequently gain privileges, by leveraging write access."
753,CVE-2015-8966,"  struct oabi_flock64 {
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct flock64 kernel;
	struct oabi_flock64 user;
	mm_segment_t fs;
	long ret;

	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
			   sizeof(user)))
		return -EFAULT;
	kernel.l_type	= user.l_type;
	kernel.l_whence	= user.l_whence;
	kernel.l_start	= user.l_start;
	kernel.l_len	= user.l_len;
	kernel.l_pid	= user.l_pid;

	fs = get_fs();
	set_fs(KERNEL_DS);
	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
	set_fs(fs);

	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
		user.l_type	= kernel.l_type;
		user.l_whence	= kernel.l_whence;
		user.l_start	= kernel.l_start;
		user.l_len	= kernel.l_len;
		user.l_pid	= kernel.l_pid;
		if (copy_to_user((struct oabi_flock64 __user *)arg,
				 &user, sizeof(user)))
			ret = -EFAULT;
	}
	return ret;
}
 
asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
				 unsigned long arg)
{
 	switch (cmd) {
 	case F_OFD_GETLK:
 	case F_OFD_SETLK:
 	case F_OFD_SETLKW:
 	case F_GETLK64:
 	case F_SETLK64:
 	case F_SETLKW64:
		return do_locks(fd, cmd, arg);
 
	default:
		return sys_fcntl64(fd, cmd, arg);
 	}
 }
 
 struct oabi_epoll_event {","arch/arm/kernel/sys_oabi-compat.c in the Linux kernel before 4.4 allows local users to gain privileges via a crafted (1) F_OFD_GETLK, (2) F_OFD_SETLK, or (3) F_OFD_SETLKW command in an fcntl64 system call."
754,CVE-2015-8964,"  EXPORT_SYMBOL_GPL(tty_ldisc_flush);
  *	they are not on hot paths so a little discipline won't do
  *	any harm.
  *
 *	The line discipline-related tty_struct fields are reset to
 *	prevent the ldisc driver from re-using stale information for
 *	the new ldisc instance.
 *
  *	Locking: takes termios_rwsem
  */
 
  static void tty_set_termios_ldisc(struct tty_struct *tty, int num)
 	down_write(&tty->termios_rwsem);
 	tty->termios.c_line = num;
 	up_write(&tty->termios_rwsem);

	tty->disc_data = NULL;
	tty->receive_room = 0;
 }
 
 /**",The tty_set_termios_ldisc function in drivers/tty/tty_ldisc.c in the Linux kernel before 4.5 allows local users to obtain sensitive information from kernel memory by reading a tty data structure.
755,CVE-2015-8963,"  struct swevent_htable {
 
 	 
 	int				recursion[PERF_NR_CONTEXTS];
 };
 
 static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);
  static int perf_swevent_add(struct perf_event *event, int flags)
 	hwc->state = !(flags & PERF_EF_START);
 
 	head = find_swevent_head(swhash, event);
	if (WARN_ON_ONCE(!head))
 		return -EINVAL;
 
 	hlist_add_head_rcu(&event->hlist_entry, head);
 	perf_event_update_userpage(event);
  static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)
 	int err = 0;
 
 	mutex_lock(&swhash->hlist_mutex);
 	if (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {
 		struct swevent_hlist *hlist;
 
  static void perf_event_init_cpu(int cpu)
 	struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);
 
 	mutex_lock(&swhash->hlist_mutex);
 	if (swhash->hlist_refcount > 0) {
 		struct swevent_hlist *hlist;
 
  static void perf_event_exit_cpu_context(int cpu)
 
 static void perf_event_exit_cpu(int cpu)
 {
 	perf_event_exit_cpu_context(cpu);
 }
 #else
 static inline void perf_event_exit_cpu(int cpu) { }",Race condition in kernel/events/core.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect handling of an swevent data structure during a CPU unplug operation.
756,CVE-2015-8962,"  sg_common_write(Sg_fd * sfp, Sg_request * srp,
 		return k;	 
 	}
 	if (atomic_read(&sdp->detaching)) {
		if (srp->bio) {
			if (srp->rq->cmd != srp->rq->__cmd)
				kfree(srp->rq->cmd);

 			blk_end_request_all(srp->rq, -EIO);
			srp->rq = NULL;
		}

 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}",Double free vulnerability in the sg_common_write function in drivers/scsi/sg.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (memory corruption and system crash) by detaching a device during an SG_IO ioctl call.
757,CVE-2015-8961,"  int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)
 		return 0;
 	}
 
	err = handle->h_err;
 	if (!handle->h_transaction) {
		rc = jbd2_journal_stop(handle);
		return err ? err : rc;
 	}
 
 	sb = handle->h_transaction->t_journal->j_private;
 	rc = jbd2_journal_stop(handle);
 
 	if (!err)",The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field.
758,CVE-2015-8956,"  static int rfcomm_sock_create(struct net *net, struct socket *sock,
 
 static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
	struct sockaddr_rc sa;
 	struct sock *sk = sock->sk;
	int len, err = 0;
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
	memset(&sa, 0, sizeof(sa));
	len = min_t(unsigned int, sizeof(sa), addr_len);
	memcpy(&sa, addr, len);

	BT_DBG(""sk %p %pMR"", sk, &sa.rc_bdaddr);

 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
  static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr
 
 	write_lock(&rfcomm_sk_list.lock);
 
	if (sa.rc_channel &&
	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		 
		bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
		rfcomm_pi(sk)->channel = sa.rc_channel;
 		sk->sk_state = BT_BOUND;
 	}
 ",The rfcomm_sock_bind function in net/bluetooth/rfcomm/sock.c in the Linux kernel before 4.2 allows local users to obtain sensitive information or cause a denial of service (NULL pointer dereference) via vectors involving a bind system call on a Bluetooth RFCOMM socket.
759,CVE-2015-8955,"  armpmu_add(struct perf_event *event, int flags)
 }
 
 static int
validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,
				struct perf_event *event)
 {
	struct arm_pmu *armpmu;
 	struct hw_perf_event fake_event = event->hw;
 	struct pmu *leader_pmu = event->group_leader->pmu;
 
 	if (is_software_event(event))
 		return 1;
 
	 
	if (event->pmu != pmu)
		return 0;

 	if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)
 		return 1;
 
 	if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)
 		return 1;
 
	armpmu = to_arm_pmu(event->pmu);
 	return armpmu->get_event_idx(hw_events, &fake_event) >= 0;
 }
 
  validate_group(struct perf_event *event)
 	memset(fake_used_mask, 0, sizeof(fake_used_mask));
 	fake_pmu.used_mask = fake_used_mask;
 
	if (!validate_event(event->pmu, &fake_pmu, leader))
 		return -EINVAL;
 
 	list_for_each_entry(sibling, &leader->sibling_list, group_entry) {
		if (!validate_event(event->pmu, &fake_pmu, sibling))
 			return -EINVAL;
 	}
 
	if (!validate_event(event->pmu, &fake_pmu, event))
 		return -EINVAL;
 
 	return 0;",arch/arm64/kernel/perf_event.c in the Linux kernel before 4.1 on arm64 platforms allows local users to gain privileges or cause a denial of service (invalid pointer dereference) via vectors involving events that are mishandled during a span of multiple HW PMUs.
760,CVE-2015-8953,"  static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,
 
 out_cleanup:
 	ovl_cleanup(wdir, newdentry);
	goto out2;
 }
 
 /*","fs/overlayfs/copy_up.c in the Linux kernel before 4.2.6 uses an incorrect cleanup code path, which allows local users to cause a denial of service (dentry reference leak) via filesystem operations on a large file in a lower overlayfs layer."
761,CVE-2015-8950,"  static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
		memset(ptr, 0, size);
 	}
 
 	return ptr;
  static void *__dma_alloc_coherent(struct device *dev, size_t size,
 
 		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 		addr = page_address(page);
		memset(addr, 0, size);
 		return addr;
 	} else {
 		return swiotlb_alloc_coherent(dev, size, dma_handle, flags);","arch/arm64/mm/dma-mapping.c in the Linux kernel before 4.0.3, as used in the ION subsystem in Android and other products, does not initialize certain data structures, which allows local users to obtain sensitive information from kernel memory by triggering a dma_mmap call."
762,CVE-2015-8877,"  gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,
     } 
 
     if (src != tmp_im) {
        gdImageDestroy(tmp_im);
     } 
 
 	return dst;","The gdImageScaleTwoPass function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in PHP before 5.6.12, uses inconsistent allocate and free approaches, which allows remote attackers to cause a denial of service (memory consumption) via a crafted call, as demonstrated by a call to the PHP imagescale function."
763,CVE-2015-8872,"  void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)
 	    data[1] = new >> 4;
 	} else {
 	    FAT_ENTRY subseqEntry;
	    if (cluster != fs->clusters + 1)
 		get_fat(&subseqEntry, fs->fat, cluster + 1, fs);
 	    else
 		subseqEntry.value = 0;","The set_fat function in fat.c in dosfstools before 4.0 might allow attackers to corrupt a FAT12 filesystem or cause a denial of service (invalid memory read and crash) by writing an odd number of clusters to the third to last entry on a FAT12 filesystem, which triggers an *off-by-two error.*"
764,CVE-2015-8871,"  static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,
         assert(p_stream != 00);
 
         l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);
	
         l_mco_size = 5 + l_tcp->m_nb_mcc_records;
         if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
 
  static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,
                 p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
                 p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
         }
        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;

 
         opj_write_bytes(l_current_data,J2K_MS_MCO,2);                    
         l_current_data += 2;
  static OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,
         ++l_current_data;
 
         l_mcc_record = l_tcp->m_mcc_records;
        for (i=0;i<l_tcp->m_nb_mcc_records;++i) {
                 opj_write_bytes(l_current_data,l_mcc_record->m_index,1); 
                 ++l_current_data;
                 ++l_mcc_record;
         }
 ",Use-after-free vulnerability in the opj_j2k_write_mco function in j2k.c in OpenJPEG before 2.1.1 allows remote attackers to have unspecified impact via unknown vectors.
765,CVE-2015-8865," 
 #include ""file.h""
 
 #ifndef	lint
FILE_RCSID(""@(#)$File: funcs.c,v 1.81 2015/05/28 19:26:59 christos Exp $"")
 #endif	 
 
 #include ""magic.h""
  file_check_mem(struct magic_set *ms, unsigned int level)
 	size_t len;
 
 	if (level >= ms->c.len) {
		len = (ms->c.len = 20 + level) * sizeof(*ms->c.li);
 		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
 		    malloc(len) :
 		    realloc(ms->c.li, len));","The file_check_mem function in funcs.c in file before 5.23, as used in the Fileinfo component in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5, mishandles continuation-level jumps, which allows context-dependent attackers to cause a denial of service (buffer overflow and application crash) or possibly execute arbitrary code via a crafted magic file."
766,CVE-2015-8863,"  static pfunc stream_token(struct jv_parser* p, char ch) {
 
 static void tokenadd(struct jv_parser* p, char c) {
   assert(p->tokenpos <= p->tokenlen);
  if (p->tokenpos >= (p->tokenlen - 1)) {
     p->tokenlen = p->tokenlen*2 + 256;
     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);
   }
  static pfunc check_literal(struct jv_parser* p) {
     TRY(value(p, v));
   } else {
      
    p->tokenbuf[p->tokenpos] = 0;
     char* end = 0;
     double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);
     if (end == 0 || *end != 0)","Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow."
767,CVE-2015-8852,"  http_splitline(struct worker *w, int fd, struct http *hp,
  
 
 static int
htc_request_check_hdrs(struct sess *sp, struct http *hp)
 {
 	int u;
 	int seen_host = 0;
	int seen_cl = 0;

 	for (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {
 		if (hp->hd[u].b == NULL)
 			continue;
 		AN(hp->hd[u].b);
 		AN(hp->hd[u].e);
 		if (http_IsHdr(&hp->hd[u], H_Host)) {
 			if (seen_host) {
				WSP(sp, SLT_Error, ""Duplicated Host header"");
 				return (400);
 			}
 			seen_host = 1;
 		}
		if (http_IsHdr(&hp->hd[u], H_Content_Length)) {
			if (seen_cl) {
				WSP(sp, SLT_Error,
				    ""Duplicated Content-Length header"");
				return (400);
			}
			seen_cl = 1;
		}
 	}
 	return (0);
 }
  http_DissectRequest(struct sess *sp)
 	}
 	http_ProtoVer(hp);
 
	retval = htc_request_check_hdrs(sp, hp);
 	return (retval);
 }
 ","Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request."
768,CVE-2015-8845,"  static void tm_reclaim_thread(struct thread_struct *thr,
 		msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
	 
	if (!MSR_TM_SUSPENDED(mfmsr()))
		return;

 	tm_reclaim(thr, thr->regs->msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed","The tm_reclaim_thread function in arch/powerpc/kernel/process.c in the Linux kernel before 4.4.1 on powerpc platforms does not ensure that TM suspend mode exists before proceeding with a tm_reclaim call, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application."
769,CVE-2015-8844," 
 #define MSR_TS_T	__MASK(MSR_TS_T_LG)	 
 #define MSR_TS_MASK	(MSR_TS_T | MSR_TS_S)    
 #define MSR_TM_ACTIVE(x) (((x) & MSR_TS_MASK) != 0)  
#define MSR_TM_RESV(x) (((x) & MSR_TS_MASK) == MSR_TS_MASK)  
 #define MSR_TM_TRANSACTIONAL(x)	(((x) & MSR_TS_MASK) == MSR_TS_T)
 #define MSR_TM_SUSPENDED(x)	(((x) & MSR_TS_MASK) == MSR_TS_S)
 ","The signal implementation in the Linux kernel before 4.3.5 on powerpc platforms does not check for an MSR with both the S and T bits set, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application."
770,CVE-2015-8839,"  struct ext4_inode_info {
 	 * by other means, so we have i_data_sem.
 	 */
 	struct rw_semaphore i_data_sem;
	 
	struct rw_semaphore i_mmap_sem;
 	struct inode vfs_inode;
 	struct jbd2_inode *jinode;
 
  extern int ext4_chunk_trans_blocks(struct inode *, int nrblocks);
 extern int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,
 			     loff_t lstart, loff_t lend);
 extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);
extern int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
 extern qsize_t *ext4_get_reserved_space(struct inode *inode);
 extern void ext4_da_update_reserve_space(struct inode *inode,
 					int used, int quota_claim);",Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.
771,CVE-2015-8830,"  static ssize_t aio_setup_single_vector(struct kiocb *kiocb,
 				       unsigned long *nr_segs,
 				       struct iovec *iovec)
 {
	size_t len = kiocb->ki_nbytes;

	if (len > MAX_RW_COUNT)
		len = MAX_RW_COUNT;

	if (unlikely(!access_ok(!rw, buf, len)))
 		return -EFAULT;
 
 	iovec->iov_base = buf;
	iovec->iov_len = len;
 	*nr_segs = 1;
 	return 0;
 }",Integer overflow in the aio_setup_single_vector function in fs/aio.c in the Linux kernel 4.0 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.  NOTE: this vulnerability exists because of a CVE-2012-6701 regression.
772,CVE-2015-8816,"  static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	unsigned delay;
 
 	 
	if (type == HUB_INIT2 || type == HUB_INIT3) {
		device_lock(hub->intfdev);

		 
		if (hub->disconnected) {
			device_unlock(hub->intfdev);
			kref_put(&hub->kref, hub_release);
			return;
		}
		if (type == HUB_INIT2)
			goto init2;
 		goto init3;
	}
	kref_get(&hub->kref);
 
 	 
 		} else {
 			msleep(delay);
  static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	 
 	if (type <= HUB_INIT3)
 		usb_autopm_put_interface_async(to_usb_interface(hub->intfdev));

	if (type == HUB_INIT2 || type == HUB_INIT3)
		device_unlock(hub->intfdev);

	kref_put(&hub->kref, hub_release);
 }
 
  ","The hub_activate function in drivers/usb/core/hub.c in the Linux kernel before 4.3.5 does not properly maintain a hub-interface data structure, which allows physically proximate attackers to cause a denial of service (invalid memory access and system crash) or possibly have unspecified other impact by unplugging a USB hub device."
773,CVE-2015-8812,"  static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_en
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error < 0 ? error : 0;
 }
 
 int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
  int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
 	error = cxgb3_ofld_send(tdev, skb);
 	if (error < 0)
 		kfree_skb(skb);
	return error < 0 ? error : 0;
 }
 
 static void release_tid(struct t3cdev *tdev, u32 hwtid, struct sk_buff *skb)","drivers/infiniband/hw/cxgb3/iwch_cm.c in the Linux kernel before 4.5 does not properly identify error conditions, which allows remote attackers to execute arbitrary code or cause a denial of service (use-after-free) via crafted packets."
774,CVE-2015-8787,"  nf_nat_redirect_ipv4(struct sk_buff *skb,
 
 		rcu_read_lock();
 		indev = __in_dev_get_rcu(skb->dev);
		if (indev && indev->ifa_list) {
 			ifa = indev->ifa_list;
 			newdst = ifa->ifa_local;
 		}","The nf_nat_redirect_ipv4 function in net/netfilter/nf_nat_redirect.c in the Linux kernel before 4.4 allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by sending certain IPv4 packets to an incompletely configured interface, a related issue to CVE-2003-1604."
775,CVE-2015-8785,"  static ssize_t fuse_fill_write_pages(struct fuse_req *req,
 		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
 		flush_dcache_page(page);
 
		iov_iter_advance(ii, tmp);
 		if (!tmp) {
 			unlock_page(page);
 			page_cache_release(page);
  static ssize_t fuse_fill_write_pages(struct fuse_req *req,
 		req->page_descs[req->num_pages].length = tmp;
 		req->num_pages++;
 
 		count += tmp;
 		pos += tmp;
 		offset += tmp;",The fuse_fill_write_pages function in fs/fuse/file.c in the Linux kernel before 4.4 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers a zero length for the first segment of an iov.
776,CVE-2015-8767,"  void sctp_generate_t3_rtx_event(unsigned long peer)
 	int error;
 	struct sctp_transport *transport = (struct sctp_transport *) peer;
 	struct sctp_association *asoc = transport->asoc;
	struct sock *sk = asoc->base.sk;
	struct net *net = sock_net(sk);
 
 	 
 
	bh_lock_sock(sk);
	if (sock_owned_by_user(sk)) {
 		pr_debug(""%s: sock is busy\n"", __func__);
 
 		 
  void sctp_generate_t3_rtx_event(unsigned long peer)
 			   transport, GFP_ATOMIC);
 
 	if (error)
		sk->sk_err = -error;
 
 out_unlock:
	bh_unlock_sock(sk);
 	sctp_transport_put(transport);
 }
 
  void sctp_generate_t3_rtx_event(unsigned long peer)
 static void sctp_generate_timeout_event(struct sctp_association *asoc,
 					sctp_event_timeout_t timeout_type)
 {
	struct sock *sk = asoc->base.sk;
	struct net *net = sock_net(sk);
 	int error = 0;
 
	bh_lock_sock(sk);
	if (sock_owned_by_user(sk)) {
 		pr_debug(""%s: sock is busy: timer %d\n"", __func__,
 			 timeout_type);
 
  static void sctp_generate_timeout_event(struct sctp_association *asoc,
 			   (void *)timeout_type, GFP_ATOMIC);
 
 	if (error)
		sk->sk_err = -error;
 
 out_unlock:
	bh_unlock_sock(sk);
 	sctp_association_put(asoc);
 }
 
  void sctp_generate_heartbeat_event(unsigned long data)
 	int error = 0;
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport->asoc;
	struct sock *sk = asoc->base.sk;
	struct net *net = sock_net(sk);
 
	bh_lock_sock(sk);
	if (sock_owned_by_user(sk)) {
 		pr_debug(""%s: sock is busy\n"", __func__);
 
 		 
  void sctp_generate_heartbeat_event(unsigned long data)
 			   transport, GFP_ATOMIC);
 
 	if (error)
		sk->sk_err = -error;
 
 out_unlock:
	bh_unlock_sock(sk);
 	sctp_transport_put(transport);
 }
 
  void sctp_generate_proto_unreach_event(unsigned long data)
 {
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport->asoc;
	struct sock *sk = asoc->base.sk;
	struct net *net = sock_net(sk);
 
	bh_lock_sock(sk);
	if (sock_owned_by_user(sk)) {
 		pr_debug(""%s: sock is busy\n"", __func__);
 
 		 
  void sctp_generate_proto_unreach_event(unsigned long data)
 		   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);
 
 out_unlock:
	bh_unlock_sock(sk);
 	sctp_association_put(asoc);
 }
 ","net/sctp/sm_sideeffect.c in the Linux kernel before 4.3 does not properly manage the relationship between a lock and a socket, which allows local users to cause a denial of service (deadlock) via a crafted sctp_accept call."
777,CVE-2015-8746,"  static const struct nfs4_minor_version_ops nfs_v4_2_minor_ops = {
 	.reboot_recovery_ops = &nfs41_reboot_recovery_ops,
 	.nograce_recovery_ops = &nfs41_nograce_recovery_ops,
 	.state_renewal_ops = &nfs41_state_renewal_ops,
	.mig_recovery_ops = &nfs41_mig_recovery_ops,
 };
 #endif
 ","fs/nfs/nfs4proc.c in the NFS client in the Linux kernel before 4.2.2 does not properly initialize memory for migration recovery operations, which allows remote NFS servers to cause a denial of service (NULL pointer dereference and panic) via crafted network traffic."
778,CVE-2015-8702,"  DNSResult DNS::GetResult()
 				 
 
 			case DNS_QUERY_PTR:
			{
 				 
 				resultstr = std::string((const char*)data.first);
				if (resultstr.find_first_not_of(""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-"") != std::string::npos)
				{
					std::string ro = req->orig;
					delete req;
					return DNSResult(this_id | ERROR_MASK, ""Invalid char(s) in reply"", 0, ro);
				}
			}
 			break;
 
 			default:","The DNS::GetResult function in dns.cpp in InspIRCd before 2.0.19 allows remote DNS servers to cause a denial of service (netsplit) via an invalid character in a PTR response, as demonstrated by a *032* (whitespace) character in a hostname."
779,CVE-2015-8631,"  create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret          ret;
     char                        *prime_arg;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
     restriction_t               *rp;
  create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
 
 exit_func:
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret          ret;
     char                        *prime_arg;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
     restriction_t               *rp;
  create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
 
 exit_func:
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)
 
     }
     free(prime_arg);
 
 exit_func:
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     restriction_t                   *rp;
  modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  generic_ret *
 rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret          ret;
    char                        *prime_arg1 = NULL, *prime_arg2 = NULL;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
     restriction_t               *rp;
  rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
 
     }
exit_func:
     free(prime_arg1);
     free(prime_arg2);
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)
 {
     static gprinc_ret               ret;
     char                            *prime_arg, *funcname;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)
 {
     static gprincs_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
 
     }
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)
     }
 
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)
     }
 
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)
     }
 
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)
     }
 
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)
     }
 
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)
     krb5_keyblock               *k;
     int                         nkeys;
     char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
  chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)
     krb5_keyblock               *k;
     int                         nkeys;
     char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
  chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)
         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
     }
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)
         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
     }
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)
         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
     }
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)
     static gpol_ret             ret;
     kadm5_ret_t         ret2;
     char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_principal_ent_rec     caller_ent;
     kadm5_server_handle_t       handle;
  get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)
         log_unauth(funcname, prime_arg,
                    &client_name, &service_name, rqstp);
     }
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 
  get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)
 {
     static gpols_ret                ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)
         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
     }
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
 
 getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
 {
     static getprivs_ret            ret;
    gss_buffer_desc                client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                      minor_stat;
     kadm5_server_handle_t          handle;
     const char                     *errmsg = NULL;
  getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
     if (errmsg != NULL)
         krb5_free_error_message(handle->context, errmsg);
 
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret          ret;
     char                        *prime_arg, *funcname;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
 
  purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)
 {
     static gstrings_ret             ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
  set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret              ret;
     char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                       minor_stat;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
  set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)
             krb5_free_error_message(handle->context, errmsg);
     }
     free(prime_arg);
exit_func:
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
 
 generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
 {
     static generic_ret         ret;
    gss_buffer_desc            client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc            service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t      handle;
     OM_uint32                  minor_stat;
     const char                 *errmsg = NULL;
  generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
                      rqstp->rq_cred.oa_flavor);
     if (errmsg != NULL)
         krb5_free_error_message(NULL, errmsg);
 
 exit_func:
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
     return(&ret);
 }
 ",Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.
780,CVE-2015-8630,"  kadm5_create_principal_3(void *server_handle,
      
    if (entry == NULL)
        return EINVAL;
     if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||
        (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||
        (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||
  kadm5_create_principal_3(void *server_handle,
         return KADM5_BAD_MASK;
     if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)
         return KADM5_BAD_MASK;
    if((mask & KADM5_POLICY) && entry->policy == NULL)
        return KADM5_BAD_MASK;
     if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))
         return KADM5_BAD_MASK;
     if((mask & ~ALL_PRINC_MASK))
         return KADM5_BAD_MASK;
 
     /*
      * Check to see if the principal exists
  kadm5_modify_principal(void *server_handle,
 
     krb5_clear_error_message(handle->context);
 
    if(entry == NULL)
        return EINVAL;
     if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||
        (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||
        (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||
  kadm5_modify_principal(void *server_handle,
         return KADM5_BAD_MASK;
     if((mask & ~ALL_PRINC_MASK))
         return KADM5_BAD_MASK;
    if((mask & KADM5_POLICY) && entry->policy == NULL)
        return KADM5_BAD_MASK;
     if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))
         return KADM5_BAD_MASK;
     if (mask & KADM5_TL_DATA) {
         tl_data_orig = entry->tl_data;
         while (tl_data_orig) {",The (1) kadm5_create_principal_3 and (2) kadm5_modify_principal functions in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) by specifying KADM5_POLICY with a NULL policy name.
781,CVE-2015-8629,"  bool_t xdr_nullstring(XDR *xdrs, char **objp)
 		    return FALSE;
 	       }
 	  }
	  if (!xdr_opaque(xdrs, *objp, size))
		  return FALSE;
	   
	  if ((*objp)[size - 1] != '\0')
		  return FALSE;
	  if (memchr(*objp, '\0', size - 1) != NULL)
		  return FALSE;
	  return TRUE;
 
      case XDR_ENCODE:
 	  if (size != 0)","The xdr_nullstring function in lib/kadm5/kadm_rpc_xdr.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 does not verify whether '0' characters exist as expected, which allows remote authenticated users to obtain sensitive information or cause a denial of service (out-of-bounds read) via a crafted string."
782,CVE-2015-8617,"  static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce,
 	zend_vspprintf(&message, 0, format, va);
 
 	if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {
		zend_throw_error(exception_ce, ""%s"", message);
 	} else {
 		zend_error(E_ERROR, ""%s"", message);
 	}","Format string vulnerability in the zend_throw_or_error function in Zend/zend_execute_API.c in PHP 7.x before 7.0.1 allows remote attackers to execute arbitrary code via format string specifiers in a string that is misused as a class name, leading to incorrect error handling."
783,CVE-2015-8575,"  static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
	if (addr_len < sizeof(struct sockaddr_sco))
		return -EINVAL;

 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {","The sco_sock_bind function in net/bluetooth/sco.c in the Linux kernel before 4.3.4 does not verify an address length, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism via a crafted application."
784,CVE-2015-8547,"  void CoreUserInputHandler::doMode(const BufferInfo &bufferInfo, const QChar& add
     if (!isNumber || maxModes == 0) maxModes = 1;
 
     QStringList nickList;
    if (nicks == ""*"" && bufferInfo.type() == BufferInfo::ChannelBuffer) {  
         const QList<IrcUser*> users = network()->ircChannel(bufferInfo.bufferName())->ircUsers();
         foreach(IrcUser *user, users) {
             if ((addOrRemove == '+' && !network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode))",The CoreUserInputHandler::doMode function in core/coreuserinputhandler.cpp in Quassel 0.10.0 allows remote attackers to cause a denial of service (application crash) via the */op ** command in a query.
785,CVE-2015-8539,"  static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 ","The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c."
786,CVE-2015-8324,"  typedef struct ext4_io_end {
 	struct list_head	list;		 
 	struct inode		*inode;		 
 	unsigned int		flag;		 
	struct page		*page;		 
 	loff_t			offset;		 
 	ssize_t			size;		 
 	struct work_struct	work;		 
  struct ext4_new_group_data {
 					 EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)
 	 
 #define EXT4_GET_BLOCKS_IO_CONVERT_EXT		(EXT4_GET_BLOCKS_CONVERT|\
					 EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)
 
  
 	struct list_head i_completed_io_list;
	spinlock_t i_completed_io_lock;
 	 
 	ext4_io_end_t *cur_aio_dio;
 
  struct ext4_inode_info {
 #define EXT4_MOUNT_QUOTA		0x80000  
 #define EXT4_MOUNT_USRQUOTA		0x100000  
 #define EXT4_MOUNT_GRPQUOTA		0x200000  
#define EXT4_MOUNT_DIOREAD_NOLOCK	0x400000  
 #define EXT4_MOUNT_JOURNAL_CHECKSUM	0x800000  
 #define EXT4_MOUNT_JOURNAL_ASYNC_COMMIT	0x1000000  
 #define EXT4_MOUNT_I_VERSION            0x2000000  
  extern int ext4_move_extents(struct file *o_filp, struct file *d_filp,
 			     __u64 len, __u64 *moved_len);
 
 
 
enum ext4_state_bits {
	BH_Uninit	 
	  = BH_JBDPrivateStart,
};

BUFFER_FNS(Uninit, uninit)
TAS_BUFFER_FNS(Uninit, uninit)

 /*
  * Add new method to test wether block and inode bitmaps are properly
  * initialized. With uninit_bg reading the block from disk is not enough","The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function."
787,CVE-2015-7566,"  static int clie_5_attach(struct usb_serial *serial)
 	 */
 
 	 
	if (serial->num_bulk_out < 2) {
		dev_err(&serial->interface->dev, ""missing bulk out endpoints\n"");
		return -ENODEV;
	}
 
 	 
 	port = serial->port[0];",The clie_5_attach function in drivers/usb/serial/visor.c in the Linux kernel through 4.4.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by inserting a USB device that lacks a bulk-out endpoint.
788,CVE-2015-7550,"  long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	 
 can_read_key:
	ret = -EOPNOTSUPP;
	if (key->type->read) {
		 
		down_read(&key->sem);
		ret = key_validate(key);
		if (ret == 0)
 			ret = key->type->read(key, buffer, buflen);
		up_read(&key->sem);
 	}
 
 error2:","The keyctl_read_key function in security/keys/keyctl.c in the Linux kernel before 4.3.4 does not properly use a semaphore, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted application that leverages a race condition between keyctl_revoke and keyctl_read calls."
789,CVE-2015-7515,"  aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	input_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0);
 	input_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0);
 
	 
	if (intf->altsetting[0].desc.bNumEndpoints < 1) {
		dev_err(&intf->dev,
			""interface has %d endpoints, but must have minimum 1\n"",
			intf->altsetting[0].desc.bNumEndpoints);
		err = -EINVAL;
		goto fail3;
	}
 	endpoint = &intf->altsetting[0].endpoint[0].desc;
 
 	/* Go set up our URB, which is called when the tablet receives
  aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	if (i == ARRAY_SIZE(speeds)) {
 		dev_info(&intf->dev,
 			 ""Aiptek tried all speeds, no sane response\n"");
		err = -EINVAL;
 		goto fail3;
 	}
 ",The aiptek_probe function in drivers/input/tablet/aiptek.c in the Linux kernel before 4.4 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted USB device that lacks endpoints.
790,CVE-2015-7513,"  static int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 
 static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)
 {
	int i;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	memcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));
	for (i = 0; i < 3; i++)
		kvm_pit_load_count(kvm, i, ps->channels[i].count, 0);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
  static int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
	int i;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
  static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
	for (i = 0; i < 3; i++)
		kvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }","arch/x86/kvm/x86.c in the Linux kernel before 4.4 does not reset the PIT counter values during state restoration, which allows guest OS users to cause a denial of service (divide-by-zero error and host OS crash) via a zero value, related to the kvm_vm_ioctl_set_pit and kvm_vm_ioctl_set_pit2 functions."
791,CVE-2015-4178,"  static DEFINE_SPINLOCK(pin_lock);
 void pin_remove(struct fs_pin *pin)
 {
 	spin_lock(&pin_lock);
	hlist_del_init(&pin->m_list);
	hlist_del_init(&pin->s_list);
 	spin_unlock(&pin_lock);
 	spin_lock_irq(&pin->wait.lock);
 	pin->done = 1;","The fs_pin implementation in the Linux kernel before 4.0.5 does not ensure the internal consistency of a certain list data structure, which allows local users to cause a denial of service (system crash) by leveraging user-namespace root access for an MNT_DETACH umount2 system call, related to fs/fs_pin.c and include/linux/fs_pin.h."
792,CVE-2015-4177,"  struct vfsmount *collect_mounts(struct path *path)
 {
 	struct mount *tree;
 	namespace_lock();
	if (!check_mnt(real_mount(path->mnt)))
		tree = ERR_PTR(-EINVAL);
	else
		tree = copy_tree(real_mount(path->mnt), path->dentry,
				 CL_COPY_ALL | CL_PRIVATE);
 	namespace_unlock();
 	if (IS_ERR(tree))
 		return ERR_CAST(tree);","The collect_mounts function in fs/namespace.c in the Linux kernel before 4.0.5 does not properly consider that it may execute after a path has been unmounted, which allows local users to cause a denial of service (system crash) by leveraging user-namespace root access for an MNT_DETACH umount2 system call."
793,CVE-2015-4176,"  static inline void namespace_lock(void)
 enum umount_tree_flags {
 	UMOUNT_SYNC = 1,
 	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
 };
 /*
  * mount_lock must be held
  static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 
		disconnect = !(((how & UMOUNT_CONNECTED) &&
				mnt_has_parent(p) &&
				(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||
			       IS_MNT_LOCKED_AND_LAZY(p));
 
 		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
 				 disconnect ? &unmounted : NULL);
  void __detach_mounts(struct dentry *dentry)
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, UMOUNT_CONNECTED);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);","fs/namespace.c in the Linux kernel before 4.0.2 does not properly support mount connectivity, which allows local users to read arbitrary files by leveraging user-namespace root access for deletion of a file or directory."
794,CVE-2015-4170,"  static inline long ldsem_atomic_update(long delta, struct ld_semaphore *sem)
 	return atomic_long_add_return(delta, (atomic_long_t *)&sem->count);
 }
 
 
 static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
 {
	long tmp = atomic_long_cmpxchg(&sem->count, *old, new);
	if (tmp == *old) {
		*old = new;
		return 1;
	} else {
		*old = tmp;
		return 0;
	}
 }
 
 /*",Race condition in the ldsem_cmpxchg function in drivers/tty/tty_ldsem.c in the Linux kernel before 3.13-rc4-next-20131218 allows local users to cause a denial of service (ldsem_down_read and ldsem_down_write deadlock) by establishing a new tty thread during shutdown of a previous tty thread.
795,CVE-2015-3288,"  static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 
 	pte_unmap(page_table);
 
	 
	if (vma->vm_flags & VM_SHARED)
		return VM_FAULT_SIGBUS;

 	 
 	if (check_stack_guard_page(vma, address) < 0)
 		return VM_FAULT_SIGSEGV;
  static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 
 	pte_unmap(page_table);
	 
	if (!vma->vm_ops->fault)
		return VM_FAULT_SIGBUS;
 	if (!(flags & FAULT_FLAG_WRITE))
 		return do_read_fault(mm, vma, address, pmd, pgoff, flags,
 				orig_pte);
  static int handle_pte_fault(struct mm_struct *mm,
 	barrier();
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
			if (vma->vm_ops)
				return do_fault(mm, vma, address, pte, pmd,
						flags, entry);

			return do_anonymous_page(mm, vma, address, pte, pmd,
					flags);
 		}
 		return do_swap_page(mm, vma, address,
 					pte, pmd, flags, entry);","mm/memory.c in the Linux kernel before 4.1.4 mishandles anonymous pages, which allows local users to gain privileges or cause a denial of service (page tainting) via a crafted application that triggers writing to page zero."
796,CVE-2015-3152,"  init_connection_options(MYSQL *mysql)
   if (using_opt_local_infile)
     mysql_options(mysql, MYSQL_OPT_LOCAL_INFILE, (char*) &opt_local_infile);
 
  SSL_SET_OPTIONS(mysql);
 
   if (opt_protocol)
     mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);","Oracle MySQL before 5.7.3, Oracle MySQL Connector/C (aka libmysqlclient) before 6.1.3, and MariaDB before 5.5.44 use the --ssl option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, aka a *BACKRONYM* attack."
797,CVE-2015-2686,"  SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
 
 	if (len > INT_MAX)
 		len = INT_MAX;
	if (unlikely(!access_ok(VERIFY_READ, buff, len)))
		return -EFAULT;
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;
  SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
 
 	if (size > INT_MAX)
 		size = INT_MAX;
	if (unlikely(!access_ok(VERIFY_WRITE, ubuf, size)))
		return -EFAULT;
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		goto out;","net/socket.c in the Linux kernel 3.19 before 3.19.3 does not validate certain range data for (1) sendto and (2) recvfrom system calls, which allows local users to gain privileges by leveraging a subsystem that uses the copy_from_iter function in the iov_iter interface, as demonstrated by the Bluetooth subsystem."
798,CVE-2015-2672,"  static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)
 	if (boot_cpu_has(X86_FEATURE_XSAVES))
 		asm volatile(""1:""XSAVES""\n\t""
 			""2:\n\t""
			     xstate_fault
			: ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
 			:   ""memory"");
 	else
 		asm volatile(""1:""XSAVE""\n\t""
 			""2:\n\t""
			     xstate_fault
			: ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
 			:   ""memory"");
 	return err;
 }
 
  static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)
 	if (boot_cpu_has(X86_FEATURE_XSAVES))
 		asm volatile(""1:""XRSTORS""\n\t""
 			""2:\n\t""
			     xstate_fault
			: ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
 			:   ""memory"");
 	else
 		asm volatile(""1:""XRSTOR""\n\t""
 			""2:\n\t""
			     xstate_fault
			: ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
 			:   ""memory"");
 	return err;
 }
 
  static inline int xsave_state(struct xsave_struct *fx, u64 mask)
 	 */
 	alternative_input_2(
 		""1:""XSAVE,
		XSAVEOPT,
 		X86_FEATURE_XSAVEOPT,
		XSAVES,
 		X86_FEATURE_XSAVES,
 		[fx] ""D"" (fx), ""a"" (lmask), ""d"" (hmask) :
 		""memory"");
  static inline int xrstor_state(struct xsave_struct *fx, u64 mask)
 	 */
 	alternative_input(
 		""1: "" XRSTOR,
		XRSTORS,
 		X86_FEATURE_XSAVES,
 		""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
 		: ""memory"");","The xsave/xrstor implementation in arch/x86/include/asm/xsave.h in the Linux kernel before 3.19.2 creates certain .altinstr_replacement pointers and consequently does not provide any protection against instruction faulting, which allows local users to cause a denial of service (panic) by triggering a fault, as demonstrated by an unaligned memory operand or a non-canonical address memory operand."
799,CVE-2015-1573,"  static int nft_flush_table(struct nft_ctx *ctx)
 	struct nft_chain *chain, *nc;
 	struct nft_set *set, *ns;
 
	list_for_each_entry(chain, &ctx->table->chains, list) {
 		ctx->chain = chain;
 
 		err = nft_delrule_by_chain(ctx);
 		if (err < 0)
 			goto out;
 	}
 
 	list_for_each_entry_safe(set, ns, &ctx->table->sets, list) {
  static int nft_flush_table(struct nft_ctx *ctx)
 			goto out;
 	}
 
	list_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {
		ctx->chain = chain;

		err = nft_delchain(ctx);
		if (err < 0)
			goto out;
	}

 	err = nft_deltable(ctx);
 out:
 	return err;","The nft_flush_table function in net/netfilter/nf_tables_api.c in the Linux kernel before 3.18.5 mishandles the interaction between cross-chain jumps and ruleset flushes, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability."
800,CVE-2015-1339,"  static int cuse_channel_release(struct inode *inode, struct file *file)
 		unregister_chrdev_region(cc->cdev->dev, 1);
 		cdev_del(cc->cdev);
 	}
	 
	fuse_conn_put(&cc->fc);
 
 	rc = fuse_dev_release(inode, file);	 
 ",Memory leak in the cuse_channel_release function in fs/fuse/cuse.c in the Linux kernel before 4.4 allows local users to cause a denial of service (memory consumption) or possibly have unspecified other impact by opening /dev/cuse many times.
801,CVE-2014-9904,"  static int snd_compress_check_input(struct snd_compr_params *params)
 {
 	 
 	if (params->buffer.fragment_size == 0 ||
	    params->buffer.fragments > INT_MAX / params->buffer.fragment_size)
 		return -EINVAL;
 
 	 ","The snd_compress_check_input function in sound/core/compress_offload.c in the ALSA subsystem in the Linux kernel before 3.17 does not properly check for an integer overflow, which allows local users to cause a denial of service (insufficient memory allocation) or possibly have unspecified other impact via a crafted SNDRV_COMPRESS_SET_PARAMS ioctl call."
802,CVE-2014-9903,"  static int sched_read_attr(struct sched_attr __user *uattr,
 		attr->size = usize;
 	}
 
	ret = copy_to_user(uattr, attr, attr->size);
 	if (ret)
 		return -EFAULT;
 ","The sched_read_attr function in kernel/sched/core.c in the Linux kernel 3.14-rc before 3.14-rc4 uses an incorrect size, which allows local users to obtain sensitive information from kernel stack memory via a crafted sched_getattr system call."
803,CVE-2014-9895,"  static long __media_device_enum_links(struct media_device *mdev,
 
 		for (p = 0; p < entity->num_pads; p++) {
 			struct media_pad_desc pad;

			memset(&pad, 0, sizeof(pad));
 			media_device_kpad_to_upad(&entity->pads[p], &pad);
 			if (copy_to_user(&links->pads[p], &pad, sizeof(pad)))
 				return -EFAULT;
  static long __media_device_enum_links(struct media_device *mdev,
 			if (entity->links[l].source->entity != entity)
 				continue;
 
			memset(&link, 0, sizeof(link));
 			media_device_kpad_to_upad(entity->links[l].source,
 						  &link.source);
 			media_device_kpad_to_upad(entity->links[l].sink,","drivers/media/media-device.c in the Linux kernel before 3.11, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize certain data structures, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28750150 and Qualcomm internal bug CR570757, a different vulnerability than CVE-2014-1739."
804,CVE-2014-9888,"  static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
  void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
 	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))","arch/arm/mm/dma-mapping.c in the Linux kernel before 3.13 on ARM platforms, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not prevent executable DMA mappings, which might allow local users to gain privileges via a crafted application, aka Android internal bug 28803642 and Qualcomm internal bug CR642735."
805,CVE-2014-9870,"  struct thread_info {
 	struct cpu_context_save	cpu_context;	 
 	__u32			syscall;	 
 	__u8			used_cp[16];	 
	unsigned long		tp_value[2];	 
 #ifdef CONFIG_CRUNCH
 	struct crunch_state	crunchstate;
 #endif","The Linux kernel before 3.11 on ARM platforms, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly consider user-space access to the TPIDRURW register, which allows local users to gain privileges via a crafted application, aka Android internal bug 28749743 and Qualcomm internal bug CR561044."
806,CVE-2014-9803,"  extern void __pgd_error(const char *file, int line, unsigned long val);
 #define PAGE_COPY_EXEC		__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN)
 #define PAGE_READONLY		__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN | PTE_UXN)
 #define PAGE_READONLY_EXEC	__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN)
 
 #define __P000  PAGE_NONE
 #define __P001  PAGE_READONLY
 #define __P010  PAGE_COPY
 #define __P011  PAGE_COPY
#define __P100  PAGE_READONLY_EXEC
 #define __P101  PAGE_READONLY_EXEC
 #define __P110  PAGE_COPY_EXEC
 #define __P111  PAGE_COPY_EXEC
  extern void __pgd_error(const char *file, int line, unsigned long val);
 #define __S001  PAGE_READONLY
 #define __S010  PAGE_SHARED
 #define __S011  PAGE_SHARED
#define __S100  PAGE_READONLY_EXEC
 #define __S101  PAGE_READONLY_EXEC
 #define __S110  PAGE_SHARED_EXEC
 #define __S111  PAGE_SHARED_EXEC
  extern struct page *empty_zero_page;
 #define pte_write(pte)		(!!(pte_val(pte) & PTE_WRITE))
 #define pte_exec(pte)		(!(pte_val(pte) & PTE_UXN))
 
#define pte_valid_user(pte) \
	((pte_val(pte) & (PTE_VALID | PTE_USER)) == (PTE_VALID | PTE_USER))
 
 static inline pte_t pte_wrprotect(pte_t pte)
 {
  extern void __sync_icache_dcache(pte_t pteval, unsigned long addr);
 static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
 			      pte_t *ptep, pte_t pte)
 {
	if (pte_valid_user(pte)) {
 		if (!pte_special(pte) && pte_exec(pte))
 			__sync_icache_dcache(pte, addr);
 		if (pte_dirty(pte) && pte_write(pte))","arch/arm64/include/asm/pgtable.h in the Linux kernel before 3.15-rc5-next-20140519, as used in Android before 2016-07-05 on Nexus 5X and 6P devices, mishandles execute-only pages, which allows attackers to gain privileges via a crafted application, aka Android internal bug 28557020."
807,CVE-2014-9773,"  DECLARE_MODULE_V1
 );
 
 static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[]);
static void check_registration_keywords(hook_user_register_check_t *hdata);
 
 command_t cs_flags = { ""FLAGS"", N_(""Manipulates specific permissions on a channel.""),
                         AC_NONE, 3, cs_cmd_flags, { .path = ""cservice/flags"" } };
 
static bool anope_flags_compat = true;

 void _modinit(module_t *m)
 {
 	service_named_bind_command(""chanserv"", &cs_flags);

	add_bool_conf_item(""ANOPE_FLAGS_COMPAT"", &chansvs.me->conf_table, 0, &anope_flags_compat, true);

	hook_add_event(""nick_can_register"");
	hook_add_nick_can_register(check_registration_keywords);

	hook_add_event(""user_can_register"");
	hook_add_user_can_register(check_registration_keywords);
 }
 
 void _moddeinit(module_unload_intent_t intent)
 {
 	service_named_unbind_command(""chanserv"", &cs_flags);

	hook_del_nick_can_register(check_registration_keywords);

	hook_del_user_can_register(check_registration_keywords);

	del_conf_item(""ANOPE_FLAGS_COMPAT"", &chansvs.me->conf_table);
 }
 
 typedef struct {
  static void do_list(sourceinfo_t *si, mychan_t *mc, unsigned int flags)
 		logcommand(si, CMDLOG_GET, ""FLAGS: \2%s\2"", mc->name);
 }
 
static void check_registration_keywords(hook_user_register_check_t *hdata)
{
	if (hdata->approved || !anope_flags_compat)
	{
		return;
	}

	if (!strcasecmp(hdata->account, ""LIST"") || !strcasecmp(hdata->account, ""CLEAR"") || !strcasecmp(hdata->account, ""MODIFY""))
	{
		command_fail(hdata->si, fault_badparams, ""The nick \2%s\2 is reserved and cannot be registered."", hdata->account);
		hdata->approved = 1;
	}
}

  
 static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])
 {
  static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])
 	 *
 	 *   --nenolod
 	 */
	else if (anope_flags_compat && !strcasecmp(target, ""LIST"") && myentity_find_ext(target) == NULL)
 	{
 		do_list(si, mc, 0);
 		free(target);
 
 		return;
 	}
	else if (anope_flags_compat && !strcasecmp(target, ""CLEAR"") && myentity_find_ext(target) == NULL)
 	{
 		free(target);
 
  static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])
 		command_success_nodata(si, _(""Cleared flags in \2%s\2.""), mc->name);
 		return;
 	}
	else if (anope_flags_compat && !strcasecmp(target, ""MODIFY"") && myentity_find_ext(target) == NULL)
 	{
 		free(target);
 ","modules/chanserv/flags.c in Atheme before 7.2.7 allows remote attackers to modify the Anope FLAGS behavior by registering and dropping the (1) LIST, (2) CLEAR, or (3) MODIFY keyword nicks."
808,CVE-2014-9767," 
 #include <zip.h>
 
 #include ""hphp/runtime/base/array-init.h""
#include ""hphp/runtime/base/file-util.h""
 #include ""hphp/runtime/base/preg.h""
 #include ""hphp/runtime/base/stream-wrapper-registry.h""
 #include ""hphp/runtime/ext/extension.h""
  static bool HHVM_METHOD(ZipArchive, deleteName, const String& name) {
   return true;
 }
 
 
 
 
 
 
static std::string make_relative_path(const std::string& path) {
  if (path.empty()) {
    return path;
  }

   
   
  std::string canonical(FileUtil::canonicalize(path));

   
   
   
   
  if (FileUtil::isDirSeparator(canonical[0])) {
    return canonical.substr(1);
  }

   
   

   
   
   
  std::string relative(canonical);
  int idx = canonical.length() - 1;
  while (1) {
    while (idx > 0 && !(FileUtil::isDirSeparator(canonical[idx]))) {
      idx--;
    }
     
    if (idx == 0) {
      return canonical;
    }
    if (idx >= 1 && (canonical[idx - 1] == '.' || canonical[idx - 1] == ':')) {
      relative = canonical.substr(idx + 1);
      break;
    }
    idx--;
  }
  return relative;
}

 static bool extractFileTo(zip* zip, const std::string &file, std::string& to,
                           char* buf, size_t len) {

  struct zip_stat zipStat;
   
  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {
    return false;
  }

  auto clean_file = file;
  auto sep = std::string::npos;
   
   
   
  int idx = file.length() - 1;
  while (idx >= 0) {
    if (FileUtil::isDirSeparator(file[idx])) {
      sep = idx;
      break;
    }
    idx--;
  }
   if (sep != std::string::npos) {
     
     
    clean_file = make_relative_path(file);
    std::string path = to + clean_file;
    bool is_dir_only = true;
    if (sep < file.length() - 1) {  
      auto clean_file_dir = HHVM_FN(dirname)(clean_file);
      path = to + clean_file_dir.toCppString();
      is_dir_only = false;
    }

     
     if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {
       return false;
     }
 
     
     
    if (is_dir_only) {  
       return true;
     }
     
   }
 
   
   
  to.append(clean_file);
 
   auto zipFile = zip_fopen_index(zip, zipStat.index, 0);
   FAIL_IF_INVALID_PTR(zipFile);","Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive."
809,CVE-2014-9765,"  main_get_appheader (xd3_stream *stream, main_file *ifile,
 
   if (appheadsz > 0)
     {
      const int kMaxArgs = 4;
       char *start = (char*)apphead;
       char *slash;
       int   place = 0;
      char *parsed[kMaxArgs];
 
       memset (parsed, 0, sizeof (parsed));
 
      while ((slash = strchr (start, '/')) != NULL && place < (kMaxArgs-1))
 	{
 	  *slash = 0;
 	  parsed[place++] = start;",Buffer overflow in the main_get_appheader function in xdelta3-main.h in xdelta3 before 3.0.9 allows remote attackers to execute arbitrary code via a crafted input file.
810,CVE-2014-9717,"  static void mntput_no_expire(struct mount *mnt)
 	rcu_read_unlock();
 
 	list_del(&mnt->mnt_instance);

	if (unlikely(!list_empty(&mnt->mnt_mounts))) {
		struct mount *p, *tmp;
		list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
			umount_mnt(p);
		}
	}
 	unlock_mount_hash();
 
 	if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {
  static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
  static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 
		disconnect = !IS_MNT_LOCKED_AND_LAZY(p);

		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
				 disconnect ? &unmounted : NULL);
 		if (mnt_has_parent(p)) {
 			mnt_add_count(p->mnt_parent, -1);
			if (!disconnect) {
				 
				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(p);
			}
 		}
 		change_mnt_propagation(p, MS_PRIVATE);
 	}
  void __detach_mounts(struct dentry *dentry)
 	lock_mount_hash();
 	while (!hlist_empty(&mp->m_list)) {
 		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
				umount_mnt(p);
			}
		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);","fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace."
811,CVE-2013-7456,"  static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi
 		double dTotalWeight = 0.0;
 		int iSrc;
 
 		 
 		if (iRight - iLeft + 1 > windows_size)  {
 			if (iLeft < ((int)src_size - 1 / 2))  {
  static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi
 			}
 		}
 
		res->ContribRow[u].Left = iLeft;
		res->ContribRow[u].Right = iRight;

 		for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
 			dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
 		}","gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function."
812,CVE-2013-7449,"  ssl_do_connect (server * serv)
 		switch (verify_error)
 		{
 		case X509_V_OK:
			{
				X509 *cert = SSL_get_peer_certificate (serv->ssl);
				int hostname_err;
				if ((hostname_err = _SSL_check_hostname(cert, serv->hostname)) != 0)
				{
					snprintf (buf, sizeof (buf), ""* Verify E: Failed to validate hostname? (%d)%s"",
							 hostname_err, serv->accept_invalid_cert ? "" -- Ignored"" : """");
					if (serv->accept_invalid_cert)
						EMIT_SIGNAL (XP_TE_SSLMESSAGE, serv->server_session, buf, NULL, NULL, NULL, 0);
					else
						goto conn_fail;
				}
				break;
			}
 			 
 			 
 		case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
 		case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
 		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
  ssl_do_connect (server * serv)
 			snprintf (buf, sizeof (buf), ""%s.? (%d)"",
 						 X509_verify_cert_error_string (verify_error),
 						 verify_error);
conn_fail:
 			EMIT_SIGNAL (XP_TE_CONNFAIL, serv->server_session, buf, NULL, NULL,
 							 NULL, 0);
 ","The ssl_do_connect function in common/server.c in HexChat before 2.10.2, XChat, and XChat-GNOME does not verify that the server hostname matches a domain name in the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate."
813,CVE-2013-7448,"  wiki_show_footer(HttpResponse *res)
 		       );
 }
 
int page_name_is_good(char* page_name)
{
 
    if (!page_name)
        return FALSE;

    if (!isalnum(page[0]))
        return FALSE;

    if (strstr(page, ""..""))
        return FALSE;

    return TRUE;
}


 void
 wiki_handle_rest_call(HttpRequest  *req, 
 		      HttpResponse *res,
  wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""%s"", file_read(page));
 	      http_response_send(res);
  wiki_handle_rest_call(HttpRequest  *req,
 	  if( ( (wikitext = http_request_param_get(req, ""text"")) != NULL)
 	      && ( (page = http_request_param_get(req, ""page"")) != NULL))
 	    {
	  if (page_name_is_good(page))
	    {
	      file_write(page, wikitext);
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
 	      return;
 	    }
	    }
 	}
       else if (!strcmp(func, ""page/delete""))
 	{
  wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && page_name_is_good(page) && (unlink(page) > 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
  wiki_handle_rest_call(HttpRequest  *req,
 	  if (page == NULL)
 	    page = http_request_get_query_string(req);
 
	  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))
 	    {
 	      http_response_printf(res, ""success"");
 	      http_response_send(res);
  wiki_handle_http_request(HttpRequest *req)
    
  if (!page_name_is_good(page))
     {
       http_response_set_status(res, 404, ""Not Found"");
       http_response_printf(res, ""<html><body>404 Not Found</body></html>\n"");",Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.
814,CVE-2013-4312,"  struct user_struct {
 	unsigned long mq_bytes;	 
 #endif
 	unsigned long locked_shm;  
	unsigned long unix_inflight;	 
 
 #ifdef CONFIG_KEYS
 	struct key *uid_keyring;	 ","The Linux kernel before 4.4.1 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by sending each descriptor over a UNIX socket before closing it, related to net/unix/af_unix.c and net/unix/garbage.c."
815,CVE-2013-4119,"  rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*
 		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
 		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
 		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
		SecInvalidateHandle(&credssp->context);
 
 		if (credssp->server)
 		{",FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.
816,CVE-2013-4118,"  BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)
 
 	stream_read(s, wmac, sizeof(wmac));
 	length -= sizeof(wmac);
	if (!security_decrypt(s->p, length, rdp))
		return FALSE;
 
 	if (securityFlags & SEC_SECURE_CHECKSUM)
 		security_salted_mac_signature(rdp, s->p, length, FALSE, cmac);",FreeRDP before 1.1.0-beta1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors.
817,CVE-2012-6704,"  int sock_setsockopt(struct socket *sock, int level, int optname,
 		break;
 	case SO_SNDBUF:
 		 
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_wmem_max);
 set_sndbuf:
 		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
		 
 		sk->sk_write_space(sk);
 		break;
 
  int sock_setsockopt(struct socket *sock, int level, int optname,
 
 	case SO_RCVBUF:
 		 
		 * about it this is right. Otherwise apps have to
		 * play 'guess the biggest size' games. RCVBUF/SNDBUF
		 * are treated in BSD as hints
		 */
		val = min_t(u32, val, sysctl_rmem_max);
 set_rcvbuf:
 		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
 		 
		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
 		break;
 
 	case SO_RCVBUFFORCE:
  int sock_getsockopt(struct socket *sock, int level, int optname,
 		break;
 
 	case SO_PASSCRED:
		v.val = !!test_bit(SOCK_PASSCRED, &sock->flags);
 		break;
 
 	case SO_PEERCRED:
  int sock_getsockopt(struct socket *sock, int level, int optname,
 		break;
 
 	case SO_PASSSEC:
		v.val = !!test_bit(SOCK_PASSSEC, &sock->flags);
 		break;
 
 	case SO_PEERSEC:","The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5 mishandles negative values of sk_sndbuf and sk_rcvbuf, which allows local users to cause a denial of service (memory corruption and system crash) or possibly have unspecified other impact by leveraging the CAP_NET_ADMIN capability for a crafted setsockopt system call with the (1) SO_SNDBUF or (2) SO_RCVBUF option."
818,CVE-2012-6703,"  static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,
 	unsigned int buffer_size;
 	void *buffer;
 
	if (params->buffer.fragment_size == 0 ||
	    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)
		return -EINVAL;

 	buffer_size = params->buffer.fragment_size * params->buffer.fragments;
 	if (stream->ops->copy) {
 		buffer = NULL;",Integer overflow in the snd_compr_allocate_buffer function in sound/core/compress_offload.c in the ALSA subsystem in the Linux kernel before 3.6-rc6-next-20120917 allows local users to cause a denial of service (insufficient memory allocation) or possibly have unspecified other impact via a crafted SNDRV_COMPRESS_SET_PARAMS ioctl call.
819,CVE-2012-6701,"  static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)
 	if (ret < 0)
 		goto out;
 
	ret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);
	if (ret < 0)
		goto out;

 	kiocb->ki_nr_segs = kiocb->ki_nbytes;
 	kiocb->ki_cur_seg = 0;
 	 
  static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)
 	return ret;
 }
 
static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)
 {
	int bytes;

	bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
	if (bytes < 0)
		return bytes;

 	kiocb->ki_iovec = &kiocb->ki_inline_vec;
 	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
	kiocb->ki_iovec->iov_len = bytes;
 	kiocb->ki_nr_segs = 1;
 	kiocb->ki_cur_seg = 0;
 	return 0;
  static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)
 		if (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,
 			kiocb->ki_left)))
 			break;
		ret = aio_setup_single_vector(READ, file, kiocb);
 		if (ret)
 			break;
 		ret = -EINVAL;
  static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)
 		if (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,
 			kiocb->ki_left)))
 			break;
		ret = aio_setup_single_vector(WRITE, file, kiocb);
 		if (ret)
 			break;
 		ret = -EINVAL;
  static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)
 		ret = -EBADF;
 		if (unlikely(!(file->f_mode & FMODE_READ)))
 			break;
 		ret = aio_setup_vectored_rw(READ, kiocb, compat);
 		if (ret)
 			break;
  static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)
 		ret = -EBADF;
 		if (unlikely(!(file->f_mode & FMODE_WRITE)))
 			break;
 		ret = aio_setup_vectored_rw(WRITE, kiocb, compat);
 		if (ret)
 			break;",Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.
820,CVE-2012-6689,"  static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
		if ((dst_group || dst_pid) &&
		    !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;
  static void __init netlink_add_usersock_entry(void)
 	rcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);
 	nl_table[NETLINK_USERSOCK].module = THIS_MODULE;
 	nl_table[NETLINK_USERSOCK].registered = 1;
	nl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;
 
 	netlink_table_ungrab();
 }","The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages."
821,CVE-2011-5321,"  static int tty_open(struct inode *inode, struct file *filp)
 		if (IS_ERR(tty)) {
 			tty_unlock();
 			mutex_unlock(&tty_mutex);
			tty_driver_kref_put(driver);
 			return PTR_ERR(tty);
 		}
 	}","The tty_open function in drivers/tty/tty_io.c in the Linux kernel before 3.1.1 mishandles a driver-lookup failure, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via crafted access to a device file under the /dev/pts directory."
822,CVE-2008-7316,"  static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)
 		const struct iovec *iov = i->iov;
 		size_t base = i->iov_offset;
 
		 
		while (bytes || !iov->iov_len) {
 			int copy = min(bytes, iov->iov_len - base);
 
 			bytes -= copy;
  static ssize_t generic_perform_write(struct file *file,
 
 		cond_resched();
 
		iov_iter_advance(i, copied);
 		if (unlikely(copied == 0)) {
 			/*
 			 * If we were unable to copy any data at all, we must
  static ssize_t generic_perform_write(struct file *file,
 						iov_iter_single_seg_count(i));
 			goto again;
 		}
 		pos += copied;
 		written += copied;
 ","mm/filemap.c in the Linux kernel before 2.6.25 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers an iovec of zero length, followed by a page fault for an iovec of nonzero length."
823,CVE-2017-1000380,"  static int snd_timer_user_tselect(struct file *file,
 	if (err < 0)
 		goto __err;
 
	tu->qhead = tu->qtail = tu->qused = 0;
 	kfree(tu->queue);
 	tu->queue = NULL;
 	kfree(tu->tqueue);","sound/core/timer.c in the Linux kernel before 4.11.5 is vulnerable to a data race in the ALSA /dev/snd/timer driver resulting in local users being able to read information belonging to other users, i.e., uninitialized memory contents may be disclosed when a read and an ioctl happen at the same time."
824,CVE-2017-1000252,"  kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)
 {
 	if (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))
 		return -EINVAL;
	if (args->gsi >= KVM_MAX_IRQ_ROUTES)
		return -EINVAL;
 
 	if (args->flags & KVM_IRQFD_FLAG_DEASSIGN)
 		return kvm_irqfd_deassign(kvm, args);","The KVM subsystem in the Linux kernel through 4.13.3 allows guest OS users to cause a denial of service (assertion failure, and hypervisor hang or crash) via an out-of bounds guest_irq value, related to arch/x86/kvm/vmx.c and virt/kvm/eventfd.c."
825,CVE-2017-1000251," 
 
  
 #define L2CAP_DEFAULT_MTU		672
#define L2CAP_DEFAULT_MIN_MTU		48
 #define L2CAP_DEFAULT_FLUSH_TO		0xffff
#define L2CAP_DEFAULT_TX_WINDOW		1
 #define L2CAP_DEFAULT_MAX_RECEIVE	1
 #define L2CAP_DEFAULT_RETRANS_TO	300     
 #define L2CAP_DEFAULT_MONITOR_TO	1000    
  struct l2cap_pinfo {
 	__u16		omtu;
 	__u16		flush_to;
 	__u8		mode;
	__u8		num_conf_req;
	__u8		num_conf_rsp;

 	__u8		fcs;
 	__u8		sec_level;
 	__u8		role_switch;
  struct l2cap_pinfo {
 	__u8		conf_req[64];
 	__u8		conf_len;
 	__u8		conf_state;
 
 	__u8		ident;
 
	__u8		remote_tx_win;
	__u8		remote_max_tx;
	__u16		retrans_timeout;
	__u16		monitor_timeout;
	__u16		max_pdu_size;

 	__le16		sport;
 
 	struct l2cap_conn	*conn;
 	struct sock		*next_c;
 	struct sock		*prev_c;
 };
 
#define L2CAP_CONF_REQ_SENT       0x01
#define L2CAP_CONF_INPUT_DONE     0x02
#define L2CAP_CONF_OUTPUT_DONE    0x04
#define L2CAP_CONF_MTU_DONE       0x08
#define L2CAP_CONF_MODE_DONE      0x10
#define L2CAP_CONF_CONNECT_PEND   0x20
#define L2CAP_CONF_STATE2_DEVICE  0x80

#define L2CAP_CONF_MAX_CONF_REQ 2
#define L2CAP_CONF_MAX_CONF_RSP 2
 
 
 void l2cap_load(void);
 ","The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space."
826,CVE-2017-1000249," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.138 2017/08/27 07:55:02 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,
     size_t noff, size_t doff, int *flags)
 {
 	if (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&
	    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {
 		uint8_t desc[20];
 		const char *btype;
 		uint32_t i;",An issue in file() was introduced in commit 9611f31313a93aa036389c5f3b15eea53510d4d1 (Oct 2016) lets an attacker overwrite a fixed 20 bytes stack buffer with a specially crafted .notes section in an ELF binary. This was fixed in commit 35c94dc6acc418f1ad7f6241a6680e5327495793 (Aug 2017).
827,CVE-2017-1000203,"  const char *shellMeta   = ""~*[]{}?$"";
 const char *shellStuff  = ""(){}<>\""'"";
 const char  shellEscape = '\\';
 
  
  
 
  static const char *HomeDirectory(const char *name)
 }
 
  
 
 
static const char *WorkingDirectory()
 {
   static char path[kMAXPATHLEN];
 
   if (getcwd(path, kMAXPATHLEN)) return path;
   return 0;
}
 
 
 
 
 
Bool_t RootdExpandFileName(const char *fname, char *xname, const int kBufSize)
{
   int n, ier, iter, lx, ncopy;
   char *inp, *out, *x, *t, buff[kBufSize * 4];
   const char *b, *c, *e;
   const char *p;
 
   iter = 0;
   xname[0] = 0;
   inp = buff + kBufSize;
   out = inp + kBufSize;
   inp[-1] = ' ';
   inp[0] = 0;
   out[-1] = ' ';
   c = fname + strspn(fname, "" \t\f\r"");
    
 
   strncat(inp, c, kBufSize - strlen(inp) - 1);
 
again:
   iter++;
   c = inp;
   ier = 0;
   x = out;
   x[0] = 0;

   p = 0;
   e = 0;
   if (c[0] == '~' && c[1] == '/') {  
      std::string hd = HomeDirectory(0);
      p = hd.c_str();
      e = c + 1;
      if (p) {  
         strlcpy(x, p, kBufSize);
         x += strlen(p);
         c = e;
       } else {
         ++ier;
         ++c;
      }
   } else if (c[0] == '~' && c[1] != '/') {  
      n = strcspn(c + 1, ""/ "");
      buff[0] = 0;
      strncat(buff, c + 1, n);
      std::string hd = HomeDirectory(buff);
      e = c + 1 + n;
      if (!hd.empty()) {  
         p = hd.c_str();
         strlcpy(x, p, kBufSize);
         x += strlen(p);
         c = e;
      } else {
         x++ [0] = c[0];
          
         ++c;
      }
   }

   for (; c[0]; c++) {

      p = 0;
      e = 0;

      if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') {  
         std::string wd = WorkingDirectory();
         strlcpy(buff, wd.c_str(), kBufSize);
         p = buff;
         e = c + 1;
      }
      if (p) {  
         strlcpy(x, p, kBufSize);
         x += strlen(p);
         c = e - 1;
         continue;
      }

      if (c[0] != '$') {  
         x++ [0] = c[0];
      } else {  
         b = c + 1;
         if (c[1] == '(') b++;
         if (c[1] == '{') b++;
         if (b[0] == '$')
            e = b + 1;
         else
            for (e = b; isalnum(e[0]) || e[0] == '_'; e++)
               ;
         buff[0] = 0;
         strncat(buff, b, e - b);
         p = getenv(buff);
         if (!p) {  
            for (t = buff; (t[0] = toupper(t[0])); t++)
               ;
            p = getenv(buff);
         }
         if (!p) {  
            for (t = buff; (t[0] = tolower(t[0])); t++)
               ;
            p = getenv(buff);
         }
         if (!p && !strcmp(buff, ""cwd"")) {  
            std::string wd = WorkingDirectory();
            strlcpy(buff, wd.c_str(), kBufSize);
            p = buff;
         }
         if (!p && !strcmp(buff, ""$"")) {  
            snprintf(buff, kBufSize * 4, ""%d"", (int)getpid());
            p = buff;
         }
         if (!p) {  
            ier++;
            x++ [0] = c[0];
         } else {  
            int lp = strlen(p);
            if (lp >= kBufSize) {
                
               strlcpy(x, p, kBufSize);
               x += kBufSize;
               break;
            }
            strcpy(x, p);
            x += lp;
            c = (b == c + 1) ? e - 1 : e;
          }
       }
   }
 
   x[0] = 0;
   lx = x - out;
   if (ier && iter < 3) {
      strlcpy(inp, out, kBufSize);
      goto again;
    }
   ncopy = (lx >= kBufSize) ? kBufSize - 1 : lx;
   xname[0] = 0;
   strncat(xname, out, ncopy);
 
   if (ier || ncopy != lx) {
      Error(ErrFatal, kErrFatal, ""RootdExpandFileName: fatal error:\n\t input: %s\n\t output: %s"", fname, xname);
      return true;
    }

   return false;
}

 
 
 

char *RootdExpandPathName(const char *name)
{
   const char *patbuf = name;

    
   while (*patbuf == ' ') patbuf++;

    
   bool needesc = false;
   for (const char *p = patbuf; *p; p++)
      if (strchr(shellMeta, *p)) {
         needesc = true;
         break;
      }

    
   if (needesc) {
      const int kBufSize = kMAXPATHLEN;
      char xname[kBufSize];
      if (RootdExpandFileName(name, xname, kBufSize)) {
         Error(ErrFatal, kErrFatal, ""RootdExpandPathName: problem escaping meta characters"");
          return 0;
      } else {
         return strdup(xname);
       }
    }
   return strdup(name);
 }
 
  ",ROOT version 6.9.03 and below is vulnerable to an authenticated shell metacharacter injection in the rootd daemon resulting in remote code execution
828,CVE-2017-1000201,"  on_unregister_handler(TCMUService1HandlerManager1 *interface,
 		      gpointer user_data)
 {
 	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;
 
 	if (!handler) {
 		g_dbus_method_invocation_return_value(invocation,",The tcmu-runner daemon in tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a local denial of service attack
829,CVE-2017-1000200,"  int tcmur_register_handler(struct tcmur_handler *handler)
 	return 0;
 }
 
static int tcmur_register_dbus_handler(struct tcmur_handler *handler)
{
	assert(handler->_is_dbus_handler == true);
	return tcmur_register_handler(handler);
}

 bool tcmur_unregister_handler(struct tcmur_handler *handler)
 {
 	int i;
  bool tcmur_unregister_handler(struct tcmur_handler *handler)
 	return false;
 }
 
static bool tcmur_unregister_dbus_handler(struct tcmur_handler *handler)
{
	bool ret = false;
	assert(handler->_is_dbus_handler == true);

	ret = tcmur_unregister_handler(handler);

	return ret;
}

 static int is_handler(const struct dirent *dirent)
 {
 	if (strncmp(dirent->d_name, ""handler_"", 8))
  on_handler_appeared(GDBusConnection *connection,
 
 	if (info->register_invocation) {
 		info->connection = connection;
		tcmur_register_dbus_handler(handler);
 		dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config));
 		g_dbus_method_invocation_return_value(info->register_invocation,
 			    g_variant_new(""(bs)"", TRUE, ""succeeded""));
  on_handler_vanished(GDBusConnection *connection,
 			    g_variant_new(""(bs)"", FALSE, reason));
 		g_free(reason);
 	}
	tcmur_unregister_dbus_handler(handler);
 	dbus_unexport_handler(handler);
 }
 
  on_register_handler(TCMUService1HandlerManager1 *interface,
 	handler->handle_cmd   = dbus_handler_handle_cmd;
 
 	info = g_new0(struct dbus_info, 1);
	handler->opaque = info;
	handler->_is_dbus_handler = 1;
 	info->register_invocation = invocation;
 	info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM,
 					    bus_name,
  on_unregister_handler(TCMUService1HandlerManager1 *interface,
 				      ""unknown subtype""));
 		return TRUE;
 	}
	else if (handler->_is_dbus_handler != 1) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
				      ""cannot unregister internal handler""));
		return TRUE;
	}

 	dbus_unexport_handler(handler);
	tcmur_unregister_dbus_handler(handler);

 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);",tcmu-runner version 1.0.5 to 1.2.0 is vulnerable to a dbus triggered NULL pointer dereference in the tcmu-runner daemon's on_unregister_handler() function resulting in denial of service
830,CVE-2017-1000198,"  static char* tcmu_get_path( struct tcmu_device *dev)
 	return config;
 }
 
 static int tcmu_glfs_open(struct tcmu_device *dev)
 {
 	struct glfs_state *gfsp;
  struct tcmur_handler glfs_handler = {
 	.subtype 	= ""glfs"",
 	.cfg_desc	= glfs_cfg_desc,
 
 	.open 		= tcmu_glfs_open,
 	.close 		= tcmu_glfs_close,
 	.read 		= tcmu_glfs_read,",tcmu-runner daemon version 0.9.0 to 1.2.0 is vulnerable to invalid memory references in the handler_glfs.so handler resulting in denial of service
831,CVE-2017-1000083,"  typedef enum
 	RARLABS,
 	GNAUNRAR,
 	UNZIP,
	P7ZIP
 } ComicBookDecompressType;
 
 typedef struct _ComicsDocumentClass ComicsDocumentClass;
  static const ComicBookDecompressCommand command_usage_def[] = {
 
          
 	{NULL               , ""%s l -- %s""     , ""%s x -y %s -o%s"", FALSE, OFFSET_7Z},
 };
 
 static GSList*    get_supported_image_extensions (void);
  comics_check_decompress_command	(gchar          *mime_type,
 			comics_document->command_usage = GNAUNRAR;
 			return TRUE;
 		}
 	} else if (g_content_type_is_a (mime_type, ""application/x-cbz"") ||
 		   g_content_type_is_a (mime_type, ""application/zip"")) {
 		 
  comics_check_decompress_command	(gchar          *mime_type,
 			comics_document->command_usage = P7ZIP;
 			return TRUE;
 		}
 
 	} else if (g_content_type_is_a (mime_type, ""application/x-cb7"") ||
 		   g_content_type_is_a (mime_type, ""application/x-7z-compressed"")) {
  comics_check_decompress_command	(gchar          *mime_type,
 			comics_document->command_usage = P7ZIP;
 			return TRUE;
 		}
 	} else {
 		g_set_error (error,
 			     EV_DOCUMENT_ERROR,","backend/comics/comics-document.c (aka the comic book backend) in GNOME Evince before 3.24.1 allows remote attackers to execute arbitrary commands via a .cbt file that is a TAR archive containing a filename beginning with a *--* command-line option substring, as demonstrated by a --checkpoint-action=exec=bash at the beginning of the filename."
832,CVE-2017-17862,"  struct bpf_insn_aux_data {
 		struct bpf_map *map_ptr;	 
 	};
 	int ctx_field_size;  
	bool seen;  
 };
 
 #define MAX_USED_MAPS 64  ","kernel/bpf/verifier.c in the Linux kernel through 4.14.8 ignores unreachable code, even though it would still be processed by JIT compilers. This behavior, also considered an improper branch-pruning logic issue, could possibly be used by local users for denial of service."
833,CVE-2017-17857,"  static int check_stack_boundary(struct bpf_verifier_env *env, int regno,
 		tnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);
 		verbose(env, ""invalid variable stack read R%d var_off=%s\n"",
 			regno, tn_buf);
		return -EACCES;
 	}
 	off = regs[regno].off + regs[regno].var_off.value;
 	if (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||",The check_stack_boundary function in kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging mishandling of invalid variable stack read operations.
834,CVE-2017-17856,"  static int check_ptr_alignment(struct bpf_verifier_env *env,
 		break;
 	case PTR_TO_STACK:
 		pointer_desc = ""stack "";
		 
		strict = true;
 		break;
 	default:
 		break;",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging the lack of stack-pointer alignment enforcement.
835,CVE-2017-17855,"  static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,
 			return range_within(rold, rcur) &&
 			       tnum_in(rold->var_off, rcur->var_off);
 		} else {
			return false;
 		}
 	case PTR_TO_MAP_VALUE:
 		/* If the new min/max/var_off satisfy the old ones and",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging improper use of pointers in place of scalars.
836,CVE-2017-17854," 
  * In practice this is far bigger than any realistic pointer offset; this limit
  * ensures that umax_value + (int)off + (int)size cannot overflow a u64.
  */
#define BPF_MAX_VAR_OFF	(1 << 29)
  
#define BPF_MAX_VAR_SIZ	(1 << 29)
 
 /* Liveness marks, used for registers and spilled-regs (in stack slots).
  * Read marks propagate upwards until they find a write mark; they record that",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (integer overflow and memory corruption) or possibly have unspecified other impact by leveraging unrestricted integer values for pointer arithmetic.
837,CVE-2017-17853,"  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 			mark_reg_unknown(env, regs, insn->dst_reg);
 			break;
 		}
		 
		dst_reg->smin_value = S64_MIN;
		dst_reg->smax_value = S64_MAX;
 		if (src_known)
 			dst_reg->var_off = tnum_rshift(dst_reg->var_off,
 						       umin_val);",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging incorrect BPF_RSH signed bounds calculations.
838,CVE-2017-17852,"  static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,
 	return 0;
 }
 
 
 static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 				      struct bpf_insn *insn,
 				      struct bpf_reg_state *dst_reg,
  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 	bool src_known, dst_known;
 	s64 smin_val, smax_val;
 	u64 umin_val, umax_val;
	u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;
 
 	smin_val = src_reg.smin_value;
 	smax_val = src_reg.smax_value;
 	umin_val = src_reg.umin_value;
  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 		__update_reg_bounds(dst_reg);
 		break;
 	case BPF_LSH:
 			mark_reg_unknown(env, regs, insn->dst_reg);
 			break;
  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 		__update_reg_bounds(dst_reg);
 		break;
 	case BPF_RSH:
 			mark_reg_unknown(env, regs, insn->dst_reg);
 			break;
  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 		break;
 	}
 
	if (BPF_CLASS(insn->code) != BPF_ALU64) {
		 
		coerce_reg_to_size(dst_reg, 4);
		coerce_reg_to_size(&src_reg, 4);
	}

 	__reg_deduce_bounds(dst_reg);
 	__reg_bound_offset(dst_reg);
 	return 0;",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging mishandling of 32-bit ALU ops.
839,CVE-2017-17807,"  static int construct_key(struct key *key, const void *callout_info,
  * The keyring selected is returned with an extra reference upon it which the
  * caller must release.
  */
static int construct_get_dest_keyring(struct key **_dest_keyring)
 {
 	struct request_key_auth *rka;
 	const struct cred *cred = current_cred();
 	struct key *dest_keyring = *_dest_keyring, *authkey;
	int ret;
 
 	kenter(""%p"", dest_keyring);
 
  static void construct_get_dest_keyring(struct key **_dest_keyring)
 		 
 		key_get(dest_keyring);
 	} else {
		bool do_perm_check = true;

 		 
 		switch (cred->jit_keyring) {
  static void construct_get_dest_keyring(struct key **_dest_keyring)
 					dest_keyring =
 						key_get(rka->dest_keyring);
 				up_read(&authkey->sem);
				if (dest_keyring) {
					do_perm_check = false;
 					break;
				}
 			}
 
 		case KEY_REQKEY_DEFL_THREAD_KEYRING:
  static void construct_get_dest_keyring(struct key **_dest_keyring)
 		default:
 			BUG();
 		}

		 
		if (dest_keyring && do_perm_check) {
			ret = key_permission(make_key_ref(dest_keyring, 1),
					     KEY_NEED_WRITE);
			if (ret) {
				key_put(dest_keyring);
				return ret;
			}
		}
 	}
 
 	*_dest_keyring = dest_keyring;
 	kleave("" [dk %d]"", key_serial(dest_keyring));
	return 0;
 }
 
 /*
  static struct key *construct_key_and_link(struct keyring_search_context *ctx,
 	if (ctx->index_key.type == &key_type_keyring)
 		return ERR_PTR(-EPERM);
 
	ret = construct_get_dest_keyring(&dest_keyring);
	if (ret)
		goto error;
 
	user = key_user_lookup(current_fsuid());
	if (!user) {
		ret = -ENOMEM;
		goto error_put_dest_keyring;
	}
 
 	ret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);
 	key_user_put(user);
  static struct key *construct_key_and_link(struct keyring_search_context *ctx,
 	} else if (ret == -EINPROGRESS) {
 		ret = 0;
 	} else {
		goto error_put_dest_keyring;
 	}
 
 	key_put(dest_keyring);
  static struct key *construct_key_and_link(struct keyring_search_context *ctx,
 construction_failed:
 	key_negate_and_link(key, key_negative_timeout, NULL, NULL);
 	key_put(key);
error_put_dest_keyring:
 	key_put(dest_keyring);
error:
 	kleave("" = %d"", ret);
 	return ERR_PTR(ret);
 }","The KEYS subsystem in the Linux kernel before 4.14.6 omitted an access-control check when adding a key to the current task's *default request-key keyring* via the request_key() system call, allowing a local user to use a sequence of crafted system calls to add keys to a keyring with only Search permission (not Write permission) to that keyring, related to construct_get_dest_keyring() in security/keys/request_key.c."
840,CVE-2017-17806,"  static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
 	salg = shash_attr_alg(tb[1], 0, 0);
 	if (IS_ERR(salg))
 		return PTR_ERR(salg);
	alg = &salg->base;
 
	 
 	err = -EINVAL;
	if (crypto_shash_alg_has_setkey(salg))
		goto out_put_alg;

 	ds = salg->digestsize;
 	ss = salg->statesize;
 	if (ds > alg->cra_blocksize ||
 	    ss < alg->cra_blocksize)
 		goto out_put_alg;","The HMAC implementation (crypto/hmac.c) in the Linux kernel before 4.14.8 does not validate that the underlying cryptographic hash algorithm is unkeyed, allowing a local attacker able to use the AF_ALG-based hash interface (CONFIG_CRYPTO_USER_API_HASH) and the SHA-3 hash algorithm (CONFIG_CRYPTO_SHA3) to cause a kernel stack buffer overflow by executing a crafted sequence of system calls that encounter a missing SHA-3 initialization."
841,CVE-2017-17805,"  static int encrypt(struct blkcipher_desc *desc,
 
 	salsa20_ivsetup(ctx, walk.iv);
 
 	while (walk.nbytes >= 64) {
 		salsa20_encrypt_bytes(ctx, walk.src.virt.addr,
 				      walk.dst.virt.addr,","The Salsa20 encryption algorithm in the Linux kernel before 4.14.8 does not correctly handle zero-length inputs, allowing a local attacker able to use the AF_ALG-based skcipher interface (CONFIG_CRYPTO_USER_API_SKCIPHER) to cause a denial of service (uninitialized-memory free and kernel crash) or have unspecified other impact by executing a crafted sequence of system calls that use the blkcipher_walk API. Both the generic implementation (crypto/salsa20_generic.c) and x86 implementation (arch/x86/crypto/salsa20_glue.c) of Salsa20 were vulnerable."
842,CVE-2017-17760,"  bool PxMDecoder::readData( Mat& img )
                         }
                     }
                     else
                        memcpy(data, src, img.elemSize1()*m_width);
                 }
                 else
                 {","OpenCV 3.3.1 has a Buffer Overflow in the cv::PxMDecoder::readData function in grfmt_pxm.cpp, because an incorrect size value is used."
843,CVE-2017-17712,"  static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 	int err;
 	struct ip_options_data opt_copy;
 	struct raw_frag_vec rfv;
	int hdrincl;
 
 	err = -EMSGSIZE;
 	if (len > 0xFFFF)
 		goto out;
 
	 
	hdrincl = inet->hdrincl;
 	 
  static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 		 
		if (hdrincl)
 			goto done;
 		if (ipc.opt->opt.srr) {
 			if (!daddr)
  static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 
 	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
 			   RT_SCOPE_UNIVERSE,
			   hdrincl ? IPPROTO_RAW : sk->sk_protocol,
 			   inet_sk_flowi_flags(sk) |
			    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
 			   daddr, saddr, 0, 0, sk->sk_uid);
 
	if (!hdrincl) {
 		rfv.msg = msg;
 		rfv.hlen = 0;
 
  static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 		goto do_confirm;
 back_from_confirm:
 
	if (hdrincl)
 		err = raw_send_hdrinc(sk, &fl4, msg, len,
 				      &rt, msg->msg_flags, &ipc.sockc);
 ",The raw_sendmsg() function in net/ipv4/raw.c in the Linux kernel through 4.14.6 has a race condition in inet->hdrincl that leads to uninitialized stack pointer usage; this allows a local user to execute code and gain privileges.
844,CVE-2017-17499,"  void Magick::Image::read(MagickCore::Image *image,
       image == (MagickCore::Image *) NULL)
     {
       (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  else
    {
      ThrowImageException;
     }
   if (image != (MagickCore::Image *) NULL)
     throwException(&image->exception,quiet());
 }",ImageMagick before 6.9.9-24 and 7.x before 7.0.7-12 has a use-after-free in Magick::Image::read in Magick++/lib/Image.cpp.
845,CVE-2017-17439,"  _kdc_as_rep(kdc_request_t r,
      
    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {
 	ret = _kdc_fast_mk_error(context, r,
 				 &error_method,
 				 r->armor_crypto,
 				 &req->req_body,
 				 ret, r->e_text,
 				 r->server_princ,
				 r->client_princ ?
                                     &r->client_princ->name : NULL,
				 r->client_princ ?
                                     &r->client_princ->realm : NULL,
 				 NULL, NULL,
 				 reply);
 	if (ret)","In Heimdal through 7.4, remote unauthenticated attackers are able to crash the KDC by sending a crafted UDP packet containing empty data fields for client name or realm. The parser would unconditionally dereference NULL pointers in that case, leading to a segmentation fault. This is related to the _kdc_as_rep function in kdc/kerberos5.c and the der_length_visible_string function in lib/asn1/der_length.c."
846,CVE-2017-17081,"  static void gmc_mmx(uint8_t *dst, uint8_t *src,
     const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);
     const int dxh = dxy * (h - 1);
     const int dyw = dyx * (w - 1);
    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
                     (unsigned) iy >= height - h || height< h
                     ;
 
     if (  
         ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |","The gmc_mmx function in libavcodec/x86/mpegvideodsp.c in FFmpeg 3.4 does not properly validate widths and heights, which allows remote attackers to cause a denial of service (integer signedness error and out-of-array read) via a crafted MPEG file."
847,CVE-2017-17053,"  static inline int init_new_context(struct task_struct *tsk,
 		mm->context.execute_only_pkey = -1;
 	}
 	#endif
	return init_new_context_ldt(tsk, mm);
 }
 static inline void destroy_context(struct mm_struct *mm)
 {","The init_new_context function in arch/x86/include/asm/mmu_context.h in the Linux kernel before 4.12.10 does not correctly handle errors from LDT table allocation when forking a new process, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program. This vulnerability only affected kernels built with CONFIG_MODIFY_LDT_SYSCALL=y."
848,CVE-2017-17052,"  static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 	mm_init_cpumask(mm);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
	RCU_INIT_POINTER(mm->exe_file, NULL);
 	mmu_notifier_mm_init(mm);
 	init_tlb_flush_pending(mm);
 #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS","The mm_init function in kernel/fork.c in the Linux kernel before 4.12.10 does not clear the ->exe_file member of a new process's mm_struct, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program."
849,CVE-2017-16996,"  static int check_ptr_alignment(struct bpf_verifier_env *env,
 					   strict);
 }
 
 
static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)
{
	u64 mask;

	 
	reg->var_off = tnum_cast(reg->var_off, size);

	 
	mask = ((u64)1 << (size * 8)) - 1;
	if ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {
		reg->umin_value &= mask;
		reg->umax_value &= mask;
	} else {
		reg->umin_value = 0;
		reg->umax_value = mask;
	}
	reg->smin_value = reg->umin_value;
	reg->smax_value = reg->umax_value;
}

  
		coerce_reg_to_size(&regs[value_regno], size);
 	}
 	return err;
 }
  static int check_call(struct bpf_verifier_env *env, int func_id, int insn_idx)
 	return 0;
 }
 
 static bool signed_add_overflows(s64 a, s64 b)
 {
 	 
  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 
 	if (BPF_CLASS(insn->code) != BPF_ALU64) {
 		 
		coerce_reg_to_size(dst_reg, 4);
		coerce_reg_to_size(&src_reg, 4);
 	}
 	smin_val = src_reg.smin_value;
 	smax_val = src_reg.smax_value;
  static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)
 					return -EACCES;
 				}
 				mark_reg_unknown(env, regs, insn->dst_reg);
				coerce_reg_to_size(&regs[insn->dst_reg], 4);
 			}
 		} else {
 			/* case: R = imm",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging register truncation mishandling.
850,CVE-2017-16995,"  static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)
 			 * remember the value we stored into this reg
 			 */
 			regs[insn->dst_reg].type = SCALAR_VALUE;
			if (BPF_CLASS(insn->code) == BPF_ALU64) {
				__mark_reg_known(regs + insn->dst_reg,
						 insn->imm);
			} else {
				__mark_reg_known(regs + insn->dst_reg,
						 (u32)insn->imm);
			}
 		}
 
 	} else if (opcode > BPF_END) {",The check_alu_op function in kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging incorrect sign extension.
851,CVE-2017-16994,"  static int walk_hugetlb_range(unsigned long addr, unsigned long end,
 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk->mm, addr & hmask, sz);

		if (pte)
 			err = walk->hugetlb_entry(pte, hmask, addr, next, walk);
		else if (walk->pte_hole)
			err = walk->pte_hole(addr, next, walk);

 		if (err)
 			break;
 	} while (addr = next, addr != end);","The walk_hugetlb_range function in mm/pagewalk.c in the Linux kernel before 4.14.2 mishandles holes in hugetlb ranges, which allows local users to obtain sensitive information from uninitialized kernel memory via crafted use of the mincore() system call."
852,CVE-2017-16939,"  static int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr
 
 static int xfrm_dump_policy_done(struct netlink_callback *cb)
 {
	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;
 	struct net *net = sock_net(cb->skb->sk);
 
 	xfrm_policy_walk_done(walk, net);
 	return 0;
 }
 
static int xfrm_dump_policy_start(struct netlink_callback *cb)
{
	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;

	BUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));

	xfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);
	return 0;
}

 static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)
 {
 	struct net *net = sock_net(skb->sk);
	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;
 	struct xfrm_dump_info info;
 
 	info.in_skb = cb->skb;
 	info.out_skb = skb;
 	info.nlmsg_seq = cb->nlh->nlmsg_seq;
 	info.nlmsg_flags = NLM_F_MULTI;
 
 	(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);
 
 	return skb->len;
  static const struct nla_policy xfrma_spd_policy[XFRMA_SPD_MAX+1] = {
 
 static const struct xfrm_link {
 	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);
	int (*start)(struct netlink_callback *);
 	int (*dump)(struct sk_buff *, struct netlink_callback *);
 	int (*done)(struct netlink_callback *);
 	const struct nla_policy *nla_pol;
  static const struct xfrm_link {
 	[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
 	[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },
 	[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,
						   .start = xfrm_dump_policy_start,
 						   .dump = xfrm_dump_policy,
 						   .done = xfrm_dump_policy_done },
 	[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },
  static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,
 
 		{
 			struct netlink_dump_control c = {
				.start = link->start,
 				.dump = link->dump,
 				.done = link->done,
 			};",The XFRM dump policy implementation in net/xfrm/xfrm_user.c in the Linux kernel before 4.13.11 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted SO_RCVBUF setsockopt system call in conjunction with XFRM_MSG_GETPOLICY Netlink messages.
853,CVE-2017-16932,"  xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 	xmlGenericError(xmlGenericErrorContext,
 		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
     }
    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
        (ctxt->inputNr > 1024)) {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
        while (ctxt->inputNr > 1)
            xmlFreeInputStream(inputPop(ctxt));
	return(-1);
    }
     ret = inputPush(ctxt, input);
     if (ctxt->instate == XML_PARSER_EOF)
         return(-1);
  xmlParsePEReference(xmlParserCtxtPtr ctxt)
 		return;
 
 	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0) {
                xmlFreeInputStream(input);
 		return;
            }
 
 	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
                 /*",parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.
854,CVE-2017-16820,"  static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
     if (oid_list_todo_num == 0) {
        
       DEBUG(""snmp plugin: all variables have left their subtree"");
      snmp_free_pdu(req);
       status = 0;
       break;
     }
 
     res = NULL;
     
     status = snmp_sess_synch_response(host->sess_handle, req, &res);
     if ((status != STAT_SUCCESS) || (res == NULL)) {
       char *errstr = NULL;
  static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
         snmp_free_pdu(res);
       res = NULL;
 
       sfree(errstr);
       csnmp_host_close_session(host);
 
  static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {
     snmp_free_pdu(res);
   res = NULL;
 
 
   if (status == 0)
     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);","The csnmp_read_table function in snmp.c in the SNMP plugin in collectd before 5.6.3 is susceptible to a double free in a certain error case, which could lead to a crash (or potentially have other impact)."
855,CVE-2017-16818,"  class Principal {
   }
 
   const std::string& get_tenant() const {
     return u.tenant;
   }
 
   const std::string& get_id() const {
     return u.id;
   }
 ","RADOS Gateway in Ceph 12.1.0 through 12.2.1 allows remote authenticated users to cause a denial of service (assertion failure and application exit) by leveraging *full* (not necessarily admin) privileges to post an invalid profile to the admin API, related to rgw/rgw_iam_policy.cc, rgw/rgw_basic_types.h, and rgw/rgw_iam_types.h."
856,CVE-2017-16805," 
 
 
 #define D0 if(1)
 #define D1 if(1)
  static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf)
 			values = dies[j].attr_values;
 
 			for (k = 0; k < dies[j].length; k++) {
				if (!values[k].name) {
 					continue;
				}
 
 				if (values[k].name < DW_AT_vtable_elem_location &&
 						dwarf_attr_encodings[values[k].name]) {
  static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,
 	const ut8 *buf_end = obuf + obuf_len;
 	size_t j;
 
	if (!spec || !value || !hdr || !obuf || obuf_len < 1) {
 		return NULL;
 	}
 
  static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,
 			value->encoding.address = READ (buf, ut64);
 			break;
 		default:
			eprintf (""DWARF: Unexpected pointer size: %u\n"", (unsigned)hdr->pointer_size);
 			return NULL;
 		}
 		break;
  static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,
 			value->encoding.block.data = data;
 		}
 		break;
#if 0
 
 	case DW_FORM_data2:
 		value->encoding.data = READ (buf, ut16);
 		break;
  static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,
 	case DW_FORM_data8:
 		value->encoding.data = READ (buf, ut64);
 		break;
#endif
 	case DW_FORM_string:
 		value->encoding.str_struct.string = *buf? strdup ((const char*)buf) : NULL;
 		buf += (strlen ((const char*)buf) + 1);
  static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,
 		if (!buf) {
 			return NULL;
 		}
		value->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length);
		if (value->encoding.block.data) {
			for (j = 0; j < value->encoding.block.length; j++) {
				value->encoding.block.data[j] = READ (buf, ut8);
			}
 		}
 		break;
 	case DW_FORM_block1:
 		value->encoding.block.length = READ (buf, ut8);
 		value->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length + 1);
		if (value->encoding.block.data) {
			for (j = 0; j < value->encoding.block.length; j++) {
				value->encoding.block.data[j] = READ (buf, ut8);
			}
 		}
 		break;
 	case DW_FORM_flag:
  static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,
 				eprintf (""Warning: malformed dwarf attribute capacity doesn't match length\n"");
 				break;
 			}
			memset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));
 			buf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,
 					&da->decls[abbr_code - 1].specs[i],
 					&cu->dies[cu->length].attr_values[i],","In radare2 2.0.1, libr/bin/dwarf.c allows remote attackers to cause a denial of service (invalid read and application crash) via a crafted ELF file, related to r_bin_dwarf_parse_comp_unit in dwarf.c and sdb_set_internal in shlr/sdb/src/sdb.c."
857,CVE-2017-16803," 
 
 #define SMKTREE_BITS 9
 #define SMK_NODE 0x80000000
#define SMKTREE_DECODE_MAX_RECURSION 32
 
 typedef struct SmackVContext {
     AVCodecContext *avctx;
  enum SmkBlockTypes {
 static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,
                                uint32_t prefix, int length)
 {
    if (length > SMKTREE_DECODE_MAX_RECURSION) {
        av_log(NULL, AV_LOG_ERROR, ""Maximum tree recursion level exceeded.\n"");
        return AVERROR_INVALIDDATA;
    }

     if (!bitstream_read_bit(bc)) {  
         if(hc->current >= 256){
             av_log(NULL, AV_LOG_ERROR, ""Tree size exceeded!\n"");","In Libav through 11.11 and 12.x through 12.1, the smacker_decode_tree function in libavcodec/smacker.c does not properly restrict tree recursion, which allows remote attackers to cause a denial of service (bitstream.c:build_table() out-of-bounds read and application crash) via a crafted Smacker stream."
858,CVE-2017-16645,"  ims_pcu_get_cdc_union_desc(struct usb_interface *intf)
 		return NULL;
 	}
 
	while (buflen >= sizeof(*union_desc)) {
 		union_desc = (struct usb_cdc_union_desc *)buf;
 
		if (union_desc->bLength > buflen) {
			dev_err(&intf->dev, ""Too large descriptor\n"");
			return NULL;
		}

 		if (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&
 		    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {
 			dev_dbg(&intf->dev, ""Found union header\n"");

			if (union_desc->bLength >= sizeof(*union_desc))
				return union_desc;

			dev_err(&intf->dev,
				""Union descriptor to short (%d vs %zd\n)"",
				union_desc->bLength, sizeof(*union_desc));
			return NULL;
 		}
 
 		buflen -= union_desc->bLength;",The ims_pcu_get_cdc_union_desc function in drivers/input/misc/ims-pcu.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (ims_pcu_parse_cdc_data out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
859,CVE-2017-16643,"  static void parse_hid_report_descriptor(struct gtco *device, char * report,
 
 	 
 	while (i < length) {
		prefix = report[i++];
 
 		 
		size = (1U << PREF_SIZE(prefix)) >> 1;
		if (i + size > length) {
			dev_err(ddev,
				""Not enough data (need %d, have %d)\n"",
				i + size, length);
			break;
		}

 		switch (size) {
 		case 1:
 			data = report[i];
 			break;
 		case 2:
 			data16 = get_unaligned_le16(&report[i]);
 			break;
		case 4:
 			data32 = get_unaligned_le32(&report[i]);
 			break;
 		}",The parse_hid_report_descriptor function in drivers/input/tablet/gtco.c in the Linux kernel before 4.13.11 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
860,CVE-2017-16546,"  static Image *ReadWPGImage(const ImageInfo *image_info,
               WPG_Palette.StartIndex=ReadBlobLSBShort(image);
               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                  (Rec2.RecordLength-2-2)/3)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              if (WPG_Palette.StartIndex > WPG_Palette.NumOfEntries)
                 ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
               image->colors=WPG_Palette.NumOfEntries;
               if (!AcquireImageColormap(image,image->colors,exception))","The ReadWPGImage function in coders/wpg.c in ImageMagick 7.0.7-9 does not properly validate the colormap index in a WPG palette, which allows remote attackers to cause a denial of service (use of uninitialized data or invalid memory allocation) or possibly have unspecified other impact via a malformed WPG file."
861,CVE-2017-16535,"  int usb_get_bos_descriptor(struct usb_device *dev)
 	for (i = 0; i < num; i++) {
 		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
 
		if (total_len < sizeof(*cap) || total_len < cap->bLength) {
			dev->bos->desc->bNumDeviceCaps = i;
 			break;
		}
		length = cap->bLength;
 		total_len -= length;
 
 		if (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {",The usb_get_bos_descriptor function in drivers/usb/core/config.c in the Linux kernel before 4.13.10 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
862,CVE-2017-16534,"  int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,
 			elength = 1;
 			goto next_desc;
 		}
		if ((buflen < elength) || (elength < 3)) {
			dev_err(&intf->dev, ""invalid descriptor buffer length\n"");
			break;
		}
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&intf->dev, ""skipping garbage\n"");
 			goto next_desc;",The cdc_parse_cdc_header function in drivers/usb/core/message.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
863,CVE-2017-16533,"  static int usbhid_parse(struct hid_device *hid)
 	unsigned int rsize = 0;
 	char *rdesc;
 	int ret, n;
	int num_descriptors;
	size_t offset = offsetof(struct hid_descriptor, desc);
 
 	quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),
 			le16_to_cpu(dev->descriptor.idProduct));
  static int usbhid_parse(struct hid_device *hid)
 		return -ENODEV;
 	}
 
	if (hdesc->bLength < sizeof(struct hid_descriptor)) {
		dbg_hid(""hid descriptor is too short\n"");
		return -EINVAL;
	}

 	hid->version = le16_to_cpu(hdesc->bcdHID);
 	hid->country = hdesc->bCountryCode;
 
	num_descriptors = min_t(int, hdesc->bNumDescriptors,
	       (hdesc->bLength - offset) / sizeof(struct hid_class_descriptor));

	for (n = 0; n < num_descriptors; n++)
 		if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);
 ",The usbhid_parse function in drivers/hid/usbhid/hid-core.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
864,CVE-2017-16532,"  get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			return tmp;
 	}
 
	if (in)
 		dev->in_pipe = usb_rcvbulkpipe(udev,
 			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
	if (out)
 		dev->out_pipe = usb_sndbulkpipe(udev,
 			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);

 	if (iso_in) {
 		dev->iso_in = &iso_in->desc;
 		dev->in_iso_pipe = usb_rcvisocpipe(udev,",The get_endpoints function in drivers/usb/misc/usbtest.c in the Linux kernel through 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a crafted USB device.
865,CVE-2017-16531,"  static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 		} else if (header->bDescriptorType ==
 				USB_DT_INTERFACE_ASSOCIATION) {
			struct usb_interface_assoc_descriptor *d;

			d = (struct usb_interface_assoc_descriptor *)header;
			if (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {
				dev_warn(ddev,
					 ""config %d has an invalid interface association descriptor of length %d, skipping\n"",
					 cfgno, d->bLength);
				continue;
			}

 			if (iad_num == USB_MAXIADS) {
 				dev_warn(ddev, ""found more Interface ""
 					       ""Association Descriptors ""
 					       ""than allocated for in ""
 					       ""configuration %d\n"", cfgno);
 			} else {
				config->intf_assoc[iad_num] = d;
 				iad_num++;
 			}
 ","drivers/usb/core/config.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to the USB_DT_INTERFACE_ASSOCIATION descriptor."
866,CVE-2017-16530,"  static int uas_is_interface(struct usb_host_interface *intf)
 		intf->desc.bInterfaceProtocol == USB_PR_UAS);
 }
 
static struct usb_host_interface *uas_find_uas_alt_setting(
		struct usb_interface *intf)
 {
 	int i;
 
 	for (i = 0; i < intf->num_altsetting; i++) {
 		struct usb_host_interface *alt = &intf->altsetting[i];
 
 		if (uas_is_interface(alt))
			return alt;
 	}
 
	return NULL;
 }
 
 static int uas_find_endpoints(struct usb_host_interface *alt,
  static int uas_use_uas_driver(struct usb_interface *intf,
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_hcd *hcd = bus_to_hcd(udev->bus);
 	unsigned long flags = id->driver_info;
	struct usb_host_interface *alt;
	int r;
 
 	alt = uas_find_uas_alt_setting(intf);
	if (!alt)
 		return 0;
 
	r = uas_find_endpoints(alt, eps);
 	if (r < 0)
 		return 0;
 ","The uas driver in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to drivers/usb/storage/uas-detect.h and drivers/usb/storage/uas.c."
867,CVE-2017-16529,"  static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	struct usb_interface_descriptor *altsd;
 	void *control_header;
 	int i, protocol;
	int rest_bytes;
 
 	 
 	host_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];
  static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 		return -EINVAL;
 	}
 
	rest_bytes = (void *)(host_iface->extra + host_iface->extralen) -
		control_header;

	 
	if (rest_bytes <= 0) {
		dev_err(&dev->dev, ""invalid control header\n"");
		return -EINVAL;
	}

 	switch (protocol) {
 	default:
 		dev_warn(&dev->dev,
  static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
		if (rest_bytes < sizeof(*h1)) {
			dev_err(&dev->dev, ""too short v1 buffer descriptor\n"");
			return -EINVAL;
		}

 		if (!h1->bInCollection) {
 			dev_info(&dev->dev, ""skipping empty audio interface (v1)\n"");
 			return -EINVAL;
 		}
 
		if (rest_bytes < h1->bLength) {
			dev_err(&dev->dev, ""invalid buffer length (v1)\n"");
			return -EINVAL;
		}

 		if (h1->bLength < sizeof(*h1) + h1->bInCollection) {
 			dev_err(&dev->dev, ""invalid UAC_HEADER (v1)\n"");
 			return -EINVAL;",The snd_usb_create_streams function in sound/usb/card.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
868,CVE-2017-16528,"  void snd_seq_device_load_drivers(void)
 	flush_work(&autoload_work);
 }
 EXPORT_SYMBOL(snd_seq_device_load_drivers);
#define cancel_autoload_drivers()	cancel_work_sync(&autoload_work)
 #else
 #define queue_autoload_drivers()  
#define cancel_autoload_drivers()  
 #endif
 
 /*
  static int snd_seq_device_dev_free(struct snd_device *device)
 {
 	struct snd_seq_device *dev = device->device_data;
 
	cancel_autoload_drivers();
 	put_device(&dev->dev);
 	return 0;
 }",sound/core/seq_device.c in the Linux kernel before 4.13.4 allows local users to cause a denial of service (snd_rawmidi_dev_seq_free use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.
869,CVE-2017-16527,"  static int parse_audio_unit(struct mixer_build *state, int unitid)
 
 static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)
 {
	 
	snd_usb_mixer_disconnect(mixer);

 	kfree(mixer->id_elems);
 	if (mixer->urb) {
 		kfree(mixer->urb->transfer_buffer);
  int snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,
 
 void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)
 {
	if (mixer->disconnected)
		return;
	if (mixer->urb)
		usb_kill_urb(mixer->urb);
	if (mixer->rc_urb)
		usb_kill_urb(mixer->rc_urb);
	mixer->disconnected = true;
 }
 
 #ifdef CONFIG_PM",sound/usb/mixer.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (snd_usb_mixer_interrupt use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.
870,CVE-2017-16526,"  static int uwbd(void *param)
  
 void uwbd_start(struct uwb_rc *rc)
 {
	struct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");
	if (IS_ERR(task)) {
		rc->uwbd.task = NULL;
 		printk(KERN_ERR ""UWB: Cannot start management daemon; ""
 		       ""UWB won't work\n"");
	} else {
		rc->uwbd.task = task;
 		rc->uwbd.pid = rc->uwbd.task->pid;
	}
 }
 
  
 void uwbd_stop(struct uwb_rc *rc)
 {
	if (rc->uwbd.task)
		kthread_stop(rc->uwbd.task);
 	uwbd_flush(rc);
 }
 ",drivers/uwb/uwbd.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (general protection fault and system crash) or possibly have unspecified other impact via a crafted USB device.
871,CVE-2017-16525,"  static int usb_console_setup(struct console *co, char *options)
 	tty_kref_put(tty);
  reset_open_count:
 	port->port.count = 0;
	info->port = NULL;
 	usb_autopm_put_interface(serial->interface);
  error_get_interface:
 	usb_serial_put(serial);","The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup."
872,CVE-2017-16359,"  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;","In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c."
873,CVE-2017-16358,"  static int string_scan_range(RList *list, const ut8 *buf, int min,
 				 
 				switch (str_type) {
 				case R_STRING_TYPE_WIDE:
					if (str_start > 1) {
						const ut8 *p = buf + str_start - 2;
 						if (p[0] == 0xff && p[1] == 0xfe) {
 							str_start -= 2;  
 						}
 					}
 					break;
 				case R_STRING_TYPE_WIDE32:
					if (str_start > 3) {
						const ut8 *p = buf + str_start - 4;
 						if (p[0] == 0xff && p[1] == 0xfe) {
 							str_start -= 4;  
 						}","In radare 2.0.1, an out-of-bounds read vulnerability exists in string_scan_range() in libr/bin/bin.c when doing a string search."
874,CVE-2017-16357,"  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		return false;
 	}
 	link_shdr = &bin->shdr[shdr->sh_link];
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
 		return false;
 	}
 	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
  static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 	if (shdr->sh_link > bin->ehdr.e_shnum) {
 		return NULL;
 	}
	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
 		return NULL;
 	}
 	sdb = sdb_new0 ();","In radare 2.0.1, a memory corruption vulnerability exists in store_versioninfo_gnu_verdef() and store_versioninfo_gnu_verneed() in libr/bin/format/elf/elf.c, as demonstrated by an invalid free. This error is due to improper sh_size validation when allocating memory."
875,CVE-2017-16355,"  class Spawner {
 		prepareChroot(info, options);
 		info.userSwitching = prepareUserSwitching(options);
 		prepareSwitchingWorkingDirectory(info, options);
 		return info;
 	}
 
  class Spawner {
 		assert(info.appRootPathsInsideChroot.back() == info.appRootInsideChroot);
 	}
 
#ifdef false
 	void inferApplicationInfo(SpawnPreparationInfo &info) const {
 		info.codeRevision = readFromRevisionFile(info);
 		if (info.codeRevision.empty()) {
  class Spawner {
 			return string();
 		}
 	}
#endif
 
 	bool shouldLoadShellEnvvars(const Options &options, const SpawnPreparationInfo &preparation) const {
 		if (options.loadShellEnvvars) {","In agent/Core/SpawningKit/Spawner.h in Phusion Passenger 5.1.10 (fixed in Passenger Open Source 5.1.11 and Passenger Enterprise 5.1.10), if Passenger is running as root, it is possible to list the contents of arbitrary files on a system by symlinking a file named REVISION from the application root folder to a file of choice and querying passenger-status --show=xml."
876,CVE-2017-15951,"  struct key_restriction {
 	struct key_type *keytype;
 };
 
enum key_state {
	KEY_IS_UNINSTANTIATED,
	KEY_IS_POSITIVE,		 
};

  
  
	short			state;		 
 
 #ifdef KEY_DEBUGGING
 	unsigned		magic;
 #define KEY_DEBUG_MAGIC		0x18273645u
 #endif
 
 	unsigned long		flags;		 
#define KEY_FLAG_DEAD		0	 
#define KEY_FLAG_REVOKED	1	 
#define KEY_FLAG_IN_QUOTA	2	 
#define KEY_FLAG_USER_CONSTRUCT	3	 
#define KEY_FLAG_ROOT_CAN_CLEAR	4	 
#define KEY_FLAG_INVALIDATED	5	 
#define KEY_FLAG_BUILTIN	6	 
#define KEY_FLAG_ROOT_CAN_INVAL	7	 
#define KEY_FLAG_KEEP		8	 
#define KEY_FLAG_UID_KEYRING	9	 
 
 	 
 #define	KEY_NEED_ALL	0x3f	 
 
static inline short key_read_state(const struct key *key)
{
	 
	return smp_load_acquire(&key->state);
}

  
static inline bool key_is_positive(const struct key *key)
{
	return key_read_state(key) == KEY_IS_POSITIVE;
}

static inline bool key_is_negative(const struct key *key)
 {
	return key_read_state(key) < 0;
 }
 
 #define dereference_key_rcu(KEY)					\","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
877,CVE-2017-15932,"  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_hash = READ32 (dfs, j)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
		int vdaux = verdef->vd_aux;
		if (vdaux < 1) {
			sdb_free (sdb_verdef);
			goto out_error;
		}
		vstart += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;","In radare2 2.0.1, an integer exception (negative number leading to an invalid memory access) exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c via crafted ELF files when parsing the ELF version on 32bit systems."
878,CVE-2017-15931,"  static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 			free (s);
 		}
 		sdb_num_set (sdb_version, ""cnt"", entry->vn_cnt, 0);
		st32 vnaux = entry->vn_aux;
		if (vnaux < 1) {
			goto beach;
		}
		vstart += vnaux;
 		for (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {
 			int k;
 			Elf_(Vernaux) * aux = NULL;","In radare2 2.0.1, an integer exception (negative number leading to an invalid memory access) exists in store_versioninfo_gnu_verneed() in libr/bin/format/elf/elf.c via crafted ELF files on 32bit systems."
879,CVE-2017-15924,"  destroy_server(struct server *server) {
 }
 
 static void
build_config(char *prefix, struct manager_ctx *manager, struct server *server)
 {
     char *path    = NULL;
     int path_size = strlen(prefix) + strlen(server->port) + 20;
  build_config(char *prefix, struct server *server)
     fprintf(f, ""{\n"");
     fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
     fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->method)
        fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    else if (manager->method)
        fprintf(f, "",\n\""method\"":\""%s\"""", manager->method);
    if (server->fast_open[0])
        fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)
        fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->plugin)
        fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts)
        fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
     fprintf(f, ""\n}\n"");
     fclose(f);
     ss_free(path);
  static char *
 construct_command_line(struct manager_ctx *manager, struct server *server)
 {
     static char cmd[BUF_SIZE];
     int i;
    int port;
 
    port = atoi(server->port);

    build_config(working_dir, manager, server);
 
     memset(cmd, 0, BUF_SIZE);
     snprintf(cmd, BUF_SIZE,
             ""%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf"",
             executable, manager->manager_address, working_dir, port, working_dir, port);
 
     if (manager->acl != NULL) {
         int len = strlen(cmd);","In manager.c in ss-manager in shadowsocks-libev 3.1.0, improper parsing allows command injection via shell metacharacters in a JSON configuration request received via 127.0.0.1 UDP traffic, related to the add_server, build_config, and construct_command_line functions."
880,CVE-2017-15906," 
 
 /*
  * Copyright (c) 2000-2004 Markus Friedl.  All rights reserved.
  *
  process_open(u_int32_t id)
 	logit(""open \""%s\"" flags %s mode 0%o"",
 	    name, string_from_portable(pflags), mode);
 	if (readonly &&
	    ((flags & O_ACCMODE) != O_RDONLY ||
	    (flags & (O_CREAT|O_TRUNC)) != 0)) {
 		verbose(""Refusing open request in read-only mode"");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {","The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files."
881,CVE-2017-15868,"  int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)
 
 	BT_DBG("""");
 
	if (!l2cap_is_socket(sock))
		return -EBADFD;

 	baswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);
 	baswap((void *) src, &l2cap_pi(sock->sk)->chan->src);
 ","The bnep_add_connection function in net/bluetooth/bnep/core.c in the Linux kernel before 3.19 does not ensure that an l2cap socket is available, which allows local users to gain privileges via a crafted application."
882,CVE-2017-15649,"  static int packet_do_bind(struct sock *sk, const char *name, int ifindex,
 	int ret = 0;
 	bool unlisted = false;
 
 	lock_sock(sk);
 	spin_lock(&po->bind_lock);
 	rcu_read_lock();
 
	if (po->fanout) {
		ret = -EINVAL;
		goto out_unlock;
	}

 	if (name) {
 		dev = dev_get_by_name_rcu(sock_net(sk), name);
 		if (!dev) {","net/packet/af_packet.c in the Linux kernel before 4.13.6 allows local users to gain privileges via crafted system calls that trigger mishandling of packet_fanout data structures, because of a race condition (involving fanout_add and packet_do_bind) that leads to a use-after-free, a different vulnerability than CVE-2017-6346."
883,CVE-2017-15537,"  int xstateregs_set(struct task_struct *target, const struct user_regset *regset,
 			ret = copy_user_to_xstate(xsave, ubuf);
 	} else {
 		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);

		 
		if (!ret && xsave->header.xcomp_bv)
			ret = -EINVAL;
 	}
 
 	/*","The x86/fpu (Floating Point Unit) subsystem in the Linux kernel before 4.13.5, when a processor supports the xsave feature but not the xsaves feature, does not correctly handle attempts to set reserved bits in the xstate header via the ptrace() or rt_sigreturn() system call, allowing local users to read the FPU registers of other processes on the system, related to arch/x86/kernel/fpu/regset.c and arch/x86/kernel/fpu/signal.c."
884,CVE-2017-15385,"  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
		if ((st32)verdef->vd_next < 1) {
			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
			break;
		}
 		i += verdef->vd_next;
 	}
 	free (defs);",The store_versioninfo_gnu_verdef function in libr/bin/format/elf/elf.c in radare2 2.0.0 allows remote attackers to cause a denial of service (r_read_le16 invalid write and application crash) or possibly have unspecified other impact via a crafted ELF file.
885,CVE-2017-15377," 
                    det_ctx->discontinue_matching = 1;
                }

                 goto no_match;
             } else if (found == NULL && (cd->flags & DETECT_CONTENT_NEGATED)) {
                 goto match;
  int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx
                         SCLogWarning(SC_ERR_INVALID_VALUE, ""Can't modify payload without packet"");
                     }
                 }
 
                 
                 if (smd->is_last) {
                    goto match;
                 }
 
                 SCLogDebug(""content %""PRIu32, cd->id);
  int DetectEngineContentInspection(DetectEngineCtx *de_ctx, DetectEngineThreadCtx
                 if (r == 1) {
                     SCReturnInt(1);
                 }
                SCLogDebug(""no match for 'next sm'"");
 
                if (det_ctx->discontinue_matching) {
                    SCLogDebug(""'next sm' said to discontinue this right now"");
                     goto no_match;
                }

                 
                if ((cd->flags & DETECT_CONTENT_RELATIVE_NEXT) == 0) {
                    SCLogDebug(""'next sm' does not depend on me, so we can give up"");
                    det_ctx->discontinue_matching = 1;
                    goto no_match;
                }

                SCLogDebug(""'next sm' depends on me %p, lets see what we can do (flags %u)"", cd, cd->flags);
 
                  
                 prev_offset = (match_offset - (cd->content_len - 1));","In Suricata before 4.x, it was possible to trigger lots of redundant checks on the content of crafted network traffic with a certain signature, because of DetectEngineContentInspection in detect-engine-content-inspection.c. The search engine doesn't stop when it should after no match is found; instead, it stops only upon reaching inspection-recursion-limit (3000 by default)."
886,CVE-2017-15368,"  int wasm_asm(const char *str, unsigned char *buf, int buf_len) {
 int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {
 	op->len = 1;
 	op->op = buf[0];
	if (op->op > 0xbf) {
		return 1;
	}
 	 
 	WasmOpDef *opdef = &opcodes[op->op];
 	switch (op->op) {
  int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {
 		{
 			ut32 count = 0, *table = NULL, def = 0;
 			size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);
			if (!(n > 0 && n < buf_len)) {
				goto err;
			}
			if (!(table = calloc (count, sizeof (ut32)))) {
				goto err;
			}
 			int i = 0;
 			op->len += n;
 			for (i = 0; i < count; i++) {
 				n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);
				if (!(op->len + n <= buf_len)) {
					goto beach;
				}
 				op->len += n;
 			}
 			n = read_u32_leb128 (buf + op->len, buf + buf_len, &def);
			if (!(n > 0 && n + op->len < buf_len)) {
				goto beach;
			}
 			op->len += n;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d "", opdef->txt, count);
			for (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {
				int optxtlen = strlen (op->txt);
				snprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, ""%d "", table[i]);
 			}	
 			snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, ""%d"", def);
 			free (table);
 			break;
 			beach:
			free (table);
			goto err;
 		}
 		break;
 	case WASM_OP_CALLINDIRECT:
  int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {
 	snprintf (op->txt, R_ASM_BUFSIZE, ""invalid"");
 	return op->len;
 }
887,CVE-2017-15306,"  int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 		break;
 #endif
 	case KVM_CAP_PPC_HTM:
		r = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;
 		break;
 	default:
 		r = 0;",The kvm_vm_ioctl_check_extension function in arch/powerpc/kvm/powerpc.c in the Linux kernel before 4.13.11 allows local users to cause a denial of service (NULL pointer dereference and system crash) via a KVM_CHECK_EXTENSION KVM_CAP_PPC_HTM ioctl call to /dev/kvm.
888,CVE-2017-15277,"  static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
    sizeof(*global_colormap));
   if (BitSet((int) flag,0x80) != 0)
     {
       count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);","ReadGIFImage in coders/gif.c in ImageMagick 7.0.6-1 and GraphicsMagick 1.3.26 leaves the palette uninitialized when processing a GIF file that has neither a global nor local palette. If the affected product is used as a library loaded into a process that operates on interesting data, this data sometimes can be leaked via the uninitialized palette."
889,CVE-2017-15274,"  SYSCALL_DEFINE5(add_key, const char __user *, _type,
 	 
 	payload = NULL;
 
	if (plen) {
 		ret = -ENOMEM;
 		payload = kvmalloc(plen, GFP_KERNEL);
 		if (!payload)
  long keyctl_update_key(key_serial_t id,
 
 	 
 	payload = NULL;
	if (plen) {
 		ret = -ENOMEM;
 		payload = kmalloc(plen, GFP_KERNEL);
 		if (!payload)","security/keys/keyctl.c in the Linux kernel before 4.11.5 does not consider the case of a NULL payload in conjunction with a nonzero length value, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted add_key or keyctl system call, a different vulnerability than CVE-2017-12192."
890,CVE-2017-15265,"  static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
	int port_idx;
 
 	 
 	if (info->addr.client != client->number)
  static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 		return -ENOMEM;
 
 	if (client->type == USER_CLIENT && info->kernel) {
		port_idx = port->addr.port;
		snd_seq_port_unlock(port);
		snd_seq_delete_port(client, port_idx);
 		return -EINVAL;
 	}
 	if (client->type == KERNEL_CLIENT) {
  static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);
	snd_seq_port_unlock(port);
 
 	return 0;
 }","Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c."
891,CVE-2017-15116," 
  * RNG operations.
  *
  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>
 * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
  static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)
 	return container_of(tfm, struct crypto_rng, base);
 }
 
 int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 {
 	u8 *buf = NULL;
  int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 		seed = buf;
 	}
 
	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
 
 	kfree(buf);
 	return err;
  EXPORT_SYMBOL_GPL(crypto_rng_reset);
 
 static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
 {
 	return 0;
 }
 
 static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
	return ralg->seedsize;
 }
 
 #ifdef CONFIG_NET
  static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
 	seq_printf(m, ""seedsize     : %u\n"", seedsize(alg));
 }
 
static const struct crypto_type crypto_rng_type = {
 	.extsize = crypto_alg_extsize,
 	.init_tfm = crypto_rng_init_tfm,
 #ifdef CONFIG_PROC_FS
  const struct crypto_type crypto_rng_type = {
 	.type = CRYPTO_ALG_TYPE_RNG,
 	.tfmsize = offsetof(struct crypto_rng, base),
 };
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {",The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).
892,CVE-2017-15115,"  int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	struct socket *sock;
 	int err = 0;
 
	 
	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
		return -EINVAL;

 	if (!asoc)
 		return -EINVAL;
 ","The sctp_do_peeloff function in net/sctp/socket.c in the Linux kernel before 4.14 does not check whether the intended netns is used in a peel-off action, which allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls."
893,CVE-2017-15102,"  static int tower_probe (struct usb_interface *interface, const struct usb_device
 	dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;
 	dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;
 
 	 
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
  static int tower_probe (struct usb_interface *interface, const struct usb_device
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
	 
	usb_set_intfdata (interface, dev);

	retval = usb_register_dev (interface, &tower_class);

	if (retval) {
		 
		dev_err(idev, ""Not able to get a minor for this device.\n"");
		usb_set_intfdata (interface, NULL);
		goto error;
	}
	dev->minor = interface->minor;

	 
	dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major ""
		 ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),
		 USB_MAJOR, dev->minor);
 
 exit:
 	return retval;",The tower_probe function in drivers/usb/misc/legousbtower.c in the Linux kernel before 4.8.1 allows local users (who are physically proximate for inserting a crafted USB device) to gain privileges by leveraging a write-what-where condition that occurs after a race condition and a NULL pointer dereference.
894,CVE-2017-15088,"  crypto_retrieve_X509_key_usage(krb5_context context,
     return retval;
 }
 
static krb5_error_code
rfc2253_name(X509_NAME *name, char **str_out)
 {
    BIO *b = NULL;
    char *str;
 
    *str_out = NULL;
    b = BIO_new(BIO_s_mem());
    if (b == NULL)
        return ENOMEM;
    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)
        goto error;
    str = calloc(BIO_number_written(b) + 1, 1);
    if (str == NULL)
        goto error;
    BIO_read(b, str, BIO_number_written(b));
    BIO_free(b);
    *str_out = str;
    return 0;

error:
    BIO_free(b);
    return ENOMEM;
 }
 
  
    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);
    if (ret)
         goto cleanup;
    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);
    if (ret)
         goto cleanup;
 
      
     ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,","plugins/preauth/pkinit/pkinit_crypto_openssl.c in MIT Kerberos 5 (aka krb5) through 1.15.2 mishandles Distinguished Name (DN) fields, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) in situations involving untrusted X.509 data, related to the get_matching_data and X509_NAME_oneline_ex functions. NOTE: this has security relevance only in use cases outside of the MIT Kerberos distribution, e.g., the use of get_matching_data in KDC certauth plugin code that is specific to Red Hat."
895,CVE-2017-15033,"  static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)
       horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,
       MagickTrue,exception);
     if (chroma_image == (Image *) NULL)
      {
        scanline=(unsigned char *) RelinquishMagickMemory(scanline); 
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
      
  static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)
         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
         if (status == MagickFalse)
           {
            scanline=(unsigned char *) RelinquishMagickMemory(scanline); 
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
  static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)
         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
         if (status == MagickFalse)
           {
            scanline=(unsigned char *) RelinquishMagickMemory(scanline); 
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
  static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)
           status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
           if (status == MagickFalse)
             {
              scanline=(unsigned char *) RelinquishMagickMemory(scanline); 
               image=DestroyImageList(image);
               return((Image *) NULL);
             }
  static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)
       TriangleFilter,exception);
     chroma_image=DestroyImage(chroma_image);
     if (resize_image == (Image *) NULL)
      {
        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
  static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
            scanline=(unsigned char *) RelinquishMagickMemory(scanline); 
             image=DestroyImageList(image);
             return((Image *) NULL);
           }",ImageMagick version 7.0.7-2 contains a memory leak in ReadYUVImage in coders/yuv.c.
896,CVE-2017-15032,"  static Image *ReadYCBCRImage(const ImageInfo *image_info,
     if (status == MagickFalse)
     {
       quantum_info=DestroyQuantumInfo(quantum_info);
      canvas_image=DestroyImage(canvas_image);
       return(DestroyImageList(image));
     }
     SetImageColorspace(image,YCbCrColorspace,exception);",ImageMagick version 7.0.7-2 contains a memory leak in ReadYCBCRImage in coders/ycbcr.c.
897,CVE-2017-14991,"  sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)
 	list_for_each_entry(srp, &sfp->rq_list, entry) {
 		if (val > SG_MAX_QUEUE)
 			break;
 		rinfo[val].req_state = srp->done + 1;
 		rinfo[val].problem =
 			srp->header.masked_status &
  sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
 		else {
 			sg_req_info_t *rinfo;
 
			rinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
					GFP_KERNEL);
 			if (!rinfo)
 				return -ENOMEM;
 			read_lock_irqsave(&sfp->rq_list_lock, iflags);",The sg_ioctl function in drivers/scsi/sg.c in the Linux kernel before 4.13.4 allows local users to obtain sensitive information from uninitialized kernel heap-memory locations via an SG_GET_REQUEST_TABLE ioctl call for /dev/sg0.
898,CVE-2017-14954,"  SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;

 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
  COMPAT_SYSCALL_DEFINE5(waitid,
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
		if (uru) {
			 
			if (COMPAT_USE_64BIT_TIME)
				err = copy_to_user(uru, &ru, sizeof(ru));
			else
				err = put_compat_rusage(&ru, uru);
			if (err)
				return -EFAULT;
		}
 	}
 
 	if (!infop)","The waitid implementation in kernel/exit.c in the Linux kernel through 4.13.4 accesses rusage data structures in unintended cases, which allows local users to obtain sensitive information, and bypass the KASLR protection mechanism, via a crafted system call."
899,CVE-2017-14767,"  static int sdp_parse_fmtp_config_h264(AVFormatContext *s,
             parse_profile_level_id(s, h264_data, value);
     } else if (!strcmp(attr, ""sprop-parameter-sets"")) {
         int ret;
        if (*value == 0 || value[strlen(value) - 1] == ',') {
             av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
             return 0;
         }","The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file."
900,CVE-2017-14646,"  AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :
     m_SequenceParameters.EnsureCapacity(num_seq_params);
     unsigned int cursor = 6;
     for (unsigned int i=0; i<num_seq_params; i++) {
        if (cursor+2 <= payload_size) {
            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);
            cursor += 2;
            if (cursor + param_length < payload_size) {
                m_SequenceParameters.Append(AP4_DataBuffer());
                m_SequenceParameters[i].SetData(&payload[cursor], param_length);
                cursor += param_length;
            }
        }
     }
     AP4_UI08 num_pic_params = payload[cursor++];
     m_PictureParameters.EnsureCapacity(num_pic_params);
     for (unsigned int i=0; i<num_pic_params; i++) {
        if (cursor+2 <= payload_size) {
            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);
            cursor += 2;
            if (cursor + param_length < payload_size) {
                m_PictureParameters.Append(AP4_DataBuffer());
                m_PictureParameters[i].SetData(&payload[cursor], param_length);
                cursor += param_length;
            }
        }
     }
 }
 ","The AP4_AvccAtom and AP4_HvccAtom classes in Bento4 version 1.5.0-617 do not properly validate data sizes, leading to a heap-based buffer over-read and application crash in AP4_DataBuffer::SetData in Core/Ap4DataBuffer.cpp."
901,CVE-2017-14643,"  AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size,
      
      
      
    if ((AP4_UI08)name[0] == (AP4_UI08)(name_size-1)) {
         m_HandlerName = name+1;
     } else {
         m_HandlerName = name;","The AP4_HdlrAtom class in Core/Ap4HdlrAtom.cpp in Bento4 version 1.5.0-617 uses an incorrect character data type, leading to a heap-based buffer over-read and application crash in AP4_BytesToUInt32BE in Core/Ap4Utils.h."
902,CVE-2017-14642,"  AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size,
     stream.ReadUI32(m_Reserved[2]);
     
      
    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;
    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);
     char* name = new char[name_size+1];
    if (name == NULL) return;
     stream.Read(name, name_size);
     name[name_size] = '\0';  
      ","A NULL pointer dereference was discovered in the AP4_HdlrAtom class in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash in AP4_StdcFileByteStream::ReadPartial in System/StdC/Ap4StdCFileByteStream.cpp, which leads to remote denial of service."
903,CVE-2017-14641,"  AP4_AtomMetaDataValue::ToInteger() const
 +---------------------------------------------------------------------*/
 AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :
     AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE),
    m_DataType(DATA_TYPE_BINARY),
    m_Source(NULL)
 {
     AP4_MemoryByteStream* memory = new AP4_MemoryByteStream();
     AP4_Size payload_size = 8;
  AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :
 |   AP4_DataAtom::AP4_DataAtom
 +---------------------------------------------------------------------*/
 AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :
    AP4_Atom(AP4_ATOM_TYPE_DATA, size),
    m_Source(NULL)
 {
     if (size < AP4_ATOM_HEADER_SIZE+8) return;
 ","A NULL pointer dereference was discovered in the AP4_DataAtom class in MetaData/Ap4MetaData.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service."
904,CVE-2017-14640,"  AP4_AtomSampleTable::GetSample(AP4_Ordinal index,
     AP4_UI32 cts_offset = 0;
     AP4_UI64 dts        = 0;
     AP4_UI32 duration   = 0;
    if (m_SttsAtom) {
        result = m_SttsAtom->GetDts(index, dts, &duration);
        if (AP4_FAILED(result)) return result;
    }
     sample.SetDuration(duration);
     sample.SetDts(dts);
     if (m_CttsAtom == NULL) {","A NULL pointer dereference was discovered in AP4_AtomSampleTable::GetSample in Core/Ap4AtomSampleTable.cpp in Bento4 version 1.5.0-617. The vulnerability causes a segmentation fault and application crash, which leads to remote denial of service."
905,CVE-2017-14639,"  AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)
     stream.ReadUI32(m_Reserved3);
     stream.ReadUI16(m_FrameCount);
 
    AP4_UI08 compressor_name[33];
     compressor_name[32] = 0;
     stream.Read(compressor_name, 32);
    AP4_UI08 name_length = compressor_name[0];
     if (name_length < 32) {
         compressor_name[name_length+1] = 0;  
        m_CompressorName = (const char*)(&compressor_name[1]);
     }
 
     stream.ReadUI16(m_Depth);","AP4_VisualSampleEntry::ReadFields in Core/Ap4SampleEntry.cpp in Bento4 1.5.0-617 uses incorrect character data types, which causes a stack-based buffer underflow and out-of-bounds write, leading to denial of service (application crash) or possibly unspecified other impact."
906,CVE-2017-14638,"  AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream,
           case AP4_ATOM_TYPE_HVCE:
             if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
             atom = AP4_HvccAtom::Create(size_32, stream);
            if (atom) {
                atom->SetType(AP4_ATOM_TYPE_HVCE);
            }
             break;
 
           case AP4_ATOM_TYPE_AVCE:
             if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;
             atom = AP4_AvccAtom::Create(size_32, stream);
            if (atom) {
                atom->SetType(AP4_ATOM_TYPE_AVCE);
            }
             break;
 
     #if !defined(AP4_CONFIG_MINI_BUILD)","AP4_AtomFactory::CreateAtomFromStream in Core/Ap4AtomFactory.cpp in Bento4 version 1.5.0-617 has missing NULL checks, leading to a NULL pointer dereference, segmentation fault, and application crash in AP4_Atom::SetType in Core/Ap4Atom.h."
907,CVE-2017-14604," 
 #include ""nautilus-global-preferences.h""
 #include ""nautilus-link.h""
 #include ""nautilus-profile.h""
#include ""nautilus-metadata.h""
 #include <eel/eel-glib-extensions.h>
 #include <gtk/gtk.h>
 #include <libxml/parser.h>
  is_link_trusted (NautilusFile *file,
 {
     GFile *location;
     gboolean res;
    g_autofree gchar* trusted = NULL;
 
     if (!is_launcher)
     {
         return TRUE;
     }
 
    trusted = nautilus_file_get_metadata (file,
                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
                                          NULL);
    if (nautilus_file_can_execute (file) && trusted != NULL)
     {
         return TRUE;
     }","GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious *sh -c* command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field."
908,CVE-2017-14502,"  read_header(struct archive_read *a, struct archive_entry *entry,
         return (ARCHIVE_FATAL);
       }
       filename[filename_size++] = '\0';
       
      filename[filename_size] = '\0';
 
        ","read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header."
909,CVE-2017-14500,"  void pb_controller::play_file(const std::string& file) {
 	if (player == """")
 		return;
 	cmdline.append(player);
	cmdline.append("" '"");
	cmdline.append(utils::replace_all(file,""'"", ""%27""));
	cmdline.append(""'"");
 	stfl::reset();
 	utils::run_interactively(cmdline, ""pb_controller::play_file"");
 }","Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904."
910,CVE-2017-14497,"  static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
 	struct timespec ts;
 	__u32 ts_status;
 	bool is_drop_n_account = false;
	bool do_vnet = false;
 
 	/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.
 	 * We may add members to them until current aligned size without forcing
  static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
 		netoff = TPACKET_ALIGN(po->tp_hdrlen +
 				       (maclen < 16 ? 16 : maclen)) +
 				       po->tp_reserve;
		if (po->has_vnet_hdr) {
 			netoff += sizeof(struct virtio_net_hdr);
			do_vnet = true;
		}
 		macoff = netoff - maclen;
 	}
 	if (po->tp_version <= TPACKET_V2) {
  static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
 					skb_set_owner_r(copy_skb, sk);
 			}
 			snaplen = po->rx_ring.frame_size - macoff;
			if ((int)snaplen < 0) {
 				snaplen = 0;
				do_vnet = false;
			}
 		}
 	} else if (unlikely(macoff + snaplen >
 			    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {
  static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
 		if (unlikely((int)snaplen < 0)) {
 			snaplen = 0;
 			macoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;
			do_vnet = false;
 		}
 	}
 	spin_lock(&sk->sk_receive_queue.lock);
  static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
 	}
 	spin_unlock(&sk->sk_receive_queue.lock);
 
	if (do_vnet) {
 		if (virtio_net_hdr_from_skb(skb, h.raw + macoff -
 					    sizeof(struct virtio_net_hdr),
 					    vio_le(), true)) {","The tpacket_rcv function in net/packet/af_packet.c in the Linux kernel before 4.13 mishandles vnet headers, which might allow local users to cause a denial of service (buffer overflow, and disk and memory corruption) or possibly have unspecified other impact via crafted system calls."
911,CVE-2017-14341,"  static Image *ReadWPGImage(const ImageInfo *image_info,
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
          if (Rec.RecordLength > GetBlobSize(image))
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           if(EOFBlob(image))
             break;
 ","ImageMagick 7.0.6-6 has a large loop vulnerability in ReadWPGImage in coders/wpg.c, causing CPU exhaustion via a crafted wpg image file."
912,CVE-2017-14340,"  static inline uint64_t howmany_64(uint64_t x, uint32_t y)
 #endif  
 
 #ifdef CONFIG_XFS_RT

 
#define XFS_IS_REALTIME_INODE(ip)			\
	(((ip)->i_d.di_flags & XFS_DIFLAG_REALTIME) &&	\
	 (ip)->i_mount->m_rtdev_targp)
 #else
 #define XFS_IS_REALTIME_INODE(ip) (0)
 #endif","The XFS_IS_REALTIME_INODE macro in fs/xfs/xfs_linux.h in the Linux kernel before 4.13.2 does not verify that a filesystem has a realtime device, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via vectors related to setting an RHINHERIT flag on a directory."
913,CVE-2017-14230,"  static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)
         if (len) len--;  
 
         if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {
            if (prefixlen <= len) {
                  
                 strlcpy(domainpat+domainlen, ""user."", sizeof(domainpat)-domainlen);
             }","In the mboxlist_do_find function in imap/mboxlist.c in Cyrus IMAP before 3.0.4, an off-by-one error in prefix calculation for the LIST command caused use of uninitialized memory, which might allow remote attackers to obtain sensitive information or cause a denial of service (daemon crash) via a 'LIST ** *Other Users*' command."
914,CVE-2017-14225,"  static void print_pkt_side_data(WriterContext *w,
     writer_print_section_footer(w);
 }
 
static void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)
{
    const char *val = av_color_primaries_name(color_primaries);
    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {
        print_str_opt(""color_primaries"", ""unknown"");
    } else {
        print_str(""color_primaries"", val);
    }
}

 static void clear_log(int need_lock)
 {
     int i;
  static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,
         else
             print_str_opt(""color_space"", av_color_space_name(frame->colorspace));
 
        print_primaries(w, frame->color_primaries);
 
         if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)
             print_str(""color_transfer"", av_color_transfer_name(frame->color_trc));
  static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_id
         else
             print_str_opt(""color_transfer"", av_color_transfer_name(par->color_trc));
 
        print_primaries(w, par->color_primaries);
 
         if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)
             print_str(""chroma_location"", av_chroma_location_name(par->chroma_location));","The av_color_primaries_name function in libavutil/pixdesc.c in FFmpeg 3.3.3 may return a NULL pointer depending on a value contained in a file, but callers do not anticipate this, as demonstrated by the avcodec_string function in libavcodec/utils.c, leading to a NULL pointer dereference. (It is also conceivable that there is security relevance for a NULL pointer dereference in av_color_primaries_name calls within the ffprobe command-line program.)"
915,CVE-2017-14223,"  static int asf_build_simple_index(AVFormatContext *s, int stream_index)
             int64_t pos       = s->internal->data_offset + s->packet_size * (int64_t)pktnum;
             int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);
 
            if (avio_feof(s->pb)) {
                ret = AVERROR_INVALIDDATA;
                goto end;
            }

             if (pos != last_pos) {
                 av_log(s, AV_LOG_DEBUG, ""pktnum:%d, pktct:%d  pts: %""PRId64""\n"",
                        pktnum, pktct, index_pts);","In libavformat/asfdec_f.c in FFmpeg 3.3.3, a DoS in asf_build_simple_index() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted ASF file, which claims a large *ict* field in the header but does not contain sufficient backing data, is provided, the for loop would consume huge CPU and memory resources, since there is no EOF check inside the loop."
916,CVE-2017-14222,"  static int read_tfra(MOVContext *mov, AVIOContext *f)
     }
     for (i = 0; i < index->item_count; i++) {
         int64_t time, offset;

        if (avio_feof(f)) {
            index->item_count = 0;
            av_freep(&index->items);
            return AVERROR_INVALIDDATA;
        }

         if (version == 1) {
             time   = avio_rb64(f);
             offset = avio_rb64(f);","In libavformat/mov.c in FFmpeg 3.3.3, a DoS in read_tfra() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MOV file, which claims a large *item_count* field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU and memory resources, since there is no EOF check inside the loop."
917,CVE-2017-14175,"  static MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)
 %
 */
 
static int XBMInteger(Image *image,short int *hex_digits)
 { 
   int
     c;
  static unsigned int XBMInteger(Image *image,short int *hex_digits)
   { 
     c=ReadBlobByte(image);
     if (c == EOF)
      return(-1);
   } while ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r'));
   /*
     Evaluate number.
  static unsigned int XBMInteger(Image *image,short int *hex_digits)
     value+=hex_digits[c];
     c=ReadBlobByte(image);
     if (c == EOF)
      return(-1);
   }
  return((int) value);
 }
 
 static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
  static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
   Image
     *image;
 
  int
    c;

   MagickBooleanType
     status;
 
  static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
     height,
     length,
     padding,
     version,
     width;
 
  static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if (version == 10)
     for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))
     {
      c=XBMInteger(image,hex_digits);
      if (c < 0)
        break;
      *p++=(unsigned char) c;
       if ((padding == 0) || (((i+2) % bytes_per_line) != 0))
        *p++=(unsigned char) (c >> 8);
     }
   else
     for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)
     {
       value=XBMInteger(image,hex_digits);
      if (c < 0)
        break;
      *p++=(unsigned char) c;
    }
  if (EOFBlob(image) != MagickFalse)
    {
      data=(unsigned char *) RelinquishMagickMemory(data);
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   /*
     Convert X bitmap image to pixel packets.
  static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       if (bit == 0)
        byte=(unsigned int) (*p++);
       SetPixelIndex(indexes+x,(byte & 0x01) != 0 ? 0x01 : 0x00);
       bit++;
       byte>>=1;","In coders/xbm.c in ImageMagick 7.0.6-1 Q16, a DoS in ReadXBMImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted XBM file, which claims large rows and columns fields in the header but does not contain sufficient backing data, is provided, the loop over the rows would consume huge CPU resources, since there is no EOF check inside the loop."
918,CVE-2017-14174,"  static MagickBooleanType ReadPSDLayersInternal(Image *image,
                 {
                   size_t blend_source=ReadBlobLong(image);
                   size_t blend_dest=ReadBlobLong(image);
                  if (EOFBlob(image) != MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""InsufficientImageDataInFile"",image->filename);
                    }
                   if (image->debug != MagickFalse)
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""        source(%x), dest(%x)"",(unsigned int)","In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large *length* field in the header but does not contain sufficient backing data, is provided, the loop over *length* would consume huge CPU resources, since there is no EOF check inside the loop."
919,CVE-2017-14173,"  static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     image->columns=width;
     image->rows=height;
    if ((max_value == 0) || (max_value > 4294967295))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
     image->depth=depth;
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)","In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation *GetQuantumRange(depth)+1* when *depth* is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large *max_value* value."
920,CVE-2017-14172,"  static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
         if (count != 1)
           continue;
         length=extent;
        if (length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         profile=BlobToStringInfo((const void *) NULL,length);
         if (profile != (StringInfo *) NULL)
           {
  ModuleExport size_t RegisterPSImage(void)
   entry->decoder=(DecodeImageHandler *) ReadPSImage;
   entry->encoder=(EncodeImageHandler *) WritePSImage;
   entry->magick=(IsImageFormatHandler *) IsPS;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->blob_support=MagickFalse;
   entry->seekable_stream=MagickTrue;
  ModuleExport size_t RegisterPSImage(void)
   entry=SetMagickInfo(""EPS"");
   entry->decoder=(DecodeImageHandler *) ReadPSImage;
   entry->encoder=(EncodeImageHandler *) WritePSImage;
  entry->seekable_stream=MagickTrue;
   entry->magick=(IsImageFormatHandler *) IsPS;
   entry->adjoin=MagickFalse;
   entry->blob_support=MagickFalse;
  ModuleExport size_t RegisterPSImage(void)
   entry=SetMagickInfo(""EPSF"");
   entry->decoder=(DecodeImageHandler *) ReadPSImage;
   entry->encoder=(EncodeImageHandler *) WritePSImage;
  entry->seekable_stream=MagickTrue;
   entry->magick=(IsImageFormatHandler *) IsPS;
   entry->adjoin=MagickFalse;
   entry->blob_support=MagickFalse;
  ModuleExport size_t RegisterPSImage(void)
   entry=SetMagickInfo(""EPSI"");
   entry->decoder=(DecodeImageHandler *) ReadPSImage;
   entry->encoder=(EncodeImageHandler *) WritePSImage;
  entry->seekable_stream=MagickTrue;
   entry->magick=(IsImageFormatHandler *) IsPS;
   entry->adjoin=MagickFalse;
   entry->blob_support=MagickFalse;
  ModuleExport size_t RegisterPSImage(void)
   entry=SetMagickInfo(""PS"");
   entry->decoder=(DecodeImageHandler *) ReadPSImage;
   entry->encoder=(EncodeImageHandler *) WritePSImage;
  entry->seekable_stream=MagickTrue;
   entry->magick=(IsImageFormatHandler *) IsPS;
   entry->mime_type=ConstantString(""application/postscript"");
   entry->module=ConstantString(""PS"");","In coders/ps.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large *extent* field in the header but does not contain sufficient backing data, is provided, the loop over *length* would consume huge CPU resources, since there is no EOF check inside the loop."
921,CVE-2017-14171,"  static int nsv_parse_NSVf_header(AVFormatContext *s)
         if (!nsv->nsvs_file_offset)
             return AVERROR(ENOMEM);
 
        for(i=0;i<table_entries_used;i++) {
            if (avio_feof(pb))
                return AVERROR_INVALIDDATA;
             nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;
        }
 
         if(table_entries > table_entries_used &&
            avio_rl32(pb) == MKTAG('T','O','C','2')) {","In libavformat/nsvdec.c in FFmpeg 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large *table_entries_used* field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop."
922,CVE-2017-14170,"  static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *seg
     segment->nb_index_entries = avio_rb32(pb);
 
     length = avio_rb32(pb);
    if(segment->nb_index_entries && length < 11)
        return AVERROR_INVALIDDATA;
 
     if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
         !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
  static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *seg
     }
 
     for (i = 0; i < segment->nb_index_entries; i++) {
        if(avio_feof(pb))
            return AVERROR_INVALIDDATA;
         segment->temporal_offset_entries[i] = avio_r8(pb);
         avio_r8(pb);                                         
         segment->flag_entries[i] = avio_r8(pb);","In libavformat/mxfdec.c in FFmpeg 3.3.3, a DoS in mxf_read_index_entry_array() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted MXF file, which claims a large *nb_index_entries* field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop. Moreover, this big loop can be invoked multiple times if there is more than one applicable data segment in the crafted MXF file."
923,CVE-2017-14169,"  static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, U
         avpriv_request_sample(pb, ""Primer pack item length %d"", item_len);
         return AVERROR_PATCHWELCOME;
     }
    if (item_num > 65536 || item_num < 0) {
         av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num);
         return AVERROR_INVALIDDATA;
     }","In the mxf_read_primer_pack function in libavformat/mxfdec.c in FFmpeg 3.3.3, an integer signedness error might occur when a crafted file, which claims a large *item_num* field such as 0xffffffff, is provided. As a result, the variable *item_num* turns negative, bypassing the check for a large value."
924,CVE-2017-14166,"  atol10(const char *p, size_t char_cnt)
 	uint64_t l;
 	int digit;
 
	if (char_cnt == 0)
		return (0);

 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
  atol8(const char *p, size_t char_cnt)
 {
 	int64_t l;
 	int digit;

	if (char_cnt == 0)
		return (0);

 	l = 0;
 	while (char_cnt-- > 0) {
 		if (*p >= '0' && *p <= '7')","libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c."
925,CVE-2017-14164,"  static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k,
  * Writes the SOT marker (Start of tile-part)
  *
  * @param       p_j2k            J2K codec.
 * @param       p_data           Output buffer
 * @param       p_total_data_size Output buffer size
 * @param       p_data_written   Number of bytes written into stream
  * @param       p_stream         the stream to write data to.
  * @param       p_manager        the user event manager.
 */
 static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,
                                   OPJ_BYTE * p_data,
                                  OPJ_UINT32 p_total_data_size,
                                   OPJ_UINT32 * p_data_written,
                                   const opj_stream_private_t *p_stream,
                                   opj_event_mgr_t * p_manager);
  static OPJ_BOOL opj_j2k_write_tlm(opj_j2k_t *p_j2k,
 
 static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,
                                   OPJ_BYTE * p_data,
                                  OPJ_UINT32 p_total_data_size,
                                   OPJ_UINT32 * p_data_written,
                                   const opj_stream_private_t *p_stream,
                                   opj_event_mgr_t * p_manager
  static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,
     OPJ_UNUSED(p_stream);
     OPJ_UNUSED(p_manager);
 
    if (p_total_data_size < 12) {
        opj_event_msg(p_manager, EVT_ERROR,
                      ""Not enough bytes in output buffer to write SOT marker\n"");
        return OPJ_FALSE;
    }

     opj_write_bytes(p_data, J2K_MS_SOT,
                     2);                                  
     p_data += 2;
  static OPJ_BOOL opj_j2k_write_first_tile_part(opj_j2k_t *p_j2k,
 
     l_current_nb_bytes_written = 0;
     l_begin_data = p_data;
    if (! opj_j2k_write_sot(p_j2k, p_data, p_total_data_size,
                            &l_current_nb_bytes_written, p_stream,
                             p_manager)) {
         return OPJ_FALSE;
     }
  static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,
         l_part_tile_size = 0;
         l_begin_data = p_data;
 
        if (! opj_j2k_write_sot(p_j2k, p_data,
                                p_total_data_size,
                                &l_current_nb_bytes_written,
                                p_stream,
                                 p_manager)) {
             return OPJ_FALSE;
         }
  static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,
             l_part_tile_size = 0;
             l_begin_data = p_data;
 
            if (! opj_j2k_write_sot(p_j2k, p_data,
                                    p_total_data_size,
                                    &l_current_nb_bytes_written, p_stream,
                                     p_manager)) {
                 return OPJ_FALSE;
             }","A size-validation issue was discovered in opj_j2k_write_sot in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c) or possibly remote code execution. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-14152."
926,CVE-2017-14152,"  static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,
 
      
     parameters->csty |= 0x01;
    if (parameters->numresolution == 1) {
        parameters->res_spec = 1;
        parameters->prcw_init[0] = 128;
        parameters->prch_init[0] = 128;
    } else {
        parameters->res_spec = parameters->numresolution - 1;
        for (i = 0; i < parameters->res_spec; i++) {
            parameters->prcw_init[i] = 256;
            parameters->prch_init[i] = 256;
        }
     }
 
      ","A mishandled zero case was discovered in opj_j2k_set_cinema_parameters in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c and opj_j2k_write_sot in lib/openjp2/j2k.c) or possibly remote code execution."
927,CVE-2017-14151,"  static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *
 {
     OPJ_UINT32 l_data_size;
 
     
     
     
     
    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *
                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));
 
     if (l_data_size > p_code_block->data_size) {","An off-by-one error was discovered in opj_tcd_code_block_enc_allocate_data in lib/openjp2/tcd.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_mqc_flush in lib/openjp2/mqc.c and opj_t1_encode_cblk in lib/openjp2/t1.c) or possibly remote code execution."
928,CVE-2017-14140," 
 #include <linux/page_idle.h>
 #include <linux/page_owner.h>
 #include <linux/sched/mm.h>
#include <linux/ptrace.h>
 
 #include <asm/tlbflush.h>
 
  SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
 		const int __user *, nodes,
 		int __user *, status, int, flags)
 {
 	struct task_struct *task;
 	struct mm_struct *mm;
 	int err;
  SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
 
 	 
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {
 		rcu_read_unlock();
 		err = -EPERM;
 		goto out;","The move_pages system call in mm/migrate.c in the Linux kernel before 4.12.9 doesn't check the effective uid of the target process, enabling a local attacker to learn the memory layout of a setuid executable despite ASLR."
929,CVE-2017-14107,"  _zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offse
         zip_error_set(error, ZIP_ER_SEEK, EFBIG);
         return NULL;
     }
    if (offset+size > buf_offset + eocd_offset) {
	 
	zip_error_set(error, ZIP_ER_INCONS, 0);
	return NULL;
    }
    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {
 	zip_error_set(error, ZIP_ER_INCONS, 0);
 	return NULL;
     }","The _zip_read_eocd64 function in zip_open.c in libzip before 1.3.0 mishandles EOCD records, which allows remote attackers to cause a denial of service (memory allocation failure in _zip_cdir_grow in zip_dirent.c) via a crafted ZIP archive."
930,CVE-2017-14106,"  int tcp_disconnect(struct sock *sk, int flags)
 	tcp_set_ca_state(sk, TCP_CA_Open);
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
	 
	icsk->icsk_ack.rcv_mss = TCP_MIN_MSS;
 	tcp_init_send_head(sk);
 	memset(&tp->rx_opt, 0, sizeof(tp->rx_opt));
 	__sk_dst_reset(sk);",The tcp_disconnect function in net/ipv4/tcp.c in the Linux kernel before 4.12 allows local users to cause a denial of service (__tcp_select_window divide-by-zero error and system crash) by triggering a disconnect within a certain tcp_recvmsg code path.
931,CVE-2017-14059,"  static int cine_read_header(AVFormatContext *avctx)
 
      
     avio_seek(pb, offImageOffsets, SEEK_SET);
    for (i = 0; i < st->duration; i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;

         av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);
    }
 
     return 0;
 }","In FFmpeg 3.3.3, a DoS in cine_read_header() due to lack of an EOF check might cause huge CPU and memory consumption. When a crafted CINE file, which claims a large *duration* field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop."
932,CVE-2017-14057,"  static int asf_read_marker(AVFormatContext *s, int64_t size)
     count = avio_rl32(pb);     
     avio_rl16(pb);             
     name_len = avio_rl16(pb);  
    avio_skip(pb, name_len);
 
     for (i = 0; i < count; i++) {
         int64_t pres_time;
         int name_len;
 
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;

         avio_rl64(pb);              
         pres_time = avio_rl64(pb);  
         pres_time -= asf->hdr.preroll * 10000;","In FFmpeg 3.3.3, a DoS in asf_read_marker() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted ASF file, which claims a large *name_len* or *count* field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops."
933,CVE-2017-14056,"  static av_cold int rl2_read_header(AVFormatContext *s)
     }
 
      
    for(i=0; i < frame_count;i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;
         chunk_size[i] = avio_rl32(pb);
    }
    for(i=0; i < frame_count;i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;
         chunk_offset[i] = avio_rl32(pb);
    }
    for(i=0; i < frame_count;i++) {
        if (avio_feof(pb))
            return AVERROR_INVALIDDATA;
         audio_size[i] = avio_rl32(pb) & 0xFFFF;
    }
 
      
     for(i=0;i<frame_count;i++){","In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large *frame_count* field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops."
934,CVE-2017-14055,"  static int mv_read_header(AVFormatContext *avctx)
             uint32_t pos   = avio_rb32(pb);
             uint32_t asize = avio_rb32(pb);
             uint32_t vsize = avio_rb32(pb);
            if (avio_feof(pb))
                return AVERROR_INVALIDDATA;
             avio_skip(pb, 8);
             av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);
             av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);","In libavformat/mvdec.c in FFmpeg 3.3.3, a DoS in mv_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MV file, which claims a large *nb_frames* field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop."
935,CVE-2017-14054,"  static int ivr_read_header(AVFormatContext *s)
             av_log(s, AV_LOG_DEBUG, ""%s = '%s'\n"", key, val);
         } else if (type == 4) {
             av_log(s, AV_LOG_DEBUG, ""%s = '0x"", key);
            for (j = 0; j < len; j++) {
                if (avio_feof(pb))
                    return AVERROR_INVALIDDATA;
                 av_log(s, AV_LOG_DEBUG, ""%X"", avio_r8(pb));
            }
             av_log(s, AV_LOG_DEBUG, ""'\n"");
         } else if (len == 4 && type == 3 && !strncmp(key, ""StreamCount"", tlen)) {
             nb_streams = value = avio_rb32(pb);","In libavformat/rmdec.c in FFmpeg 3.3.3, a DoS in ivr_read_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted IVR file, which claims a large *len* field in the header but does not contain sufficient backing data, is provided, the first type==4 loop would consume huge CPU resources, since there is no EOF check inside the loop."
936,CVE-2017-14041,"  opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters)
     }
 
     fseek(f, 0, SEEK_SET);
    if (fscanf(f, ""PG%31[ \t]%c%c%31[ \t+-]%d%31[ \t]%d%31[ \t]%d"", temp, &endian1,
                &endian2, signtmp, &prec, temp, &w, temp, &h) != 9) {
         fclose(f);
         fprintf(stderr,","A stack-based buffer overflow was discovered in the pgxtoimage function in bin/jp2/convert.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution."
937,CVE-2017-14040,"  struct tga_header {
 };
 #endif  
 
 
static unsigned short get_tga_ushort(const unsigned char *data)
 {
    return data[0] | (data[1] << 8);
 }
 
 #define TGA_HEADER_SIZE 18
  static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,
     id_len = tga[0];
      
     image_type = tga[2];
     
    cmap_len = get_tga_ushort(&tga[5]);
     cmap_entry_size = tga[7];
 
 
 #if 0
    x_origin = get_tga_ushort(&tga[8]);
    y_origin = get_tga_ushort(&tga[10]);
 #endif
    image_w = get_tga_ushort(&tga[12]);
    image_h = get_tga_ushort(&tga[14]);
     pixel_depth = tga[16];
     image_desc  = tga[17];
 
  opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters)
         color_space = OPJ_CLRSPC_SRGB;
     }
 
     
     
    if (image_height != 0 && image_width > 10000000 / image_height / numcomps) {
        char ch;
        OPJ_UINT64 expected_file_size =
            (OPJ_UINT64)image_width * image_height * numcomps;
        long curpos = ftell(f);
        if (expected_file_size > (OPJ_UINT64)INT_MAX) {
            expected_file_size = (OPJ_UINT64)INT_MAX;
        }
        fseek(f, (long)expected_file_size - 1, SEEK_SET);
        if (fread(&ch, 1, 1, f) != 1) {
            fclose(f);
            return NULL;
        }
        fseek(f, curpos, SEEK_SET);
    }

     subsampling_dx = parameters->subsampling_dx;
     subsampling_dy = parameters->subsampling_dy;
 ","An invalid write access was discovered in bin/jp2/convert.c in OpenJPEG 2.2.0, triggering a crash in the tgatoimage function. The vulnerability may lead to remote denial of service or possibly unspecified other impact."
938,CVE-2017-14039,"  static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,
     assert(p_stream != 00);
 
     OPJ_UNUSED(p_stream);
 
     if (p_total_data_size < 12) {
         opj_event_msg(p_manager, EVT_ERROR,
  static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,
 
     OPJ_UNUSED(p_stream);
 
    if (p_total_data_size < 4) {
        opj_event_msg(p_manager, EVT_ERROR,
                      ""Not enough bytes in output buffer to write SOD marker\n"");
        return OPJ_FALSE;
    }

     opj_write_bytes(p_data, J2K_MS_SOD,
                     2);                                  
     p_data += 2;","A heap-based buffer overflow was discovered in the opj_t2_encode_packet function in lib/openjp2/t2.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly unspecified other impact."
939,CVE-2017-13725,"  rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2
 	register const struct in6_addr *addr;
 
 	dp = (const struct ip6_rthdr *)bp;
 
 	 
 	ep = ndo->ndo_snapend;
 
 	ND_TCHECK(dp->ip6r_segleft);
 
	len = dp->ip6r_len;
 	ND_PRINT((ndo, ""srcrt (len=%d"", dp->ip6r_len));	 
 	ND_PRINT((ndo, "", type=%d"", dp->ip6r_type));
 	ND_PRINT((ndo, "", segleft=%d"", dp->ip6r_segleft));",The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
940,CVE-2017-13715,"  bool __skb_flow_dissect(const struct sk_buff *skb,
 	struct flow_dissector_key_tags *key_tags;
 	struct flow_dissector_key_keyid *key_keyid;
 	u8 ip_proto = 0;
	bool ret = false;
 
 	if (!data) {
 		data = skb->data;
  bool __skb_flow_dissect(const struct sk_buff *skb,
 ip:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph || iph->ihl < 5)
			goto out_bad;
 		nhoff += iph->ihl * 4;
 
 		ip_proto = iph->protocol;
  bool __skb_flow_dissect(const struct sk_buff *skb,
 ipv6:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph)
			goto out_bad;
 
 		ip_proto = iph->nexthdr;
 		nhoff += sizeof(struct ipv6hdr);
  bool __skb_flow_dissect(const struct sk_buff *skb,
 
 		vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);
 		if (!vlan)
			goto out_bad;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_VLANID)) {
  bool __skb_flow_dissect(const struct sk_buff *skb,
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
			goto out_bad;
 		proto = hdr->proto;
 		nhoff += PPPOE_SES_HLEN;
 		switch (proto) {
  bool __skb_flow_dissect(const struct sk_buff *skb,
 		case htons(PPP_IPV6):
 			goto ipv6;
 		default:
			goto out_bad;
 		}
 	}
 	case htons(ETH_P_TIPC): {
  bool __skb_flow_dissect(const struct sk_buff *skb,
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
			goto out_bad;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {
  bool __skb_flow_dissect(const struct sk_buff *skb,
 			key_addrs->tipcaddrs.srcnode = hdr->srcnode;
 			key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;
 		}
		goto out_good;
 	}
 
 	case htons(ETH_P_MPLS_UC):
  bool __skb_flow_dissect(const struct sk_buff *skb,
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,
 					   hlen, &_hdr);
 		if (!hdr)
			goto out_bad;
 
 		if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>
 		     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {
  bool __skb_flow_dissect(const struct sk_buff *skb,
 					htonl(MPLS_LS_LABEL_MASK);
 			}
 
			goto out_good;
 		}
 
		goto out_good;
 	}
 
 	case htons(ETH_P_FCOE):
 		key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);
 		 
 	default:
		goto out_bad;
 	}
 
 ip_proto_again:
  bool __skb_flow_dissect(const struct sk_buff *skb,
 
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
			goto out_bad;
 		/*
 		 * Only look inside GRE if version zero and no
 		 * routing
  bool __skb_flow_dissect(const struct sk_buff *skb,
 						     data, hlen, &_keyid);
 
 			if (!keyid)
				goto out_bad;
 
 			if (skb_flow_dissector_uses_key(flow_dissector,
 							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
  bool __skb_flow_dissect(const struct sk_buff *skb,
 						   sizeof(_eth),
 						   data, hlen, &_eth);
 			if (!eth)
				goto out_bad;
 			proto = eth->h_proto;
 			nhoff += sizeof(*eth);
 		}
  bool __skb_flow_dissect(const struct sk_buff *skb,
 		opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),
 					      data, hlen, &_opthdr);
 		if (!opthdr)
			goto out_bad;
 
 		ip_proto = opthdr[0];
 		nhoff += (opthdr[1] + 1) << 3;
  bool __skb_flow_dissect(const struct sk_buff *skb,
 		break;
 	}
 
 	if (skb_flow_dissector_uses_key(flow_dissector,
 					FLOW_DISSECTOR_KEY_PORTS)) {
 		key_ports = skb_flow_dissector_target(flow_dissector,
  bool __skb_flow_dissect(const struct sk_buff *skb,
 							data, hlen);
 	}
 
out_good:
	ret = true;

out_bad:
	key_basic->n_proto = proto;
	key_basic->ip_proto = ip_proto;
	key_control->thoff = (u16)nhoff;

	return ret;
 }
 EXPORT_SYMBOL(__skb_flow_dissect);
 ","The __skb_flow_dissect function in net/core/flow_dissector.c in the Linux kernel before 4.3 does not ensure that n_proto, ip_proto, and thoff are initialized, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a single crafted MPLS packet."
941,CVE-2017-13695,"  AcpiNsEvaluate (
 
         Status = AE_OK;
     }
    else if (ACPI_FAILURE(Status)) 
    {
         

        if (Info->ReturnObject) 
        {
            AcpiUtRemoveReference (Info->ReturnObject);
            Info->ReturnObject = NULL;
        }
    }
 
     ACPI_DEBUG_PRINT ((ACPI_DB_NAMES,
         ""*** Completed evaluation of object %s ***\n"",","The acpi_ns_evaluate() function in drivers/acpi/acpica/nseval.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
942,CVE-2017-13694,"  AcpiPsCompleteFinalOp (
     ACPI_PARSE_OBJECT       *Op,
     ACPI_STATUS             Status)
 {
    ACPI_STATUS             ReturnStatus = AE_OK;
    BOOLEAN                 Ascending = TRUE;
 
 
     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);
  AcpiPsCompleteFinalOp (
     {
         if (Op)
         {
            if (Ascending && WalkState->AscendingCallback != NULL)
             {
                 WalkState->Op = Op;
                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);
  AcpiPsCompleteFinalOp (
 
                 if (Status == AE_CTRL_TERMINATE)
                 {
                    Ascending = FALSE;
                    ReturnStatus = AE_CTRL_TERMINATE;
                 }
 
                 else if (ACPI_FAILURE (Status))
                 {
                      
 
                    Ascending = FALSE;
                    ReturnStatus = Status;
                 }
             }
 
            Status = AcpiPsCompleteThisOp (WalkState, Op);
            if (ACPI_FAILURE (Status))
             {
                Ascending = FALSE;
                if (ACPI_SUCCESS (ReturnStatus) ||
                    ReturnStatus == AE_CTRL_TERMINATE)
                {
                    ReturnStatus = Status;
                }
             }
         }
 
  AcpiPsCompleteFinalOp (
 
     } while (Op);
 
    return_ACPI_STATUS (ReturnStatus);
 }","The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
943,CVE-2017-13693,"  AcpiDsCreateOperands (
     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];
     UINT32                  ArgCount = 0;
     UINT32                  Index = WalkState->NumOperands;
    UINT32                  PrevNumOperands = WalkState->NumOperands;
    UINT32                  NewNumOperands;
     UINT32                  i;
 
 
  AcpiDsCreateOperands (
 
      
 
    NewNumOperands = Index;
     Index--;
     for (i = 0; i < ArgCount; i++)
     {
  AcpiDsCreateOperands (
      * pop everything off of the operand stack and delete those
      * objects
      */
    WalkState->NumOperands = i;
    AcpiDsObjStackPopAndDelete (NewNumOperands, WalkState);

     
    WalkState->NumOperands = PrevNumOperands;
 
     ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index));
     return_ACPI_STATUS (Status);","The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
944,CVE-2017-13690,"  ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 	ND_PRINT((ndo,"" key len=%d"", ntohs(e.len) - 4));
 	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
 			goto trunc;
  ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,
 	ND_PRINT((ndo,"" len=%d"", item_len - 4));
 	ND_PRINT((ndo,"" type=%s"", STR_OR_ID((cert.encode), certstr)));
 	if (2 < ndo->ndo_vflag && 4 < item_len) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))
 			goto trunc;
  ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,
 	ND_PRINT((ndo,"" len=%d"", item_len - 4));
 	ND_PRINT((ndo,"" type=%s"", STR_OR_ID((cert.encode), certstr)));
 	if (2 < ndo->ndo_vflag && 4 < item_len) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))
 			goto trunc;
  ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
 	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
 			goto trunc;
  ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
 	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
 			goto trunc;
  ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
 	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
 			goto trunc;
  ikev2_gen_print(netdissect_options *ndo, u_char tpay,
 
 	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
 	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
 			goto trunc;
  ikev2_p_print(netdissect_options *ndo, u_char tpay _U_, int pcount _U_,
 		if (prop_length < sizeof(*ext))
 			goto toolong;
 		ND_TCHECK(*ext);
 		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 
 		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), id_len - 4))
 			goto trunc;
  ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 	const u_char *authdata = (const u_char*)ext + sizeof(a);
 	unsigned int len;
 
	ND_TCHECK2(*ext, sizeof(a));
 	UNALIGNED_MEMCPY(&a, ext, sizeof(a));
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
  ikev2_vid_print(netdissect_options *ndo, u_char tpay,
 		else ND_PRINT((ndo, "".""));
 	}
 	if (2 < ndo->ndo_vflag && 4 < len) {
		 
 		ND_PRINT((ndo,"" ""));
 		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
 			goto trunc;
  ikev1_sub_print(netdissect_options *ndo,
 
 	while (np) {
 		ND_TCHECK(*ext);
 		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 
 		ND_TCHECK2(*ext, ntohs(e.len));
  ikev2_sub_print(netdissect_options *ndo,
 	cp = (const u_char *)ext;
 	while (np) {
 		ND_TCHECK(*ext);
 		UNALIGNED_MEMCPY(&e, ext, sizeof(e));
 
 		ND_TCHECK2(*ext, ntohs(e.len));","The IKEv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions."
945,CVE-2017-13689,"  ikev1_id_print(netdissect_options *ndo, u_char tpay _U_,
 		case IPSECDOI_ID_IPV6_ADDR_SUBNET:
 		    {
 			const u_char *mask;
			if (len < 32)
				ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));
 			else {
 				mask = (const u_char *)(data + sizeof(struct in6_addr));
 				 ",The IKEv1 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:ikev1_id_print().
946,CVE-2017-13688,"  olsr_print(netdissect_options *ndo,
         } msgptr;
         int msg_len_valid = 0;
 
         if (is_ipv6)
         {
            ND_TCHECK2(*tptr, sizeof(struct olsr_msg6));
             msgptr.v6 = (const struct olsr_msg6 *) tptr;
             msg_type = msgptr.v6->msg_type;
             msg_len = EXTRACT_16BITS(msgptr.v6->msg_len);
  olsr_print(netdissect_options *ndo,
         }
         else  
         {
            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));
             msgptr.v4 = (const struct olsr_msg4 *) tptr;
             msg_type = msgptr.v4->msg_type;
             msg_len = EXTRACT_16BITS(msgptr.v4->msg_len);
  olsr_print(netdissect_options *ndo,
 
         case OLSR_NAMESERVICE_MSG:
         {
            u_int name_entries;
            u_int addr_size;
            int name_entries_valid;
             u_int i;
 
            if (msg_tlen < 4)
                goto trunc;
            ND_TCHECK2(*msg_data, 4);

            name_entries = EXTRACT_16BITS(msg_data+2);
            addr_size = 4;
             if (is_ipv6)
                 addr_size = 16;
 
            name_entries_valid = 0;
             if ((name_entries > 0)
                     && ((name_entries * (4 + addr_size)) <= msg_tlen))
                 name_entries_valid = 1;
 
             ND_PRINT((ndo, ""\n\t  Version %u, Entries %u%s"",
                    EXTRACT_16BITS(msg_data),
                    name_entries, (name_entries_valid == 0) ? "" (invalid)"" : """"));",The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().
947,CVE-2017-13686,"  static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,
 	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
 		table_id = rt->rt_table_id;
 
	if (rtm->rtm_flags & RTM_F_FIB_MATCH) {
		if (!res.fi) {
			err = fib_props[res.type].error;
			if (!err)
				err = -EHOSTUNREACH;
			goto errout_free;
		}
 		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
 				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
 				    rt->rt_type, res.prefix, res.prefixlen,
 				    fl4.flowi4_tos, res.fi, 0);
	} else {
 		err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
 				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
	}
 	if (err < 0)
 		goto errout_free;
 ","net/ipv4/route.c in the Linux kernel 4.13-rc1 through 4.13-rc6 is too late to check for a NULL fi field when RTM_F_FIB_MATCH is set, which allows local users to cause a denial of service (NULL pointer dereference) or possibly have unspecified other impact via crafted system calls. NOTE: this does not affect any stable release."
948,CVE-2017-13658,"  static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
     {
 MATLAB_KO:
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
 ","In ImageMagick before 6.9.9-3 and 7.x before 7.0.6-3, there is a missing NULL check in the ReadMATImage function in coders/mat.c, leading to a denial of service (assertion failure and application exit) in the DestroyImageInfo function in MagickCore/image.c."
949,CVE-2017-13146,"  static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
    
  quantum_info=(QuantumInfo *) NULL;
   image = AcquireImage(image_info);
 
   status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  RestoreMSCWarning
   }
 
   RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
   clone_info=DestroyImageInfo(clone_info);
   CloseBlob(image);","In ImageMagick before 6.9.8-5 and 7.x before 7.0.5-6, there is a memory leak in the ReadMATImage function in coders/mat.c."
950,CVE-2017-13145,"  static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)
         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||
         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||
         (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||
        ((image->ping == MagickFalse) && (jp2_image->comps[i].data == NULL)))
       {
         opj_destroy_codec(jp2_codec);
         opj_image_destroy(jp2_image);","In ImageMagick before 6.9.8-8 and 7.x before 7.0.5-9, the ReadJP2Image function in coders/jp2.c does not properly validate the channel geometry, leading to a crash."
951,CVE-2017-13143,"  RestoreMSCWarning
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));     
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;","In ImageMagick before 6.9.7-6 and 7.x before 7.0.4-6, the ReadMATImage function in coders/mat.c uses uninitialized data, which might allow remote attackers to obtain sensitive information from process memory."
952,CVE-2017-13142,"  static Image *ReadPNGImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if (count < 8 || memcmp(magic_number,""\211PNG\r\n\032\n"",8) != 0)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   
  if (GetBlobSize(image) < 61)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");

    
  static Image *ReadJNGImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if (count < 8 || memcmp(magic_number,""\213JNG\r\n\032\n"",8) != 0)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   
  if (GetBlobSize(image) < 147)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");

    
 
   mng_info=(MngInfo *) AcquireMagickMemory(sizeof(*mng_info));
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry=SetMagickInfo(""MNG"");
  entry->seekable_stream=MagickTrue;
 
 #if defined(MAGICKCORE_PNG_DELEGATE)
   entry->decoder=(DecodeImageHandler *) ReadMNGImage;
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(""Portable Network Graphics"");
   entry->mime_type=ConstantString(""image/png"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(
             ""8-bit indexed with optional binary transparency"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(""opaque or binary transparent 24-bit RGB"");
   entry->mime_type=ConstantString(""image/png"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(""opaque or transparent 32-bit RGBA"");
   entry->mime_type=ConstantString(""image/png"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(""opaque or binary transparent 48-bit RGB"");
   entry->mime_type=ConstantString(""image/png"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(""opaque or transparent 64-bit RGBA"");
   entry->mime_type=ConstantString(""image/png"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsPNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(
      ""PNG inheriting bit-depth, color-type from original if possible"");
  ModuleExport size_t RegisterPNGImage(void)
 #endif
 
   entry->magick=(IsImageFormatHandler *) IsJNG;
  entry->seekable_stream=MagickTrue;
   entry->adjoin=MagickFalse;
   entry->description=ConstantString(""JPEG Network Graphics"");
   entry->mime_type=ConstantString(""image/x-jng"");","In ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1, a crafted PNG file could trigger a crash because there was an insufficient check for short files."
953,CVE-2017-13139,"  static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,
 
                 for (i=(int) first_object; i <= (int) last_object; i++)
                 {
                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))
                    continue;
                   if (mng_info->exists[i] && !mng_info->frozen[i])
                     {
                       MngBox","In ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1, the ReadOneMNGImage function in coders/png.c has an out-of-bounds read with the MNG CLIP chunk."
954,CVE-2017-13055,"  isis_print_is_reach_subtlv(netdissect_options *ndo,
             break;
         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS:  
         case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:
            if (subl == 0)
                break;
             ND_PRINT((ndo, ""%sBandwidth Constraints Model ID: %s (%u)"",
                    ident,
                    tok2str(diffserv_te_bc_values, ""unknown"", *tptr),
                    *tptr));
             tptr++;
              
             for (te_class = 0; te_class < (subl-1)/4; te_class++) {
                 bw.i = EXTRACT_32BITS(tptr);
                 ND_PRINT((ndo, ""%s  Bandwidth constraint CT%u: %.3f Mbps"",
                        ident,",The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_is_reach_subtlv().
955,CVE-2017-13054,"  lldp_private_8023_print(netdissect_options *ndo,
         break;
 
     case LLDP_PRIVATE_8023_SUBTYPE_MTU:
        if (tlv_len < 6) {
            return hexdump;
        }
         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));
         break;
 ",The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_private_8023_print().
956,CVE-2017-13053,"  decode_rt_routing_info(netdissect_options *ndo,
 {
 	uint8_t route_target[8];
 	u_int plen;
	char asbuf[sizeof(astostr)];  
 
	 
 	ND_TCHECK(pptr[0]);
 	plen = pptr[0];    
 
	 
 	if (0 == plen) {
		 
 		snprintf(buf, buflen, ""default route target"");
 		return 1;
 	}
 
 	if (32 > plen)
 		return -1;
 
	 
	ND_TCHECK_32BITS(pptr + 1);
	as_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));

         plen-=32;  
 
 	if (64 < plen)
 		return -1;
 
	 
 	memset(&route_target, 0, sizeof(route_target));
	ND_TCHECK2(pptr[5], (plen + 7) / 8);
	memcpy(&route_target, &pptr[5], (plen + 7) / 8);
	 
 	if (plen % 8) {
 		((u_char *)&route_target)[(plen + 7) / 8 - 1] &=
 			((0xff00 >> (plen % 8)) & 0xff);
 	}
 	snprintf(buf, buflen, ""origin AS: %s, route target %s"",
	    asbuf,
 	    bgp_vpn_rd_print(ndo, (u_char *)&route_target));
 
 	return 5 + (plen + 7) / 8;",The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_rt_routing_info().
957,CVE-2017-13052,"  static const struct tok cfm_tlv_senderid_chassisid_values[] = {
 
 static int
 cfm_network_addr_print(netdissect_options *ndo,
                       register const u_char *tptr, const u_int length)
 {
     u_int network_addr_type;
     u_int hexdump =  FALSE;
  cfm_network_addr_print(netdissect_options *ndo,
      * 802.1ab specifies that this field width
      * is only once octet
      */
    if (length < 1) {
        ND_PRINT((ndo, ""\n\t  Network Address Type (invalid, no data""));
        return hexdump;
    }
     
     network_addr_type = *tptr;
     ND_PRINT((ndo, ""\n\t  Network Address Type %s (%u)"",
            tok2str(af_values, ""Unknown"", network_addr_type),
  cfm_network_addr_print(netdissect_options *ndo,
      */
     switch(network_addr_type) {
     case AFNUM_INET:
        if (length != 1 + 4) {
            ND_PRINT((ndo, ""(invalid IPv4 address length %u)"", length - 1));
            hexdump = TRUE;
            break;
        }
         ND_PRINT((ndo, "", %s"", ipaddr_string(ndo, tptr + 1)));
         break;
 
     case AFNUM_INET6:
        if (length != 1 + 16) {
            ND_PRINT((ndo, ""(invalid IPv6 address length %u)"", length - 1));
            hexdump = TRUE;
            break;
        }
         ND_PRINT((ndo, "", %s"", ip6addr_string(ndo, tptr + 1)));
         break;
 
  cfm_print(netdissect_options *ndo,
 
             if (cfm_tlv_len < 1) {
                 ND_PRINT((ndo, "" (too short, must be >= 1)""));
                goto next_tlv;
             }
 
              
             chassis_id_length = *tptr;
             tptr++;
             tlen--;
             cfm_tlv_len--;
 
             if (chassis_id_length) {
                 
                 if (cfm_tlv_len < 1) {
                     ND_PRINT((ndo, ""\n\t  (TLV too short)""));
                    goto next_tlv;
                 }
                 chassis_id_type = *tptr;
                 cfm_tlv_len--;
  cfm_print(netdissect_options *ndo,
 
                 if (cfm_tlv_len < chassis_id_length) {
                     ND_PRINT((ndo, ""\n\t  (TLV too short)""));
                    goto next_tlv;
                 }
 
                 
                 switch (chassis_id_type) {
                 case CFM_CHASSIS_ID_MAC_ADDRESS:
                    if (chassis_id_length != ETHER_ADDR_LEN) {
                        ND_PRINT((ndo, "" (invalid MAC address length)""));
                        hexdump = TRUE;
                        break;
                    }
                     ND_PRINT((ndo, ""\n\t  MAC %s"", etheraddr_string(ndo, tptr + 1)));
                     break;
 
                 case CFM_CHASSIS_ID_NETWORK_ADDRESS:
                    hexdump |= cfm_network_addr_print(ndo, tptr + 1, chassis_id_length);
                     break;
 
                 case CFM_CHASSIS_ID_INTERFACE_NAME:  
  cfm_print(netdissect_options *ndo,
 
              
             if (cfm_tlv_len == 0) {
                  
                break;
             }
 
             
             mgmt_addr_length = *tptr;
             tptr++;
             tlen--;
             cfm_tlv_len--;
            ND_PRINT((ndo, ""\n\t  Management Address Domain Length %u"", mgmt_addr_length));
             if (mgmt_addr_length) {
                 
                 if (cfm_tlv_len < mgmt_addr_length) {
                     ND_PRINT((ndo, ""\n\t  (TLV too short)""));
                    goto next_tlv;
                 }
                 cfm_tlv_len -= mgmt_addr_length;
                  
                hex_print(ndo, ""\n\t  Management Address Domain: "", tptr, mgmt_addr_length);
                 tptr += mgmt_addr_length;
                 tlen -= mgmt_addr_length;
 
                 
                 if (cfm_tlv_len < 1) {
                    ND_PRINT((ndo, "" (Management Address Length is missing)""));
                    hexdump = TRUE;
                    break;
                 }
 
                 
                 mgmt_addr_length = *tptr;
                 tptr++;
                 tlen--;
                 cfm_tlv_len--;
                ND_PRINT((ndo, ""\n\t  Management Address Length %u"", mgmt_addr_length));
                 if (mgmt_addr_length) {
                     
                     if (cfm_tlv_len < mgmt_addr_length) {
                         ND_PRINT((ndo, ""\n\t  (TLV too short)""));
                         return;
  cfm_print(netdissect_options *ndo,
                      
                    hex_print(ndo, ""\n\t  Management Address: "", tptr, mgmt_addr_length);
                     tptr += mgmt_addr_length;
                     tlen -= mgmt_addr_length;
                 }
  cfm_print(netdissect_options *ndo,
         if (hexdump || ndo->ndo_vflag > 1)
             print_unknown_data(ndo, tlv_ptr, ""\n\t  "", cfm_tlv_len);
 
next_tlv:
         tptr+=cfm_tlv_len;
         tlen-=cfm_tlv_len;
     }",The CFM parser in tcpdump before 4.9.2 has a buffer over-read in print-cfm.c:cfm_print().
958,CVE-2017-13051,"  rsvp_obj_print(netdissect_options *ndo,
 		 
 		total_subobj_len = obj_tlen;
                 while(total_subobj_len > 0) {
                     
                    if (total_subobj_len < 4)
                        goto invalid;
                     subobj_len  = EXTRACT_16BITS(obj_tptr);
                     subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;
                     af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;
  rsvp_obj_print(netdissect_options *ndo,
                            tok2str(af_values, ""Unknown"", af), af,
                            subobj_len));
 
                     
                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;
 
                     switch(subobj_type) {",The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().
959,CVE-2017-13050,"  typedef struct rpki_rtr_pdu_ipv6_prefix_ {
 typedef struct rpki_rtr_pdu_error_report_ {
     rpki_rtr_pdu pdu_header;
     u_char encapsulated_pdu_length[4];  
     
     
     
 } rpki_rtr_pdu_error_report;
 
  
static u_int
rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, const u_int len,
	const u_char recurse, const u_int indent)
 {
     const rpki_rtr_pdu *pdu_header;
     u_int pdu_type, pdu_len, hexdump;
     const u_char *msg;
 
     
    ND_TCHECK_8BITS(tptr);
    if (*tptr != 0) {
	 
	ND_PRINT((ndo, ""%sRPKI-RTRv%u (unknown)"", indent_string(8), *tptr));
	return len;
    }
    if (len < sizeof(rpki_rtr_pdu)) {
	ND_PRINT((ndo, ""(%u bytes is too few to decode)"", len));
	goto invalid;
    }
    ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));
     pdu_header = (const rpki_rtr_pdu *)tptr;
     pdu_type = pdu_header->pdu_type;
     pdu_len = EXTRACT_32BITS(pdu_header->length);
     
     hexdump = FALSE;
 
     ND_PRINT((ndo, ""%sRPKI-RTRv%u, %s PDU (%u), length: %u"",
 	   indent_string(8),
 	   pdu_header->version,
 	   tok2str(rpki_rtr_pdu_values, ""Unknown"", pdu_type),
 	   pdu_type, pdu_len));
    if (pdu_len < sizeof(rpki_rtr_pdu) || pdu_len > len)
	goto invalid;
 
     switch (pdu_type) {
 
  rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)
     case RPKI_RTR_SERIAL_NOTIFY_PDU:
     case RPKI_RTR_SERIAL_QUERY_PDU:
     case RPKI_RTR_END_OF_DATA_PDU:
	if (pdu_len != sizeof(rpki_rtr_pdu) + 4)
	    goto invalid;
	ND_TCHECK2(*tptr, pdu_len);
         msg = (const u_char *)(pdu_header + 1);
 	ND_PRINT((ndo, ""%sSession ID: 0x%04x, Serial: %u"",
 	       indent_string(indent+2),
  rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)
 	 */
     case RPKI_RTR_RESET_QUERY_PDU:
     case RPKI_RTR_CACHE_RESET_PDU:
	if (pdu_len != sizeof(rpki_rtr_pdu))
	    goto invalid;
	 
 
 	 
 	break;
 
     case RPKI_RTR_CACHE_RESPONSE_PDU:
	if (pdu_len != sizeof(rpki_rtr_pdu))
	    goto invalid;
	 
 	ND_PRINT((ndo, ""%sSession ID: 0x%04x"",
 	       indent_string(indent+2),
 	       EXTRACT_16BITS(pdu_header->u.session_id)));
  rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)
 	{
 	    const rpki_rtr_pdu_ipv4_prefix *pdu;
 
	    if (pdu_len != sizeof(rpki_rtr_pdu) + 12)
		goto invalid;
	    ND_TCHECK2(*tptr, pdu_len);
 	    pdu = (const rpki_rtr_pdu_ipv4_prefix *)tptr;
 	    ND_PRINT((ndo, ""%sIPv4 Prefix %s/%u-%u, origin-as %u, flags 0x%02x"",
 		   indent_string(indent+2),
  rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)
 	{
 	    const rpki_rtr_pdu_ipv6_prefix *pdu;
 
	    if (pdu_len != sizeof(rpki_rtr_pdu) + 24)
		goto invalid;
	    ND_TCHECK2(*tptr, pdu_len);
 	    pdu = (const rpki_rtr_pdu_ipv6_prefix *)tptr;
 	    ND_PRINT((ndo, ""%sIPv6 Prefix %s/%u-%u, origin-as %u, flags 0x%02x"",
 		   indent_string(indent+2),
  rpki_rtr_pdu_print (netdissect_options *ndo, const u_char *tptr, u_int indent)
 	    const rpki_rtr_pdu_error_report *pdu;
 	    u_int encapsulated_pdu_length, text_length, tlen, error_code;
 
	    tlen = sizeof(rpki_rtr_pdu);
	     
	    if (pdu_len < tlen + 4)
		goto invalid;
	    ND_TCHECK2(*tptr, tlen + 4);
	     
 	    pdu = (const rpki_rtr_pdu_error_report *)tptr;
 	    encapsulated_pdu_length = EXTRACT_32BITS(pdu->encapsulated_pdu_length);
	    tlen += 4;
 
 	    error_code = EXTRACT_16BITS(pdu->pdu_header.u.error_code);
 	    ND_PRINT((ndo, ""%sError code: %s (%u), Encapsulated PDU length: %u"",
 		   indent_string(indent+2),
 		   tok2str(rpki_rtr_error_codes, ""Unknown"", error_code),
 		   error_code, encapsulated_pdu_length));
 
	    if (encapsulated_pdu_length) {
		 
		if (pdu_len < tlen + encapsulated_pdu_length)
		    goto invalid;
		if (! recurse) {
		    ND_TCHECK2(*tptr, tlen + encapsulated_pdu_length);
		}
		else {
		    ND_PRINT((ndo, ""%s-----encapsulated PDU-----"", indent_string(indent+4)));
		    rpki_rtr_pdu_print(ndo, tptr + tlen,
			encapsulated_pdu_length, 0, indent + 2);
		}
		tlen += encapsulated_pdu_length;
 	    }
 
	    if (pdu_len < tlen + 4)
		goto invalid;
	    ND_TCHECK2(*tptr, tlen + 4);
	     
 
 	     
	    text_length = EXTRACT_32BITS(tptr + tlen);
	    tlen += 4;

	    if (text_length) {
		if (pdu_len < tlen + text_length)
		    goto invalid;
		 
 		ND_PRINT((ndo, ""%sError text: "", indent_string(indent+2)));
		if (fn_printn(ndo, tptr + tlen, text_length, ndo->ndo_snapend))
 			goto trunc;
 	    }
 	}
 	break;
 
     default:
	ND_TCHECK2(*tptr, pdu_len);
 
 	 
    while (len) {
	u_int pdu_len = rpki_rtr_pdu_print(ndo, pptr, len, 1, 8);
	len -= pdu_len;
	pptr += pdu_len;
     }
 }
 
 /*",The RPKI-Router parser in tcpdump before 4.9.2 has a buffer over-read in print-rpki-rtr.c:rpki_rtr_pdu_print().
960,CVE-2017-13049,"  ubik_print(netdissect_options *ndo,
 			INTOUT();
 			ND_PRINT((ndo, "" length""));
 			INTOUT();
			ND_TCHECK_32BITS(bp);
 			temp = EXTRACT_32BITS(bp);
 			bp += sizeof(int32_t);
 			tok2str(ubik_lock_types, ""type %d"", temp);",The Rx protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-rx.c:ubik_print().
961,CVE-2017-13048,"  rsvp_obj_print(netdissect_options *ndo,
         case RSVP_OBJ_FASTREROUTE:
              
             obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;
 
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:  
                 if (obj_tlen < sizeof(struct rsvp_obj_frr_t))
                     return-1;
                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,
  rsvp_obj_print(netdissect_options *ndo,
             case RSVP_CTYPE_TUNNEL_IPV4:  
                 if (obj_tlen < 16)
                     return-1;
                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,",The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().
962,CVE-2017-13047,"  esis_print(netdissect_options *ndo,
 
             case ESIS_OPTION_PROTOCOLS:
                 while (opli>0) {
                    ND_TCHECK(*tptr);
                     ND_PRINT((ndo, ""%s (0x%02x)"",
                            tok2str(nlpid_values,
                                    ""unknown"",
  esis_print(netdissect_options *ndo,
             pptr += opli;
         }
 trunc:
        ND_PRINT((ndo, ""[|esis]""));
 }
 
 static void",The ISO ES-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:esis_print().
963,CVE-2017-13046,"  bgp_attr_print(netdissect_options *ndo,
         {
                 uint8_t tunnel_type, flags;
 
                ND_TCHECK2(tptr[0], 5);
                 tunnel_type = *(tptr+1);
                 flags = *tptr;
                 tlen = len;
 
                 ND_PRINT((ndo, ""\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u"",
                        tok2str(bgp_pmsi_tunnel_values, ""Unknown"", tunnel_type),
                        tunnel_type,",The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().
964,CVE-2017-13045," 
 #include ""netdissect.h""
 #include ""extract.h""
 #include ""addrtoname.h""
#include ""ether.h""
 
 #define VQP_VERSION            		1
 #define VQP_EXTRACT_VERSION(x) ((x)&0xFF)
  vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int l
     const u_char *tptr;
     uint16_t vqp_obj_len;
     uint32_t vqp_obj_type;
    u_int tlen;
     uint8_t nitems;
 
     tptr=pptr;
     tlen = len;
     vqp_common_header = (const struct vqp_common_header_t *)pptr;
     ND_TCHECK(*vqp_common_header);
    if (sizeof(struct vqp_common_header_t) > tlen)
        goto trunc;
 
      
         ND_TCHECK2(*tptr, vqp_obj_len);
        if (vqp_obj_len > tlen)
            goto trunc;
 
         switch(vqp_obj_type) {
 	case VQP_OBJ_IP_ADDRESS:
            if (vqp_obj_len != 4)
                goto trunc;
             ND_PRINT((ndo, ""%s (0x%08x)"", ipaddr_string(ndo, tptr), EXTRACT_32BITS(tptr)));
             break;
              
  vqp_print(netdissect_options *ndo, register const u_char *pptr, register u_int l
              
 	case VQP_OBJ_MAC_ADDRESS:
 	case VQP_OBJ_MAC_NULL:
            if (vqp_obj_len != ETHER_ADDR_LEN)
                goto trunc;
 	      ND_PRINT((ndo, ""%s"", etheraddr_string(ndo, tptr)));
               break;
         default:",The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().
965,CVE-2017-13044,"  dhcpv4_print(netdissect_options *ndo,
 
     i = 0;
     while (i < length) {
        if (i + 2 > length)
            return -1;
         tlv = cp + i;
         type = (uint8_t)tlv[0];
         optlen = (uint8_t)tlv[1];
  dhcpv4_print(netdissect_options *ndo,
 
         ND_PRINT((ndo, ""%s"", tok2str(dh4opt_str, ""Unknown"", type)));
         ND_PRINT((ndo,"" (%u)"", optlen + 2 ));
        if (i + 2 + optlen > length)
            return -1;
 
         switch (type) {
         case DH4OPT_DNS_SERVERS:",The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv4_print().
966,CVE-2017-13043,"  decode_multicast_vpn(netdissect_options *ndo,
 
         case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN:  
         case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:
            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);
             offset = strlen(buf);
 	    snprintf(buf + offset, buflen - offset, "", RD: %s, Source-AS %s"",
 		bgp_vpn_rd_print(ndo, pptr),
 		as_printf(ndo, astostr, sizeof(astostr),
 		EXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));
            pptr += BGP_VPN_RD_LEN + 4;
 
             bgp_vpn_sg_print(ndo, pptr, buf, buflen);
             break;",The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_multicast_vpn().
967,CVE-2017-13042,"  dhcpv6_print(netdissect_options *ndo,
 
     i = 0;
     while (i < length) {
        if (i + 4 > length)
            return -1;
         tlv = cp + i;
         type = EXTRACT_16BITS(tlv);
         optlen = EXTRACT_16BITS(tlv + 2);
  dhcpv6_print(netdissect_options *ndo,
 
         ND_PRINT((ndo, ""%s"", tok2str(dh6opt_str, ""Unknown"", type)));
         ND_PRINT((ndo,"" (%u)"", optlen + 4 ));
        if (i + 4 + optlen > length)
            return -1;
 
         switch (type) {
             case DH6OPT_DNS_SERVERS:",The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv6_print().
968,CVE-2017-13041,"  icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp,
 
 		needcomma = 0;
 
		ND_TCHECK2(*dp, sizeof(*ni6));
 		ni6 = (const struct icmp6_nodeinfo *)dp;
 		ND_PRINT((ndo,"" node information reply""));
 		ND_PRINT((ndo,"" (""));	 
  icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp,
 				ND_PRINT((ndo,"", ""));
 			ND_PRINT((ndo,""DNS name""));
 			cp = (const u_char *)(ni6 + 1) + 4;
			ND_TCHECK(cp[0]);
 			if (cp[0] == ep - cp - 1) {
 				 
 				if (ndo->ndo_vflag)",The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_nodeinfo_print().
969,CVE-2017-13040,"  mp_capable_print(netdissect_options *ndo,
 {
         const struct mp_capable *mpc = (const struct mp_capable *) opt;
 
        if (!(opt_len == 12 && (flags & TH_SYN)) &&
             !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))
                 return 0;
 
  mp_join_print(netdissect_options *ndo,
 {
         const struct mp_join *mpj = (const struct mp_join *) opt;
 
        if (!(opt_len == 12 && (flags & TH_SYN)) &&
             !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&
            !(opt_len == 24 && (flags & TH_ACK)))
                 return 0;
 
         if (opt_len != 24) {
  mp_join_print(netdissect_options *ndo,
         return 1;
 }
 
 static int
 mp_dss_print(netdissect_options *ndo,
              const u_char *opt, u_int opt_len, u_char flags)
 {
         const struct mp_dss *mdss = (const struct mp_dss *) opt;
 
         
        if (opt_len < 4)
                return 0;

        if (flags & TH_SYN)
                 return 0;
 
         if (mdss->flags & MP_DSS_F)
                 ND_PRINT((ndo, "" fin""));
 
         opt += 4;
        opt_len -= 4;
         if (mdss->flags & MP_DSS_A) {
                 
                 ND_PRINT((ndo, "" ack ""));
                 
                 if (mdss->flags & MP_DSS_a) {
                        if (opt_len < 8)
                                return 0;
                         ND_PRINT((ndo, ""%"" PRIu64, EXTRACT_64BITS(opt)));
                         opt += 8;
                        opt_len -= 8;
                 } else {
                        if (opt_len < 4)
                                return 0;
                         ND_PRINT((ndo, ""%u"", EXTRACT_32BITS(opt)));
                         opt += 4;
                        opt_len -= 4;
                 }
         }
 
         if (mdss->flags & MP_DSS_M) {
                 
                 ND_PRINT((ndo, "" seq ""));
		 
                 if (mdss->flags & MP_DSS_m) {
                        if (opt_len < 8)
                                return 0;
                         ND_PRINT((ndo, ""%"" PRIu64, EXTRACT_64BITS(opt)));
                         opt += 8;
                        opt_len -= 8;
                 } else {
                        if (opt_len < 4)
                                return 0;
                         ND_PRINT((ndo, ""%u"", EXTRACT_32BITS(opt)));
                         opt += 4;
                        opt_len -= 4;
                 }
                if (opt_len < 4)
                        return 0;
                 ND_PRINT((ndo, "" subseq %u"", EXTRACT_32BITS(opt)));
                 opt += 4;
                opt_len -= 4;
                if (opt_len < 2)
                        return 0;
                 ND_PRINT((ndo, "" len %u"", EXTRACT_16BITS(opt)));
                 opt += 2;
                opt_len -= 2;
 
                 
                if (opt_len >= 2) {
                         ND_PRINT((ndo, "" csum 0x%x"", EXTRACT_16BITS(opt)));
                        opt_len -= 2;
                }
         }
        if (opt_len != 0)
                return 0;
         return 1;
 }
 ","The MPTCP parser in tcpdump before 4.9.2 has a buffer over-read in print-mptcp.c, several functions."
970,CVE-2017-13039,"  struct attrmap {
 
 static const u_char *
 ikev1_attrmap_print(netdissect_options *ndo,
		    const u_char *p, const u_char *ep2,
 		    const struct attrmap *map, size_t nmap)
 {
 	int totlen;
 	uint32_t t, v;
 
	ND_TCHECK(p[0]);
 	if (p[0] & 0x80)
 		totlen = 4;
	else {
		ND_TCHECK_16BITS(&p[2]);
 		totlen = 4 + EXTRACT_16BITS(&p[2]);
	}
	if (ep2 < p + totlen) {
 		ND_PRINT((ndo,""[|attr]""));
		return ep2 + 1;
 	}
 
	ND_TCHECK_16BITS(&p[0]);
 	ND_PRINT((ndo,""(""));
 	t = EXTRACT_16BITS(&p[0]) & 0x7fff;
 	if (map && t < nmap && map[t].type)
  ikev1_attrmap_print(netdissect_options *ndo,
 		ND_PRINT((ndo,""type=#%d "", t));
 	if (p[0] & 0x80) {
 		ND_PRINT((ndo,""value=""));
		ND_TCHECK_16BITS(&p[2]);
 		v = EXTRACT_16BITS(&p[2]);
 		if (map && t < nmap && v < map[t].nvalue && map[t].value[v])
 			ND_PRINT((ndo,""%s"", map[t].value[v]));
		else {
			if (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {
				ND_PRINT((ndo,"")""));
				goto trunc;
			}
		}
 	} else {
		ND_PRINT((ndo,""len=%d value="", totlen - 4));
		if (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {
			ND_PRINT((ndo,"")""));
			goto trunc;
		}
 	}
 	ND_PRINT((ndo,"")""));
 	return p + totlen;

trunc:
	return NULL;
 }
 
 static const u_char *
ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep2)
 {
 	int totlen;
 	uint32_t t;
 
	ND_TCHECK(p[0]);
 	if (p[0] & 0x80)
 		totlen = 4;
	else {
		ND_TCHECK_16BITS(&p[2]);
 		totlen = 4 + EXTRACT_16BITS(&p[2]);
	}
	if (ep2 < p + totlen) {
 		ND_PRINT((ndo,""[|attr]""));
		return ep2 + 1;
 	}
 
	ND_TCHECK_16BITS(&p[0]);
 	ND_PRINT((ndo,""(""));
 	t = EXTRACT_16BITS(&p[0]) & 0x7fff;
 	ND_PRINT((ndo,""type=#%d "", t));
 	if (p[0] & 0x80) {
 		ND_PRINT((ndo,""value=""));
 		t = p[2];
		if (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {
			ND_PRINT((ndo,"")""));
			goto trunc;
		}
 	} else {
		ND_PRINT((ndo,""len=%d value="", totlen - 4));
		if (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {
			ND_PRINT((ndo,"")""));
			goto trunc;
		}
 	}
 	ND_PRINT((ndo,"")""));
 	return p + totlen;

trunc:
	return NULL;
 }
 
 static const u_char *
  ikev1_t_print(netdissect_options *ndo, u_char tpay _U_,
 	cp = (const u_char *)(p + 1);
 	ep2 = (const u_char *)p + item_len;
 	while (cp < ep && cp < ep2) {
		if (map && nmap)
			cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);
		else
			cp = ikev1_attr_print(ndo, cp, ep2);
		if (cp == NULL)
			goto trunc;
 	}
 	if (ep < ep2)
 		ND_PRINT((ndo,""...""));
  ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
 			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
				cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);
				if (cp == NULL) {
					ND_PRINT((ndo,"")""));
					goto trunc;
				}
 			}
 			ND_PRINT((ndo,"")""));
 			break;
  ikev2_t_print(netdissect_options *ndo, int tcount,
 	ep2 = (const u_char *)p + item_len;
 	while (cp < ep && cp < ep2) {
 		if (map && nmap) {
			cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);
 		} else
			cp = ikev1_attr_print(ndo, cp, ep2);
		if (cp == NULL)
			goto trunc;
 	}
 	if (ep < ep2)
 		ND_PRINT((ndo,""...""));","The ISAKMP parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions."
971,CVE-2017-13038,"  handle_mlppp(netdissect_options *ndo,
     if (!ndo->ndo_eflag)
         ND_PRINT((ndo, ""MLPPP, ""));
 
    if (length < 2) {
        ND_PRINT((ndo, ""[|mlppp]""));
        return;
    }
    if (!ND_TTEST_16BITS(p)) {
        ND_PRINT((ndo, ""[|mlppp]""));
        return;
    }

     ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",
            (EXTRACT_16BITS(p))&0x0fff,  
            bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),",The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:handle_mlppp().
972,CVE-2017-13037,"  nextproto4_cksum(netdissect_options *ndo,
 	return (in_cksum(vec, 2));
 }
 
static int
 ip_printts(netdissect_options *ndo,
            register const u_char *cp, u_int length)
 {
  ip_printts(netdissect_options *ndo,
 
 	if (length < 4) {
 		ND_PRINT((ndo, ""[bad length %u]"", length));
		return (0);
 	}
 	ND_PRINT((ndo, "" TS{""));
 	hoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;
 	if ((length - 4) & (hoplen-1))
 		ND_PRINT((ndo, ""[bad length %u]"", length));
	ND_TCHECK(cp[2]);
 	ptr = cp[2] - 1;
 	len = 0;
 	if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)
 		ND_PRINT((ndo, ""[bad ptr %u]"", cp[2]));
	ND_TCHECK(cp[3]);
 	switch (cp[3]&0xF) {
 	case IPOPT_TS_TSONLY:
 		ND_PRINT((ndo, ""TSONLY""));
  ip_printts(netdissect_options *ndo,
 	for (len = 4; len < length; len += hoplen) {
 		if (ptr == len)
 			type = "" ^ "";
		ND_TCHECK2(cp[len], hoplen);
 		ND_PRINT((ndo, ""%s%d@%s"", type, EXTRACT_32BITS(&cp[len+hoplen-4]),
 		       hoplen!=8 ? """" : ipaddr_string(ndo, &cp[len])));
 		type = "" "";
  ip_printts(netdissect_options *ndo,
 		ND_PRINT((ndo, "" [%d hops not recorded]} "", cp[3]>>4));
 	else
 		ND_PRINT((ndo, ""}""));
	return (0);

trunc:
	return (-1);
 }
 
  ",The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts().
973,CVE-2017-13036,"  ospf6_decode_v3(netdissect_options *ndo,
 	case OSPF_TYPE_HELLO: {
 		register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);
 
		ND_TCHECK_32BITS(&hellop->hello_options);
 		ND_PRINT((ndo, ""\n\tOptions [%s]"",
 		          bittok2str(ospf6_option_values, ""none"",
 		          EXTRACT_32BITS(&hellop->hello_options))));",The OSPFv3 parser in tcpdump before 4.9.2 has a buffer over-read in print-ospf6.c:ospf6_decode_v3().
974,CVE-2017-13035,"  isis_print_id(const uint8_t *cp, int id_len)
     int i;
     static char id[sizeof(""xxxx.xxxx.xxxx.yy-zz"")];
     char *pos = id;
    int sysid_len;
 
    sysid_len = SYSTEM_ID_LEN;
    if (sysid_len > id_len)
        sysid_len = id_len;
    for (i = 1; i <= sysid_len; i++) {
         snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);
 	pos += strlen(pos);
 	if (i == 2 || i == 4)",The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_id().
975,CVE-2017-13034,"  pgm_print(netdissect_options *ndo,
 			ND_PRINT((ndo, ""%s > %s: [|pgm]"",
 				ip6addr_string(ndo, &ip6->ip6_src),
 				ip6addr_string(ndo, &ip6->ip6_dst)));
 		} else {
 			ND_PRINT((ndo, ""%s > %s: [|pgm]"",
 				ipaddr_string(ndo, &ip->ip_src),
 				ipaddr_string(ndo, &ip->ip_dst)));
 		}
		return;
 	}
 
 	sport = EXTRACT_16BITS(&pgm->pgm_sport);
  pgm_print(netdissect_options *ndo,
 	     * and stopping if we don't have enough.
 	     */
 	    bp += (2 * sizeof(uint16_t));
	    ND_TCHECK_16BITS(bp);
 	    switch (EXTRACT_16BITS(bp)) {
 	    case AFNUM_INET:
 		ND_TCHECK2(*bp, sizeof(struct in_addr));",The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print().
976,CVE-2017-13033," 
  * FOR A PARTICULAR PURPOSE.
  *
  * Reference documentation:
 *  http: 
 *  http: 
  *
  * Original code ode by Carles Kishimoto <carles.kishimoto@gmail.com>
  */
 
 #define	VTP_DOMAIN_NAME_LEN		32
 #define	VTP_MD5_DIGEST_LEN		16
 #define VTP_UPDATE_TIMESTAMP_LEN	12
#define VTP_VLAN_INFO_FIXED_PART_LEN	12	 
 
 #define VTP_SUMMARY_ADV			0x01
 #define VTP_SUBSET_ADV			0x02
  vtp_print (netdissect_options *ndo,
 	    ND_TCHECK2(*tptr, len);
 
 	    vtp_vlan = (const struct vtp_vlan_*)tptr;
	    if (len < VTP_VLAN_INFO_FIXED_PART_LEN)
		goto trunc;
 	    ND_TCHECK(*vtp_vlan);
 	    ND_PRINT((ndo, ""\n\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name "",
 		   tok2str(vtp_vlan_status,""Unknown"",vtp_vlan->status),
 		   tok2str(vtp_vlan_type_values,""Unknown"",vtp_vlan->type),
 		   EXTRACT_16BITS(&vtp_vlan->vlanid),
 		   EXTRACT_16BITS(&vtp_vlan->mtu),
 		   EXTRACT_32BITS(&vtp_vlan->index)));
	    len  -= VTP_VLAN_INFO_FIXED_PART_LEN;
	    tptr += VTP_VLAN_INFO_FIXED_PART_LEN;
	    if (len < 4*((vtp_vlan->name_len + 3)/4))
		goto trunc;
	    ND_TCHECK2(*tptr, vtp_vlan->name_len);
	    fn_printzp(ndo, tptr, vtp_vlan->name_len, NULL);

	     
	    len  -= 4*((vtp_vlan->name_len + 3)/4);
	    tptr += 4*((vtp_vlan->name_len + 3)/4);
 
              
 
             while (len > 0) {
 
                  
                if (len < 2)
                    goto trunc;
                ND_TCHECK2(*tptr, 2);
                 type = *tptr;
                 tlv_len = *(tptr+1);
 
                 ND_PRINT((ndo, ""\n\t\t%s (0x%04x) TLV"",
                        tok2str(vtp_vlan_tlv_values, ""Unknown"", type),
                        type));
 
                if (len < tlv_len * 2 + 2) {
                    ND_PRINT((ndo, "" (TLV goes past the end of the packet)""));
                     return;
                 }
                 ND_TCHECK2(*tptr, tlv_len * 2 +2);
 
                 
                if (tlv_len != 1) {
                    ND_PRINT((ndo, "" (invalid TLV length %u != 1)"", tlv_len));
                    return;
                } else {
                    tlv_value = EXTRACT_16BITS(tptr+2);

                    switch (type) {
                    case VTP_VLAN_STE_HOP_COUNT:
                        ND_PRINT((ndo, "", %u"", tlv_value));
                        break;

                    case VTP_VLAN_PRUNING:
                        ND_PRINT((ndo, "", %s (%u)"",
                               tlv_value == 1 ? ""Enabled"" : ""Disabled"",
                               tlv_value));
                        break;

                    case VTP_VLAN_STP_TYPE:
                        ND_PRINT((ndo, "", %s (%u)"",
                               tok2str(vtp_stp_type_values, ""Unknown"", tlv_value),
                               tlv_value));
                        break;

                    case VTP_VLAN_BRIDGE_TYPE:
                        ND_PRINT((ndo, "", %s (%u)"",
                               tlv_value == 1 ? ""SRB"" : ""SRT"",
                               tlv_value));
                        break;

                    case VTP_VLAN_BACKUP_CRF_MODE:
                        ND_PRINT((ndo, "", %s (%u)"",
                               tlv_value == 1 ? ""Backup"" : ""Not backup"",
                               tlv_value));
                        break;

                         

                    case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:
                    case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:
                    case VTP_VLAN_PARENT_VLAN:
                    case VTP_VLAN_TRANS_BRIDGED_VLAN:
                    case VTP_VLAN_ARP_HOP_COUNT:
                    default:
                        print_unknown_data(ndo, tptr, ""\n\t\t  "", 2 + tlv_len*2);
                        break;
                    }
                 }
                 len -= 2 + tlv_len*2;
                 tptr += 2 + tlv_len*2;",The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print().
977,CVE-2017-13032,"  print_attr_string(netdissect_options *ndo,
    {
       case TUNNEL_PASS:
            if (length < 3)
              goto trunc;
            if (*data && (*data <=0x1F) )
               ND_PRINT((ndo, ""Tag[%u] "", *data));
            else
  print_attr_string(netdissect_options *ndo,
            if (*data <= 0x1F)
            {
               if (length < 1)
                 goto trunc;
               if (*data)
                 ND_PRINT((ndo, ""Tag[%u] "", *data));
               else
  print_attr_string(netdissect_options *ndo,
            }
         break;
       case EGRESS_VLAN_NAME:
           if (length < 1)
              goto trunc;
            ND_PRINT((ndo, ""%s (0x%02x) "",
                   tok2str(rfc4675_tagged,""Unknown tag"",*data),
                   *data));
  print_attr_string(netdissect_options *ndo,
         break;
    }
 
   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));
 
    return;",The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().
978,CVE-2017-13031,"  frag6_print(netdissect_options *ndo, register const u_char *bp, register const u
 	dp = (const struct ip6_frag *)bp;
 	ip6 = (const struct ip6_hdr *)bp2;
 
	ND_TCHECK(*dp);
 
 	if (ndo->ndo_vflag) {
 		ND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",",The IPv6 fragmentation header parser in tcpdump before 4.9.2 has a buffer over-read in print-frag6.c:frag6_print().
979,CVE-2017-13030,"  pimv1_join_prune_print(netdissect_options *ndo,
 		return;
 	}
 
	if (len < sizeof(struct in_addr))
		goto trunc;
 	ND_TCHECK2(bp[0], sizeof(struct in_addr));
 	if (ndo->ndo_vflag > 1)
 		ND_PRINT((ndo, ""\n""));
 	ND_PRINT((ndo, "" Upstream Nbr: %s"", ipaddr_string(ndo, bp)));
	bp += 4;
	len -= 4;
	if (len < 4)
		goto trunc;
	ND_TCHECK2(bp[2], 2);
 	if (ndo->ndo_vflag > 1)
 		ND_PRINT((ndo, ""\n""));
 	ND_PRINT((ndo, "" Hold time: ""));
	unsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));
 	if (ndo->ndo_vflag < 2)
 		return;
	bp += 4;
	len -= 4;
 
	if (len < 4)
		goto trunc;
 	ND_TCHECK2(bp[0], 4);
 	ngroups = bp[3];
 	bp += 4;
  pimv1_join_prune_print(netdissect_options *ndo,
 		 * XXX - does the address have length ""addrlen"" and the
 		 * mask length ""maddrlen""?
 		 */
		if (len < 4)
			goto trunc;
 		ND_TCHECK2(bp[0], sizeof(struct in_addr));
 		ND_PRINT((ndo, ""\n\tGroup: %s"", ipaddr_string(ndo, bp)));
		bp += 4;
		len -= 4;
		if (len < 4)
			goto trunc;
		ND_TCHECK2(bp[0], sizeof(struct in_addr));
		if (EXTRACT_32BITS(&bp[0]) != 0xffffffff)
			ND_PRINT((ndo, ""/%s"", ipaddr_string(ndo, &bp[0])));
		bp += 4;
		len -= 4;
		if (len < 4)
			goto trunc;
		ND_TCHECK2(bp[0], 4);
		njoin = EXTRACT_16BITS(&bp[0]);
		nprune = EXTRACT_16BITS(&bp[2]);
 		ND_PRINT((ndo, "" joined: %d pruned: %d"", njoin, nprune));
		bp += 4;
		len -= 4;
 		for (njp = 0; njp < (njoin + nprune); njp++) {
 			const char *type;
 
 			if (njp < njoin)
 				type = ""Join "";
 			else
 				type = ""Prune"";
			if (len < 6)
				goto trunc;
 			ND_TCHECK2(bp[0], 6);
 			ND_PRINT((ndo, ""\n\t%s %s%s%s%s/%d"", type,
 			    (bp[0] & 0x01) ? ""Sparse "" : ""Dense "",
 			    (bp[1] & 0x80) ? ""WC "" : """",
 			    (bp[1] & 0x40) ? ""RP "" : ""SPT "",
			    ipaddr_string(ndo, &bp[2]),
			    bp[1] & 0x3f));
 			bp += 6;
 			len -= 6;
 		}
  void
 pimv1_print(netdissect_options *ndo,
             register const u_char *bp, register u_int len)
 {
 	register u_char type;
 
 	ND_TCHECK(bp[1]);
 	type = bp[1];
 
  pimv1_print(netdissect_options *ndo,
 	case PIMV1_TYPE_JOIN_PRUNE:
 	case PIMV1_TYPE_GRAFT:
 	case PIMV1_TYPE_GRAFT_ACK:
		if (ndo->ndo_vflag) {
			if (len < 8)
				goto trunc;
 			pimv1_join_prune_print(ndo, &bp[8], len - 8);
		}
 		break;
 	}
 	ND_TCHECK(bp[4]);
  cisco_autorp_print(netdissect_options *ndo,
 	int numrps;
 	int hold;
 
	if (len < 8)
		goto trunc;
 	ND_TCHECK(bp[0]);
 	ND_PRINT((ndo, "" auto-rp ""));
 	type = bp[0];
  cisco_autorp_print(netdissect_options *ndo,
 		int nentries;
 		char s;
 
		if (len < 4)
			goto trunc;
 		ND_TCHECK2(bp[0], 4);
 		ND_PRINT((ndo, "" RP %s"", ipaddr_string(ndo, bp)));
		bp += 4;
		len -= 4;
		if (len < 1)
			goto trunc;
		ND_TCHECK(bp[0]);
		switch (bp[0] & 0x3) {
 		case 0: ND_PRINT((ndo, "" PIMv?""));
 			break;
 		case 1:	ND_PRINT((ndo, "" PIMv1""));
  cisco_autorp_print(netdissect_options *ndo,
 		case 3:	ND_PRINT((ndo, "" PIMv1+2""));
 			break;
 		}
		if (bp[0] & 0xfc)
			ND_PRINT((ndo, "" [rsvd=0x%02x]"", bp[0] & 0xfc));
		bp += 1;
		len -= 1;
		if (len < 1)
			goto trunc;
		ND_TCHECK(bp[0]);
		nentries = bp[0];
		bp += 1;
		len -= 1;
 		s = ' ';
 		for (; nentries; nentries--) {
			if (len < 6)
				goto trunc;
 			ND_TCHECK2(bp[0], 6);
 			ND_PRINT((ndo, ""%c%s%s/%d"", s, bp[0] & 1 ? ""!"" : """",
 			          ipaddr_string(ndo, &bp[2]), bp[1]));
  void
 pim_print(netdissect_options *ndo,
           register const u_char *bp, register u_int len, const u_char *bp2)
 {
 	register const struct pim *pim = (const struct pim *)bp;
 
 #ifdef notyet			 
 	ND_TCHECK(pim->pim_rsv);
 #endif
 
	ND_TCHECK(pim->pim_typever);
 	switch (PIM_VER(pim->pim_typever)) {
 	case 2:
 		if (!ndo->ndo_vflag) {
  pim_print(netdissect_options *ndo,
 		break;
 	}
 	return;

trunc:
	ND_PRINT((ndo, ""[|pim]""));
	return;
 }
 
  
 
 enum pimv2_addrtype {
 	pimv2_unicast, pimv2_group, pimv2_source
 };
  enum pimv2_addrtype {
  */
 static int
 pimv2_addr_print(netdissect_options *ndo,
                 const u_char *bp, u_int len, enum pimv2_addrtype at,
                 u_int addr_len, int silent)
 {
 	int af;
	int hdrlen;
 
	if (addr_len == 0) {
		if (len < 2)
			goto trunc;
 		ND_TCHECK(bp[1]);
 		switch (bp[0]) {
 		case 1:
 			af = AF_INET;
			addr_len = (u_int)sizeof(struct in_addr);
 			break;
 		case 2:
 			af = AF_INET6;
			addr_len = (u_int)sizeof(struct in6_addr);
 			break;
 		default:
 			return -1;
  pimv2_addr_print(netdissect_options *ndo,
 			return -1;
 		hdrlen = 2;
 	} else {
		switch (addr_len) {
 		case sizeof(struct in_addr):
 			af = AF_INET;
 			break;
  pimv2_addr_print(netdissect_options *ndo,
 			return -1;
 			break;
 		}
 		hdrlen = 0;
 	}
 
 	bp += hdrlen;
	len -= hdrlen;
 	switch (at) {
 	case pimv2_unicast:
		if (len < addr_len)
			goto trunc;
		ND_TCHECK2(bp[0], addr_len);
 		if (af == AF_INET) {
 			if (!silent)
 				ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, bp)));
  pimv2_addr_print(netdissect_options *ndo,
 			if (!silent)
 				ND_PRINT((ndo, ""%s"", ip6addr_string(ndo, bp)));
 		}
		return hdrlen + addr_len;
 	case pimv2_group:
 	case pimv2_source:
		if (len < addr_len + 2)
			goto trunc;
		ND_TCHECK2(bp[0], addr_len + 2);
 		if (af == AF_INET) {
 			if (!silent) {
 				ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, bp + 2)));
  pimv2_addr_print(netdissect_options *ndo,
 				ND_PRINT((ndo, "")""));
 			}
 		}
		return hdrlen + 2 + addr_len;
 	default:
 		return -1;
 	}
  pimv2_print(netdissect_options *ndo,
 	register const struct pim *pim = (const struct pim *)bp;
 	int advance;
 	enum checksum_status cksum_status;
	int pimv2_addr_len;
 
 	ep = (const u_char *)ndo->ndo_snapend;
 	if (bp >= ep)
 		return;
 	if (ep > bp + len)
 		ep = bp + len;
	if (len < 2)
		goto trunc;
 	ND_TCHECK(pim->pim_rsv);
 	pimv2_addr_len = pim->pim_rsv;
 	if (pimv2_addr_len != 0)
 		ND_PRINT((ndo, "", RFC2117-encoding""));
 
	if (len < 4)
		goto trunc;
	ND_TCHECK(pim->pim_cksum);
 	ND_PRINT((ndo, "", cksum 0x%04x "", EXTRACT_16BITS(&pim->pim_cksum)));
 	if (EXTRACT_16BITS(&pim->pim_cksum) == 0) {
 		ND_PRINT((ndo, ""(unverified)""));
  pimv2_print(netdissect_options *ndo,
 			break;
 		}
 	}
	bp += 4;
	len -= 4;
 
 	switch (PIM_TYPE(pim->pim_typever)) {
 	case PIMV2_TYPE_HELLO:
 	    {
 		uint16_t otype, olen;
		while (len > 0) {
			if (len < 4)
				goto trunc;
 			ND_TCHECK2(bp[0], 4);
 			otype = EXTRACT_16BITS(&bp[0]);
 			olen = EXTRACT_16BITS(&bp[2]);
 			ND_PRINT((ndo, ""\n\t  %s Option (%u), length %u, Value: "",
 			          tok2str(pimv2_hello_option_values, ""Unknown"", otype),
 			          otype,
 			          olen));
 			bp += 4;
			len -= 4;
 
			if (len < olen)
				goto trunc;
			ND_TCHECK2(bp[0], olen);
 			switch (otype) {
 			case PIMV2_HELLO_OPTION_HOLDTIME:
 				if (olen != 2) {
  pimv2_print(netdissect_options *ndo,
 			case PIMV2_HELLO_OPTION_ADDRESS_LIST:
 				if (ndo->ndo_vflag > 1) {
 					const u_char *ptr = bp;
					u_int plen = len;
 					while (ptr < (bp+olen)) {
 						ND_PRINT((ndo, ""\n\t    ""));
						advance = pimv2_addr_print(ndo, ptr, plen, pimv2_unicast, pimv2_addr_len, 0);
						if (advance < 0)
							goto trunc;
 						ptr += advance;
						plen -= advance;
 					}
 				}
 				break;
  pimv2_print(netdissect_options *ndo,
 			if (ndo->ndo_vflag> 1)
 				print_unknown_data(ndo, bp, ""\n\t    "", olen);
 			bp += olen;
			len -= olen;
 		}
 		break;
 	    }
  pimv2_print(netdissect_options *ndo,
 	{
 		const struct ip *ip;
 
		if (len < 4)
			goto trunc;
		ND_TCHECK2(*bp, PIMV2_REGISTER_FLAG_LEN);
 
 		ND_PRINT((ndo, "", Flags [ %s ]\n\t"",
 		          tok2str(pimv2_register_flag_values,
 		          ""none"",
		          EXTRACT_32BITS(bp))));
 
		bp += 4; len -= 4;
 		 
		if (len == 0)
			goto trunc;
 		ip = (const struct ip *)bp;
		ND_TCHECK(ip->ip_vhl);
 		switch (IP_V(ip)) {
                 case 0:  
			ND_TCHECK(ip->ip_dst);
 			ND_PRINT((ndo, ""IP-Null-header %s > %s"",
 			          ipaddr_string(ndo, &ip->ip_src),
 			          ipaddr_string(ndo, &ip->ip_dst)));
  pimv2_print(netdissect_options *ndo,
 	}
 
 	case PIMV2_TYPE_REGISTER_STOP:
 		ND_PRINT((ndo, "" group=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance; len -= advance;
 		ND_PRINT((ndo, "" source=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance; len -= advance;
 		break;
 
  pimv2_print(netdissect_options *ndo,
 		uint16_t nprune;
 		int i, j;
 
 		if (PIM_TYPE(pim->pim_typever) != 7) {	 
 			ND_PRINT((ndo, "", upstream-neighbor: ""));
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
				goto trunc;
 			bp += advance; len -= advance;
 		}
		if (len < 4)
			goto trunc;
		ND_TCHECK2(*bp, 4);
 		ngroup = bp[1];
 		holdtime = EXTRACT_16BITS(&bp[2]);
 		ND_PRINT((ndo, ""\n\t  %u group(s)"", ngroup));
  pimv2_print(netdissect_options *ndo,
 		}
 		bp += 4; len -= 4;
 		for (i = 0; i < ngroup; i++) {
 			ND_PRINT((ndo, ""\n\t    group #%u: "", i+1));
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
				goto trunc;
 			bp += advance; len -= advance;
			if (len < 4)
				goto trunc;
			ND_TCHECK2(*bp, 4);
 			njoin = EXTRACT_16BITS(&bp[0]);
 			nprune = EXTRACT_16BITS(&bp[2]);
 			ND_PRINT((ndo, "", joined sources: %u, pruned sources: %u"", njoin, nprune));
 			bp += 4; len -= 4;
 			for (j = 0; j < njoin; j++) {
 				ND_PRINT((ndo, ""\n\t      joined source #%u: "", j+1));
				if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_source, pimv2_addr_len, 0)) < 0)
					goto trunc;
 				bp += advance; len -= advance;
 			}
 			for (j = 0; j < nprune; j++) {
 				ND_PRINT((ndo, ""\n\t      pruned source #%u: "", j+1));
				if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_source, pimv2_addr_len, 0)) < 0)
					goto trunc;
 				bp += advance; len -= advance;
 			}
 		}
 		break;
 	    }
 
 	case PIMV2_TYPE_BOOTSTRAP:
 	{
 		int i, j, frpcnt;
 
 		 
		if (len < 2)
			goto trunc;
		ND_TCHECK_16BITS(bp);
 		ND_PRINT((ndo, "" tag=%x"", EXTRACT_16BITS(bp)));
		bp += 2;
		len -= 2;
		if (len < 1)
			goto trunc;
		ND_TCHECK(bp[0]);
 		ND_PRINT((ndo, "" hashmlen=%d"", bp[0]));
		if (len < 2)
			goto trunc;
		ND_TCHECK(bp[2]);
 		ND_PRINT((ndo, "" BSRprio=%d"", bp[1]));
 		bp += 2;
		len -= 2;
 
 		 
 		ND_PRINT((ndo, "" BSR=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance;
		len -= advance;
 
 		for (i = 0; bp < ep; i++) {
 			 
 			ND_PRINT((ndo, "" (group%d: "", i));
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
				goto trunc;
 			bp += advance;
			len -= advance;
 
 			 
			if (len < 1)
				goto trunc;
			ND_TCHECK(bp[0]);
 			ND_PRINT((ndo, "" RPcnt=%d"", bp[0]));
			if (len < 2)
				goto trunc;
			ND_TCHECK(bp[1]);
 			ND_PRINT((ndo, "" FRPcnt=%d"", frpcnt = bp[1]));
			if (len < 4)
				goto trunc;
 			bp += 4;
			len -= 4;
 
 			for (j = 0; j < frpcnt && bp < ep; j++) {
 				 
 				ND_PRINT((ndo, "" RP%d="", j));
				if ((advance = pimv2_addr_print(ndo, bp, len,
 								pimv2_unicast,
								pimv2_addr_len,
								0)) < 0)
					goto trunc;
 				bp += advance;
				len -= advance;
 
				if (len < 2)
					goto trunc;
				ND_TCHECK_16BITS(bp);
 				ND_PRINT((ndo, "",holdtime=""));
 				unsigned_relts_print(ndo, EXTRACT_16BITS(bp));
				if (len < 3)
					goto trunc;
				ND_TCHECK(bp[2]);
 				ND_PRINT((ndo, "",prio=%d"", bp[2]));
				if (len < 4)
					goto trunc;
 				bp += 4;
				len -= 4;
 			}
 			ND_PRINT((ndo, "")""));
 		}
 		break;
 	}
 	case PIMV2_TYPE_ASSERT:
 		ND_PRINT((ndo, "" group=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance; len -= advance;
 		ND_PRINT((ndo, "" src=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance; len -= advance;
		if (len < 8)
			goto trunc;
		ND_TCHECK2(*bp, 8);
 		if (bp[0] & 0x80)
 			ND_PRINT((ndo, "" RPT""));
 		ND_PRINT((ndo, "" pref=%u"", EXTRACT_32BITS(&bp[0]) & 0x7fffffff));
  pimv2_print(netdissect_options *ndo,
 	case PIMV2_TYPE_CANDIDATE_RP:
 	{
 		int i, pfxcnt;
 
 		 
		if (len < 1)
			goto trunc;
		ND_TCHECK(bp[0]);
 		ND_PRINT((ndo, "" prefix-cnt=%d"", bp[0]));
 		pfxcnt = bp[0];
		if (len < 2)
			goto trunc;
		ND_TCHECK(bp[1]);
 		ND_PRINT((ndo, "" prio=%d"", bp[1]));
		if (len < 4)
			goto trunc;
		ND_TCHECK_16BITS(&bp[2]);
 		ND_PRINT((ndo, "" holdtime=""));
 		unsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));
 		bp += 4;
		len -= 4;
 
 		 
 		ND_PRINT((ndo, "" RP=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance;
		len -= advance;
 
 		 
 		for (i = 0; i < pfxcnt && bp < ep; i++) {
 			ND_PRINT((ndo, "" Group%d="", i));
			if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
				goto trunc;
 			bp += advance;
			len -= advance;
 		}
 		break;
 	}
 
 	case PIMV2_TYPE_PRUNE_REFRESH:
 		ND_PRINT((ndo, "" src=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance;
		len -= advance;
 		ND_PRINT((ndo, "" grp=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_group, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance;
		len -= advance;
 		ND_PRINT((ndo, "" forwarder=""));
		if ((advance = pimv2_addr_print(ndo, bp, len, pimv2_unicast, pimv2_addr_len, 0)) < 0)
			goto trunc;
 		bp += advance;
		len -= advance;
		if (len < 2)
			goto trunc;
		ND_TCHECK_16BITS(bp);
 		ND_PRINT((ndo, "" TUNR ""));
 		unsigned_relts_print(ndo, EXTRACT_16BITS(bp));
 		break;","The PIM parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c, several functions."
980,CVE-2017-13029,"  print_lcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be >= 6)""));
 			return len;
 		}
		ND_TCHECK_24BITS(p + 2);
 		ND_PRINT((ndo, "": Vendor: %s (%u)"",
 			tok2str(oui_values,""Unknown"",EXTRACT_24BITS(p+2)),
 			EXTRACT_24BITS(p + 2)));
  print_lcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be = 4)""));
 			return len;
 		}
		ND_TCHECK_16BITS(p + 2);
 		ND_PRINT((ndo, "": %u"", EXTRACT_16BITS(p + 2)));
 		break;
 	case LCPOPT_ACCM:
 		if (len != 6) {
 			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
 			return len;
 		}
		ND_TCHECK_32BITS(p + 2);
 		ND_PRINT((ndo, "": 0x%08x"", EXTRACT_32BITS(p + 2)));
 		break;
 	case LCPOPT_AP:
 		if (len < 4) {
 			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
 			return len;
 		}
		ND_TCHECK_16BITS(p + 2);
 		ND_PRINT((ndo, "": %s"", tok2str(ppptype2str, ""Unknown Auth Proto (0x04x)"", EXTRACT_16BITS(p + 2))));
 
 		switch (EXTRACT_16BITS(p+2)) {
  print_lcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
 			return 0;
 		}
		ND_TCHECK_16BITS(p+2);
 		if (EXTRACT_16BITS(p+2) == PPP_LQM)
 			ND_PRINT((ndo, "": LQR""));
 		else
  print_lcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
 			return 0;
 		}
		ND_TCHECK_32BITS(p + 2);
 		ND_PRINT((ndo, "": 0x%08x"", EXTRACT_32BITS(p + 2)));
 		break;
 	case LCPOPT_PFC:
  print_lcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be = 4)""));
 			return 0;
 		}
		ND_TCHECK_16BITS(p + 2);
 		ND_PRINT((ndo, "": 0x%04x"", EXTRACT_16BITS(p + 2)));
 		break;
 	case LCPOPT_CBACK:
  print_lcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be = 4)""));
 			return 0;
 		}
		ND_TCHECK_16BITS(p + 2);
 		ND_PRINT((ndo, "": %u"", EXTRACT_16BITS(p + 2)));
 		break;
 	case LCPOPT_MLED:
  print_ipcp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
 			return 0;
 		}
		ND_TCHECK_16BITS(p+2);
 		compproto = EXTRACT_16BITS(p+2);
 
 		ND_PRINT((ndo, "": %s (0x%02x):"",
  print_ccp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be >= 3)""));
 			return len;
 		}
		ND_TCHECK(p[2]);
 		ND_PRINT((ndo, "": Version: %u, Dictionary Bits: %u"",
 			p[2] >> 5, p[2] & 0x1f));
 		break;
  print_ccp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
 			return len;
 		}
		ND_TCHECK(p[3]);
 		ND_PRINT((ndo, "": Features: %u, PxP: %s, History: %u, #CTX-ID: %u"",
 				(p[2] & 0xc0) >> 6,
 				(p[2] & 0x20) ? ""Enabled"" : ""Disabled"",
  print_ccp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
 			return len;
 		}
		ND_TCHECK(p[3]);
 		ND_PRINT((ndo, "": Window: %uK, Method: %s (0x%x), MBZ: %u, CHK: %u"",
 			(p[2] & 0xf0) >> 4,
 			((p[2] & 0x0f) == 8) ? ""zlib"" : ""unknown"",
  print_bacp_config_options(netdissect_options *ndo,
 			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
 			return len;
 		}
		ND_TCHECK_32BITS(p + 2);
 		ND_PRINT((ndo, "": Magic-Num 0x%08x"", EXTRACT_32BITS(p + 2)));
 		break;
 	default:",The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:print_ccp_config_options().
981,CVE-2017-13027,"  lldp_mgmt_addr_tlv_print(netdissect_options *ndo,
     if (tlen) {
         oid_len = *tptr;
 
        if (tlen < 1U + oid_len) {
             return 0;
         }
         if (oid_len) {",The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_mgmt_addr_tlv_print().
982,CVE-2017-13026,"  isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
 
   while (len > 2)
   {
    ND_TCHECK2(*tptr, 2);
     stlv_type = *(tptr++);
     stlv_len  = *(tptr++);
 
  isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
      
     len = len -2;
 
     
    if (len < stlv_len)
      goto trunc;
     
    ND_TCHECK2(*(tptr), stlv_len);

     switch (stlv_type)
     {
       case ISIS_SUBTLV_SPB_MCID:
       {
      	if (stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN)
      	  goto trunc;
 
         subtlv_spb_mcid = (const struct isis_subtlv_spb_mcid *)tptr;
 
  isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
 
            
        tptr = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN;
        len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN;
        stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN;
 
         break;
       }
 
       case ISIS_SUBTLV_SPB_DIGEST:
       {
        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
          goto trunc;
 
         ND_PRINT((ndo, ""\n\t        RES: %d V: %d A: %d D: %d"",
                         (*(tptr) >> 5), (((*tptr)>> 4) & 0x01),
  isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
         }
 
         len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
        stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
 
         break;
       }
 
       case ISIS_SUBTLV_SPB_BVID:
       {
        while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
         {
           ND_PRINT((ndo, ""\n\t           ECT: %08x"",
                       EXTRACT_32BITS(tptr)));
 
  isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
 
           tptr = tptr + 2;
           len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
          stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
         }
 
         break;
       }
 
       default:
        break;
     }
    tptr += stlv_len;
    len -= stlv_len;
   }
 
   return 0;
  isis_print_mt_capability_subtlv(netdissect_options *ndo,
 
   while (len > 2)
   {
    ND_TCHECK2(*tptr, 2);
     stlv_type = *(tptr++);
     stlv_len  = *(tptr++);
 
  isis_print_mt_capability_subtlv(netdissect_options *ndo,
 
     len = len - 2;
 
     
    if (len < stlv_len)
      goto trunc;
     
    ND_TCHECK2(*(tptr), stlv_len);

     switch (stlv_type)
     {
       case ISIS_SUBTLV_SPB_INSTANCE:
          if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN)
            goto trunc;
 
           ND_PRINT((ndo, ""\n\t        CIST Root-ID: %08x"", EXTRACT_32BITS(tptr)));
           tptr = tptr+4;
  isis_print_mt_capability_subtlv(netdissect_options *ndo,
           tmp = *(tptr++);
 
           len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;
          stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;
 
           while (tmp)
           {
            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
              goto trunc;
 
             ND_PRINT((ndo, ""\n\t         U:%d, M:%d, A:%d, RES:%d"",
                       *(tptr) >> 7, (*(tptr) >> 6) & 0x01,
  isis_print_mt_capability_subtlv(netdissect_options *ndo,
 
             tptr = tptr + 3;
             len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;
            stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;
             tmp--;
           }
 
           break;
 
       case ISIS_SUBTLV_SPBM_SI:
          if (stlv_len < 8)
            goto trunc;
 
           ND_PRINT((ndo, ""\n\t        BMAC: %08x"", EXTRACT_32BITS(tptr)));
           tptr = tptr+4;
  isis_print_mt_capability_subtlv(netdissect_options *ndo,
       default:
         break;
     }
    tptr += stlv_len;
    len -= stlv_len;
   }
   return 0;
 ","The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions."
983,CVE-2017-13025,"  EXTRACT_64BITS(const void *p)
 
 #define ND_TTEST_64BITS(p) ND_TTEST2(*(p), 8)
 #define ND_TCHECK_64BITS(p) ND_TCHECK2(*(p), 8)

#define ND_TTEST_128BITS(p) ND_TTEST2(*(p), 16)
#define ND_TCHECK_128BITS(p) ND_TCHECK2(*(p), 16)",The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().
984,CVE-2017-13024,"  mobility_opt_print(netdissect_options *ndo,
 				ND_PRINT((ndo, ""(ni: trunc)""));
 				goto trunc;
 			}
			ND_TCHECK_16BITS(&bp[i+2]);
			ND_TCHECK_16BITS(&bp[i+4]);
 			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
 				EXTRACT_16BITS(&bp[i+2]),
 				EXTRACT_16BITS(&bp[i+4])));",The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().
985,CVE-2017-13023,"  mobility_opt_print(netdissect_options *ndo,
 				goto trunc;
 			}
 			 
			ND_TCHECK_16BITS(&bp[i+2]);
 			ND_PRINT((ndo, ""(refresh: %u)"",
 				EXTRACT_16BITS(&bp[i+2]) << 2));
 			break;",The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().
986,CVE-2017-13022,"  static const struct tok ip_option_values[] = {
  
static int
 ip_printroute(netdissect_options *ndo,
               register const u_char *cp, u_int length)
 {
  ip_printroute(netdissect_options *ndo,
 
 	if (length < 3) {
 		ND_PRINT((ndo, "" [bad length %u]"", length));
		return (0);
 	}
 	if ((length + 1) & 3)
 		ND_PRINT((ndo, "" [bad length %u]"", length));
	ND_TCHECK(cp[2]);
 	ptr = cp[2] - 1;
 	if (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)
 		ND_PRINT((ndo, "" [bad ptr %u]"", cp[2]));
 
 	for (len = 3; len < length; len += 4) {
		ND_TCHECK2(cp[len], 4);
 		ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, &cp[len])));
 		if (ptr > len)
 			ND_PRINT((ndo, "",""));
 	}
	return (0);

trunc:
	return (-1);
 }
 
  
 		case IPOPT_SSRR:
 		case IPOPT_LSRR:
			if (ip_printroute(ndo, cp, option_len) == -1)
				goto trunc;
 			break;
 
 		case IPOPT_RA:",The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printroute().
987,CVE-2017-13021,"  icmp6_print(netdissect_options *ndo,
 		if (ndo->ndo_vflag) {
 			ND_TCHECK(dp->icmp6_data16[0]);
 			ND_PRINT((ndo,"", id 0x%04x"", EXTRACT_16BITS(&dp->icmp6_data16[0])));
			ND_TCHECK(dp->icmp6_data16[1]);
 			if (dp->icmp6_data16[1] & 0xc0)
 				ND_PRINT((ndo,"" ""));
 			if (dp->icmp6_data16[1] & 0x80)",The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_print().
988,CVE-2017-13020,"  vtp_print (netdissect_options *ndo,
 	 *
 	 */
 
	ND_TCHECK_32BITS(tptr);
 	ND_PRINT((ndo, "", Config Rev %x"", EXTRACT_32BITS(tptr)));
 
 	/*
  vtp_print (netdissect_options *ndo,
 	tptr += 4;
 	while (tptr < (pptr+length)) {
 
	    ND_TCHECK_8BITS(tptr);
 	    len = *tptr;
 	    if (len == 0)
 		break;",The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print().
989,CVE-2017-13019,"  pgm_print(netdissect_options *ndo,
 
 		switch (opt_type & PGM_OPT_MASK) {
 		case PGM_OPT_LENGTH:
#define PGM_OPT_LENGTH_LEN	(2+2)
		    if (opt_len != PGM_OPT_LENGTH_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_LENGTH option, length %u != %u]"",
			    opt_len, PGM_OPT_LENGTH_LEN));
 			return;
 		    }
 		    ND_PRINT((ndo, "" OPTS LEN (extra?) %d"", EXTRACT_16BITS(bp)));
		    bp += 2;
		    opts_len -= PGM_OPT_LENGTH_LEN;
 		    break;
 
 		case PGM_OPT_FRAGMENT:
#define PGM_OPT_FRAGMENT_LEN	(2+2+4+4+4)
		    if (opt_len != PGM_OPT_FRAGMENT_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_FRAGMENT option, length %u != %u]"",
			    opt_len, PGM_OPT_FRAGMENT_LEN));
 			return;
 		    }
 		    bp += 2;
 		    seq = EXTRACT_32BITS(bp);
		    bp += 4;
 		    offset = EXTRACT_32BITS(bp);
		    bp += 4;
 		    len = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" FRAG seq %u off %u len %u"", seq, offset, len));
		    opts_len -= PGM_OPT_FRAGMENT_LEN;
 		    break;
 
 		case PGM_OPT_NAK_LIST:
 		    bp += 2;
		    opt_len -= 4;	 
 		    ND_PRINT((ndo, "" NAK LIST""));
 		    while (opt_len) {
			if (opt_len < 4) {
 			    ND_PRINT((ndo, ""[Option length not a multiple of 4]""));
 			    return;
 			}
			ND_TCHECK2(*bp, 4);
 			ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(bp)));
			bp += 4;
			opt_len -= 4;
			opts_len -= 4;
 		    }
 		    break;
 
 		case PGM_OPT_JOIN:
#define PGM_OPT_JOIN_LEN	(2+2+4)
		    if (opt_len != PGM_OPT_JOIN_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_JOIN option, length %u != %u]"",
			    opt_len, PGM_OPT_JOIN_LEN));
 			return;
 		    }
 		    bp += 2;
 		    seq = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" JOIN %u"", seq));
		    opts_len -= PGM_OPT_JOIN_LEN;
 		    break;
 
 		case PGM_OPT_NAK_BO_IVL:
#define PGM_OPT_NAK_BO_IVL_LEN	(2+2+4+4)
		    if (opt_len != PGM_OPT_NAK_BO_IVL_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_NAK_BO_IVL option, length %u != %u]"",
			    opt_len, PGM_OPT_NAK_BO_IVL_LEN));
 			return;
 		    }
 		    bp += 2;
 		    offset = EXTRACT_32BITS(bp);
		    bp += 4;
 		    seq = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" BACKOFF ivl %u ivlseq %u"", offset, seq));
		    opts_len -= PGM_OPT_NAK_BO_IVL_LEN;
 		    break;
 
 		case PGM_OPT_NAK_BO_RNG:
#define PGM_OPT_NAK_BO_RNG_LEN	(2+2+4+4)
		    if (opt_len != PGM_OPT_NAK_BO_RNG_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_NAK_BO_RNG option, length %u != %u]"",
			    opt_len, PGM_OPT_NAK_BO_RNG_LEN));
 			return;
 		    }
 		    bp += 2;
 		    offset = EXTRACT_32BITS(bp);
		    bp += 4;
 		    seq = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" BACKOFF max %u min %u"", offset, seq));
		    opts_len -= PGM_OPT_NAK_BO_RNG_LEN;
 		    break;
 
 		case PGM_OPT_REDIRECT:
#define PGM_OPT_REDIRECT_FIXED_LEN	(2+2+2+2)
		    if (opt_len < PGM_OPT_REDIRECT_FIXED_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u < %u]"",
			    opt_len, PGM_OPT_REDIRECT_FIXED_LEN));
			return;
		    }
 		    bp += 2;
 		    nla_afnum = EXTRACT_16BITS(bp);
		    bp += 2+2;
 		    switch (nla_afnum) {
 		    case AFNUM_INET:
			if (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != %u + address size]"",
			        opt_len, PGM_OPT_REDIRECT_FIXED_LEN));
 			    return;
 			}
 			ND_TCHECK2(*bp, sizeof(struct in_addr));
 			addrtostr(bp, nla_buf, sizeof(nla_buf));
 			bp += sizeof(struct in_addr);
			opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr);
 			break;
 		    case AFNUM_INET6:
			if (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != %u + address size]"",
			        PGM_OPT_REDIRECT_FIXED_LEN, opt_len));
 			    return;
 			}
 			ND_TCHECK2(*bp, sizeof(struct in6_addr));
 			addrtostr6(bp, nla_buf, sizeof(nla_buf));
 			bp += sizeof(struct in6_addr);
			opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr);
 			break;
 		    default:
 			goto trunc;
  pgm_print(netdissect_options *ndo,
 		    break;
 
 		case PGM_OPT_PARITY_PRM:
#define PGM_OPT_PARITY_PRM_LEN	(2+2+4)
		    if (opt_len != PGM_OPT_PARITY_PRM_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_PARITY_PRM option, length %u != %u]"",
			    opt_len, PGM_OPT_PARITY_PRM_LEN));
 			return;
 		    }
 		    bp += 2;
 		    len = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" PARITY MAXTGS %u"", len));
		    opts_len -= PGM_OPT_PARITY_PRM_LEN;
 		    break;
 
 		case PGM_OPT_PARITY_GRP:
#define PGM_OPT_PARITY_GRP_LEN	(2+2+4)
		    if (opt_len != PGM_OPT_PARITY_GRP_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_PARITY_GRP option, length %u != %u]"",
			    opt_len, PGM_OPT_PARITY_GRP_LEN));
 			return;
 		    }
 		    bp += 2;
 		    seq = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" PARITY GROUP %u"", seq));
		    opts_len -= PGM_OPT_PARITY_GRP_LEN;
 		    break;
 
 		case PGM_OPT_CURR_TGSIZE:
#define PGM_OPT_CURR_TGSIZE_LEN	(2+2+4)
		    if (opt_len != PGM_OPT_CURR_TGSIZE_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_CURR_TGSIZE option, length %u != %u]"",
			    opt_len, PGM_OPT_CURR_TGSIZE_LEN));
 			return;
 		    }
 		    bp += 2;
 		    len = EXTRACT_32BITS(bp);
		    bp += 4;
 		    ND_PRINT((ndo, "" PARITY ATGS %u"", len));
		    opts_len -= PGM_OPT_CURR_TGSIZE_LEN;
 		    break;
 
 		case PGM_OPT_NBR_UNREACH:
#define PGM_OPT_NBR_UNREACH_LEN	(2+2)
		    if (opt_len != PGM_OPT_NBR_UNREACH_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_NBR_UNREACH option, length %u != %u]"",
			    opt_len, PGM_OPT_NBR_UNREACH_LEN));
 			return;
 		    }
 		    bp += 2;
 		    ND_PRINT((ndo, "" NBR_UNREACH""));
		    opts_len -= PGM_OPT_NBR_UNREACH_LEN;
 		    break;
 
 		case PGM_OPT_PATH_NLA:
  pgm_print(netdissect_options *ndo,
 		    break;
 
 		case PGM_OPT_SYN:
#define PGM_OPT_SYN_LEN	(2+2)
		    if (opt_len != PGM_OPT_SYN_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_SYN option, length %u != %u]"",
			    opt_len, PGM_OPT_SYN_LEN));
 			return;
 		    }
 		    bp += 2;
 		    ND_PRINT((ndo, "" SYN""));
		    opts_len -= PGM_OPT_SYN_LEN;
 		    break;
 
 		case PGM_OPT_FIN:
#define PGM_OPT_FIN_LEN	(2+2)
		    if (opt_len != PGM_OPT_FIN_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_FIN option, length %u != %u]"",
			    opt_len, PGM_OPT_FIN_LEN));
 			return;
 		    }
 		    bp += 2;
 		    ND_PRINT((ndo, "" FIN""));
		    opts_len -= PGM_OPT_FIN_LEN;
 		    break;
 
 		case PGM_OPT_RST:
#define PGM_OPT_RST_LEN	(2+2)
		    if (opt_len != PGM_OPT_RST_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_RST option, length %u != %u]"",
			    opt_len, PGM_OPT_RST_LEN));
 			return;
 		    }
 		    bp += 2;
 		    ND_PRINT((ndo, "" RST""));
		    opts_len -= PGM_OPT_RST_LEN;
 		    break;
 
 		case PGM_OPT_CR:
  pgm_print(netdissect_options *ndo,
 		    break;
 
 		case PGM_OPT_CRQST:
#define PGM_OPT_CRQST_LEN	(2+2)
		    if (opt_len != PGM_OPT_CRQST_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_CRQST option, length %u != %u]"",
			    opt_len, PGM_OPT_CRQST_LEN));
 			return;
 		    }
 		    bp += 2;
 		    ND_PRINT((ndo, "" CRQST""));
		    opts_len -= PGM_OPT_CRQST_LEN;
 		    break;
 
 		case PGM_OPT_PGMCC_DATA:
#define PGM_OPT_PGMCC_DATA_FIXED_LEN	(2+2+4+2+2)
		    if (opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN) {
			ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u < %u]"",
			    opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));
			return;
		    }
 		    bp += 2;
 		    offset = EXTRACT_32BITS(bp);
		    bp += 4;
 		    nla_afnum = EXTRACT_16BITS(bp);
		    bp += 2+2;
 		    switch (nla_afnum) {
 		    case AFNUM_INET:
			if (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != %u + address size]"",
			        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));
 			    return;
 			}
 			ND_TCHECK2(*bp, sizeof(struct in_addr));
 			addrtostr(bp, nla_buf, sizeof(nla_buf));
 			bp += sizeof(struct in_addr);
			opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr);
 			break;
 		    case AFNUM_INET6:
			if (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != %u + address size]"",
			        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));
 			    return;
 			}
 			ND_TCHECK2(*bp, sizeof(struct in6_addr));
 			addrtostr6(bp, nla_buf, sizeof(nla_buf));
 			bp += sizeof(struct in6_addr);
			opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr);
 			break;
 		    default:
 			goto trunc;
  pgm_print(netdissect_options *ndo,
 		    break;
 
 		case PGM_OPT_PGMCC_FEEDBACK:
#define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN	(2+2+4+2+2)
		    if (opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN) {
			ND_PRINT((ndo, ""[Bad PGM_OPT_PGMCC_FEEDBACK option, length %u < %u]"",
			    opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));
			return;
		    }
 		    bp += 2;
 		    offset = EXTRACT_32BITS(bp);
		    bp += 4;
 		    nla_afnum = EXTRACT_16BITS(bp);
		    bp += 2+2;
 		    switch (nla_afnum) {
 		    case AFNUM_INET:
			if (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]"",
			        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));
 			    return;
 			}
 			ND_TCHECK2(*bp, sizeof(struct in_addr));
 			addrtostr(bp, nla_buf, sizeof(nla_buf));
 			bp += sizeof(struct in_addr);
			opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr);
 			break;
 		    case AFNUM_INET6:
			if (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]"",
			        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));
 			    return;
 			}
 			ND_TCHECK2(*bp, sizeof(struct in6_addr));
 			addrtostr6(bp, nla_buf, sizeof(nla_buf));
 			bp += sizeof(struct in6_addr);
			opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr);
 			break;
 		    default:
 			goto trunc;",The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print().
990,CVE-2017-13018,"  pgm_print(netdissect_options *ndo,
 		    ND_PRINT((ndo, ""[Total option length leaves no room for final option]""));
 		    return;
 		}
		if (!ND_TTEST2(*bp, 2)) {
		    ND_PRINT((ndo, "" [|OPT]""));
		    return;
		}
 		opt_type = *bp++;
 		opt_len = *bp++;
 		if (opt_len < PGM_MIN_OPT_LEN) {",The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print().
991,CVE-2017-13017,"  dhcp6opt_print(netdissect_options *ndo,
 			ND_PRINT((ndo, ""...)""));
 			break;
 		case DH6OPT_RECONF_MSG:
			if (optlen != 1) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
 			tp = (const u_char *)(dh6o + 1);
 			switch (*tp) {
 			case DH6_RENEW:",The DHCPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-dhcp6.c:dhcp6opt_print().
992,CVE-2017-13016,"  enum {
     LINKADDR_ETHER,
     LINKADDR_FRELAY,
     LINKADDR_IEEE1394,
    LINKADDR_ATM,
    LINKADDR_OTHER
 };
 
 #define BUFSIZE 128",The ISO ES-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:esis_print().
993,CVE-2017-13015,"  eap_print(netdissect_options *ndo,
 
     switch (eap->type) {
     case EAP_FRAME_TYPE_PACKET:
        ND_TCHECK_8BITS(tptr);
         type = *(tptr);
        ND_TCHECK_16BITS(tptr+2);
         len = EXTRACT_16BITS(tptr+2);
         ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
                tok2str(eap_code_values, ""unknown"", type),
  eap_print(netdissect_options *ndo,
         ND_TCHECK2(*tptr, len);
 
         if (type <= 2) {  
            ND_TCHECK_8BITS(tptr+4);
             subtype = *(tptr+4);
             ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
                   tok2str(eap_type_values, ""unknown"", subtype),
                   subtype));
 
             switch (subtype) {
             case EAP_TYPE_IDENTITY:
  eap_print(netdissect_options *ndo,
                  * type one octet per type
                  */
                 while (count < len) {
                    ND_TCHECK_8BITS(tptr+count);
                     ND_PRINT((ndo, "" %s (%u),"",
                            tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                            *(tptr + count)));
  eap_print(netdissect_options *ndo,
                 break;
 
             case EAP_TYPE_TTLS:
             case EAP_TYPE_TLS:
                ND_TCHECK_8BITS(tptr + 5);
                if (subtype == EAP_TYPE_TTLS)
                    ND_PRINT((ndo, "" TTLSv%u"",
                           EAP_TTLS_VERSION(*(tptr + 5))));
                 ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                        bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                        *(tptr + 5)));
 
                 if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_TCHECK_32BITS(tptr + 6);
 		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                 }
                 break;
 
             case EAP_TYPE_FAST:
                ND_TCHECK_8BITS(tptr + 5);
                 ND_PRINT((ndo, "" FASTv%u"",
                        EAP_TTLS_VERSION(*(tptr + 5))));
                 ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                        bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                        *(tptr + 5)));
 
                 if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_TCHECK_32BITS(tptr + 6);
                     ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                 }
 
  eap_print(netdissect_options *ndo,
 
             case EAP_TYPE_AKA:
             case EAP_TYPE_SIM:
                ND_TCHECK_8BITS(tptr + 5);
                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                        *(tptr + 5)));",The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().
994,CVE-2017-13014,"  wb_prep(netdissect_options *ndo,
 	const u_char *ep = ndo->ndo_snapend;
 
 	ND_PRINT((ndo, "" wb-prep:""));
	if (len < sizeof(*prep) || !ND_TTEST(*prep))
 		return (-1);
 	n = EXTRACT_32BITS(&prep->pp_n);
 	ps = (const struct pgstate *)(prep + 1);
 	while (--n >= 0 && ND_TTEST(*ps)) {
  wb_print(netdissect_options *ndo,
 	case PT_ID:
 		if (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)
 			return;
		ND_PRINT((ndo, ""%s"", tstr));
 		break;
 
 	case PT_RREQ:
 		if (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)
 			return;
		ND_PRINT((ndo, ""%s"", tstr));
 		break;
 
 	case PT_RREP:
 		if (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)
 			return;
		ND_PRINT((ndo, ""%s"", tstr));
 		break;
 
 	case PT_DRAWOP:
 		if (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)
 			return;
		ND_PRINT((ndo, ""%s"", tstr));
 		break;
 
 	case PT_PREQ:
 		if (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)
 			return;
		ND_PRINT((ndo, ""%s"", tstr));
 		break;
 
 	case PT_PREP:
 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;
		ND_PRINT((ndo, ""%s"", tstr));
 		break;
 
 	default:","The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions."
995,CVE-2017-13013,"  struct  arp_pkthdr {
 	u_char	ar_tha[];	 
 	u_char	ar_tpa[];	 
 #endif
#define ar_sha(ap)	(((const u_char *)((ap)+1))+  0)
 #define ar_spa(ap)	(((const u_char *)((ap)+1))+  (ap)->ar_hln)
 #define ar_tha(ap)	(((const u_char *)((ap)+1))+  (ap)->ar_hln+(ap)->ar_pln)
 #define ar_tpa(ap)	(((const u_char *)((ap)+1))+2*(ap)->ar_hln+(ap)->ar_pln)
  isnonzero(const u_char *a, size_t len)
 	return (0);
 }
 
static void
tpaddr_print_ip(netdissect_options *ndo,
	        const struct arp_pkthdr *ap, u_short pro)
{
	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
		ND_PRINT((ndo, ""<wrong proto type>""));
	else if (PROTO_LEN(ap) != 4)
		ND_PRINT((ndo, ""<wrong len>""));
	else
		ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, TPA(ap))));
}

static void
spaddr_print_ip(netdissect_options *ndo,
	        const struct arp_pkthdr *ap, u_short pro)
{
	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
		ND_PRINT((ndo, ""<wrong proto type>""));
	else if (PROTO_LEN(ap) != 4)
		ND_PRINT((ndo, ""<wrong len>""));
	else
		ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, SPA(ap))));
}

 static void
 atmarp_addr_print(netdissect_options *ndo,
 		  const u_char *ha, u_int ha_len, const u_char *srca,
  atmarp_addr_print(netdissect_options *ndo,
 	}
 }
 
static void
atmarp_tpaddr_print(netdissect_options *ndo,
		    const struct atmarp_pkthdr *ap, u_short pro)
{
	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
		ND_PRINT((ndo, ""<wrong proto type>""));
	else if (ATMTPROTO_LEN(ap) != 4)
		ND_PRINT((ndo, ""<wrong tplen>""));
	else
		ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, ATMTPA(ap))));
}

static void
atmarp_spaddr_print(netdissect_options *ndo,
		    const struct atmarp_pkthdr *ap, u_short pro)
{
	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
		ND_PRINT((ndo, ""<wrong proto type>""));
	else if (ATMSPROTO_LEN(ap) != 4)
		ND_PRINT((ndo, ""<wrong splen>""));
	else
		ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, ATMSPA(ap))));
}

 static void
 atmarp_print(netdissect_options *ndo,
 	     const u_char *bp, u_int length, u_int caplen)
  atmarp_print(netdissect_options *ndo,
 	switch (op) {
 
 	case ARPOP_REQUEST:
		ND_PRINT((ndo, ""who-has ""));
		atmarp_tpaddr_print(ndo, ap, pro);
 		if (ATMTHRD_LEN(ap) != 0) {
 			ND_PRINT((ndo, "" (""));
 			atmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap),
 			    ATMTSA(ap), ATMTSLN(ap));
 			ND_PRINT((ndo, "")""));
 		}
		ND_PRINT((ndo, "" tell ""));
		atmarp_spaddr_print(ndo, ap, pro);
 		break;
 
 	case ARPOP_REPLY:
		atmarp_spaddr_print(ndo, ap, pro);
		ND_PRINT((ndo, "" is-at ""));
 		atmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),
                                   ATMSSLN(ap));
 		break;
  atmarp_print(netdissect_options *ndo,
 	case ARPOP_INVREPLY:
 		atmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),
 		    ATMSSLN(ap));
		ND_PRINT((ndo, ""at ""));
		atmarp_spaddr_print(ndo, ap, pro);
 		break;
 
 	case ARPOP_NAK:
		ND_PRINT((ndo, ""for ""));
		atmarp_spaddr_print(ndo, ap, pro);
 		break;
 
 	default:
  arp_print(netdissect_options *ndo,
             break;
 	}
 
	if (!ND_TTEST2(*TPA(ap), PROTO_LEN(ap))) {
 		ND_PRINT((ndo, ""%s"", tstr));
 		ND_DEFAULTPRINT((const u_char *)ap, length);
 		return;
  arp_print(netdissect_options *ndo,
 	switch (op) {
 
 	case ARPOP_REQUEST:
		ND_PRINT((ndo, ""who-has ""));
		tpaddr_print_ip(ndo, ap, pro);
 		if (isnonzero((const u_char *)THA(ap), HRD_LEN(ap)))
 			ND_PRINT((ndo, "" (%s)"",
 				  linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap))));
		ND_PRINT((ndo, "" tell ""));
		spaddr_print_ip(ndo, ap, pro);
 		break;
 
 	case ARPOP_REPLY:
		spaddr_print_ip(ndo, ap, pro);
		ND_PRINT((ndo, "" is-at %s"",
                           linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap))));
 		break;
 
  arp_print(netdissect_options *ndo,
 		break;
 
 	case ARPOP_REVREPLY:
		ND_PRINT((ndo, ""%s at "",
			  linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap))));
		tpaddr_print_ip(ndo, ap, pro);
 		break;
 
 	case ARPOP_INVREQUEST:
  arp_print(netdissect_options *ndo,
 		break;
 
 	case ARPOP_INVREPLY:
		ND_PRINT((ndo,""%s at "",
			  linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap))));
		spaddr_print_ip(ndo, ap, pro);
 		break;
 
 	default:","The ARP parser in tcpdump before 4.9.2 has a buffer over-read in print-arp.c, several functions."
996,CVE-2017-13012,"  icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *
 		ND_PRINT((ndo, ""\n\t""));
 		ip = (const struct ip *)bp;
                 snapend_save = ndo->ndo_snapend;
		ND_TCHECK_16BITS(&ip->ip_len);
 		ip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));
                 ndo->ndo_snapend = snapend_save;
 	}",The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().
997,CVE-2017-13010," 
  */
 
 static int
l_strnstart(netdissect_options *ndo, const char *tstr1, u_int tl1,
    const char *str2, u_int l2)
 {
	if (!ND_TTEST2(*str2, tl1)) {
		 
		return 0;
	}
 	if (tl1 > l2)
 		return 0;
 
  void
 beep_print(netdissect_options *ndo, const u_char *bp, u_int length)
 {
 
	if (l_strnstart(ndo, ""MSG"", 4, (const char *)bp, length))  
 		ND_PRINT((ndo, "" BEEP MSG""));
	else if (l_strnstart(ndo, ""RPY "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP RPY""));
	else if (l_strnstart(ndo, ""ERR "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ERR""));
	else if (l_strnstart(ndo, ""ANS "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ANS""));
	else if (l_strnstart(ndo, ""NUL "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP NUL""));
	else if (l_strnstart(ndo, ""SEQ "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP SEQ""));
	else if (l_strnstart(ndo, ""END"", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP END""));
 	else
 		ND_PRINT((ndo, "" BEEP (payload or undecoded)""));",The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().
998,CVE-2017-13009," 
  */
 
  
 
 
 #ifdef HAVE_CONFIG_H
 #include ""config.h""
  mobility_print(netdissect_options *ndo,
 	case IP6M_CAREOF_TEST_INIT:
 		hlen = IP6M_MINLEN;
 		if (ndo->ndo_vflag) {
			ND_TCHECK_32BITS(&bp[hlen + 4]);
 			ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
 			       type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"",
 			       EXTRACT_32BITS(&bp[hlen]),
  mobility_print(netdissect_options *ndo,
 		ND_PRINT((ndo, "" nonce id=0x%x"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
 		hlen = IP6M_MINLEN;
 		if (ndo->ndo_vflag) {
			ND_TCHECK_32BITS(&bp[hlen + 4]);
 			ND_PRINT((ndo, "" %s Init Cookie=%08x:%08x"",
 			       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
 			       EXTRACT_32BITS(&bp[hlen]),
 			       EXTRACT_32BITS(&bp[hlen + 4])));
 		}
 		hlen += 8;
 		if (ndo->ndo_vflag) {
			ND_TCHECK_32BITS(&bp[hlen + 4]);
 			ND_PRINT((ndo, "" %s Keygen Token=%08x:%08x"",
 			       type == IP6M_HOME_TEST ? ""Home"" : ""Care-of"",
 			       EXTRACT_32BITS(&bp[hlen]),
  mobility_print(netdissect_options *ndo,
 		ND_TCHECK(mh->ip6m_data16[0]);
 		ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&mh->ip6m_data16[0])));
 		hlen = IP6M_MINLEN;
		ND_TCHECK_16BITS(&bp[hlen]);
		if (bp[hlen] & 0xf0) {
 			ND_PRINT((ndo, "" ""));
			if (bp[hlen] & 0x80)
				ND_PRINT((ndo, ""A""));
			if (bp[hlen] & 0x40)
				ND_PRINT((ndo, ""H""));
			if (bp[hlen] & 0x20)
				ND_PRINT((ndo, ""L""));
			if (bp[hlen] & 0x10)
				ND_PRINT((ndo, ""K""));
		}
 		 
 		hlen += 1;
 		 
 		hlen += 1;
		ND_TCHECK_16BITS(&bp[hlen]);
 		 
 		ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
 		hlen += 2;
 		break;
 	case IP6M_BINDING_ACK:
 		ND_TCHECK(mh->ip6m_data8[0]);
 		ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
		ND_TCHECK(mh->ip6m_data8[1]);
 		if (mh->ip6m_data8[1] & 0x80)
 			ND_PRINT((ndo, "" K""));
 		 
 		hlen = IP6M_MINLEN;
		ND_TCHECK_16BITS(&bp[hlen]);
 		ND_PRINT((ndo, "" seq#=%u"", EXTRACT_16BITS(&bp[hlen])));
 		hlen += 2;
		ND_TCHECK_16BITS(&bp[hlen]);
 		 
 		ND_PRINT((ndo, "" lifetime=%u"", EXTRACT_16BITS(&bp[hlen]) << 2));
 		hlen += 2;
  mobility_print(netdissect_options *ndo,
 		ND_PRINT((ndo, "" status=%u"", mh->ip6m_data8[0]));
 		 
 		hlen = IP6M_MINLEN;
		ND_TCHECK2(bp[hlen], 16);
 		ND_PRINT((ndo, "" homeaddr %s"", ip6addr_string(ndo, &bp[hlen])));
 		hlen += 16;
 		break;",The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_print().
999,CVE-2017-13008,"  parse_elements(netdissect_options *ndo,
 			if (ssid.length != 0) {
 				if (ssid.length > sizeof(ssid.ssid) - 1)
 					return 0;
 				memcpy(&ssid.ssid, p + offset, ssid.length);
 				offset += ssid.length;
 				length -= ssid.length;
  parse_elements(netdissect_options *ndo,
 				if (challenge.length >
 				    sizeof(challenge.text) - 1)
 					return 0;
 				memcpy(&challenge.text, p + offset,
 				    challenge.length);
 				offset += challenge.length;
  parse_elements(netdissect_options *ndo,
 			if (rates.length != 0) {
 				if (rates.length > sizeof rates.rate)
 					return 0;
 				memcpy(&rates.rate, p + offset, rates.length);
 				offset += rates.length;
 				length -= rates.length;
  parse_elements(netdissect_options *ndo,
 			offset += 3;
 			length -= 3;
 
			memcpy(tim.bitmap, p + offset, tim.length - 3);
 			offset += tim.length - 3;
 			length -= tim.length - 3;
 			/*",The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().
1000,CVE-2017-13007,"  pktap_if_print(netdissect_options *ndo,
 	u_int length = h->len;
 	if_printer printer;
 	const pktap_header_t *hdr;
	struct pcap_pkthdr nhdr;
 
 	if (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {
 		ND_PRINT((ndo, ""[|pktap]""));
  pktap_if_print(netdissect_options *ndo,
 
 	case PKT_REC_PACKET:
 		if ((printer = lookup_printer(dlt)) != NULL) {
			nhdr = *h;
			nhdr.caplen = caplen;
			nhdr.len = length;
			hdrlen += printer(ndo, &nhdr, p);
 		} else {
 			if (!ndo->ndo_eflag)
 				pktap_header_print(ndo, (const u_char *)hdr,",The Apple PKTAP parser in tcpdump before 4.9.2 has a buffer over-read in print-pktap.c:pktap_if_print().
1001,CVE-2017-13006,"  print_32bits_val(netdissect_options *ndo, const uint32_t *dat)
  
  
 static void
l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	ND_PRINT((ndo, ""%s"", tok2str(l2tp_msgtype2str, ""MSGTYPE-#%u"",
 	    EXTRACT_16BITS(ptr))));
 }
  l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 
	 
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
 	}
	ND_PRINT((ndo, ""%u"", EXTRACT_16BITS(ptr)));
	ptr++;
	length -= 2;

	 
	if (length == 0)
		return;
	if (length < 2) {
		ND_PRINT((ndo, "" AVP too short""));
		return;
 	}
	ND_PRINT((ndo, ""/%u"", EXTRACT_16BITS(ptr)));
	ptr++;
	length -= 2;

	 
	if (length == 0)
		return;
	ND_PRINT((ndo, "" ""));
	print_string(ndo, (const u_char *)ptr, length);
 }
 
 static void
l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat, u_int length)
 {
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }
 
 static void
l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
  l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
 }
 
 static void
l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	if (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
  l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)
 static void
 l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
	if (length < 3) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	print_16bits_val(ndo, (const uint16_t *)dat);
 	ND_PRINT((ndo, "", %02x"", dat[2]));
	dat += 3;
	length -= 3;
	if (length != 0) {
 		ND_PRINT((ndo, "" ""));
		print_string(ndo, dat, length);
 	}
 }
 
 static void
l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	if (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
  l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)
 }
 
 static void
l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
  l2tp_packet_proc_delay_print(netdissect_options *ndo)
 }
 
 static void
l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	ND_PRINT((ndo, ""%s"", tok2str(l2tp_authentype2str,
 			     ""AuthType-#%u"", EXTRACT_16BITS(ptr))));
 }
 
 static void
l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	ND_PRINT((ndo, ""%u"", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));
 }
 
 static void
l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	ptr++;		 
	length -= 2;
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	val_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;
	val_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;
 	ND_PRINT((ndo, ""CRCErr=%u "", (val_h<<16) + val_l));
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	val_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;
	val_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;
 	ND_PRINT((ndo, ""FrameErr=%u "", (val_h<<16) + val_l));
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	val_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;
	val_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;
 	ND_PRINT((ndo, ""HardOver=%u "", (val_h<<16) + val_l));
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	val_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;
	val_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;
 	ND_PRINT((ndo, ""BufOver=%u "", (val_h<<16) + val_l));
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	val_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;
	val_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;
 	ND_PRINT((ndo, ""Timeout=%u "", (val_h<<16) + val_l));
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""AlignErr=%u "", (val_h<<16) + val_l));
 }
 
 static void
l2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
	if (length < 2) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	ptr++;		 
	length -= 2;
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	val_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;
	val_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 
	if (length < 4) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
  l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int lengt
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 
	if (length < 5) {
		ND_PRINT((ndo, ""AVP too short""));
		return;
	}
	 
	ND_PRINT((ndo, ""%04x, "", EXTRACT_16BITS(dat)));
	dat += 2;
	length -= 2;
	 
	ND_PRINT((ndo, ""%04x "",  EXTRACT_16BITS(dat)));
	dat += 2;
	length -= 2;
	 
 	ND_PRINT((ndo, ""%s"", tok2str(l2tp_cc_direction2str,
			     ""Direction-#%u"", EXTRACT_8BITS(ptr))));
	ptr++;
	length--;
 
	if (length != 0) {
 		ND_PRINT((ndo, "" ""));
		print_string(ndo, (const u_char *)ptr, length);
 	}
 }
 
  l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)
 	 
 	ND_TCHECK2(*ptr, len);

	 
 
 	if (EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_FLAG_MANDATORY) {
 		ND_PRINT((ndo, ""*""));
  l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)
 		} else {
 			switch (attr_type) {
 			case L2TP_AVP_MSGTYPE:
				l2tp_msgtype_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_RESULT_CODE:
 				l2tp_result_code_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_PROTO_VER:
				l2tp_proto_ver_print(ndo, ptr, len-6);
 				break;
 			case L2TP_AVP_FRAMING_CAP:
				l2tp_framing_cap_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_BEARER_CAP:
				l2tp_bearer_cap_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_TIE_BREAKER:
				if (len-6 < 8) {
					ND_PRINT((ndo, ""AVP too short""));
					break;
				}
 				print_octets(ndo, (const u_char *)ptr, 8);
 				break;
 			case L2TP_AVP_FIRM_VER:
 			case L2TP_AVP_ASSND_TUN_ID:
 			case L2TP_AVP_RECV_WIN_SIZE:
 			case L2TP_AVP_ASSND_SESS_ID:
				if (len-6 < 2) {
					ND_PRINT((ndo, ""AVP too short""));
					break;
				}
 				print_16bits_val(ndo, ptr);
 				break;
 			case L2TP_AVP_HOST_NAME:
  l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)
 				l2tp_q931_cc_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_CHALLENGE_RESP:
				if (len-6 < 16) {
					ND_PRINT((ndo, ""AVP too short""));
					break;
				}
 				print_octets(ndo, (const u_char *)ptr, 16);
 				break;
 			case L2TP_AVP_CALL_SER_NUM:
  l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)
 			case L2TP_AVP_TX_CONN_SPEED:
 			case L2TP_AVP_PHY_CHANNEL_ID:
 			case L2TP_AVP_RX_CONN_SPEED:
				if (len-6 < 4) {
					ND_PRINT((ndo, ""AVP too short""));
					break;
				}
 				print_32bits_val(ndo, (const uint32_t *)ptr);
 				break;
 			case L2TP_AVP_BEARER_TYPE:
				l2tp_bearer_type_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_FRAMING_TYPE:
				l2tp_framing_type_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_PACKET_PROC_DELAY:
 				l2tp_packet_proc_delay_print(ndo);
 				break;
 			case L2TP_AVP_PROXY_AUTH_TYPE:
				l2tp_proxy_auth_type_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_PROXY_AUTH_ID:
				l2tp_proxy_auth_id_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_CALL_ERRORS:
				l2tp_call_errors_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_ACCM:
				l2tp_accm_print(ndo, (const u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_SEQ_REQUIRED:
 				break;	 ","The L2TP parser in tcpdump before 4.9.2 has a buffer over-read in print-l2tp.c, several functions."
1002,CVE-2017-13005,"  xid_map_enter(netdissect_options *ndo,
 		UNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));
 		UNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));
 	}
	if (!ND_TTEST(rp->rm_call.cb_proc))
		return (0);
 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
	if (!ND_TTEST(rp->rm_call.cb_vers))
		return (0);
 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
 	return (1);
 }",The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter().
1003,CVE-2017-13003," 
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  */
 
 
#define EXTRACT_8BITS(p)	(*(p))
#define EXTRACT_LE_8BITS(p)	(*(p))

  
 #define EXTRACT_LE_16BITS(p) \
 	((uint16_t)(((uint16_t)(*((const uint8_t *)(p) + 1)) << 8) | \
 	            ((uint16_t)(*((const uint8_t *)(p) + 0)) << 0)))",The LMP parser in tcpdump before 4.9.2 has a buffer over-read in print-lmp.c:lmp_print().
1004,CVE-2017-13002," 
 #include ""addrtoname.h""
 #include ""extract.h""
 
 
 struct aodv_rreq {
 	uint8_t		rreq_type;	 
 	uint8_t		rreq_flags;	 
  aodv_extension(netdissect_options *ndo,
 {
 	const struct aodv_hello *ah;
 
	ND_TCHECK(*ep);
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
		if (ep->length < 4) {
			ND_PRINT((ndo, ""\n\text HELLO - bad length %u"", ep->length));
			break;
		}
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;",The AODV parser in tcpdump before 4.9.2 has a buffer over-read in print-aodv.c:aodv_extension().
1005,CVE-2017-13001,"  nfs_printfh(netdissect_options *ndo,
 
 	if (sfsname) {
 		 
		char temp[NFSX_V3FHMAX+1];
		u_int stringlen;
 
 		 
		stringlen = len;
		if (stringlen > NFSX_V3FHMAX)
			stringlen = NFSX_V3FHMAX;
		strncpy(temp, sfsname, stringlen);
		temp[stringlen] = '\0';
 		 
 		spacep = strchr(temp, ' ');
 		if (spacep)",The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:nfs_printfh().
1006,CVE-2017-13000,"  ieee802_15_4_if_print(netdissect_options *ndo,
 			return hdrlen;
 		}
 		if (ndo->ndo_vflag)
			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));
 		p += 2;
 		caplen -= 2;
 		hdrlen += 2;",The IEEE 802.15.4 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_15_4.c:ieee802_15_4_if_print().
1007,CVE-2017-12999,"  isis_print(netdissect_options *ndo,
 	    ND_TCHECK2(*tptr, 1);
 	    alen = *tptr++;
 	    while (tmp && alen < tmp) {
	        ND_TCHECK2(*tptr, alen);
 		ND_PRINT((ndo, ""\n\t      Area address (length: %u): %s"",
                        alen,
                        isonsap_string(ndo, tptr, alen)));",The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print().
1008,CVE-2017-12998,"  isis_print_extd_ip_reach(netdissect_options *ndo,
         }
         processed++;
     } else if (afi == AF_INET6) {
        if (!ND_TTEST2(*tptr, 2))  
             return (0);
         status_byte=*(tptr++);
         bit_length=*(tptr++);",The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_extd_ip_reach().
1009,CVE-2017-12997,"  lldp_private_8021_print(netdissect_options *ndo,
     int subtype, hexdump = FALSE;
     u_int sublen;
     u_int tval;
    u_int i;
 
     if (tlv_len < 4) {
         return hexdump;
  lldp_private_8021_print(netdissect_options *ndo,
         ND_PRINT((ndo, ""\n\t    Application Priority Table""));
         while(i<sublen) {
         	tval=*(tptr+i+5);
        	ND_PRINT((ndo, ""\n\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),
        		 EXTRACT_16BITS(tptr + i + 5)));
         	i=i+3;
         }
         break;",The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().
1010,CVE-2017-12996,"  pimv2_print(netdissect_options *ndo,
 
 			switch (otype) {
 			case PIMV2_HELLO_OPTION_HOLDTIME:
				if (olen != 2) {
					ND_PRINT((ndo, ""ERROR: Option Length != 2 Bytes (%u)"", olen));
				} else {
					unsigned_relts_print(ndo, EXTRACT_16BITS(bp));
				}
 				break;
 
 			case PIMV2_HELLO_OPTION_LANPRUNEDELAY:
  pimv2_print(netdissect_options *ndo,
 				break;
 
 			case PIMV2_HELLO_OPTION_GENID:
				if (olen != 4) {
					ND_PRINT((ndo, ""ERROR: Option Length != 4 Bytes (%u)"", olen));
				} else {
					ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(bp)));
				}
 				break;
 
 			case PIMV2_HELLO_OPTION_REFRESH_CAP:
				if (olen != 4) {
					ND_PRINT((ndo, ""ERROR: Option Length != 4 Bytes (%u)"", olen));
				} else {
					ND_PRINT((ndo, ""v%d"", *bp));
					if (*(bp+1) != 0) {
						ND_PRINT((ndo, "", interval ""));
						unsigned_relts_print(ndo, *(bp+1));
					}
					if (EXTRACT_16BITS(bp+2) != 0) {
						ND_PRINT((ndo, "" ?0x%04x?"", EXTRACT_16BITS(bp+2)));
					}
 				}
 				break;
 ",The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().
1011,CVE-2017-12995,"  ns_nprint(netdissect_options *ndo,
 	register u_int i, l;
 	register const u_char *rp = NULL;
 	register int compress = 0;
 	int elt;
	u_int offset, max_offset;
 
 	if ((l = labellen(ndo, cp)) == (u_int)-1)
 		return(NULL);
 	if (!ND_TTEST2(*cp, 1))
 		return(NULL);
	max_offset = (u_int)(cp - bp);
 	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
 		compress = 0;
 		rp = cp + l;
  ns_nprint(netdissect_options *ndo,
 				}
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
				offset = (((i << 8) | *cp) & 0x3fff);
				 
				if (offset >= max_offset) {
					ND_PRINT((ndo, ""<BAD PTR>""));
					return(NULL);
				}
				max_offset = offset;
				cp = bp + offset;
 				if ((l = labellen(ndo, cp)) == (u_int)-1)
 					return(NULL);
 				if (!ND_TTEST2(*cp, 1))
 					return(NULL);
 				i = *cp++;
 				continue;
 			}
 			if ((i & INDIR_MASK) == EDNS0_MASK) {
  ns_nprint(netdissect_options *ndo,
 			}
 
 			cp += l;
 			ND_PRINT((ndo, "".""));
 			if ((l = labellen(ndo, cp)) == (u_int)-1)
 				return(NULL);
 			if (!ND_TTEST2(*cp, 1))
 				return(NULL);
 			i = *cp++;
 			if (!compress)
 				rp += l + 1;
 		}",The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().
1012,CVE-2017-12994,"  bgp_attr_print(netdissect_options *ndo,
 		uint8_t type;
 		uint16_t length;
 
 		tlen = len;
 
 		while (tlen >= 3) {
 
		    ND_TCHECK2(tptr[0], 3);

 		    type = *tptr;
 		    length = EXTRACT_16BITS(tptr+1);
		    tptr += 3;
		    tlen -= 3;
 
 		    ND_PRINT((ndo, ""\n\t    %s TLV (%u), length %u"",
 			      tok2str(bgp_aigp_values, ""Unknown"", type),
 			      type, length));
 
		    if (length < 3)
			goto trunc;
		    length -= 3;

 		     
		    ND_TCHECK2(tptr[3], length);
 
 		    switch (type) {
 
 		    case BGP_AIGP_TLV:
		        if (length < 8)
		            goto trunc;
 			ND_PRINT((ndo, "", metric %"" PRIu64,
				  EXTRACT_64BITS(tptr)));
 			break;
 
 		    default:
 			if (ndo->ndo_vflag <= 1) {
			    print_unknown_data(ndo, tptr,""\n\t      "", length);
 			}
 		    }
 ",The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().
1013,CVE-2017-12993,"  juniper_ggsn_print(netdissect_options *ndo,
         p+=l2info.header_len;
         gh = (struct juniper_ggsn_header *)&l2info.cookie;
 
        ND_TCHECK(*gh);
         if (ndo->ndo_eflag) {
             ND_PRINT((ndo, ""proto %s (%u), vlan %u: "",
                    tok2str(juniper_protocol_values,""Unknown"",gh->proto),
  juniper_ggsn_print(netdissect_options *ndo,
         }
 
         return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_es_print(netdissect_options *ndo,
         p+=l2info.header_len;
         ih = (const struct juniper_ipsec_header *)p;
 
        ND_TCHECK(*ih);
         switch (ih->type) {
         case JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPE:
         case JUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPE:
  juniper_es_print(netdissect_options *ndo,
 
         ip_print(ndo, p, l2info.length);
         return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_monitor_print(netdissect_options *ndo,
         p+=l2info.header_len;
         mh = (const struct juniper_monitor_header *)p;
 
        ND_TCHECK(*mh);
         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                    EXTRACT_32BITS(&mh->service_id),
  juniper_monitor_print(netdissect_options *ndo,
         ip_heuristic_guess (ndo, p, l2info.length);
 
         return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_services_print(netdissect_options *ndo,
         p+=l2info.header_len;
         sh = (const struct juniper_services_header *)p;
 
        ND_TCHECK(*sh);
         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                    sh->svc_id,
  juniper_services_print(netdissect_options *ndo,
         ip_heuristic_guess (ndo, p, l2info.length);
 
         return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_services]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_pppoe_atm_print(netdissect_options *ndo,
 
         p+=l2info.header_len;
 
        ND_TCHECK2(p[0], 2);
         extracted_ethertype = EXTRACT_16BITS(p);
          
  juniper_pppoe_atm_print(netdissect_options *ndo,
             ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));
 
         return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_pppoe_atm]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_atm1_print(netdissect_options *ndo,
             return l2info.header_len;
         }
 
        ND_TCHECK2(p[0], 3);
         if (EXTRACT_24BITS(p) == 0xfefe03 ||  
             EXTRACT_24BITS(p) == 0xaaaa03) {  
 
  juniper_atm1_print(netdissect_options *ndo,
             return l2info.header_len;
 
 	return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_atm1]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_atm2_print(netdissect_options *ndo,
             return l2info.header_len;
         }
 
        ND_TCHECK2(p[0], 3);
         if (EXTRACT_24BITS(p) == 0xfefe03 ||  
             EXTRACT_24BITS(p) == 0xaaaa03) {  
 
  juniper_atm2_print(netdissect_options *ndo,
             return l2info.header_len;
 
 	return l2info.header_len;

trunc:
	ND_PRINT((ndo, ""[|juniper_atm2]""));
	return l2info.header_len;
 }
 #endif
 
  juniper_parse_header(netdissect_options *ndo,
     l2info->caplen -= l2info->header_len;
 
      
    ND_TCHECK(p[0]);
     while (lp->s != NULL) {
         if (lp->pictype == l2info->pictype) {
 
  juniper_parse_header(netdissect_options *ndo,
     case DLT_JUNIPER_MLFR:
         switch (l2info->cookie_type) {
         case LS_COOKIE_ID:
            ND_TCHECK2(p[0], 2);
             l2info->bundle = l2info->cookie[1];
             l2info->proto = EXTRACT_16BITS(p);
             l2info->header_len += 2;
  juniper_parse_header(netdissect_options *ndo,
     case DLT_JUNIPER_MFR:
         switch (l2info->cookie_type) {
         case LS_COOKIE_ID:
            ND_TCHECK2(p[0], 2);
             l2info->bundle = l2info->cookie[1];
             l2info->proto = EXTRACT_16BITS(p);
             l2info->header_len += 2;","The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions."
1014,CVE-2017-12992,"  ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)
 {
 	register const struct rip6 *rp = (const struct rip6 *)dat;
 	register const struct netinfo6 *ni;
	unsigned int length_left;
	u_int j;
 
	ND_TCHECK(rp->rip6_cmd);
 	switch (rp->rip6_cmd) {
 
 	case RIP6_REQUEST:
		length_left = length;
		if (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))
			goto trunc;
		length_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));
 		j = length_left / sizeof(*ni);
		if (j == 1) {
			ND_TCHECK(rp->rip6_nets);
			if (rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
			    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
				ND_PRINT((ndo, "" ripng-req dump""));
				break;
			}
 		}
		if (j * sizeof(*ni) != length_left)
			ND_PRINT((ndo, "" ripng-req %u[%u]:"", j, length));
 		else
			ND_PRINT((ndo, "" ripng-req %u:"", j));
		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
		    length_left -= sizeof(*ni), ++ni) {
			ND_TCHECK(*ni);
 			if (ndo->ndo_vflag > 1)
 				ND_PRINT((ndo, ""\n\t""));
 			else
 				ND_PRINT((ndo, "" ""));
 			rip6_entry_print(ndo, ni, 0);
 		}
		if (length_left != 0)
			goto trunc;
 		break;
 	case RIP6_RESPONSE:
		length_left = length;
		if (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))
			goto trunc;
		length_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));
		j = length_left / sizeof(*ni);
		if (j * sizeof(*ni) != length_left)
 			ND_PRINT((ndo, "" ripng-resp %d[%u]:"", j, length));
 		else
 			ND_PRINT((ndo, "" ripng-resp %d:"", j));
		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
		    length_left -= sizeof(*ni), ++ni) {
			ND_TCHECK(*ni);
 			if (ndo->ndo_vflag > 1)
 				ND_PRINT((ndo, ""\n\t""));
 			else
 				ND_PRINT((ndo, "" ""));
 			rip6_entry_print(ndo, ni, ni->rip6_metric);
 		}
		if (length_left != 0)
			goto trunc;
 		break;
 	default:
 		ND_PRINT((ndo, "" ripng-%d ?? %u"", rp->rip6_cmd, length));
 		break;
 	}
	ND_TCHECK(rp->rip6_vers);
 	if (rp->rip6_vers != RIP6_VERSION)
 		ND_PRINT((ndo, "" [vers %d]"", rp->rip6_vers));
	return;

trunc:
	ND_PRINT((ndo, ""[|ripng]""));
	return;
 }",The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().
1015,CVE-2017-12991,"  bgp_attr_print(netdissect_options *ndo,
 			ND_TCHECK(tptr[0]);
                         ND_PRINT((ndo, ""%s"", tok2str(bgp_as_path_segment_open_values,
 						""?"", tptr[0])));
			ND_TCHECK(tptr[1]);
                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
                             ND_TCHECK2(tptr[2 + i], as_size);
 			    ND_PRINT((ndo, ""%s "",",The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().
1016,CVE-2017-12990,"  struct notify_messages {
 	char     *msg;
 };
 
 
 struct ikev2_auth {
 	struct isakmp_gen h;
 	uint8_t  auth_method;   
  ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	 
	ND_PRINT((ndo,"" n len=%u"", ntohs(e.len) - 4));
	if (ntohs(e.len) > 4) {
		if (ndo->ndo_vflag > 2) {
			ND_PRINT((ndo, "" ""));
			if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
				goto trunc;
		} else if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, "" ""));
			if (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))
				goto trunc;
		}
 	}
 	return (const u_char *)ext + ntohs(e.len);
 trunc:
  ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,
 static const u_char *
 ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	      const struct isakmp_gen *ext, u_int item_len,
	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth _U_)
 {
 	const struct ikev1_pl_n *p;
 	struct ikev1_pl_n n;
  ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ep2 = (const u_char *)p + item_len;
 
 	if (cp < ep) {
 		switch (ntohs(n.type)) {
 		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
 		    {
 			const struct attrmap *map = oakley_t_map;
 			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
			ND_PRINT((ndo,"" attrs=(""));
 			while (cp < ep && cp < ep2) {
 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);
 			}
			ND_PRINT((ndo,"")""));
 			break;
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
			ND_PRINT((ndo,"" status=(""));
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
			ND_PRINT((ndo,"")""));
 			break;
 		default:
			 
			if (ndo->ndo_vflag > 3) {
				ND_PRINT((ndo,"" data=(""));
				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
					goto trunc;
				ND_PRINT((ndo,"")""));
			} else {
				if (!ike_show_somedata(ndo, cp, ep))
					goto trunc;
			}
			break;
 		}
 	}
 	return (const u_char *)ext + item_len;
 trunc:
  ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
 	len = ntohs(a.h.len);
 
	 
	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
 		  STR_OR_ID(a.auth_method, v2_auth)));
	if (len > 4) {
		if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, "" authdata=(""));
			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
				goto trunc;
			ND_PRINT((ndo, "") ""));
		} else if (ndo->ndo_vflag) {
			if (!ike_show_somedata(ndo, authdata, ep))
				goto trunc;
		}
 	}
 
 	return (const u_char *)ext + len;
  ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	const struct ikev2_n *p;
 	struct ikev2_n n;
 	const u_char *cp;
	u_char showspi, showsomedata;
 	const char *notify_name;
 	uint32_t type;
 
  ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 	ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);
 
 	showspi = 1;
 	showsomedata=0;
 	notify_name=NULL;
 
  ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 		notify_name = ""cookie"";
 		showspi = 1;
 		showsomedata= 1;
 		break;
 
 	case IV2_NOTIFY_USE_TRANSPORT_MODE:
  ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
 
	if (cp < ep) {
		if (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {
			ND_PRINT((ndo,"" data=(""));
			if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
				goto trunc;
 
			ND_PRINT((ndo,"")""));
		} else if (showsomedata) {
			if (!ike_show_somedata(ndo, cp, ep))
				goto trunc;
		}
 	}
 
 	return (const u_char *)ext + item_len;
  isakmp_rfc3948_print(netdissect_options *ndo,
  * c-basic-offset: 8
  * End:
  */
1017,CVE-2017-12989,"  resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con
         ND_TCHECK(*bp);
         c = *bp;
         if (!(c >= '0' && c <= '9')) {
            if (!saw_digit) {
                bp++;
                 goto invalid;
            }
             break;
         }
         c -= '0';
  resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
    if (*bp != '\r') {
        bp++;
         goto invalid;
    }
     bp++;
     len--;
     if (len == 0)
         goto trunc;
     ND_TCHECK(*bp);
    if (*bp != '\n') {
        bp++;
         goto invalid;
    }
     bp++;
     len--;
     *endp = bp;
  resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con
     return (too_large ? -3 : result);
 
 trunc:
    *endp = bp;
     return (-2);
 
 invalid:
    *endp = bp;
     return (-5);
 }",The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().
1018,CVE-2017-12988,"  telnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)
 				break;
 			p++;
 		}
		ND_TCHECK(*p);
 		if (*p != IAC)
 			goto pktend;
 ",The telnet parser in tcpdump before 4.9.2 has a buffer over-read in print-telnet.c:telnet_parse().
1019,CVE-2017-12986,"  struct ip6_rthdr0 {
 	uint8_t  ip6r0_nxt;		 
 	uint8_t  ip6r0_len;		 
 	uint8_t  ip6r0_type;		 
	uint8_t  ip6r0_segleft;		 
	uint32_t ip6r0_reserved;	 
 	struct in6_addr ip6r0_addr[1];	 
 } UNALIGNED;
 ",The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
1020,CVE-2017-12985,"  ip6_print(netdissect_options *ndo, const u_char *bp, u_int length)
 	advance = sizeof(struct ip6_hdr);
 	nh = ip6->ip6_nxt;
 	while (cp < ndo->ndo_snapend && advance > 0) {
		if (len < (u_int)advance)
			goto trunc;
 		cp += advance;
 		len -= advance;
 
  ip6_print(netdissect_options *ndo, const u_char *bp, u_int length)
 			 * mobility header.
 			 */
 			advance = mobility_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0)
				return;
 			nh = *cp;
 			return;
 		case IPPROTO_ROUTING:
			ND_TCHECK(*cp);
 			advance = rt6_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0)
				return;
 			nh = *cp;
 			break;
 		case IPPROTO_SCTP:
  ip6_print(netdissect_options *ndo, const u_char *bp, u_int length)
 			return;
 		case IPPROTO_AH:
 			advance = ah_print(ndo, cp);
			if (advance < 0)
				return;
 			nh = *cp;
 			break;
 		case IPPROTO_ESP:
 		    {
 			int enh, padlen;
 			advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);
			if (advance < 0)
				return;
 			nh = enh & 0xff;
 			len -= padlen;
 			break;",The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().
1021,CVE-2017-12982,"  static OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)
 
     header->biBitCount  = (OPJ_UINT16)getc(IN);
     header->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);
    if (header->biBitCount == 0) {
        fprintf(stderr, ""Error, invalid biBitCount %d\n"", 0);
        return OPJ_FALSE;
    }
 
     if (header->biSize >= 40U) {
         header->biCompression  = (OPJ_UINT32)getc(IN);","The bmp_read_info_header function in bin/jp2/convertbmp.c in OpenJPEG 2.2.0 does not reject headers with a zero biBitCount, which allows remote attackers to cause a denial of service (memory allocation failure) in the opj_image_create function in lib/openjp2/image.c, related to the opj_aligned_alloc_n function in opj_malloc.c."
1022,CVE-2017-12904,"  std::string controller::bookmark(
 	std::string bookmark_cmd = cfg.get_configvalue(""bookmark-cmd"");
 	bool is_interactive = cfg.get_configvalue_as_bool(""bookmark-interactive"");
 	if (bookmark_cmd.length() > 0) {
		std::string cmdline = strprintf::fmt(""%s '%s' '%s' '%s' '%s'"",
 		                                       bookmark_cmd,
 		                                       utils::replace_all(url,""'"", ""%27""),
		                                       utils::replace_all(title,""'"", ""%27""),
		                                       utils::replace_all(description,""'"", ""%27""),
		                                       utils::replace_all(feed_title,""'"", ""%27""));
 
 		LOG(level::DEBUG, ""controller::bookmark: cmd = %s"", cmdline);
 ",Improper Neutralization of Special Elements used in an OS Command in bookmarking function of Newsbeuter versions 0.7 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item that includes shell code in its title and/or URL.
1023,CVE-2017-12902,"  static const struct tok z_types[] = {
 static char z_buf[256];
 
 static const char *
parse_field(netdissect_options *ndo, const char **pptr, int *len, int *truncated)
 {
     const char *s;
 
     
     s = *pptr;
     
    for (;;) {
	if (*len == 0) {
	     
	    return NULL;
	}
	if (!ND_TTEST(**pptr)) {
	     
	    *truncated = 1;
	    return NULL;
	}
	if (**pptr == '\0') {
	     
	    break;
	}
	 
 	(*pptr)++;
 	(*len)--;
     }
     
     (*pptr)++;
     (*len)--;
     return s;
 }
 
  zephyr_print(netdissect_options *ndo, const u_char *cp, int length)
     int parselen = length;
     const char *s;
     int lose = 0;
    int truncated = 0;
 
      
 
  zephyr_print(netdissect_options *ndo, const u_char *cp, int length)
     z.sender = 0;
     z.recipient = 0;
 
#define PARSE_STRING						\
	s = parse_field(ndo, &parse, &parselen, &truncated);	\
	if (truncated) goto trunc;				\
 	if (!s) lose = 1;
 
 #define PARSE_FIELD_INT(field)			\
  zephyr_print(netdissect_options *ndo, const u_char *cp, int length)
     PARSE_FIELD_INT(z.multi);
     PARSE_FIELD_STR(z.multi_uid);
 
    if (lose)
        goto trunc;
 
     ND_PRINT((ndo, "" zephyr""));
     if (strncmp(z.version+4, ""0.2"", 3)) {
  zephyr_print(netdissect_options *ndo, const u_char *cp, int length)
     ND_PRINT((ndo, "" to %s"", z_triple(z.class, z.inst, z.recipient)));
     if (*z.opcode)
 	ND_PRINT((ndo, "" op %s"", z.opcode));
    return;

trunc:
    ND_PRINT((ndo, "" [|zephyr] (%d)"", length));
    return;
 }","The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions."
1024,CVE-2017-12901," 
  
 
 struct eigrp_common_header {
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
      
 
    if (len < sizeof(struct eigrp_common_header)) {
        ND_PRINT((ndo, ""EIGRP %s, length: %u (too short, < %u)"",
               tok2str(eigrp_opcode_values, ""unknown (%u)"",eigrp_com_header->opcode),
               len, (u_int) sizeof(struct eigrp_common_header)));
        return;
    }
     tlen=len-sizeof(struct eigrp_common_header);
 
      
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
                eigrp_tlv_type,
                eigrp_tlv_len));
 
        if (eigrp_tlv_len < sizeof(struct eigrp_tlv_header)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                        (u_int) sizeof(struct eigrp_tlv_header)));
                break;
        }
         tlv_tptr=tptr+sizeof(struct eigrp_tlv_header);
         tlv_tlen=eigrp_tlv_len-sizeof(struct eigrp_tlv_header);
 
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_GENERAL_PARM:
             tlv_ptr.eigrp_tlv_general_parm = (const struct eigrp_tlv_general_parm_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_general_parm)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_general_parm))));
                break;
            }
 
             ND_PRINT((ndo, ""\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u"",
                    EXTRACT_16BITS(tlv_ptr.eigrp_tlv_general_parm->holdtime),
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_SW_VERSION:
             tlv_ptr.eigrp_tlv_sw_version = (const struct eigrp_tlv_sw_version_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_sw_version)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_sw_version))));
                break;
            }
 
             ND_PRINT((ndo, ""\n\t    IOS version: %u.%u, EIGRP version %u.%u"",
                    tlv_ptr.eigrp_tlv_sw_version->ios_major,
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_IP_INT:
             tlv_ptr.eigrp_tlv_ip_int = (const struct eigrp_tlv_ip_int_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_ip_int)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_ip_int))));
                break;
            }
 
             bit_length = tlv_ptr.eigrp_tlv_ip_int->plen;
             if (bit_length > 32) {
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_IP_EXT:
             tlv_ptr.eigrp_tlv_ip_ext = (const struct eigrp_tlv_ip_ext_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_ip_ext)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_ip_ext))));
                break;
            }
 
             bit_length = tlv_ptr.eigrp_tlv_ip_ext->plen;
             if (bit_length > 32) {
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_AT_CABLE_SETUP:
             tlv_ptr.eigrp_tlv_at_cable_setup = (const struct eigrp_tlv_at_cable_setup_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_at_cable_setup)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_at_cable_setup))));
                break;
            }
 
             ND_PRINT((ndo, ""\n\t    Cable-range: %u-%u, Router-ID %u"",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start),
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_AT_INT:
             tlv_ptr.eigrp_tlv_at_int = (const struct eigrp_tlv_at_int_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_at_int)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_at_int))));
                break;
            }
 
             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start),
  eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int
 
         case EIGRP_TLV_AT_EXT:
             tlv_ptr.eigrp_tlv_at_ext = (const struct eigrp_tlv_at_ext_t *)tlv_tptr;
            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_at_ext)) {
                ND_PRINT((ndo, "" (too short, < %u)"",
                    (u_int) (sizeof(struct eigrp_tlv_header) + sizeof(*tlv_ptr.eigrp_tlv_at_ext))));
                break;
            }
 
             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start),",The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().
1025,CVE-2017-12900,"  static const struct tok bgp_multicast_vpn_route_type_values[] = {
     { BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE, ""Source-Active""},
     { BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN, ""Shared Tree Join""},
     { BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN, ""Source Tree Join""},
    { 0, NULL}
 };
 
 static int",Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in util-print.c:tok2strbuf().
1026,CVE-2017-12898,"  nfsreq_print_noaddr(netdissect_options *ndo,
 		if ((dp = parsereq(ndo, rp, length)) != NULL &&
 		    (dp = parsefh(ndo, dp, v3)) != NULL) {
 			if (v3) {
				ND_TCHECK(dp[4]);
 				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
 						EXTRACT_32BITS(&dp[4]),
 						EXTRACT_32BITS(&dp[2]),
 						EXTRACT_64BITS(&dp[0])));
 				if (ndo->ndo_vflag) {
 					ND_PRINT((ndo, "" <%s>"",
 						tok2str(nfsv3_writemodes,
							NULL, EXTRACT_32BITS(&dp[3]))));
 				}
 			} else {
 				ND_TCHECK(dp[3]);
  parserep(netdissect_options *ndo,
 	 * skip past the ar_verf credentials.
 	 */
 	dp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);
 
 	 
	ND_TCHECK(dp[0]);
 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
 	if (astat != SUNRPC_SUCCESS) {
 		ND_PRINT((ndo, "" %s"", tok2str(sunrpc_str, ""ar_stat %d"", astat)));
  static const uint32_t *
 parse_wcc_attr(netdissect_options *ndo,
                const uint32_t *dp)
 {
	 
 	ND_PRINT((ndo, "" sz %"" PRIu64, EXTRACT_64BITS(&dp[0])));
 	ND_PRINT((ndo, "" mtime %u.%06u ctime %u.%06u"",
 	       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),
  interp_reply(netdissect_options *ndo,
 			ND_PRINT((ndo, "" attr:""));
 		if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
 			break;
		if (!er) {
			ND_TCHECK(dp[0]);
 			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));
		}
 		return;
 
 	case NFSPROC_READLINK:",The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().
1027,CVE-2017-12897,"  extern void ipx_netbios_print(netdissect_options *, const u_char *, u_int);
 extern void ipx_print(netdissect_options *, const u_char *, u_int);
 extern void isakmp_print(netdissect_options *, const u_char *, u_int, const u_char *);
 extern void isakmp_rfc3948_print(netdissect_options *, const u_char *, u_int, const u_char *);
extern void isoclns_print(netdissect_options *, const u_char *, u_int);
 extern void krb_print(netdissect_options *, const u_char *);
 extern void l2tp_print(netdissect_options *, const u_char *, u_int);
 extern void lane_print(netdissect_options *, const u_char *, u_int, u_int);",The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().
1028,CVE-2017-12895,"  icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *
              * to check if an extension header is present. This is expedient,
              * however not all implementations set the length field proper.
              */
            if (!ext_dp->icmp_length &&
                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {
                 vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
                 vec[0].len = plen - ICMP_EXTD_MINLEN;
                 if (in_cksum(vec, 1)) {
  icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *
             }
 
             hlen = plen - ICMP_EXTD_MINLEN;
            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {
                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
                vec[0].len = hlen;
                ND_PRINT((ndo, "", checksum 0x%04x (%scorrect), length %u"",
                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),
                       in_cksum(vec, 1) ? ""in"" : """",
                       hlen));
            }
 
             hlen -= 4;  
             obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;",The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().
1029,CVE-2017-12894,"  struct enamemem {
 	const char *e_name;
 	u_char *e_nsap;			 
 #define e_bs e_nsap			 
	size_t e_namelen;		 
 	struct enamemem *e_nxt;
 };
 
 static struct enamemem enametable[HASHNAMESIZE];
 static struct enamemem nsaptable[HASHNAMESIZE];

struct bsnamemem {
	u_short bs_addr0;
	u_short bs_addr1;
	u_short bs_addr2;
	const char *bs_name;
	u_char *bs_bytes;
	unsigned int bs_nbytes;
	struct bsnamemem *bs_nxt;
};

static struct bsnamemem bytestringtable[HASHNAMESIZE];
 
 struct protoidmem {
 	uint32_t p_oui;
  lookup_emem(netdissect_options *ndo, const u_char *ep)
  * with length 'nlen'
  */
 
static inline struct bsnamemem *
 lookup_bytestring(netdissect_options *ndo, register const u_char *bs,
 		  const unsigned int nlen)
 {
	struct bsnamemem *tp;
 	register u_int i, j, k;
 
 	if (nlen >= 6) {
  lookup_bytestring(netdissect_options *ndo, register const u_char *bs,
 		i = j = k = 0;
 
 	tp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];
	while (tp->bs_nxt)
		if (nlen == tp->bs_nbytes &&
		    tp->bs_addr0 == i &&
		    tp->bs_addr1 == j &&
		    tp->bs_addr2 == k &&
		    memcmp((const char *)bs, (const char *)(tp->bs_bytes), nlen) == 0)
 			return tp;
 		else
			tp = tp->bs_nxt;
 
	tp->bs_addr0 = i;
	tp->bs_addr1 = j;
	tp->bs_addr2 = k;
 
	tp->bs_bytes = (u_char *) calloc(1, nlen + 1);
	if (tp->bs_bytes == NULL)
 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");
 
	memcpy(tp->bs_bytes, bs, nlen);
	tp->bs_nbytes = nlen;
	tp->bs_nxt = (struct bsnamemem *)calloc(1, sizeof(*tp));
	if (tp->bs_nxt == NULL)
 		(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");
 
 	return tp;
  le64addr_string(netdissect_options *ndo, const u_char *ep)
 	const unsigned int len = 8;
 	register u_int i;
 	register char *cp;
	register struct bsnamemem *tp;
 	char buf[BUFSIZE];
 
 	tp = lookup_bytestring(ndo, ep, len);
	if (tp->bs_name)
		return (tp->bs_name);
 
 	cp = buf;
 	for (i = len; i > 0 ; --i) {
  le64addr_string(netdissect_options *ndo, const u_char *ep)
 
 	*cp = '\0';
 
	tp->bs_name = strdup(buf);
	if (tp->bs_name == NULL)
 		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");
 
	return (tp->bs_name);
 }
 
 const char *
  linkaddr_string(netdissect_options *ndo, const u_char *ep,
 {
 	register u_int i;
 	register char *cp;
	register struct bsnamemem *tp;
 
 	if (len == 0)
 		return (""<empty>"");
  linkaddr_string(netdissect_options *ndo, const u_char *ep,
 		return (q922_string(ndo, ep, len));
 
 	tp = lookup_bytestring(ndo, ep, len);
	if (tp->bs_name)
		return (tp->bs_name);
 
	tp->bs_name = cp = (char *)malloc(len*3);
	if (tp->bs_name == NULL)
 		(*ndo->ndo_error)(ndo, ""linkaddr_string: malloc"");
 	*cp++ = hex[*ep >> 4];
 	*cp++ = hex[*ep++ & 0xf];
  linkaddr_string(netdissect_options *ndo, const u_char *ep,
 		*cp++ = hex[*ep++ & 0xf];
 	}
 	*cp = '\0';
	return (tp->bs_name);
 }
 
 const char *",Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in addrtoname.c:lookup_bytestring().
1030,CVE-2017-12893,"  name_len(netdissect_options *ndo,
 	    return(-1);	 
 	ND_TCHECK2(*s, 1);
 	s += (*s) + 1;
	ND_TCHECK2(*s, 1);
     }
     return(PTR_DIFF(s, s0) + 1);
 ",The SMB/CIFS parser in tcpdump before 4.9.2 has a buffer over-read in smbutil.c:name_len().
1031,CVE-2017-12877,"  RestoreMSCWarning
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 END_OF_READING:
   CloseBlob(image);
 
 
  RestoreMSCWarning
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
          if (tmp == image2)
            image2=(Image *) NULL;
           DeleteImageFromList(&tmp);
         } else {
           image=p;",Use-after-free vulnerability in the DestroyImage function in image.c in ImageMagick before 7.0.6-6 allows remote attackers to cause a denial of service via a crafted file.
1032,CVE-2017-12876," 
 #include ""MagickCore/artifact.h""
 #include ""MagickCore/attribute.h""
 #include ""MagickCore/cache.h""
#include ""MagickCore/cache-private.h""
 #include ""MagickCore/cache-view.h""
 #include ""MagickCore/channel.h""
 #include ""MagickCore/color.h""
  MagickExport MagickBooleanType ContrastStretchImage(Image *image,
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (SyncImagePixelCache(image,exception) == MagickFalse)
    return(MagickFalse);
   if (SetImageGray(image,exception) != MagickFalse)
     (void) SetImageColorspace(image,GRAYColorspace,exception);
   black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));
  MagickExport MagickBooleanType EqualizeImage(Image *image,
   */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
  if (SyncImagePixelCache(image,exception) == MagickFalse)
    return(MagickFalse);
 #if defined(MAGICKCORE_OPENCL_SUPPORT)
   if (AccelerateEqualizeImage(image,exception) != MagickFalse)
     return(MagickTrue);",Heap-based buffer overflow in enhance.c in ImageMagick before 7.0.6-6 allows remote attackers to cause a denial of service via a crafted file.
1033,CVE-2017-12843,"  EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,
                                         const struct message_guid *guid)
 {
     static char buf[MAX_MAILBOX_PATH];
 
     
    const char *base = isarchive ? config_archivepartitiondir(part)
                                 : config_partitiondir(part);
 
      
     assert(base != NULL);","Cyrus IMAP before 3.0.3 allows remote authenticated users to write to arbitrary files via a crafted (1) SYNCAPPLY, (2) SYNCGET or (3) SYNCRESTORE command."
1034,CVE-2017-12678,"  void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const
      tag->frameList(""TDAT"").size() == 1)
   {
     TextIdentificationFrame *tdrc =
      dynamic_cast<TextIdentificationFrame *>(tag->frameList(""TDRC"").front());
     UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(""TDAT"").front());
 
    if(tdrc &&
       tdrc->fieldList().size() == 1 &&
        tdrc->fieldList().front().size() == 4 &&
        tdat->data().size() >= 5)
     {","In TagLib 1.11.1, the rebuildAggregateFrames function in id3v2framefactory.cpp has a pointer to cast vulnerability, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted audio file."
1035,CVE-2017-12669,"  static MagickBooleanType WriteCALSImage(const ImageInfo *image_info,
   group4_image=CloneImage(image,0,0,MagickTrue,&image->exception);
   if (group4_image == (Image *) NULL)
     {
      write_info=DestroyImageInfo(write_info);
       (void) CloseBlob(image);
       return(MagickFalse);
     }
  static MagickBooleanType WriteCALSImage(const ImageInfo *image_info,
   group4_image=DestroyImage(group4_image);
   if (group4 == (unsigned char *) NULL)
     {
      write_info=DestroyImageInfo(write_info);
       (void) CloseBlob(image);
       return(MagickFalse);
     }",ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteCALSImage in coders/cals.c.
1036,CVE-2017-12668,"  static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)
     length=(size_t) pcx_info.bytes_per_line;
     pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
      {
        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      }
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     q=pixels;
     if ((image->storage_class == DirectClass) || (image->colors > 256))",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePCXImage in coders/pcx.c.
1037,CVE-2017-12667,"  static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
     goto MATLAB_KO;     
 
   if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
    {
MATLAB_KO:
      clone_info=DestroyImageInfo(clone_info);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
 
   filepos = TellBlob(image);
   while(!EOFBlob(image))  ",ImageMagick 7.0.6-1 has a memory leak vulnerability in ReadMATImage in codersmat.c.
1038,CVE-2017-12666,"  static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,
   magick_info=GetMagickInfo(write_info->magick,exception);
   if ((magick_info == (const MagickInfo *) NULL) ||
       (GetMagickMimeType(magick_info) == (const char *) NULL))
    {
      write_info=DestroyImageInfo(write_info);
      ThrowWriterException(CorruptImageError,""ImageTypeNotSupported"");
    }
   (void) CopyMagickString(image->filename,write_info->filename,MaxTextExtent);
   blob_length=2048;
   write_image=CloneImage(image,0,0,MagickTrue,exception);",ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteINLINEImage in coders/inline.c.
1039,CVE-2017-12665,"  static MagickBooleanType WritePICTImage(const ImageInfo *image_info,
   if ((buffer == (unsigned char *) NULL) ||
       (packed_scanline == (unsigned char *) NULL) ||
       (scanline == (unsigned char *) NULL))
    {
      if (scanline != (unsigned char *) NULL)
        scanline=(unsigned char *) RelinquishMagickMemory(scanline);
      if (packed_scanline != (unsigned char *) NULL)
        packed_scanline=(unsigned char *) RelinquishMagickMemory(
          packed_scanline);
      if (buffer != (unsigned char *) NULL)
        buffer=(unsigned char *) RelinquishMagickMemory(buffer);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }
   (void) ResetMagickMemory(scanline,0,row_bytes);
   (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));
   /*",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePICTImage in coders/pict.c.
1040,CVE-2017-12664,"  static Image *ReadPALMImage(const ImageInfo *image_info,
     y;
 
   unsigned char
    *last_row,
     *one_row,
     *ptr;
 
  static Image *ReadPALMImage(const ImageInfo *image_info,
       2*image->columns),sizeof(*one_row));
     if (one_row == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    last_row=(unsigned char *) NULL;
     if (compressionType == PALM_COMPRESSION_SCANLINE)
       {
        last_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,
          2*image->columns),sizeof(*last_row));
        if (last_row == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     mask=(size_t) (1U << bits_per_pixel)-1;
  static Image *ReadPALMImage(const ImageInfo *image_info,
                   if ((y == 0) || (count & (one << (7 - bit))))
                     one_row[i+bit]=(unsigned char) ReadBlobByte(image);
                   else
                    one_row[i+bit]=last_row[i+bit];
                 }
               }
              (void) CopyMagickMemory(last_row, one_row, bytes_per_row);
             }
         }
       ptr=one_row;
  static Image *ReadPALMImage(const ImageInfo *image_info,
             {
               one_row=(unsigned char *) RelinquishMagickMemory(one_row);
               if (compressionType == PALM_COMPRESSION_SCANLINE)
                last_row=(unsigned char *) RelinquishMagickMemory(last_row);
               ThrowReaderException(CorruptImageError,""CorruptImage"");
             }
           for (x=0; x < (ssize_t) image->columns; x++)
  static Image *ReadPALMImage(const ImageInfo *image_info,
               {
                 one_row=(unsigned char *) RelinquishMagickMemory(one_row);
                 if (compressionType == PALM_COMPRESSION_SCANLINE)
                  last_row=(unsigned char *) RelinquishMagickMemory(last_row);
                 ThrowReaderException(CorruptImageError,""CorruptImage"");
               }
             index=(IndexPacket) (mask-(((*ptr) & (mask << bit)) >> bit));
  static Image *ReadPALMImage(const ImageInfo *image_info,
       }
     one_row=(unsigned char *) RelinquishMagickMemory(one_row);
     if (compressionType == PALM_COMPRESSION_SCANLINE)
      last_row=(unsigned char *) RelinquishMagickMemory(last_row);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
  static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
     bit,
     byte,
     color,
    *last_row,
     *one_row,
     *ptr,
     version;
  static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
       }
     if (flags & PALM_IS_COMPRESSED_FLAG)
       (void) WriteBlobMSBShort(image,0);   
    last_row=(unsigned char *) NULL;
     if (image_info->compression == FaxCompression)
      {
        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,
          sizeof(*last_row));
        if (last_row == (unsigned char *) NULL)
          {
            quantize_info=DestroyQuantizeInfo(quantize_info);
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
          }
      }
     one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,
       sizeof(*one_row));
     if (one_row == (unsigned char *) NULL)
      {
        quantize_info=DestroyQuantizeInfo(quantize_info);
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      }
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       ptr=one_row;
  static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
               tptr = tmpbuf;
               for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)
               {
                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))
                   {
                     byte |= (1 << (7 - bit));
                     *tptr++ = (char) one_row[x + bit];
  static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
               (void) WriteBlobByte(image, byte);
               (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);
             }
            (void) CopyMagickMemory(last_row,one_row,bytes_per_row);
           }
         else
           (void) WriteBlob(image,bytes_per_row,one_row);
  static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
       {
         offset=SeekBlob(image,currentOffset+20,SEEK_SET);
         (void) WriteBlobByte(image,0);   
        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/
          QuantumRange));
        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/
          QuantumRange));
        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/
          QuantumRange));
       }
     if (flags & PALM_IS_COMPRESSED_FLAG)   
       {
  static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
       }
     if (one_row != (unsigned char *) NULL)
       one_row=(unsigned char *) RelinquishMagickMemory(one_row);
    if (last_row != (unsigned char *) NULL)
      last_row=(unsigned char *) RelinquishMagickMemory(last_row);
     if (GetNextImageInList(image) == (Image *) NULL)
       break;
      ",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.
1041,CVE-2017-12663,"  static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)
     sizeof(*colormap));
   if ((pixels == (unsigned char *) NULL) ||
       (colormap == (unsigned char *) NULL))
    {
      if (colormap != (unsigned char *) NULL)
        colormap=(unsigned char *) RelinquishMagickMemory(colormap);
      if (pixels != (unsigned char *) NULL)
        pixels=(unsigned char *) RelinquishMagickMemory(pixels);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }
    
   q=colormap;
   if (image->colors <= 256)
     for (i=0; i < (ssize_t) image->colors; i++)
     {
  static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);
      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &
        0xff);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);
      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &
        0xff);
     }
   (void) WriteBlob(image,packet_size*image->colors,colormap);
   colormap=(unsigned char *) RelinquishMagickMemory(colormap);",ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteMAPImage in coders/map.c.
1042,CVE-2017-12662,"  RestoreMSCWarning
             length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;
             pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));
             if (pixel_info == (MemoryInfo *) NULL)
              {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                ThrowWriterException(ResourceLimitError,
                  ""MemoryAllocationFailed"");
              }
             pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
             /*
               Dump runlength encoded pixels.
  RestoreMSCWarning
               length=(size_t) number_pixels;
               pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));
               if (pixel_info == (MemoryInfo *) NULL)
                {
                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                  ThrowWriterException(ResourceLimitError,
                    ""MemoryAllocationFailed"");
                }
               pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
               /*
                 Dump runlength encoded pixels.",ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePDFImage in coders/pdf.c.
1043,CVE-2017-12644,"  static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
           if ((quantum != 0) && (length != 0))
             {
               if (length > GetBlobSize(image))
                ThrowDCMException(CorruptImageError,
                   ""InsufficientImageDataInFile"");
               if (~length >= 1)
                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*",ImageMagick 7.0.6-1 has a memory leak vulnerability in ReadDCMImage in codersdcm.c.
1044,CVE-2017-12643,"  static Image *ReadOneJNGImage(MngInfo *mng_info,
 
     if (length != 0)
       {
        if (length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,
           sizeof(*chunk));
 
  static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,
 
         if (length != 0)
           {
            if (length > GetBlobSize(image))
              ThrowReaderException(CorruptImageError,
                ""InsufficientImageDataInFile"");
             chunk=(unsigned char *) AcquireQuantumMemory(length+
               MagickPathExtent,sizeof(*chunk));
 ",ImageMagick 7.0.6-1 has a memory exhaustion vulnerability in ReadOneJNGImage in coderspng.c.
1045,CVE-2017-12640,"  static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,
 
               for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)
               {
                if ((i < 0) || (i >= MNG_MAX_OBJECTS))
                  continue;
                 if (mng_info->exists[i] && !mng_info->frozen[i] &&
                     (p-chunk) < (ssize_t) (length-8))
                   {",ImageMagick 7.0.6-1 has an out-of-bounds read vulnerability in ReadOneMNGImage in coders/png.c.
1046,CVE-2017-12588,"  static rsRetVal createSocket(instanceConf_t* info, void** sock) {
 
      
     if (info->action==ACTION_CONNECT) {
        rv = zsocket_connect(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,
  static rsRetVal createSocket(instanceConf_t* info, void** sock) {
         }
         DBGPRINTF(""imzmq3: connect for %s successful\n"",info->description);
     } else {
        rv = zsocket_bind(*sock, ""%s"", info->description);
         if (rv == -1) {
             errmsg.LogError(0,
                             RS_RET_INVALID_PARAMS,","The zmq3 input and output modules in rsyslog before 8.28.0 interpreted description fields as format strings, possibly allowing a format string attack with unspecified impact."
1047,CVE-2017-12476,"  AP4_AtomSampleTable::GetSample(AP4_Ordinal index,
 {
     AP4_Result result;
 
     
    if (!m_StscAtom) {
        return AP4_ERROR_INVALID_FORMAT;
    }
    
      
     if (m_StcoAtom == NULL && m_Co64Atom == NULL) {
         return AP4_ERROR_INVALID_FORMAT;",The AP4_AvccAtom::InspectFields function in Core/Ap4AvccAtom.cpp in Bento4 mp4dump before 1.5.0-616 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted mp4 file.
1048,CVE-2017-12193,"  static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,
 		if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)
 			goto all_leaves_cluster_together;
 
		pr_devel(""present leaves cluster but not new leaf\n"");
 	}
 
 split_node:
 	pr_devel(""split node\n"");
 
 all_leaves_cluster_together:
 	/* All the leaves, new and old, want to cluster together in this node
 	 * in the same slot, so we have to replace this node with a shortcut to","The assoc_array_insert_into_terminal_node function in lib/assoc_array.c in the Linux kernel before 4.13.11 mishandles node splitting, which allows local users to cause a denial of service (NULL pointer dereference and panic) via a crafted application, as demonstrated by the keyring key type, and key addition and link creation operations."
1049,CVE-2017-12192,"  long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	key = key_ref_to_ptr(key_ref);
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {
		ret = -ENOKEY;
		goto error2;
	}

 	 
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)","The keyctl_read_key function in security/keys/keyctl.c in the Key Management subcomponent in the Linux kernel before 4.13.5 does not properly consider that a key may be possessed but negatively instantiated, which allows local users to cause a denial of service (OOPS and system crash) via a crafted KEYCTL_READ operation."
1050,CVE-2017-12190,"  struct bio *bio_map_user_iov(struct request_queue *q,
 		offset = offset_in_page(uaddr);
 		for (j = cur_page; j < page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
			unsigned short prev_bi_vcnt = bio->bi_vcnt;
 
 			if (len <= 0)
 				break;
  struct bio *bio_map_user_iov(struct request_queue *q,
 					    bytes)
 				break;
 
			 
			if (bio->bi_vcnt == prev_bi_vcnt)
				put_page(pages[j]);

 			len -= bytes;
 			offset = 0;
 		}","The bio_map_user_iov and bio_unmap_user functions in block/bio.c in the Linux kernel before 4.13.8 do unbalanced refcounting when a SCSI I/O vector has small consecutive buffers belonging to the same page. The bio_add_pc_page function merges them into one, but the page reference is never dropped. This causes a memory leak and possible system lockup (exploitable against the host OS by a guest OS user, if a SCSI disk is passed through to a virtual machine) due to an out-of-memory condition."
1051,CVE-2017-12168,"  static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,
 
 			idx = ARMV8_PMU_CYCLE_IDX;
 		} else {
			return false;
 		}
	} else if (r->CRn == 0 && r->CRm == 9) {
		 
		if (pmu_access_event_counter_el0_disabled(vcpu))
			return false;

		idx = ARMV8_PMU_CYCLE_IDX;
 	} else if (r->CRn == 14 && (r->CRm & 12) == 8) {
 		 
 		if (pmu_access_event_counter_el0_disabled(vcpu))
 			return false;
 
 		idx = ((r->CRm & 3) << 3) | (r->Op2 & 7);
 	} else {
		return false;
 	}
 
 	if (!pmu_counter_idx_valid(vcpu, idx))",The access_pmu_evcntr function in arch/arm64/kvm/sys_regs.c in the Linux kernel before 4.8.11 allows privileged KVM guest OS users to cause a denial of service (assertion failure and host OS crash) by accessing the Performance Monitors Cycle Count Register (PMCCNTR).
1052,CVE-2017-12154,"  static int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,
 	if (exec_control & CPU_BASED_TPR_SHADOW) {
 		vmcs_write64(VIRTUAL_APIC_PAGE_ADDR, -1ull);
 		vmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);
	} else {
#ifdef CONFIG_X86_64
		exec_control |= CPU_BASED_CR8_LOAD_EXITING |
				CPU_BASED_CR8_STORE_EXITING;
#endif
 	}
 
 	/*","The prepare_vmcs02 function in arch/x86/kvm/vmx.c in the Linux kernel through 4.13.3 does not ensure that the *CR8-load exiting* and *CR8-store exiting* L0 vmcs02 controls exist in cases where L1 omits the *use TPR shadow* vmcs12 control, which allows KVM L2 guest OS users to obtain read and write access to the hardware CR8 register."
1053,CVE-2017-12146,"  static ssize_t driver_override_store(struct device *dev,
 				     const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
	char *driver_override, *old, *cp;
 
 	if (count > PATH_MAX)
 		return -EINVAL;
  static ssize_t driver_override_store(struct device *dev,
 	if (cp)
 		*cp = '\0';
 
	device_lock(dev);
	old = pdev->driver_override;
 	if (strlen(driver_override)) {
 		pdev->driver_override = driver_override;
 	} else {
 		kfree(driver_override);
 		pdev->driver_override = NULL;
 	}
	device_unlock(dev);
 
 	kfree(old);
 
  static ssize_t driver_override_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct platform_device *pdev = to_platform_device(dev);
	ssize_t len;
 
	device_lock(dev);
	len = sprintf(buf, ""%s\n"", pdev->driver_override);
	device_unlock(dev);
	return len;
 }
 static DEVICE_ATTR_RW(driver_override);
 ",The driver_override implementation in drivers/base/platform.c in the Linux kernel before 4.12.1 allows local users to gain privileges by leveraging a race condition between a read operation and a store operation that involve different overrides.
1054,CVE-2017-11721,"  int Huff_Receive (node_t *node, int *ch, byte *fin) {
 }
 
  
void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset, int maxoffset) {
 	bloc = *offset;
 	while (node && node->symbol == INTERNAL_NODE) {
		if (bloc >= maxoffset) {
			*ch = 0;
			*offset = maxoffset + 1;
			return;
		}
 		if (get_bit(fin)) {
 			node = node->right;
 		} else {
  void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {
 }
 
  
static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {
 	if (node->parent) {
		send(node->parent, node, fout, maxoffset);
 	}
 	if (child) {
		if (bloc >= maxoffset) {
			bloc = maxoffset + 1;
			return;
		}
 		if (node->right == child) {
 			add_bit(1, fout);
 		} else {
  static void send(node_t *node, node_t *child, byte *fout) {
 }
 
  
void Huff_transmit (huff_t *huff, int ch, byte *fout, int maxoffset) {
 	int i;
 	if (huff->loc[ch] == NULL) { 
 		 
		Huff_transmit(huff, NYT, fout, maxoffset);
 		for (i = 7; i >= 0; i--) {
 			add_bit((char)((ch >> i) & 0x1), fout);
 		}
 	} else {
		send(huff->loc[ch], NULL, fout, maxoffset);
 	}
 }
 
void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) {
 	bloc = *offset;
	send(huff->loc[ch], NULL, fout, maxoffset);
 	*offset = bloc;
 }
 
  void Huff_Compress(msg_t *mbuf, int offset) {
 
 	for (i=0; i<size; i++ ) {
 		ch = buffer[i];
		Huff_transmit(&huff, ch, seq, size<<3);						 
 		Huff_addRef(&huff, (byte)ch);								 
 	}
 ",Buffer overflow in ioquake3 before 2017-08-02 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted packet.
1055,CVE-2017-11719,"  static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,
     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
         ctx->data_offset = 0x170 + (ctx->mb_height << 2);
     } else {
        if (ctx->mb_height > 68) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""mb height too big: %d\n"", ctx->mb_height);
             return AVERROR_INVALIDDATA;
         }
         ctx->data_offset = 0x280;
     }
    if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
        av_log(ctx->avctx, AV_LOG_ERROR,
                ""mb height too big: %d\n"", ctx->mb_height);
        return AVERROR_INVALIDDATA;
    }
 
     if (buf_size < ctx->data_offset) {
         av_log(ctx->avctx, AV_LOG_ERROR,",The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.
1056,CVE-2017-11665,"  int ff_amf_tag_size(const uint8_t *data, const uint8_t *data_end)
     return bytestream2_tell(&gb);
 }
 
static int amf_get_field_value2(GetByteContext *gb,
                            const uint8_t *name, uint8_t *dst, int dst_size)
 {
     int namelen = strlen(name);
     int len;
 
    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {
        int ret = amf_tag_skip(gb);
        if (ret < 0)
            return -1;
     }
    if (bytestream2_get_bytes_left(gb) < 3)
         return -1;
    bytestream2_get_byte(gb);

     for (;;) {
        int size = bytestream2_get_be16(gb);
         if (!size)
             break;
        if (size < 0 || size >= bytestream2_get_bytes_left(gb))
             return -1;
        bytestream2_skip(gb, size);
        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {
            switch (bytestream2_get_byte(gb)) {
             case AMF_DATA_TYPE_NUMBER:
                snprintf(dst, dst_size, ""%g"", av_int2double(bytestream2_get_be64(gb)));
                 break;
             case AMF_DATA_TYPE_BOOL:
                snprintf(dst, dst_size, ""%s"", bytestream2_get_byte(gb) ? ""true"" : ""false"");
                 break;
             case AMF_DATA_TYPE_STRING:
                len = bytestream2_get_be16(gb);
                if (dst_size < 1)
                    return -1;
                if (dst_size < len + 1)
                    len = dst_size - 1;
                bytestream2_get_buffer(gb, dst, len);
                dst[len] = 0;
                 break;
             default:
                 return -1;
             }
             return 0;
         }
        len = amf_tag_skip(gb);
        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)
             return -1;
     }
     return -1;
 }
 
int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,
                           const uint8_t *name, uint8_t *dst, int dst_size)
{
    GetByteContext gb;

    if (data >= data_end)
        return -1;

    bytestream2_init(&gb, data, data_end - data);

    return amf_get_field_value2(&gb, name, dst, dst_size);
}

 static const char* rtmp_packet_type(int type)
 {
     switch (type) {",The ff_amf_get_field_value function in libavformat/rtmppkt.c in FFmpeg 3.3.2 allows remote RTMP servers to cause a denial of service (Segmentation Violation and application crash) via a crafted stream.
1057,CVE-2017-11664,"  extern int _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions);
 
 extern struct _mdi * _WM_initMDI(void);
 extern void _WM_freeMDI(struct _mdi *mdi);
extern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event);
 extern void _WM_ResetToStart(struct _mdi *mdi);
 extern void _WM_do_pan_adjust(struct _mdi *mdi, uint8_t ch);
 extern void _WM_do_note_off_extra(struct _note *nte);",The _WM_SetupMidiEvent function in internal_midi.c:2122 in WildMIDI 0.4.2 can cause a denial of service (invalid memory read and application crash) via a crafted mid file.
1058,CVE-2017-11523,"  static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           break;
       }
     }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {","The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered."
1059,CVE-2017-11522,"  static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
     ""  Enter WriteOnePNGImage()"");
 
   image = CloneImage(IMimage,0,0,MagickFalse,exception);
  if (image == (Image *) NULL)
    return(MagickFalse);
   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);
   if (image_info == (ImageInfo *) NULL)
    ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
 
   /* Define these outside of the following ""if logging()"" block so they will
    * show in debuggers.",The WriteOnePNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.
1060,CVE-2017-11472,"  struct acpi_namespace_node *acpi_ns_validate_handle(acpi_handle handle)
 void acpi_ns_terminate(void)
 {
 	acpi_status status;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
 
 	ACPI_FUNCTION_TRACE(ns_terminate);
 
	 
 
	next = acpi_gbl_module_code_list;
	while (next) {
		prev = next;
		next = next->method.mutex;
		prev->method.mutex = NULL;	 
		acpi_ut_remove_reference(prev);
 	}
 
 	/*
 	 * Free the entire namespace -- all nodes and all objects","The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
1061,CVE-2017-11462,"  gss_cred_id_t *		d_cred;
     } else {
 	union_ctx_id = (gss_union_ctx_id_t)*context_handle;
 	selected_mech = union_ctx_id->mech_type;
	if (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)
	    return (GSS_S_NO_CONTEXT);
     }
 
      
  gss_cred_id_t *		d_cred;
 	    free(union_ctx_id);
 	    return (status);
 	}
     }
 
      
	    if (status == GSS_S_CONTINUE_NEEDED) {
		*context_handle = (gss_ctx_id_t)union_ctx_id;
 		return GSS_S_CONTINUE_NEEDED;
	    }
 
 	     
 	    if (status != GSS_S_COMPLETE) {
  gss_cred_id_t *		d_cred;
 		*mech_type = gssint_get_public_oid(actual_mech);
 	    if (ret_flags != NULL)
 		*ret_flags = temp_ret_flags;
	    *context_handle = (gss_ctx_id_t)union_ctx_id;
	    return GSS_S_COMPLETE;
     } else {
 
 	status = GSS_S_BAD_MECH;
     }
 
 error_out:
	 
    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {
 	if (union_ctx_id->mech_type) {
 	    if (union_ctx_id->mech_type->elements)
 		free(union_ctx_id->mech_type->elements);
  gss_cred_id_t *		d_cred;
 					 GSS_C_NO_BUFFER);
 	}
 	free(union_ctx_id);
     }
 
     if (src_name)",Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
1062,CVE-2017-11450,"  static Image *ReadJPEGImage(const ImageInfo *image_info,
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
    
  ModuleExport size_t RegisterJPEGImage(void)
 #endif
   entry->magick=(IsImageFormatHandler *) IsJPEG;
   entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
  ModuleExport size_t RegisterJPEGImage(void)
 #endif
   entry->magick=(IsImageFormatHandler *) IsJPEG;
   entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
  ModuleExport size_t RegisterJPEGImage(void)
   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
 #endif
   entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
  ModuleExport size_t RegisterJPEGImage(void)
   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
 #endif
   entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
  ModuleExport size_t RegisterJPEGImage(void)
   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
 #endif
   entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);",coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via JPEG data that is too short.
1063,CVE-2017-11449,"  ModuleExport size_t RegisterMPCImage(void)
   entry=SetMagickInfo(""CACHE"");
   entry->description=ConstantString(""Magick Persistent Cache image format"");
   entry->module=ConstantString(""MPC"");
  entry->seekable_stream=MagickTrue;
   entry->stealth=MagickTrue;
   (void) RegisterMagickInfo(entry);
   entry=SetMagickInfo(""MPC"");
   entry->decoder=(DecodeImageHandler *) ReadMPCImage;
   entry->encoder=(EncodeImageHandler *) WriteMPCImage;
   entry->magick=(IsImageFormatHandler *) IsMPC;
   entry->description=ConstantString(""Magick Persistent Cache image format"");
  entry->seekable_stream=MagickTrue;
   entry->module=ConstantString(""MPC"");
   (void) RegisterMagickInfo(entry);
   return(MagickImageCoderSignature);","coders/mpc.c in ImageMagick before 7.0.6-1 does not enable seekable streams and thus cannot validate blob sizes, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an image received from stdin."
1064,CVE-2017-11448,"  static Image *ReadJPEGImage(const ImageInfo *image_info,
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
  (void) ResetMagickMemory(jpeg_pixels,0,image->columns* 
    jpeg_info.output_components*sizeof(*jpeg_pixels));
    ",The ReadJPEGImage function in coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to obtain sensitive information from uninitialized memory locations via a crafted file.
1065,CVE-2017-11447,"  static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,
       screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);
       screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);
       screen->storage_class=DirectClass;
      if (image == (Image *) NULL)
        image=screen;
      else
        AppendImageToList(&image,screen);
       status=SetImageExtent(screen,screen->columns,screen->rows);
       if (status == MagickFalse)
         {
           InheritException(exception,&image->exception);
           return(DestroyImageList(image));
         }
 
       bitmapDC=CreateCompatibleDC(hDC);
       if (bitmapDC == (HDC) NULL)","The ReadSCREENSHOTImage function in coders/screenshot.c in ImageMagick before 7.0.6-1 has memory leaks, causing denial of service."
1066,CVE-2017-11399,"  static int ape_decode_frame(AVCodecContext *avctx, void *data,
     int32_t *sample24;
     int i, ch, ret;
     int blockstodecode;
    uint64_t decoded_buffer_size;
 
      
  static int ape_decode_frame(AVCodecContext *avctx, void *data,
                 skip_bits_long(&s->gb, offset);
         }
 
        if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {
             av_log(avctx, AV_LOG_ERROR, ""Invalid sample count: %""PRIu32"".\n"",
                    nblocks);
             return AVERROR_INVALIDDATA;
  static int ape_decode_frame(AVCodecContext *avctx, void *data,
         blockstodecode = s->samples;
 
      
    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);
    av_assert0(decoded_buffer_size <= INT_MAX);
    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);
     if (!s->decoded_buffer)
         return AVERROR(ENOMEM);
     memset(s->decoded_buffer, 0, s->decoded_size);",Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.
1067,CVE-2017-11368,"  finish_process_as_req(struct as_req_state *state, krb5_error_code errcode)
     did_log = 1;
 
 egress:
    if (errcode != 0 && state->status == NULL)
        state->status = ""UNKNOWN_REASON"";
 
     au_state->status = state->status;
     au_state->reply = &state->reply;","In MIT Kerberos 5 (aka krb5) 1.7 and later, an authenticated attacker can cause a KDC assertion failure by sending invalid S4U2Self or S4U2Proxy requests."
1068,CVE-2017-11328,"  int module_load(
   set_integer(0, module_object, ""integer_array[%i]"", 0);
   set_integer(1, module_object, ""integer_array[%i]"", 1);
   set_integer(2, module_object, ""integer_array[%i]"", 2);
  set_integer(256, module_object, ""integer_array[%i]"", 256);
 
   set_string(""foo"", module_object, ""string_array[%i]"", 0);
   set_string(""bar"", module_object, ""string_array[%i]"", 1);",Heap buffer overflow in the yr_object_array_set_item() function in object.c in YARA 3.x allows a denial-of-service attack by scanning a crafted .NET file.
1069,CVE-2017-11176,"  static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1) {
				sock = NULL;
 				goto retry;
			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;","The mq_notify function in the Linux kernel through 4.11.9 does not set the sock pointer to NULL upon entry into the retry logic. During a user-space close of a Netlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact."
1070,CVE-2017-11171,"  struct GsmXSMPClientPrivate
         IceConn    ice_connection;
 
         guint      watch_id;
 
         char      *description;
         GPtrArray *props;
  client_iochannel_watch (GIOChannel    *channel,
         return keep_going;
 }
 
 static SmProp *
 find_property (GsmXSMPClient *client,
                const char    *name,
  setup_connection (GsmXSMPClient *client)
                                                  client);
         g_io_channel_unref (channel);
 
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
  gsm_xsmp_client_disconnect (GsmXSMPClient *client)
                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);
                 IceCloseConnection (client->priv->ice_connection);
         }
 }
 
 static void
  gsm_xsmp_client_connect (GsmXSMPClient *client,
 {
         client->priv->conn = conn;
 
         g_debug (""GsmXSMPClient: Initializing client %s"", client->priv->description);
 
         *mask_ret = 0;","Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible."
1071,CVE-2017-11142,"  typedef struct post_var_data {
 	char *ptr;
 	char *end;
 	uint64_t cnt;

	 
	size_t already_scanned;
 } post_var_data_t;
 
 static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)
 {
	char *start, *ksep, *vsep, *val;
 	size_t klen, vlen;
 	 
 	unsigned int new_vlen;
  static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR
 		return 0;
 	}
 
	start = var->ptr + var->already_scanned;
	vsep = memchr(start, '&', var->end - start);
 	if (!vsep) {
 		if (!eof) {
			var->already_scanned = var->end - var->ptr;
 			return 0;
 		} else {
 			vsep = var->end;
  static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSR
 	efree(val);
 
 	var->ptr = vsep + (vsep != var->end);
	var->already_scanned = 0;
 	return 1;
 }
 
  static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof
 		}
 	}
 
	if (!eof && vars->str.c != vars->ptr) {
 		memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);
 	}
 	return SUCCESS;","In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c."
1072,CVE-2017-10966,"  char *my_asctime(time_t t)
         int len;
 
 	tm = localtime(&t);
	if (tm == NULL)
	    return g_strdup(""???"");

 	str = g_strdup(asctime(tm));
 
 	len = strlen(str);","An issue was discovered in Irssi before 1.0.4. While updating the internal nick list, Irssi could incorrectly use the GHashTable interface and free the nick while updating it. This would then result in use-after-free conditions on each access of the hash table."
1073,CVE-2017-10929,"  grub_disk_read (grub_disk_t disk, grub_disk_addr_t sector,
       if (data)
 	{
 	   
	  if (buf) {
	    if (pos + real_offset + len >= size) {
               
              grub_errno = GRUB_ERR_BAD_FS;
              return grub_errno;
	    }
 	    grub_memcpy (buf, data + pos + real_offset, len);
          }
 	  grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector);
 	}
       else","The grub_memmove function in shlr/grub/kern/misc.c in radare2 1.5.0 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, possibly related to a read overflow in the grub_disk_read_small_real function in kern/disk.c in GNU GRUB 2.02."
1074,CVE-2017-10911,"  static int dispatch_rw_block_io(struct xen_blkif_ring *ring,
 static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
	struct blkif_response *resp;
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
 	spin_lock_irqsave(&ring->blk_ring_lock, flags);
 	blk_rings = &ring->blk_rings;
 	 
 	switch (ring->blkif->blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
 		break;
 	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
 		break;
 	default:
 		BUG();
 	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

 	blk_rings->common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
 	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);","The make_response function in drivers/block/xen-blkback/blkback.c in the Linux kernel before 4.11.8 allows guest OS users to obtain sensitive information from host OS (or other guest OS) kernel memory by leveraging the copying of uninitialized padding fields in Xen block-interface response structures, aka XSA-216."
1075,CVE-2017-10810,"  int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,
 		return -ENOMEM;
 	size = roundup(size, PAGE_SIZE);
 	ret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);
	if (ret != 0) {
		kfree(bo);
 		return ret;
	}
 	bo->dumb = false;
 	virtio_gpu_init_ttm_placement(bo, pinned);
 ",Memory leak in the virtio_gpu_object_create function in drivers/gpu/drm/virtio/virtgpu_object.c in the Linux kernel through 4.11.8 allows attackers to cause a denial of service (memory consumption) by triggering object-initialization failures.
1076,CVE-2017-10807,"  static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cb
             mechbuf[sizeof(mechbuf)-1]='\0';
             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);
 
            log_debug(ZONE, ""sx sasl callback: check mech (mech=%s)"", mechbuf);

              
             host = xhash_get(c2s->hosts, s->req_to);
             if(host == NULL) {","JabberD 2.x (aka jabberd2) before 2.6.1 allows anyone to authenticate using SASL ANONYMOUS, even when the sasl.anonymous c2s.xml option is not enabled."
1077,CVE-2017-10671,"  de_dotdot( char* file )
     while ( strncmp( file, ""./"", 2 ) == 0 )
 	(void) memmove( file, file + 2, strlen( file ) - 1 );
     while ( ( cp = strstr( file, ""/./"") ) != (char*) 0 )
	(void) memmove( cp, cp + 2, strlen( cp ) - 1 );
 
      
     for (;;)",Heap-based Buffer Overflow in the de_dotdot function in libhttpd.c in sthttpd before 2.27.1 allows remote attackers to cause a denial of service (daemon crash) or possibly have unspecified other impact via a crafted filename.
1078,CVE-2017-10663,"  int sanity_check_ckpt(struct f2fs_sb_info *sbi)
 	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
 	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
 	unsigned int ovp_segments, reserved_segments;
	unsigned int main_segs, blocks_per_seg;
	int i;
 
 	total = le32_to_cpu(raw_super->segment_count);
 	fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
  int sanity_check_ckpt(struct f2fs_sb_info *sbi)
 		return 1;
 	}
 
	main_segs = le32_to_cpu(raw_super->segment_count_main);
	blocks_per_seg = sbi->blocks_per_seg;

	for (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
			return 1;
	}
	for (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)
			return 1;
	}

 	if (unlikely(f2fs_cp_error(sbi))) {
 		f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
 		return 1;","The sanity_check_ckpt function in fs/f2fs/super.c in the Linux kernel before 4.12.4 does not validate the blkoff and segno arrays, which allows local users to gain privileges via unspecified vectors."
1079,CVE-2017-10662,"  static int sanity_check_raw_super(struct f2fs_sb_info *sbi,
 		return 1;
 	}
 
	if (le32_to_cpu(raw_super->segment_count) > F2FS_MAX_SEGMENT) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid segment count (%u)"",
			le32_to_cpu(raw_super->segment_count));
		return 1;
	}

 	 
 	if (sanity_check_area_boundary(sbi, bh))
 		return 1;","The sanity_check_raw_super function in fs/f2fs/super.c in the Linux kernel before 4.11.1 does not validate the segment count, which allows local users to gain privileges via unspecified vectors."
1080,CVE-2017-10661,"  struct timerfd_ctx {
 	short unsigned settime_flags;	 
 	struct rcu_head rcu;
 	struct list_head clist;
	spinlock_t cancel_lock;
 	bool might_cancel;
 };
 
  void timerfd_clock_was_set(void)
 	rcu_read_unlock();
 }
 
static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)
 {
 	if (ctx->might_cancel) {
 		ctx->might_cancel = false;
  static void timerfd_remove_cancel(struct timerfd_ctx *ctx)
 	}
 }
 
static void timerfd_remove_cancel(struct timerfd_ctx *ctx)
{
	spin_lock(&ctx->cancel_lock);
	__timerfd_remove_cancel(ctx);
	spin_unlock(&ctx->cancel_lock);
}

 static bool timerfd_canceled(struct timerfd_ctx *ctx)
 {
 	if (!ctx->might_cancel || ctx->moffs != KTIME_MAX)
  static bool timerfd_canceled(struct timerfd_ctx *ctx)
 
 static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 {
	spin_lock(&ctx->cancel_lock);
 	if ((ctx->clockid == CLOCK_REALTIME ||
 	     ctx->clockid == CLOCK_REALTIME_ALARM) &&
 	    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {
  static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 			list_add_rcu(&ctx->clist, &cancel_list);
 			spin_unlock(&cancel_lock);
 		}
	} else {
		__timerfd_remove_cancel(ctx);
 	}
	spin_unlock(&ctx->cancel_lock);
 }
 
 static ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)
  SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)
 		return -ENOMEM;
 
 	init_waitqueue_head(&ctx->wqh);
	spin_lock_init(&ctx->cancel_lock);
 	ctx->clockid = clockid;
 
 	if (isalarm(ctx))",Race condition in fs/timerfd.c in the Linux kernel before 4.10.15 allows local users to gain privileges or cause a denial of service (list corruption or use-after-free) via simultaneous file-descriptor operations that leverage improper might_cancel queueing.
1081,CVE-2017-9996,"  static int cdxl_decode_frame(AVCodecContext *avctx, void *data,
         return AVERROR_INVALIDDATA;
     if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {
         avctx->pix_fmt = AV_PIX_FMT_PAL8;
    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {
         if (c->palette_size != (1 << (c->bpp - 1)))
             return AVERROR_INVALIDDATA;
         avctx->pix_fmt = AV_PIX_FMT_BGR24;","The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
1082,CVE-2017-9995,"  static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)
         clr = (b << 16) + (g << 8) + r;
         k += run;
         while (run-- > 0) {
            if (y >= avctx->height)
                return AVERROR_INVALIDDATA;

             dst[y * linesize + x] = clr;
             lx = x;
             ly = y;","libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
1083,CVE-2017-9994,"  int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
     enum AVDiscard skip_thresh;
     VP8Frame *av_uninit(curframe), *prev_frame;
 
    av_assert0(avctx->pix_fmt == AV_PIX_FMT_YUVA420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P);

     if (is_vp7)
         ret = vp7_decode_frame_header(s, avpkt->data, avpkt->size);
     else","libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions."
1084,CVE-2017-9993,"  static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)
         if (!sub_demuxer)
             goto error;
 
        if (strcmp(sub_demuxer->name, ""srt"") && strcmp(sub_demuxer->name, ""ass""))
            goto error;

         if (!(ast->sub_ctx = avformat_alloc_context()))
             goto error;
 ","FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data."
1085,CVE-2017-9992,"  static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height
                 return AVERROR_INVALIDDATA;
             frame += v;
         } else {
            if (frame_end - frame < width + 4)
                 return AVERROR_INVALIDDATA;
             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);","Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file."
1086,CVE-2017-9991,"  static int xwd_decode_frame(AVCodecContext *avctx, void *data,
     case XWD_GRAY_SCALE:
         if (bpp != 1 && bpp != 8)
             return AVERROR_INVALIDDATA;
        if (bpp == 1 && pixdepth == 1) {
             avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;
        } else if (bpp == 8 && pixdepth == 8) {
             avctx->pix_fmt = AV_PIX_FMT_GRAY8;
         }
         break;","Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file."
1087,CVE-2017-9990," 
 typedef struct XPMContext {
     uint32_t  *pixels;
     int        pixels_size;
    uint8_t   *buf;
    int        buf_size;
 } XPMDecContext;
 
 typedef struct ColorEntry {
  static uint32_t color_string_to_rgba(const char *p, int len)
     const ColorEntry *entry;
     char color_name[100];
 
    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);

     if (*p == '#') {
         p++;
         len--;
  static int xpm_decode_frame(AVCodecContext *avctx, void *data,
 {
     XPMDecContext *x = avctx->priv_data;
     AVFrame *p=data;
    const uint8_t *end, *ptr;
     int ncolors, cpp, ret, i, j;
     int64_t size;
     uint32_t *dst;
 
     avctx->pix_fmt = AV_PIX_FMT_BGRA;
 
    av_fast_padded_malloc(&x->buf, &x->buf_size, avpkt->size);
    if (!x->buf)
        return AVERROR(ENOMEM);
    memcpy(x->buf, avpkt->data, avpkt->size);
    x->buf[avpkt->size] = 0;

    ptr = x->buf;
    end = x->buf + avpkt->size;
    while (end - ptr > 9 && memcmp(ptr, ""/* XPM */"", 9))
         ptr++;
 
    if (end - ptr <= 9) {
         av_log(avctx, AV_LOG_ERROR, ""missing signature\n"");
         return AVERROR_INVALIDDATA;
     }
  static int xpm_decode_frame(AVCodecContext *avctx, void *data,
 
     size = 1;
     for (i = 0; i < cpp; i++)
        size *= 95;
 
     if (ncolors <= 0 || ncolors > size) {
         av_log(avctx, AV_LOG_ERROR, ""invalid number of colors: %d\n"", ncolors);
  static int xpm_decode_frame(AVCodecContext *avctx, void *data,
         return AVERROR(ENOMEM);
 
     ptr += mod_strcspn(ptr, "","") + 1;
    if (end - ptr < 1)
        return AVERROR_INVALIDDATA;

     for (i = 0; i < ncolors; i++) {
         const uint8_t *index;
         int len;
 
         ptr += mod_strcspn(ptr, ""\"""") + 1;
        if (end - ptr < cpp)
             return AVERROR_INVALIDDATA;
         index = ptr;
         ptr += cpp;
  static int xpm_decode_frame(AVCodecContext *avctx, void *data,
 
         x->pixels[ret] = color_string_to_rgba(ptr, len);
         ptr += mod_strcspn(ptr, "","") + 1;
        if (end - ptr < 1)
            return AVERROR_INVALIDDATA;
     }
 
     for (i = 0; i < avctx->height; i++) {
         dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);
        if (end - ptr < 1)
            return AVERROR_INVALIDDATA;
         ptr += mod_strcspn(ptr, ""\"""") + 1;
        if (end - ptr < 1)
            return AVERROR_INVALIDDATA;
 
         for (j = 0; j < avctx->width; j++) {
            if (end - ptr < cpp)
                 return AVERROR_INVALIDDATA;
 
             if ((ret = ascii2index(ptr, cpp)) < 0)
  static av_cold int xpm_decode_close(AVCodecContext *avctx)
     XPMDecContext *x = avctx->priv_data;
     av_freep(&x->pixels);
 
    av_freep(&x->buf);
    x->buf_size = 0;

     return 0;
 }
 ",Stack-based buffer overflow in the color_string_to_rgba function in libavcodec/xpmdec.c in FFmpeg 3.3 before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.
1088,CVE-2017-9985,"  void snd_msndmidi_input_read(void *mpuv)
 	unsigned long flags;
 	struct snd_msndmidi *mpu = mpuv;
 	void *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;
	u16 head, tail, size;
 
 	spin_lock_irqsave(&mpu->input_lock, flags);
	head = readw(mpu->dev->MIDQ + JQS_wHead);
	tail = readw(mpu->dev->MIDQ + JQS_wTail);
	size = readw(mpu->dev->MIDQ + JQS_wSize);
	if (head > size || tail > size)
		goto out;
	while (head != tail) {
		unsigned char val = readw(pwMIDQData + 2 * head);

		if (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode))
			snd_rawmidi_receive(mpu->substream_input, &val, 1);
		if (++head > size)
			head = 0;
		writew(head, mpu->dev->MIDQ + JQS_wHead);
 	}
 out:
 	spin_unlock_irqrestore(&mpu->input_lock, flags);
 }
 EXPORT_SYMBOL(snd_msndmidi_input_read);","The snd_msndmidi_input_read function in sound/isa/msnd/msnd_midi.c in the Linux kernel through 4.11.7 allows local users to cause a denial of service (over-boundary access) or possibly have unspecified other impact by changing the value of a message queue head pointer between two kernel reads of that value, aka a *double fetch* vulnerability."
1089,CVE-2017-9763,"  static int cmd_mount(void *data, const char *_input) {
 	switch (*input) {
 	case ' ':
 		input++;
		if (input[0]==' ') {
 			input++;
		}
 		ptr = strchr (input, ' ');
 		if (ptr) {
 			*ptr = 0;
  static int cmd_mount(void *data, const char *_input) {
 				*ptr2 = 0;
 				off = r_num_math (core->num, ptr2+1);
 			}
			if (!r_fs_mount (core->fs, ptr, input, off)) {
 				eprintf (""Cannot mount %s\n"", input);
			}
 		} else {
			if (!(ptr = r_fs_name (core->fs, core->offset))) {
 				eprintf (""Unknown filesystem type\n"");
			} else if (!r_fs_mount (core->fs, ptr, input, core->offset)) {
 				eprintf (""Cannot mount %s\n"", input);
			}
 			free (ptr);
 		}
 		break;","The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array."
1090,CVE-2017-9761,"  static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {
 			if (haveQuote) {
 			 
 				cmd++;
				p = cmd[0] ? find_eoq (cmd + 1) : NULL;
 				if (!p || !*p) {
 					eprintf (""Missing \"" in (%s)."", cmd);
 					return false;",The find_eoq function in libr/core/cmd.c in radare2 1.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
1091,CVE-2017-9608,"  static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
                int remaining;
 
                 if (cid <= 0)
                     continue;
 
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                 }
                dctx->remaining = remaining;
                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {
                     int remaining = dctx->remaining;
 ","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file."
1092,CVE-2017-9605,"  int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
 	int ret;
 	uint32_t size;
	uint32_t backup_handle = 0;
 
 	if (req->multisample_count != 0)
 		return -EINVAL;
  int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
 		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
 					     &res->backup,
 					     &user_srf->backup_base);
		if (ret == 0) {
			if (res->backup->base.num_pages * PAGE_SIZE <
			    res->backup_size) {
				DRM_ERROR(""Surface backup buffer is too small.\n"");
				vmw_dmabuf_unreference(&res->backup);
				ret = -EINVAL;
				goto out_unlock;
			} else {
				backup_handle = req->buffer_handle;
			}
 		}
 	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,","The vmw_gb_surface_define_ioctl function (accessible via DRM_IOCTL_VMW_GB_SURFACE_CREATE) in drivers/gpu/drm/vmwgfx/vmwgfx_surface.c in the Linux kernel through 4.11.4 defines a backup_handle variable but does not give it an initial value. If one attempts to create a GB surface, with a previously allocated DMA buffer to be used as a backup buffer, the backup_handle variable does not get written to and is then later returned to user space, allowing local users to obtain sensitive information from uninitialized kernel memory via a crafted ioctl call."
1093,CVE-2017-9527,"  mark_context_stack(mrb_state *mrb, struct mrb_context *c)
 {
   size_t i;
   size_t e;
  mrb_value nil;
 
   if (c->stack == NULL) return;
   e = c->stack - c->stbase;
  mark_context_stack(mrb_state *mrb, struct mrb_context *c)
     mrb_value v = c->stbase[i];
 
     if (!mrb_immediate_p(v)) {
      mrb_gc_mark(mrb, mrb_basic_ptr(v));
     }
   }
  e = c->stend - c->stbase;
  nil = mrb_nil_value();
  for (; i<e; i++) {
    c->stbase[i] = nil;
  }
 }
 
 static void",The mark_context_stack function in gc.c in mruby through 1.2.0 allows attackers to cause a denial of service (heap-based use-after-free and application crash) or possibly have unspecified other impact via a crafted .rb file.
1094,CVE-2017-9520,"  R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *valu
 				if (node->value == value) {
 					goto beach;
 				}
				char *tmp = node->value;
 				node->value = strdup (value);
				free (tmp);
 				if (IS_DIGIT (*value)) {
 					if (strchr (value, '/')) {
 						node->i_value = r_num_get (cfg->num, value);",The r_config_set function in libr/config/config.c in radare2 1.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted DEX file.
1095,CVE-2017-9501,"  MagickExport Image *CloneImage(const Image *image,const size_t columns,
         sizeof(*clone_image->colormap));
       if (clone_image->colormap == (PixelPacket *) NULL)
         {
          image=(Image *) RelinquishMagickMemory(image);
           ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
         }
       (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*","In ImageMagick 7.0.5-7 Q16, an assertion failure was found in the function LockSemaphoreInfo, which allows attackers to cause a denial of service via a crafted file."
1096,CVE-2017-9499,"  static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)
                 if (LocaleCompare(keyword,""number-meta-channels"") == 0)
                   {
                     image->number_meta_channels=StringToUnsignedLong(options);
                    if (image->number_meta_channels > MaxPixelChannels)
                      ThrowReaderException(CorruptImageError,
                        ""ImproperImageHeader"");
                     break;
                   }
                 break;","In ImageMagick 7.0.5-7 Q16, an assertion failure was found in the function SetPixelChannelAttributes, which allows attackers to cause a denial of service via a crafted file."
1097,CVE-2017-9465,"  int yr_re_fast_exec(
 
           for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
           {
             if (bytes_matched + i >= max_bytes_matched)
               break;
 
            next_input = input + i * input_incr;

             if ( *(next_opcode) != RE_OPCODE_LITERAL ||
                 (*(next_opcode) == RE_OPCODE_LITERAL &&
                  *(next_opcode + 1) == *next_input))
  int yr_re_fast_exec(
 
           input += input_incr * repeat_any_args->min;
           bytes_matched += repeat_any_args->min;
          bytes_matched = yr_min(bytes_matched, max_bytes_matched);
           ip = next_opcode;
 
           break;",The yr_arena_write_data function in YARA 3.6.1 allows remote attackers to cause a denial of service (buffer over-read and application crash) or obtain sensitive information from process memory via a crafted file that is mishandled in the yr_re_fast_exec function in libyara/re.c and the _yr_scan_match_callback function in libyara/scan.c.
1098,CVE-2017-9454,"  int ares_parse_a_reply(const unsigned char *abuf, int alen,
       rr_class = DNS_RR_CLASS(aptr);
       rr_len = DNS_RR_LEN(aptr);
       aptr += RRFIXEDSZ;
      if (aptr + rr_len > abuf + alen)
	{
	  free(rr_name);
	  status = ARES_EBADRESP;
	  break;
	}
 
       if (rr_class == C_IN && rr_type == T_A
 	  && rr_len == sizeof(struct in_addr)",Buffer overflow in the ares_parse_a_reply function in the embedded ares library in ReSIProcate before 1.12.0 allows remote attackers to cause a denial of service (out-of-bounds-read) via a crafted DNS response.
1099,CVE-2017-9438," 
 #define mark_as_not_fast_regexp() \
     ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP
 
#define incr_ast_levels() \
    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \
    { \
      lex_env->last_error_code = ERROR_INVALID_HEX_STRING; \
      YYABORT; \
    }

 #define ERROR_IF(x, error) \
     if (x) \
     { \
 
     } \
 
 
#line 118 ""hex_grammar.c""  
 
 # ifndef YY_NULLPTR
 #  if defined __cplusplus && 201103L <= __cplusplus
  extern int hex_yydebug;
 
 union YYSTYPE
 {
#line 85 ""hex_grammar.y""  
 
   int64_t integer;
   RE_NODE *re_node;
 
#line 173 ""hex_grammar.c""  
 };
 
 typedef union YYSTYPE YYSTYPE;
  int hex_yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env);
 
  
 
#line 189 ""hex_grammar.c""  
 
 #ifdef short
 # undef short
  static const yytype_uint8 yytranslate[] =
    
 static const yytype_uint16 yyrline[] =
 {
       0,   112,   112,   121,   125,   136,   200,   204,   219,   223,
     232,   246,   245,   258,   281,   313,   335,   355,   359,   374,
     382
 };
 #endif
 
  yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, H
   switch (yytype)
     {
           case 16:  
#line 101 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1030 ""hex_grammar.c""  
         break;
 
     case 17:  
#line 102 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1036 ""hex_grammar.c""  
         break;
 
     case 18:  
#line 103 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1042 ""hex_grammar.c""  
         break;
 
     case 19:  
#line 104 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1048 ""hex_grammar.c""  
         break;
 
     case 21:  
#line 107 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1054 ""hex_grammar.c""  
         break;
 
     case 22:  
#line 106 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1060 ""hex_grammar.c""  
         break;
 
     case 23:  
#line 105 ""hex_grammar.y""  
       { yr_re_node_destroy(((*yyvaluep).re_node)); }
#line 1066 ""hex_grammar.c""  
         break;
 
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
   switch (yyn)
     {
         case 2:
#line 113 ""hex_grammar.y""  
     {
         RE_AST* re_ast = yyget_extra(yyscanner);
         re_ast->root_node = (yyvsp[-1].re_node);
       }
#line 1337 ""hex_grammar.c""  
     break;
 
   case 3:
#line 122 ""hex_grammar.y""  
     {
         (yyval.re_node) = (yyvsp[0].re_node);
       }
#line 1345 ""hex_grammar.c""  
     break;
 
   case 4:
#line 126 ""hex_grammar.y""  
     {
        incr_ast_levels();

         (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
 
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
 
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
       }
#line 1360 ""hex_grammar.c""  
     break;
 
   case 5:
#line 137 ""hex_grammar.y""  
     {
         RE_NODE* new_concat;
         RE_NODE* leftmost_concat = NULL;
         RE_NODE* leftmost_node = (yyvsp[-1].re_node);
 
        incr_ast_levels();

         (yyval.re_node) = NULL;
 
          
#line 1424 ""hex_grammar.c""  
     break;
 
   case 6:
#line 201 ""hex_grammar.y""  
     {
         (yyval.re_node) = (yyvsp[0].re_node);
       }
#line 1432 ""hex_grammar.c""  
     break;
 
   case 7:
#line 205 ""hex_grammar.y""  
     {
        incr_ast_levels();

         (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
 
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));
         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));
 
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
       }
#line 1447 ""hex_grammar.c""  
     break;
 
   case 8:
#line 220 ""hex_grammar.y""  
     {
         (yyval.re_node) = (yyvsp[0].re_node);
       }
#line 1455 ""hex_grammar.c""  
     break;
 
   case 9:
#line 224 ""hex_grammar.y""  
     {
         (yyval.re_node) = (yyvsp[0].re_node);
         (yyval.re_node)->greedy = FALSE;
       }
#line 1464 ""hex_grammar.c""  
     break;
 
   case 10:
#line 233 ""hex_grammar.y""  
     {
         lex_env->token_count++;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.re_node) = (yyvsp[0].re_node);
       }
#line 1481 ""hex_grammar.c""  
     break;
 
   case 11:
#line 246 ""hex_grammar.y""  
     {
         lex_env->inside_or++;
       }
#line 1489 ""hex_grammar.c""  
     break;
 
   case 12:
#line 250 ""hex_grammar.y""  
     {
         (yyval.re_node) = (yyvsp[-1].re_node);
         lex_env->inside_or--;
       }
#line 1498 ""hex_grammar.c""  
     break;
 
   case 13:
#line 259 ""hex_grammar.y""  
     {
         if ((yyvsp[-1].integer) <= 0)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.re_node)->start = (int) (yyvsp[-1].integer);
         (yyval.re_node)->end = (int) (yyvsp[-1].integer);
       }
#line 1525 ""hex_grammar.c""  
     break;
 
   case 14:
#line 282 ""hex_grammar.y""  
     {
         if (lex_env->inside_or &&
             ((yyvsp[-3].integer) > STRING_CHAINING_THRESHOLD ||
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.re_node)->start = (int) (yyvsp[-3].integer);
         (yyval.re_node)->end = (int) (yyvsp[-1].integer);
       }
#line 1561 ""hex_grammar.c""  
     break;
 
   case 15:
#line 314 ""hex_grammar.y""  
     {
         if (lex_env->inside_or)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.re_node)->start = (int) (yyvsp[-2].integer);
         (yyval.re_node)->end = INT_MAX;
       }
#line 1587 ""hex_grammar.c""  
     break;
 
   case 16:
#line 336 ""hex_grammar.y""  
     {
         if (lex_env->inside_or)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.re_node)->start = 0;
         (yyval.re_node)->end = INT_MAX;
       }
#line 1607 ""hex_grammar.c""  
     break;
 
   case 17:
#line 356 ""hex_grammar.y""  
     {
           (yyval.re_node) = (yyvsp[0].re_node);
       }
#line 1615 ""hex_grammar.c""  
     break;
 
   case 18:
#line 360 ""hex_grammar.y""  
     {
         mark_as_not_fast_regexp();
        incr_ast_levels();
 
         (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
       }
#line 1631 ""hex_grammar.c""  
     break;
 
   case 19:
#line 375 ""hex_grammar.y""  
     {
         (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);
 
         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
 
         (yyval.re_node)->value = (int) (yyvsp[0].integer);
       }
#line 1643 ""hex_grammar.c""  
     break;
 
   case 20:
#line 383 ""hex_grammar.y""  
     {
         uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.re_node)->mask = mask;
         }
       }
#line 1667 ""hex_grammar.c""  
     break;
 
 
#line 1671 ""hex_grammar.c""  
       default: break;
     }
    
#line 404 ""hex_grammar.y""  
 ","libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule (involving hex strings) that is mishandled in the _yr_re_emit function, a different vulnerability than CVE-2017-9304."
1100,CVE-2017-9434,"  bool TestRandomPool()
 			std::cout << ""FAILED:"";
 		else
 			std::cout << ""passed:"";
		std::cout << ""  GenerateWord32 and Crop\n"";
 	}
 
 #if !defined(NO_OS_DEPENDENCE)
  bool TestRandomPool()
 			std::cout << ""FAILED:"";
 		else
 			std::cout << ""passed:"";
		std::cout << ""  GenerateWord32 and Crop\n"";
 	}
 #endif
 
  bool TestAutoSeededX917()
 		std::cout << ""FAILED:"";
 	else
 		std::cout << ""passed:"";
	std::cout << ""  GenerateWord32 and Crop\n"";
 
 	std::cout.flush();
 	return pass;
",Crypto++ (aka cryptopp) through 5.6.5 contains an out-of-bounds read vulnerability in zinflate.cpp in the Inflator filter.
1101,CVE-2017-9432,"  bool DatabaseName::read(StarZone &zone)
         }
         data.m_name=libstoff::getString(text);
         int positions[2];
        for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4));
         data.m_selection=STOFFVec2i(positions[0],positions[1]);
         m_dataList.push_back(data);
       }",Document Liberation Project libstaroffice before 2017-04-07 has an out-of-bounds write caused by a stack-based buffer overflow related to the DatabaseName::read function in lib/StarWriterStruct.cxx.
1102,CVE-2017-9304,"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define LEX_BUF_SIZE                    8192
 
 
 
 
 
#define RE_MAX_SPLIT_ID                 128

 
#define RE_MAX_STACK                    1024

 
#define RE_MAX_CODE_SIZE                32768

 
#define RE_SCAN_LIMIT                   4096

 
#define RE_MAX_FIBERS                   1024

 
#define RE_MAX_AST_LEVELS               2000

 #endif",libyara/re.c in the regexp module in YARA 3.5.0 allows remote attackers to cause a denial of service (stack consumption) via a crafted rule that is mishandled in the _yr_re_emit function.
1103,CVE-2017-9250,"  lexer_process_char_literal (parser_context_t *context_p,  
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
  if (length == 0)
  {
    has_escape = false;
  }

   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;","The lexer_process_char_literal function in jerry-core/parser/js/js-lexer.c in JerryScript 1.0 does not skip memory allocation for empty strings, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via malformed JavaScript source code, related to the jmem_heap_free_block function."
1104,CVE-2017-9242,"  static int __ip6_append_data(struct sock *sk,
 			 */
 			alloclen += sizeof(struct frag_hdr);
 
			copy = datalen - transhdrlen - fraggap;
			if (copy < 0) {
				err = -EINVAL;
				goto error;
			}
 			if (transhdrlen) {
 				skb = sock_alloc_send_skb(sk,
 						alloclen + hh_len,
  static int __ip6_append_data(struct sock *sk,
 				data += fraggap;
 				pskb_trim_unique(skb_prev, maxfraglen);
 			}
			if (copy > 0 &&
			    getfrag(from, data + transhdrlen, offset,
				    copy, fraggap, skb) < 0) {
 				err = -EFAULT;
 				kfree_skb(skb);
 				goto error;","The __ip6_append_data function in net/ipv6/ip6_output.c in the Linux kernel through 4.11.3 is too late in checking whether an overwrite of an skb data structure may occur, which allows local users to cause a denial of service (system crash) via crafted system calls."
1105,CVE-2017-9229,"  forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
     }
     else {
       if (reg->dmax != ONIG_INFINITE_DISTANCE) {
        if (p - str < reg->dmax) {
          *low = (UChar* )str;
          if (low_prev)
            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);
         }
         else {
          *low = p - reg->dmax;
          if (*low > s) {
            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,
                                                 *low, (const UChar** )low_prev);
            if (low_prev && IS_NULL(*low_prev))
              *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : s), *low);
          }
          else {
            if (low_prev)
              *low_prev = onigenc_get_prev_char_head(reg->enc,
                                                     (pprev ? pprev : str), *low);
          }
         }
       }
     }","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A SIGSEGV occurs in left_adjust_char_head() during regular expression compilation. Invalid handling of reg->dmax in forward_search_range() could result in an invalid pointer dereference, normally as an immediate denial-of-service condition."
1106,CVE-2017-9228,"  next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
     }
   }
 
  if (*state != CCS_START)
    *state = CCS_VALUE;

   *type  = CCV_CLASS;
   return 0;
 }","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write occurs in bitset_set_range() during regular expression compilation due to an uninitialized variable from an incorrect state transition. An incorrect state transition in parse_char_class() could create an execution path that leaves a critical local variable uninitialized until it's used as an index, resulting in an out-of-bounds write memory corruption."
1107,CVE-2017-9227,"  forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,
     }
     else {
       UChar *q = p + reg->dmin;

      if (q >= end) return 0;  
       while (p < q) p += enclen(reg->enc, p);
     }
   }","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in mbc_enc_len() during regular expression searching. Invalid handling of reg->dmin in forward_search_range() could result in an invalid pointer dereference, as an out-of-bounds read from a stack buffer."
1108,CVE-2017-9226,"  next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,
   switch (*state) {
   case CCS_VALUE:
     if (*type == CCV_SB) {
      if (*vs > 0xff)
          return ONIGERR_INVALID_CODE_POINT_VALUE;

       BITSET_SET_BIT(cc->bs, (int )(*vs));
     }
     else if (*type == CCV_CODE_POINT) {","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write or read occurs in next_state_val() during regular expression compilation. Octal numbers larger than 0xff are not handled correctly in fetch_token() and fetch_token_in_cc(). A malformed regular expression containing an octal number in the form of '700' would produce an invalid code point value larger than 0xff in next_state_val(), resulting in an out-of-bounds write memory corruption."
1109,CVE-2017-9224,"  match_at(regex_t* reg, const UChar* str, const UChar* end,
       break;
 
     case OP_EXACT1:  MOP_IN(OP_EXACT1);
       DATA_ENSURE(1);
       if (*p != *s) goto fail;
       p++; s++;
       MOP_OUT;
       break;
 ","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in match_at() during regular expression searching. A logical error involving order of validation and access in match_at() could result in an out-of-bounds read from a stack buffer."
1110,CVE-2017-9217,"  int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
         if (r < 0)
                 return r;
 
        if (!p->question)
                return 0;

         if (p->question->n_keys != 1)
                 return 0;
 ",systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section.
1111,CVE-2017-9211,"  static int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)
 	return 0;
 }
 
static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,
				     const u8 *key, unsigned int keylen)
{
	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
	u8 *buffer, *alignbuffer;
	unsigned long absize;
	int ret;

	absize = keylen + alignmask;
	buffer = kmalloc(absize, GFP_ATOMIC);
	if (!buffer)
		return -ENOMEM;

	alignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);
	memcpy(alignbuffer, key, keylen);
	ret = cipher->setkey(tfm, alignbuffer, keylen);
	kzfree(buffer);
	return ret;
}

static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
			   unsigned int keylen)
{
	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
	unsigned long alignmask = crypto_skcipher_alignmask(tfm);

	if (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {
		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
		return -EINVAL;
	}

	if ((unsigned long)key & alignmask)
		return skcipher_setkey_unaligned(tfm, key, keylen);

	return cipher->setkey(tfm, key, keylen);
}

 static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)
 {
 	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
  static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
 	    tfm->__crt_alg->cra_type == &crypto_givcipher_type)
 		return crypto_init_skcipher_ops_ablkcipher(tfm);
 
	skcipher->setkey = skcipher_setkey;
 	skcipher->encrypt = alg->encrypt;
 	skcipher->decrypt = alg->decrypt;
 	skcipher->ivsize = alg->ivsize;","The crypto_skcipher_init_tfm function in crypto/skcipher.c in the Linux kernel through 4.11.2 relies on a setkey function that lacks a key-size check, which allows local users to cause a denial of service (NULL pointer dereference) via a crafted application."
1112,CVE-2017-9207,"  struct iw_exif_state {
 	size_t d_len;
 };
 
static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)
{
	if(e->d_len<2 || pos>e->d_len-2) return 0;
	return iw_get_ui16_e(&e->d[pos], e->endian);
}

static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)
{
	if(e->d_len<4 || pos>e->d_len-4) return 0;
	return iw_get_ui32_e(&e->d[pos], e->endian);
}

  
  
 static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,
  static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,
 	unsigned int field_type;
 	unsigned int value_count;
 
	field_type = get_exif_ui16(e, tag_pos+2);
	value_count = get_exif_ui32(e, tag_pos+4);
 
 	if(value_count!=1) return 0;
 
 	if(field_type==3) {  
		*pv = get_exif_ui16(e, tag_pos+8);
 		return 1;
 	}
 	else if(field_type==4) {  
		*pv = get_exif_ui32(e, tag_pos+8);
 		return 1;
 	}
 
  static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,
 	unsigned int value_pos;
 	unsigned int numer, denom;
 
	field_type = get_exif_ui16(e, tag_pos+2);
	value_count = get_exif_ui32(e, tag_pos+4);
 
 	if(value_count!=1) return 0;
 
  static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,
 	 
 	 
 
	value_pos = get_exif_ui32(e, tag_pos+8);
 	if(value_pos > e->d_len-8) return 0;
 
 	 
	numer = get_exif_ui32(e, value_pos);
	denom = get_exif_ui32(e, value_pos+4);
 	if(denom==0) return 0;
 
 	*pv = ((double)numer)/denom;
  static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,
 	unsigned int v;
 	double v_dbl;
 
	if(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;
 
	tag_count = get_exif_ui16(e, ifd);
 	if(tag_count>1000) return;  
 
 	for(i=0;i<tag_count;i++) {
 		tag_pos = ifd+2+i*12;
 		if(tag_pos+12 > e->d_len) return;  
		tag_id = get_exif_ui16(e, tag_pos);
 
 		switch(tag_id) {
 		case 274:  
  static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
 
 	e.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;
 
	ifd = get_exif_ui32(&e, 4);
 
 	iwjpeg_scan_exif_ifd(rctx,&e,ifd);
 }","The iw_get_ui16be function in imagew-util.c:422:24 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted image, related to imagew-jpeg.c."
1113,CVE-2017-9203,"  static int bmpr_read_rle(struct iwbmprcontext *rctx)
 		!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))
 	{
 		iw_set_error(rctx->ctx,""Compression type incompatible with image type"");
		goto done;
 	}
 
 	if(rctx->topdown) {
 		 
 		iw_set_error(rctx->ctx,""Compression not allowed with top-down images"");
		goto done;
 	}
 
 	 ","imagew-main.c:960:12 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (buffer underflow) via a crafted image, related to imagew-bmp.c."
1114,CVE-2017-9202,"  IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,
 {
 	*px = 1.0;
 	*py = 1.0;
	*pcode = IW_DENSITY_UNKNOWN;

	if(ctx->img1.density_code==IW_DENSITY_UNKNOWN) {
		return 0;
 	}
	if(!iw_is_valid_density(ctx->img1.density_x, ctx->img1.density_y,
		ctx->img1.density_code))
	{
		return 0;
	}
	*px = ctx->img1.density_x;
	*py = ctx->img1.density_y;
	*pcode = ctx->img1.density_code;
	return 1;
 }
 
 IW_IMPL(void) iw_set_output_density(struct iw_context *ctx,","imagew-cmd.c:854:45 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (divide-by-zero error) via a crafted image, related to imagew-api.c."
1115,CVE-2017-9150,"  static const char *const bpf_jmp_string[16] = {
 	[BPF_EXIT >> 4] = ""exit"",
 };
 
static void print_bpf_insn(const struct bpf_verifier_env *env,
			   const struct bpf_insn *insn)
 {
 	u8 class = BPF_CLASS(insn->code);
 
  static void print_bpf_insn(struct bpf_insn *insn)
 				insn->code,
 				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
 				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM &&
			   BPF_SIZE(insn->code) == BPF_DW) {
			 
			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;

			if (map_ptr && !env->allow_ptr_leaks)
				imm = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
				insn->dst_reg, (unsigned long long)imm);
 		} else {
 			verbose(""BUG_ld_%02x\n"", insn->code);
 			return;
  static int do_check(struct bpf_verifier_env *env)
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);","The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls."
1116,CVE-2017-9143,"  static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)
     pixels=(const unsigned char *) ReadBlobStream(image,length,
       GetQuantumPixels(quantum_info),&count);
     if (count != (ssize_t) length)
      {
        quantum_info=DestroyQuantumInfo(quantum_info);
        ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
      }
     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
       quantum_type,pixels,exception);
     (void) ReadBlobStream(image,(size_t) (-(ssize_t) length) & 0x01,","In ImageMagick 7.0.5-5, the ReadARTImage function in coders/art.c allows attackers to cause a denial of service (memory leak) via a crafted .art file."
1117,CVE-2017-9142,"  static Image *ReadOneJNGImage(MngInfo *mng_info,
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Copying JDAT chunk data to color_blob."");
 
         if (length != 0)
          {
            (void) WriteBlob(color_image,length,chunk);
            chunk=(unsigned char *) RelinquishMagickMemory(chunk);
          }
 
         continue;
       }","In ImageMagick 7.0.5-7 Q16, a crafted file could trigger an assertion failure in the WriteBlob function in MagickCore/blob.c because of missing checks in the ReadOneJNGImage function in coders/png.c."
1118,CVE-2017-9141,"  static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)
    
  if (ReadDDSInfo(image, &dds_info) != MagickTrue)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)
     cubemap = MagickTrue;
  static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if (volume)
     num_images = dds_info.depth;
 
  if (num_images < 1)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

   for (n = 0; n < num_images; n++)
   {
     if (n != 0)","In ImageMagick 7.0.5-7 Q16, a crafted file could trigger an assertion failure in the ResetImageProfileIterator function in MagickCore/profile.c because of missing checks in the ReadDDSImage function in coders/dds.c."
1119,CVE-2017-9098,"  static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) ResetMagickMemory(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t","ImageMagick before 7.0.5-2 and GraphicsMagick before 1.3.24 use uninitialized memory in the RLE decoder, allowing an attacker to leak sensitive information from process memory space, as demonstrated by remote attacks against ImageMagick code in a long-running server process that converts image data on behalf of multiple users. This is caused by a missing initialization step in the ReadRLEImage function in coders/rle.c."
1120,CVE-2017-9077,"  static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,
 		newsk->sk_backlog_rcv = dccp_v4_do_rcv;
 		newnp->pktoptions  = NULL;
 		newnp->opt	   = NULL;
		newnp->ipv6_mc_list = NULL;
		newnp->ipv6_ac_list = NULL;
		newnp->ipv6_fl_list = NULL;
 		newnp->mcast_oif   = inet6_iif(skb);
 		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
 
  static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,
 	 
 	newnp->rxopt.all = np->rxopt.all;
 
	newnp->ipv6_mc_list = NULL;
	newnp->ipv6_ac_list = NULL;
	newnp->ipv6_fl_list = NULL;
 	newnp->pktoptions = NULL;
 	newnp->opt	  = NULL;
 	newnp->mcast_oif  = inet6_iif(skb);","The tcp_v6_syn_recv_sock function in net/ipv6/tcp_ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890."
1121,CVE-2017-9075,"  static struct sock *sctp_v6_create_accept_sk(struct sock *sk,
 	newnp = inet6_sk(newsk);
 
 	memcpy(newnp, np, sizeof(struct ipv6_pinfo));
	newnp->ipv6_mc_list = NULL;
	newnp->ipv6_ac_list = NULL;
	newnp->ipv6_fl_list = NULL;
 
 	rcu_read_lock();
 	opt = rcu_dereference(np->opt);","The sctp_v6_create_accept_sk function in net/sctp/ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890."
1122,CVE-2017-9074,"  static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,
 
 		if (udpfrag) {
 			unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
			if (unfrag_ip6hlen < 0)
				return ERR_PTR(unfrag_ip6hlen);
 			fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
 			fptr->frag_off = htons(offset);
 			if (skb->next)","The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls."
1123,CVE-2017-9059,"  lockd(void *vrqstp)
 {
 	int		err = 0;
 	struct svc_rqst *rqstp = vrqstp;
	struct net *net = &init_net;
	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	 
 	set_freezable();
  lockd(void *vrqstp)
 	if (nlmsvc_ops)
 		nlmsvc_invalidate_all();
 	nlm_shutdown_hosts();
	cancel_delayed_work_sync(&ln->grace_period_end);
	locks_end_grace(&ln->lockd_manager);
 	return 0;
 }
 
  static void lockd_down_net(struct svc_serv *serv, struct net *net)
 	if (ln->nlmsvc_users) {
 		if (--ln->nlmsvc_users == 0) {
 			nlm_shutdown_hosts_net(net);
 			svc_shutdown_net(serv, net);
 			dprintk(""lockd_down_net: per-net data destroyed; net=%p\n"", net);
 		}","The NFSv4 implementation in the Linux kernel through 4.11.1 allows local users to cause a denial of service (resource consumption) by leveraging improper channel callback shutdown when unmounting an NFSv4 filesystem, aka a *module reference and kernel daemon* leak."
1124,CVE-2017-9051,"  static int nsv_read_chunk(AVFormatContext *s, int fill_header)
     uint32_t vsize;
     uint16_t asize;
     uint16_t auxsize;
    int ret;
 
     if (nsv->ahead[0].data || nsv->ahead[1].data)
         return 0;  
  static int nsv_read_chunk(AVFormatContext *s, int fill_header)
     if (vsize && st[NSV_ST_VIDEO]) {
         nst = st[NSV_ST_VIDEO]->priv_data;
         pkt = &nsv->ahead[NSV_ST_VIDEO];
        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)
            return ret;
         pkt->stream_index = st[NSV_ST_VIDEO]->index; 
         pkt->dts = nst->frame_offset;
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0;  
  static int nsv_read_chunk(AVFormatContext *s, int fill_header)
                        bps, channels, samplerate);
             }
         }
        if ((ret = av_get_packet(pb, pkt, asize)) < 0)
            return ret;
         pkt->stream_index = st[NSV_ST_AUDIO]->index; 
         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0;  
         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {",libav before 12.1 is vulnerable to an invalid read of size 1 due to NULL pointer dereferencing in the nsv_read_chunk function in libavformat/nsvdec.c.
1125,CVE-2017-8929,"  void yr_arena_destroy(
  
  
  
 
  
  
 ",The sized_string_cmp function in libyara/sizedstr.c in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule.
1126,CVE-2017-8925,"  static int omninet_port_remove(struct usb_serial_port *port)
 
 static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	return usb_serial_generic_open(tty, port);
 }
 ",The omninet_open function in drivers/usb/serial/omninet.c in the Linux kernel before 4.10.4 allows local users to cause a denial of service (tty exhaustion) by leveraging reference count mishandling.
1127,CVE-2017-8924,"  static void edge_bulk_in_callback(struct urb *urb)
 
 	port_number = edge_port->port->port_number;
 
	if (urb->actual_length > 0 && edge_port->lsr_event) {
 		edge_port->lsr_event = 0;
 		dev_dbg(dev, ""%s ===== Port %u LSR Status = %02x, Data = %02x ======\n"",
 			__func__, port_number, edge_port->lsr_mask, *data);",The edge_bulk_in_callback function in drivers/usb/serial/io_ti.c in the Linux kernel before 4.10.4 allows local users to obtain sensitive information (in the dmesg ringbuffer and syslog) from uninitialized kernel memory by using a crafted USB device (posing as an io_ti USB serial device) to trigger an integer underflow.
1128,CVE-2017-8891,"  bounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,
     this->size_callback = size_callback;
     buffer_position = 0;
     byte_position = 0;
    byte_bound = 0x7FFFFFFF;
     num_bytes_attempted_to_write = 0;
     set_bound(0);
 }
  void bounded_iostream::close() {
     parent->Close();
 }
 
uint32_t bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {
      
     std::pair<unsigned int, Sirikata::JpegError> retval;
     if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {",Dropbox Lepton 1.2.1 allows DoS (SEGV and application crash) via a malformed lepton file because the code does not ensure setup of a correct number of threads.
1129,CVE-2017-8890,"  struct sock *inet_csk_clone_lock(const struct sock *sk,
 		 
 		sock_reset_flag(newsk, SOCK_RCU_FREE);
 
		inet_sk(newsk)->mc_list = NULL;

 		newsk->sk_mark = inet_rsk(req)->ir_mark;
 		atomic64_set(&newsk->sk_cookie,
 			     atomic64_read(&inet_rsk(req)->ir_cookie));",The inet_csk_clone_lock function in net/ipv4/inet_connection_sock.c in the Linux kernel through 4.10.15 allows attackers to cause a denial of service (double free) or possibly have unspecified other impact by leveraging use of the accept system call.
1130,CVE-2017-8831,"  int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
 	msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);
 	msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);
 	msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);
	memcpy(msg, &msg_tmp, sizeof(*msg));
 
 	 
 	 
 	if (peekonly) {
 		goto peekout;
 	}
 
  int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
 		space_rem = bus->m_dwSizeGetRing - curr_grp;
 
 		if (space_rem < sizeof(*msg)) {
 			if (buf)
 				memcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -
 					space_rem, buf_size);
 
 		} else if (space_rem == sizeof(*msg)) {
 			if (buf)
 				memcpy_fromio(buf, bus->m_pdwGetRing, buf_size);
 		} else {
 			 
 			if (buf) {
 				memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +
 					sizeof(*msg), space_rem - sizeof(*msg));
  int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
 
 	} else {
 		 
 		if (buf)
 			memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
 				buf_size);
 	}
 
 	 
 	saa7164_writel(bus->m_dwGetReadPos, new_grp);","The saa7164_bus_get function in drivers/media/pci/saa7164/saa7164-bus.c in the Linux kernel through 4.11.5 allows local users to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact by changing a certain sequence-number value, aka a *double fetch* vulnerability."
1131,CVE-2017-8825,"  static int mailimf_group_parse(const char * message, size_t length,
   struct mailimf_group * group;
   int r;
   int res;
  clist * list;
 
   cur_token = * indx;
 
  static int mailimf_group_parse(const char * message, size_t length,
       res = r;
       goto free_display_name;
     }
    list = clist_new();
    if (list == NULL) {
      res = MAILIMF_ERROR_MEMORY;
      goto free_display_name;
    }
    mailbox_list = mailimf_mailbox_list_new(list);
    if (mailbox_list == NULL) {
      res = MAILIMF_ERROR_MEMORY;
      clist_free(list);
      goto free_display_name;
    }
     break;
   default:
     res = r;","A null dereference vulnerability has been found in the MIME handling component of LibEtPan before 1.8, as used in MailCore and MailCore 2. A crash can occur in low-level/imf/mailimf.c during a failed parse of a Cc header containing multiple e-mail addresses."
1132,CVE-2017-8807,"  vbf_stp_error(struct worker *wrk, struct busyobj *bo)
 		l = ll;
 		if (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)
 			break;
		if (l > ll)
			l = ll;
 		memcpy(ptr, VSB_data(synth_body) + o, l);
 		VFP_Extend(bo->vfc, l);
 		ll -= l;",vbf_stp_error in bin/varnishd/cache/cache_fetch.c in Varnish HTTP Cache 4.1.x before 4.1.9 and 5.x before 5.2.1 allows remote attackers to obtain sensitive information from process memory because a VFP_GetStorage buffer is larger than intended in certain circumstances involving -sfile Stevedore transient objects.
1133,CVE-2017-8797,"  nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)
 		return NULL;
 	}
 
	if (layout_type >= LAYOUT_TYPE_MAX ||
	    !(exp->ex_layout_types & (1 << layout_type))) {
 		dprintk(""%s: layout type %d not supported\n"",
 			__func__, layout_type);
 		return NULL;","The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system."
1134,CVE-2017-8327," 
 typedef double iw_tmpsample;
 
 #ifdef IW_64BIT
#define IW_DEFAULT_MAX_DIMENSION 40000
#define IW_DEFAULT_MAX_MALLOC 2000000000
 #else
 #define IW_DEFAULT_MAX_DIMENSION 40000  
 #define IW_DEFAULT_MAX_MALLOC 2000000000",The bmpr_read_uncompressed function in imagew-bmp.c in libimageworsener.a in ImageWorsener before 1.3.1 allows remote attackers to cause a denial of service (memory consumption) via a crafted image.
1135,CVE-2017-8326,"  static int find_high_bit(unsigned int x)
 {
 	int i;
 	for(i=31;i>=0;i--) {
		if(x&(1U<<(unsigned int)i)) return i;
 	}
 	return 0;
 }
 static int find_low_bit(unsigned int x)
 {
 	int i;
 	for(i=0;i<=31;i++) {
		if(x&(1U<<(unsigned int)i)) return i;
 	}
 	return 0;
 }","libimageworsener.a in ImageWorsener before 1.3.1 has *left shift cannot be represented in type int* undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c."
1136,CVE-2017-8294,"  int yr_execute_code(
           (uint8_t*) r2.re->code,
           (uint8_t*) r1.ss->c_string,
           r1.ss->length,
          0,
           r2.re->flags | RE_FLAGS_SCAN,
           NULL,
           NULL) >= 0;",libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.
1137,CVE-2017-8284,"  static target_ulong disas_insn(CPUX86State *env, DisasContext *s,
     s->vex_l = 0;
     s->vex_v = 0;
  next_byte:
     
    if (s->pc - pc_start > 14) {
        goto illegal_op;
    }
     b = cpu_ldub_code(env, s->pc);
     s->pc++;
      ","** DISPUTED ** The disas_insn function in target/i386/translate.c in QEMU before 2.9.0, when TCG mode without hardware acceleration is used, does not limit the instruction size, which allows local users to gain privileges by creating a modified basic block that injects code into a setuid program, as demonstrated by procmail. NOTE: the vendor has stated *this bug does not violate any security guarantees QEMU makes.*"
1138,CVE-2017-8073,"  irc_ctcp_dcc_filename_without_quotes (const char *filename)
     int length;
 
     length = strlen (filename);
    if (length > 1)
     {
         if ((filename[0] == '\""') && (filename[length - 1] == '\""'))
             return weechat_strndup (filename + 1, length - 2);","WeeChat before 1.7.1 allows a remote crash by sending a filename via DCC to the IRC plugin. This occurs in the irc_ctcp_dcc_filename_without_quotes function during quote removal, with a buffer overflow."
1139,CVE-2017-8072,"  static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 
 exit:
 	mutex_unlock(&dev->lock);
	return ret < 0 ? ret : -EIO;
 }
 
 static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)","The cp2112_gpio_direction_input function in drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 does not have the expected EIO error status for a zero-length report, which allows local users to have an unspecified impact via unknown vectors."
1140,CVE-2017-8071,"  struct cp2112_device {
 	atomic_t xfer_avail;
 	struct gpio_chip gc;
 	u8 *in_out_buffer;
	struct mutex lock;
 
 	struct gpio_desc *desc[8];
 	bool gpio_poll;
  static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev->hdev;
 	u8 *buf = dev->in_out_buffer;
 	int ret;
 
	mutex_lock(&dev->lock);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
  static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 	ret = 0;
 
 exit:
	mutex_unlock(&dev->lock);
 	return ret <= 0 ? ret : -EIO;
 }
 
  static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev->hdev;
 	u8 *buf = dev->in_out_buffer;
 	int ret;
 
	mutex_lock(&dev->lock);
 
 	buf[0] = CP2112_GPIO_SET;
 	buf[1] = value ? 0xff : 0;
  static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 	if (ret < 0)
 		hid_err(hdev, ""error setting GPIO values: %d\n"", ret);
 
	mutex_unlock(&dev->lock);
 }
 
 static int cp2112_gpio_get_all(struct gpio_chip *chip)
 {
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev->hdev;
 	u8 *buf = dev->in_out_buffer;
 	int ret;
 
	mutex_lock(&dev->lock);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
 				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
  static int cp2112_gpio_get_all(struct gpio_chip *chip)
 	ret = buf[1];
 
 exit:
	mutex_unlock(&dev->lock);
 
 	return ret;
 }
  static int cp2112_gpio_direction_output(struct gpio_chip *chip,
 	struct cp2112_device *dev = gpiochip_get_data(chip);
 	struct hid_device *hdev = dev->hdev;
 	u8 *buf = dev->in_out_buffer;
 	int ret;
 
	mutex_lock(&dev->lock);
 
 	ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,
 				 CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,
  static int cp2112_gpio_direction_output(struct gpio_chip *chip,
 		goto fail;
 	}
 
	mutex_unlock(&dev->lock);
 
 	/*
 	 * Set gpio value when output direction is already set,
  static int cp2112_gpio_direction_output(struct gpio_chip *chip,
 	return 0;
 
 fail:
	mutex_unlock(&dev->lock);
 	return ret < 0 ? ret : -EIO;
 }
 
  static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	if (!dev->in_out_buffer)
 		return -ENOMEM;
 
	mutex_init(&dev->lock);
 
 	ret = hid_parse(hdev);
 	if (ret) {","drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors."
1141,CVE-2017-8070,"  static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 	struct net_device *netdev;
 	struct catc *catc;
 	u8 broadcast[ETH_ALEN];
	int pktsz, ret;
 
 	if (usb_set_interface(usbdev,
 			intf->altsetting->desc.bInterfaceNumber, 1)) {
  static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
                 catc->irq_buf, 2, catc_irq_done, catc, 1);
 
 	if (!catc->is_f5u011) {
		u32 *buf;
		int i;

 		dev_dbg(dev, ""Checking memory size\n"");
 
		buf = kmalloc(4, GFP_KERNEL);
		if (!buf) {
			ret = -ENOMEM;
			goto fail_free;
		}

		*buf = 0x12345678;
		catc_write_mem(catc, 0x7a80, buf, 4);
		*buf = 0x87654321;
		catc_write_mem(catc, 0xfa80, buf, 4);
		catc_read_mem(catc, 0x7a80, buf, 4);
 	  
		switch (*buf) {
 		case 0x12345678:
 			catc_set_reg(catc, TxBufCount, 8);
 			catc_set_reg(catc, RxBufCount, 32);
  static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 			dev_dbg(dev, ""32k Memory\n"");
 			break;
 		}

		kfree(buf);
 	  
 		dev_dbg(dev, ""Getting MAC from SEEROM.\n"");
 	  ","drivers/net/usb/catc.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1142,CVE-2017-8069,"  static const char driver_name [] = ""rtl8150"";
 */
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
	void *buf;
	int ret;

	buf = kmalloc(size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
			      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
			      indx, 0, buf, size, 500);
	if (ret > 0 && ret <= size)
		memcpy(data, buf, ret);
	kfree(buf);
	return ret;
 }
 
static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)
 {
	void *buf;
	int ret;

	buf = kmemdup(data, size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

	ret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
			      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
			      indx, 0, buf, size, 500);
	kfree(buf);
	return ret;
 }
 
 static void async_set_reg_cb(struct urb *urb)","drivers/net/usb/rtl8150.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1143,CVE-2017-8068,"  static void async_ctrl_callback(struct urb *urb)
 
 static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
 {
	u8 *buf;
 	int ret;
 
	buf = kmalloc(size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

 	ret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
			      indx, buf, size, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
	else if (ret <= size)
		memcpy(data, buf, ret);
	kfree(buf);
 	return ret;
 }
 
static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,
			 const void *data)
 {
	u8 *buf;
 	int ret;
 
	buf = kmemdup(data, size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
			      indx, buf, size, 100);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
	kfree(buf);
 	return ret;
 }
 
 static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
	u8 *buf;
 	int ret;
 
	buf = kmemdup(&data, 1, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, buf, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
	kfree(buf);
 	return ret;
 }
 ","drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1144,CVE-2017-8067,"  static int put_chars(u32 vtermno, const char *buf, int count)
 {
 	struct port *port;
 	struct scatterlist sg[1];
	void *data;
	int ret;
 
 	if (unlikely(early_put_chars))
 		return early_put_chars(vtermno, buf, count);
  static int put_chars(u32 vtermno, const char *buf, int count)
 	if (!port)
 		return -EPIPE;
 
	data = kmemdup(buf, count, GFP_ATOMIC);
	if (!data)
		return -ENOMEM;

	sg_init_one(sg, data, count);
	ret = __send_to_port(port, sg, 1, count, data, false);
	kfree(data);
	return ret;
 }
 
 /*","drivers/char/virtio_console.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1145,CVE-2017-8066,"  static int gs_usb_probe(struct usb_interface *intf,
 	struct gs_usb *dev;
 	int rc = -ENOMEM;
 	unsigned int icount, i;
	struct gs_host_config *hconf;
	struct gs_device_config *dconf;

	hconf = kmalloc(sizeof(*hconf), GFP_KERNEL);
	if (!hconf)
		return -ENOMEM;

	hconf->byte_order = 0x0000beef;
 
 	 
 	rc = usb_control_msg(interface_to_usbdev(intf),
  static int gs_usb_probe(struct usb_interface *intf,
 			     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 			     1,
 			     intf->altsetting[0].desc.bInterfaceNumber,
			     hconf,
			     sizeof(*hconf),
 			     1000);
 
	kfree(hconf);

 	if (rc < 0) {
 		dev_err(&intf->dev, ""Couldn't send data format (err=%d)\n"",
 			rc);
 		return rc;
 	}
 
	dconf = kmalloc(sizeof(*dconf), GFP_KERNEL);
	if (!dconf)
		return -ENOMEM;

 	 
 	rc = usb_control_msg(interface_to_usbdev(intf),
 			     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),
 			     GS_USB_BREQ_DEVICE_CONFIG,
 			     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 			     1,
 			     intf->altsetting[0].desc.bInterfaceNumber,
			     dconf,
			     sizeof(*dconf),
 			     1000);
 	if (rc < 0) {
 		dev_err(&intf->dev, ""Couldn't get device config: (err=%d)\n"",
 			rc);
		kfree(dconf);
 		return rc;
 	}
 
	icount = dconf->icount + 1;
 	dev_info(&intf->dev, ""Configuring for %d interfaces\n"", icount);
 
 	if (icount > GS_MAX_INTF) {
 		dev_err(&intf->dev,
 			""Driver cannot handle more that %d CAN interfaces\n"",
 			GS_MAX_INTF);
		kfree(dconf);
 		return -EINVAL;
 	}
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
	if (!dev) {
		kfree(dconf);
 		return -ENOMEM;
	}

 	init_usb_anchor(&dev->rx_submitted);
 
 	atomic_set(&dev->active_channels, 0);
  static int gs_usb_probe(struct usb_interface *intf,
 	dev->udev = interface_to_usbdev(intf);
 
 	for (i = 0; i < icount; i++) {
		dev->canch[i] = gs_make_candev(i, intf, dconf);
 		if (IS_ERR_OR_NULL(dev->canch[i])) {
 			 
 			rc = PTR_ERR(dev->canch[i]);
  static int gs_usb_probe(struct usb_interface *intf,
 				gs_destroy_candev(dev->canch[i]);
 
 			usb_kill_anchored_urbs(&dev->rx_submitted);
			kfree(dconf);
 			kfree(dev);
 			return rc;
 		}
 		dev->canch[i]->parent = dev;
 	}
 
	kfree(dconf);

 	return 0;
 }
 ","drivers/net/can/usb/gs_usb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.2 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1146,CVE-2017-8065,"  struct crypto_rfc4309_req_ctx {
 
 struct crypto_ccm_req_priv_ctx {
 	u8 odata[16];
	u8 idata[16];
 	u8 auth_tag[16];
 	u32 flags;
 	struct scatterlist src[3];
  static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,
 	AHASH_REQUEST_ON_STACK(ahreq, ctx->mac);
 	unsigned int assoclen = req->assoclen;
 	struct scatterlist sg[3];
	u8 *odata = pctx->odata;
	u8 *idata = pctx->idata;
 	int ilen, err;
 
 	 ","crypto/ccm.c in the Linux kernel 4.9.x and 4.10.x through 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1147,CVE-2017-8064,"  EXPORT_SYMBOL(dvb_usbv2_probe);
 void dvb_usbv2_disconnect(struct usb_interface *intf)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
	const char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);
	const char *drvname = d->name;
 
 	dev_dbg(&d->udev->dev, ""%s: bInterfaceNumber=%d\n"", __func__,
 			intf->cur_altsetting->desc.bInterfaceNumber);
  void dvb_usbv2_disconnect(struct usb_interface *intf)
 
 	dvb_usbv2_exit(d);
 
	pr_info(""%s: '%s:%s' successfully deinitialized and disconnected\n"",
		KBUILD_MODNAME, drvname, devname);
	kfree(devname);
 }
 EXPORT_SYMBOL(dvb_usbv2_disconnect);
 ","drivers/media/usb/dvb-usb-v2/dvb_usb_core.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1148,CVE-2017-8063,"  static int cxusb_ctrl_msg(struct dvb_usb_device *d,
 			  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)
 {
 	struct cxusb_state *st = d->priv;
	int ret;
 
 	if (1 + wlen > MAX_XFER_SIZE) {
 		warn(""i2c wr: len=%d is too big!\n"", wlen);
 		return -EOPNOTSUPP;
 	}
 
	if (rlen > MAX_XFER_SIZE) {
		warn(""i2c rd: len=%d is too big!\n"", rlen);
		return -EOPNOTSUPP;
	}
 
 	mutex_lock(&d->data_mutex);
 	st->data[0] = cmd;
 	memcpy(&st->data[1], wbuf, wlen);
	ret = dvb_usb_generic_rw(d, st->data, 1 + wlen, st->data, rlen, 0);
	if (!ret && rbuf && rlen)
		memcpy(rbuf, st->data, rlen);
 
 	mutex_unlock(&d->data_mutex);
 	return ret;","drivers/media/usb/dvb-usb/cxusb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1149,CVE-2017-8062," 
 struct dw2102_state {
 	u8 initialized;
 	u8 last_lock;
	u8 data[MAX_XFER_SIZE + 4];
 	struct i2c_client *i2c_client_demod;
 	struct i2c_client *i2c_client_tuner;
 
  static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 								int num)
 {
 	struct dvb_usb_device *d = i2c_get_adapdata(adap);
	struct dw2102_state *state;
 
 	if (!d)
 		return -ENODEV;

	state = d->priv;

 	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
 		return -EAGAIN;
	if (mutex_lock_interruptible(&d->data_mutex) < 0) {
		mutex_unlock(&d->i2c_mutex);
		return -EAGAIN;
	}
 
 	switch (num) {
 	case 1:
 		switch (msg[0].addr) {
 		case SU3000_STREAM_CTRL:
			state->data[0] = msg[0].buf[0] + 0x36;
			state->data[1] = 3;
			state->data[2] = 0;
			if (dvb_usb_generic_rw(d, state->data, 3,
					state->data, 0, 0) < 0)
 				err(""i2c transfer failed."");
 			break;
 		case DW2102_RC_QUERY:
			state->data[0] = 0x10;
			if (dvb_usb_generic_rw(d, state->data, 1,
					state->data, 2, 0) < 0)
 				err(""i2c transfer failed."");
			msg[0].buf[1] = state->data[0];
			msg[0].buf[0] = state->data[1];
 			break;
 		default:
 			 
			state->data[0] = 0x08;
			state->data[1] = msg[0].addr;
			state->data[2] = msg[0].len;
 
			memcpy(&state->data[3], msg[0].buf, msg[0].len);
 
			if (dvb_usb_generic_rw(d, state->data, msg[0].len + 3,
						state->data, 1, 0) < 0)
 				err(""i2c transfer failed."");
 
 		}
 		break;
 	case 2:
 		 
		state->data[0] = 0x09;
		state->data[1] = msg[0].len;
		state->data[2] = msg[1].len;
		state->data[3] = msg[0].addr;
		memcpy(&state->data[4], msg[0].buf, msg[0].len);

		if (dvb_usb_generic_rw(d, state->data, msg[0].len + 4,
					state->data, msg[1].len + 1, 0) < 0)
 			err(""i2c transfer failed."");
 
		memcpy(msg[1].buf, &state->data[1], msg[1].len);
 		break;
 	default:
 		warn(""more than 2 i2c messages at a time is not handled yet."");
 		break;
 	}
	mutex_unlock(&d->data_mutex);
 	mutex_unlock(&d->i2c_mutex);
 	return num;
 }
  static int su3000_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)
 static int su3000_power_ctrl(struct dvb_usb_device *d, int i)
 {
 	struct dw2102_state *state = (struct dw2102_state *)d->priv;
	int ret = 0;
 
 	info(""%s: %d, initialized %d"", __func__, i, state->initialized);
 
 	if (i && !state->initialized) {
		mutex_lock(&d->data_mutex);

		state->data[0] = 0xde;
		state->data[1] = 0;

 		state->initialized = 1;
 		 
		ret = dvb_usb_generic_rw(d, state->data, 2, NULL, 0, 0);
		mutex_unlock(&d->data_mutex);
 	}
 
	return ret;
 }
 
 static int su3000_read_mac_address(struct dvb_usb_device *d, u8 mac[6])
  static int prof_7500_frontend_attach(struct dvb_usb_adapter *d)
 	return 0;
 }
 
static int su3000_frontend_attach(struct dvb_usb_adapter *adap)
 {
	struct dvb_usb_device *d = adap->dev;
	struct dw2102_state *state = d->priv;

	mutex_lock(&d->data_mutex);

	state->data[0] = 0xe;
	state->data[1] = 0x80;
	state->data[2] = 0;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0xe;
	state->data[1] = 0x02;
	state->data[2] = 1;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 	msleep(300);
 
	state->data[0] = 0xe;
	state->data[1] = 0x83;
	state->data[2] = 0;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0xe;
	state->data[1] = 0x83;
	state->data[2] = 1;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0x51;
 
	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
 		err(""command 0x51 transfer failed."");
 
	mutex_unlock(&d->data_mutex);

	adap->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,
					&d->i2c_adap);
	if (adap->fe_adap[0].fe == NULL)
 		return -EIO;
 
	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
 				&dw2104_ts2020_config,
				&d->i2c_adap)) {
 		info(""Attached DS3000/TS2020!"");
 		return 0;
 	}
  static int su3000_frontend_attach(struct dvb_usb_adapter *d)
 	return -EIO;
 }
 
static int t220_frontend_attach(struct dvb_usb_adapter *adap)
 {
	struct dvb_usb_device *d = adap->dev;
	struct dw2102_state *state = d->priv;

	mutex_lock(&d->data_mutex);
 
	state->data[0] = 0xe;
	state->data[1] = 0x87;
	state->data[2] = 0x0;

	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0xe;
	state->data[1] = 0x86;
	state->data[2] = 1;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0xe;
	state->data[1] = 0x80;
	state->data[2] = 0;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
 	msleep(50);
 
	state->data[0] = 0xe;
	state->data[1] = 0x80;
	state->data[2] = 1;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0x51;
 
	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
 		err(""command 0x51 transfer failed."");
 
	mutex_unlock(&d->data_mutex);

	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
					&d->i2c_adap, NULL);
	if (adap->fe_adap[0].fe != NULL) {
		if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
					&d->i2c_adap, &tda18271_config)) {
 			info(""Attached TDA18271HD/CXD2820R!"");
 			return 0;
 		}
  static int t220_frontend_attach(struct dvb_usb_adapter *d)
 	return -EIO;
 }
 
static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
 {
	struct dvb_usb_device *d = adap->dev;
	struct dw2102_state *state = d->priv;

	mutex_lock(&d->data_mutex);
 
	state->data[0] = 0x51;

	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
 		err(""command 0x51 transfer failed."");
 
	mutex_unlock(&d->data_mutex);
 
	adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
					&s421_m88rs2000_config,
					&d->i2c_adap);

	if (adap->fe_adap[0].fe == NULL)
 		return -EIO;
 
	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
 				&dw2104_ts2020_config,
				&d->i2c_adap)) {
 		info(""Attached RS2000/TS2020!"");
 		return 0;
 	}
  static int tt_s2_4600_frontend_attach(struct dvb_usb_adapter *adap)
 {
 	struct dvb_usb_device *d = adap->dev;
 	struct dw2102_state *state = d->priv;
 	struct i2c_adapter *i2c_adapter;
 	struct i2c_client *client;
 	struct i2c_board_info board_info;
 	struct m88ds3103_platform_data m88ds3103_pdata = {};
 	struct ts2020_config ts2020_config = {};
 
	mutex_lock(&d->data_mutex);

	state->data[0] = 0xe;
	state->data[1] = 0x80;
	state->data[2] = 0x0;

	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0xe;
	state->data[1] = 0x02;
	state->data[2] = 1;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 	msleep(300);
 
	state->data[0] = 0xe;
	state->data[1] = 0x83;
	state->data[2] = 0;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0xe;
	state->data[1] = 0x83;
	state->data[2] = 1;
 
	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
 		err(""command 0x0e transfer failed."");
 
	state->data[0] = 0x51;
 
	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
 		err(""command 0x51 transfer failed."");
 
	mutex_unlock(&d->data_mutex);

 	 
 	m88ds3103_pdata.clk = 27000000;
 	m88ds3103_pdata.i2c_wr_max = 33;","drivers/media/usb/dvb-usb/dw2102.c in the Linux kernel 4.9.x and 4.10.x before 4.10.4 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1150,CVE-2017-8061,"  static int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 le
 int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)
 {
 	struct hexline *hx;
	u8 *buf;
	int ret, pos = 0;
	u16 cpu_cs_register = cypress[type].cpu_cs_register;
 
	buf = kmalloc(sizeof(*hx), GFP_KERNEL);
	if (!buf)
 		return -ENOMEM;
	hx = (struct hexline *)buf;
 
 	 
	buf[0] = 1;
	if (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)
 		err(""could not stop the USB controller CPU."");
 
 	while ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {
  int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw
 	}
 	if (ret < 0) {
 		err(""firmware download failed at %d with %d"",pos,ret);
		kfree(buf);
 		return ret;
 	}
 
 	if (ret == 0) {
 		 
		buf[0] = 0;
		if (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {
 			err(""could not restart the USB controller CPU."");
 			ret = -EINVAL;
 		}
 	} else
 		ret = -EIO;
 
	kfree(buf);
 
 	return ret;
 }","drivers/media/usb/dvb-usb/dvb-usb-firmware.c in the Linux kernel 4.9.x and 4.10.x before 4.10.7 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1151,CVE-2017-7962,"  static int iwgif_read_image(struct iwgifrcontext *rctx)
 
 	rctx->image_width = (int)iw_get_ui16le(&rctx->rbuf[4]);
 	rctx->image_height = (int)iw_get_ui16le(&rctx->rbuf[6]);
	if(rctx->image_width<1 || rctx->image_height<1) {
		iw_set_error(rctx->ctx, ""Invalid image dimensions"");
		goto done;
	}
 
 	rctx->interlaced = (int)((rctx->rbuf[8]>>6)&0x01);
 ",The iwgif_read_image function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted file.
1152,CVE-2017-7946,"  static int init_items(struct MACH0_(obj_t)* bin) {
 		case LC_LOAD_WEAK_DYLIB:
 			sdb_set (bin->kv, sdb_fmt (0, ""mach0_cmd_%d.cmd"", i), ""load_dylib"", 0);
 			bin->nlibs++;
			if (!parse_dylib (bin, off)){
 				bprintf (""Cannot parse dylib\n"");
 				bin->nlibs--;
 				return false;
  static int init_items(struct MACH0_(obj_t)* bin) {
 			{
 			ut8 dyldi[sizeof (struct dyld_info_command)] = {0};
 			sdb_set (bin->kv, sdb_fmt (0, ""mach0_cmd_%d.cmd"", i), ""dyld_info"", 0);
			bin->dyld_info = calloc (1, sizeof (struct dyld_info_command));
			if (bin->dyld_info) {
				if (off + sizeof (struct dyld_info_command) > bin->size){
					bprintf (""Cannot parse dyldinfo\n"");
					R_FREE (bin->dyld_info);
					return false;
				}
				if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {
					free (bin->dyld_info);
					bin->dyld_info = NULL;
					bprintf (""Error: read (LC_DYLD_INFO) at 0x%08""PFMT64x""\n"", off);
				} else {
					bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);
					bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);
					bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);
					bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);
					bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);
					bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);
					bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);
					bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);
					bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);
					bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);
					bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);
					bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);
				}
 			}
 			}
 			break;
  struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {
 		if ((bind_size + lazy_size)<1) {
 			return NULL;
 		}
		if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {
 			return NULL;
		}
 		if (bin->dyld_info->lazy_bind_off > bin->size || \
			bin->dyld_info->lazy_bind_off + lazy_size > bin->size) {
 			return NULL;
		}
		if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {
 			return NULL;
		}
 		 
		if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {
 			return NULL;
		}
 		opcodes = calloc (1, bind_size + lazy_size + 1);
 		if (!opcodes) {
 			free (relocs);
  relocs[i++].last = 0;\
 		free (opcodes);
 	} else {
 		int j;
		if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {
 			return NULL;
		}
		if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {
 			return NULL;
		}
 		for (j = 0; j < bin->dysymtab.nundefsym; j++) {
			if (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {
 				relocs[i].ord = j;
 				relocs[i++].last = 0;
 			}
  struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {
 		}
 		bin->entry = entry->addr;
 	}
 	return entry;
 }
 
 struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {
 	struct lib_t *libs;
 	int i;
 
	if (!bin->nlibs) {
 		return NULL;
	}
	if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {
 		return NULL;
	}
 	for (i = 0; i < bin->nlibs; i++) {
 		strncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);
 		libs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\0';
  struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {
 ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {
 	int i;
 
	if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {
 		return 0;
	}
	for (i = 0; i < bin->nsegs; ++i) {
		if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {
 			return bin->segs[i].vmaddr;
		}
	}
 	return 0;
 }
 
  ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
 		ut8 b[128];
 		ut64 entry = addr_to_offset(bin, bin->entry);
 		 
		if (entry > bin->size || entry + sizeof (b) > bin->size) {
 			return 0;
		}
 		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
 		if (i < 1) {
 			return 0;",The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.
1153,CVE-2017-7895,"  nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,
 	args->count = ntohl(*p++);
 	args->stable = ntohl(*p++);
 	len = args->len = ntohl(*p++);
	if ((void *)p > head->iov_base + head->iov_len)
		return 0;
 	 
  nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,
 	 
 	old = (char*)p;
 	vec = &rqstp->rq_arg.head[0];
	if ((void *)old > vec->iov_base + vec->iov_len)
		return 0;
 	avail = vec->iov_len - (old - (char*)vec->iov_base);
 	while (len && avail && *old) {
 		*new++ = *old++;","The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c."
1154,CVE-2017-7889,"  void __init init_mem_mapping(void)
  * devmem_is_allowed() checks to see if /dev/mem access to a certain address
  * is valid. The argument is a physical page number.
  *
 * On x86, access has to be given to the first megabyte of RAM because that
 * area traditionally contains BIOS code and data regions used by X, dosemu,
 * and similar apps. Since they map the entire memory range, the whole range
 * must be allowed (for mapping), but any areas that would otherwise be
 * disallowed are flagged as being ""zero filled"" instead of rejected.
 * Access has to be given to non-kernel-ram areas as well, these contain the
 * PCI mmio resources as well as potential bios/acpi data regions.
  */
 int devmem_is_allowed(unsigned long pagenr)
 {
	if (page_is_ram(pagenr)) {
		 
		if (pagenr < 256)
			return 2;

		return 0;
	}

	 
	if (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {
		 
		if (pagenr < 256)
			return 1;

 		return 0;
	}

	return 1;
 }
 
 void free_init_pages(char *what, unsigned long begin, unsigned long end)","The mm subsystem in the Linux kernel through 4.10.10 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c."
1155,CVE-2017-7875,"  char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
	static size_t len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;","In wallpaper.c in feh before v2.18.3, if a malicious client pretends to be the E17 window manager, it is possible to trigger an out-of-boundary heap write while receiving an IPC message. An integer overflow leads to a buffer overflow and/or a double free."
1156,CVE-2017-7866,"  static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
     av_bprint_init(bp, 0, -1);
 
     while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 2, &buf, &buf_size);
        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         zstream.next_out  = buf;
        zstream.avail_out = buf_size - 1;
         ret = inflate(&zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END) {
             ret = AVERROR_EXTERNAL;",FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.
1157,CVE-2017-7865,"  void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
            w_align = 8;
            h_align = 8;
        }
         break;
     case AV_PIX_FMT_PAL8:
     case AV_PIX_FMT_BGR8:
  void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
             w_align = 4;
             h_align = 4;
         }
        if (s->codec_id == AV_CODEC_ID_JV ||
            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
             w_align = 8;
             h_align = 8;
         }",FFmpeg before 2017-01-24 has an out-of-bounds write caused by a heap-based buffer overflow related to the ipvideo_decode_block_opcode_0xA function in libavcodec/interplayvideo.c and the avcodec_align_dimensions2 function in libavcodec/utils.c.
1158,CVE-2017-7863,"  static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,
 {
     int v, i;
 
    if (!(s->state & PNG_IHDR)) {
        av_log(avctx, AV_LOG_ERROR, ""trns before IHDR\n"");
        return AVERROR_INVALIDDATA;
    }

    if (s->state & PNG_IDAT) {
        av_log(avctx, AV_LOG_ERROR, ""trns after IDAT\n"");
        return AVERROR_INVALIDDATA;
    }

     if (s->color_type == PNG_COLOR_TYPE_PALETTE) {
         if (length > 256 || !(s->state & PNG_PLTE))
             return AVERROR_INVALIDDATA;
  static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,
         }
     } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {
         if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||
            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||
            s->bit_depth == 1)
             return AVERROR_INVALIDDATA;
 
         for (i = 0; i < length / 2; i++) {
  static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
         size_t raw_bpp = s->bpp - byte_depth;
         unsigned x, y;
 
        av_assert0(s->bit_depth > 1);

         for (y = 0; y < s->height; ++y) {
             uint8_t *row = &s->image_buf[s->image_linesize * y];
 ",FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.
1159,CVE-2017-7862,"  static int decode_frame(AVCodecContext *avctx,
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
    if (s->width != avctx->width || s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;",FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.
1160,CVE-2017-7854,"  static size_t consume_str (ut8 *buf, ut8 *max, size_t sz, char *out, ut32 *offse
 	if (offset) *offset += sz;
 	return sz;
 }

 static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {
 	ut32 i = 0;
 	while (buf + i < max && buf[i] != eoc) {
 		 
		i++;
 	}
 	if (buf[i] != eoc) {
 		return 0;
  static RList *r_bin_wasm_get_code_entries (RBinWasmObj *bin, RBinWasmSection *se
 }
 
 static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
 	RList *ret = NULL;
 	RBinWasmDataEntry *ptr = NULL;
	ut32 len =  sec->payload_len;
 
 	if (!(ret = r_list_newf ((RListFree)free))) {
 		return NULL;
 	}
 
 	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	int buflen = bin->buf->length - (ut32)sec->payload_data;
 	ut32 count = sec->count;
 	ut32 i = 0, r = 0;
 	size_t n = 0;
 
	while (i < len && len < buflen && r < count) {
 		if (!(ptr = R_NEW0 (RBinWasmDataEntry))) {
 			return ret;
 		}
 		if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {
			goto beach;
		}
		if (i + 4 >= buflen) {
			goto beach;
 		}
 		if (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			goto beach;
 		}
 		ptr->offset.len = n;
 		if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {	
			goto beach;
		}
		if (i + 4 >= buflen) {
			goto beach;
 		}
 		ptr->data = sec->payload_data + i;
 
 		r_list_append (ret, ptr);
 
 		r += 1;
 
 	}
	return ret;
beach:
	free (ptr);
 	return ret;
 }
 
  static RList *r_bin_wasm_get_table_entries (RBinWasmObj *bin, RBinWasmSection *s
 static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
 	RList *ret = NULL;
 	RBinWasmGlobalEntry *ptr = NULL;
 
 	if (!(ret = r_list_newf ((RListFree)free))) {
 		return NULL;
 	}
 
 	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	int buflen = bin->buf->length - (ut32)sec->payload_data;
 	ut32 len =  sec->payload_len;
 	ut32 count = sec->count;
 	ut32 i = 0, r = 0;
  static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *
 }
 
 static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
 	RList *ret = NULL;
 	RBinWasmElementEntry *ptr = NULL;
 
  static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection
 	}
 
 	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	int buflen = bin->buf->length - (ut32)sec->payload_data;
 	ut32 len =  sec->payload_len;
 	ut32 count = sec->count;
 	ut32 i = 0, r = 0;
 
	while (i < len && len < buflen && r < count) {
 		if (!(ptr = R_NEW0 (RBinWasmElementEntry))) {
 			return ret;
 		}
 		if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {
			goto beach;
 		}
 		if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			goto beach;
 		}
 		if (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {
			goto beach;
 		}
 		ut32 j = 0;
		while (i < len && j < ptr->num_elem) {
 			 
 			ut32 e;
 			if (!(consume_u32 (buf + i, buf + len, &e, &i))) {
 				free (ptr);
 				return ret;
 			}
 		}
 		r_list_append (ret, ptr);
 
 		r += 1;
 	}
	return ret;
beach:
	free (ptr);
 	return ret;
 }
 ",The consume_init_expr function in wasm.c in radare2 1.3.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Web Assembly file.
1161,CVE-2017-7742,"  typedef struct
 	unsigned bufferpos ;
 
 	const FLAC__Frame *frame ;
 
 	unsigned compression ;

 } FLAC_PRIVATE ;
 
 typedef struct
  flac_buffer_copy (SF_PRIVATE *psf)
 
 	if (pflac->ptr == NULL)
 	{	 
 		for (i = 0 ; i < channels ; i++)
 		{
 			if (pflac->rbuffer [i] == NULL)
  flac_buffer_copy (SF_PRIVATE *psf)
 
 	len = SF_MIN (pflac->len, frame->header.blocksize) ;
 
	if (pflac->remain % channels != 0)
	{	psf_log_printf (psf, ""Error: pflac->remain %u    channels %u\n"", pflac->remain, channels) ;
		return 0 ;
		} ;

 	switch (pflac->pcmtype)
 	{	case PFLAC_PCM_SHORT :
 			{	short *retpcm = (short*) pflac->ptr ;
  sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC
 	pflac->frame = frame ;
 	pflac->bufferpos = 0 ;
 
 	pflac->wbuffer = buffer ;
 
 	flac_buffer_copy (psf) ;
  flac_init (SF_PRIVATE *psf)
 static unsigned
 flac_read_loop (SF_PRIVATE *psf, unsigned len)
 {	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	FLAC__StreamDecoderState state ;
 
 	pflac->pos = 0 ;
 	pflac->len = len ;
 	pflac->remain = len ;
 
	state = FLAC__stream_decoder_get_state (pflac->fsd) ;
	if (state > FLAC__STREAM_DECODER_END_OF_STREAM)
	{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
		 
		pflac->frame = NULL ;
		} ;

 	 
 	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
 		flac_buffer_copy (psf) ;
  flac_read_loop (SF_PRIVATE *psf, unsigned len)
 	while (pflac->pos < pflac->len)
 	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
 			break ;
		state = FLAC__stream_decoder_get_state (pflac->fsd) ;
		if (state >= FLAC__STREAM_DECODER_END_OF_STREAM)
		{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
			 
			pflac->frame = NULL ;
 			break ;
			} ;
 		} ;
 
 	pflac->ptr = NULL ;","In libsndfile before 1.0.28, an error in the *flac_buffer_copy()* function (flac.c) can be exploited to cause a segmentation violation (with read memory access) via a specially crafted FLAC file during a resample attempt, a similar issue to CVE-2017-7585."
1162,CVE-2017-7645,"  static __be32 map_new_errors(u32 vers, __be32 nfserr)
 	return nfserr;
 }
 
 
static bool nfs_request_too_big(struct svc_rqst *rqstp,
				struct svc_procedure *proc)
{
	 
	if (rqstp->rq_prog != NFS_PROGRAM)
		return false;
	 
	if (rqstp->rq_vers >= 4)
		return false;
	 
	if (proc->pc_xdrressize > 0 &&
	    proc->pc_xdrressize < XDR_QUADLEN(PAGE_SIZE))
		return false;

	return rqstp->rq_arg.len > PAGE_SIZE;
}

 int
 nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)
 {
  nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)
 				rqstp->rq_vers, rqstp->rq_proc);
 	proc = rqstp->rq_procinfo;
 
	if (nfs_request_too_big(rqstp, proc)) {
		dprintk(""nfsd: NFSv%d argument too large\n"", rqstp->rq_vers);
		*statp = rpc_garbage_args;
		return 1;
	}
 	/*
 	 * Give the xdr decoder a chance to change this if it wants
 	 * (necessary in the NFSv4.0 compound case)","The NFSv2/NFSv3 server in the nfsd subsystem in the Linux kernel through 4.10.11 allows remote attackers to cause a denial of service (system crash) via a long RPC reply, related to net/sunrpc/svc.c, fs/nfsd/nfs3xdr.c, and fs/nfsd/nfsxdr.c."
1163,CVE-2017-7616,"  COMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,
 COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,
 		       compat_ulong_t, maxnode)
 {
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	DECLARE_BITMAP(bm, MAX_NUMNODES);
  COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
		if (compat_get_bitmap(bm, nmask, nr_bits))
			return -EFAULT;
 		nm = compat_alloc_user_space(alloc_size);
		if (copy_to_user(nm, bm, alloc_size))
			return -EFAULT;
 	}
 
 	return sys_set_mempolicy(mode, nm, nr_bits+1);
 }
 
 COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,
 		       compat_ulong_t, mode, compat_ulong_t __user *, nmask,
 		       compat_ulong_t, maxnode, compat_ulong_t, flags)
 {
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	nodemask_t bm;
  COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
		if (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))
			return -EFAULT;
 		nm = compat_alloc_user_space(alloc_size);
		if (copy_to_user(nm, nodes_addr(bm), alloc_size))
			return -EFAULT;
 	}
 
 	return sys_mbind(start, len, mode, nm, nr_bits+1, flags);
 }
 ",Incorrect error handling in the set_mempolicy and mbind compat syscalls in mm/mempolicy.c in the Linux kernel through 4.10.9 allows local users to obtain sensitive information from uninitialized stack data by triggering failure of a certain bitmap operation.
1164,CVE-2017-7586," 
  
 		psf->fileoffset += offset + 10 ;
 
		if (psf->fileoffset < psf->filelength)
		{	psf_binheader_readf (psf, ""p"", psf->fileoffset) ;
			return 1 ;
			} ;
 		} ;
 
 	return 0 ;","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."
1165,CVE-2017-7542,"  EXPORT_SYMBOL(ipv6_select_ident);
 
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
	unsigned int offset = sizeof(struct ipv6hdr);
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
 	*nexthdr = &ipv6_hdr(skb)->nexthdr;
 
 	while (offset <= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
		unsigned int len;
 
 		switch (**nexthdr) {
 
  int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
		len = ipv6_optlen(exthdr);
		if (len + offset >= IPV6_MAXPLEN)
			return -EINVAL;
		offset += len;
 		*nexthdr = &exthdr->nexthdr;
 	}
 ",The ip6_find_1stfragopt function in net/ipv6/output_core.c in the Linux kernel through 4.12.3 allows local users to cause a denial of service (integer overflow and infinite loop) by leveraging the ability to open a raw socket.
1166,CVE-2017-7541,"  brcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
 		cfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,
 					GFP_KERNEL);
 	} else if (ieee80211_is_action(mgmt->frame_control)) {
		if (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {
			brcmf_err(""invalid action frame length\n"");
			err = -EINVAL;
			goto exit;
		}
 		af_params = kzalloc(sizeof(*af_params), GFP_KERNEL);
 		if (af_params == NULL) {
 			brcmf_err(""unable to allocate frame\n"");",The brcmf_cfg80211_mgmt_tx function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.12.3 allows local users to cause a denial of service (buffer overflow and system crash) or possibly gain privileges via a crafted NL80211_CMD_FRAME Netlink packet.
1167,CVE-2017-7533,"  static inline int dname_external(const struct dentry *dentry)
 	return dentry->d_name.name != dentry->d_iname;
 }
 
void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)
{
	spin_lock(&dentry->d_lock);
	if (unlikely(dname_external(dentry))) {
		struct external_name *p = external_name(dentry);
		atomic_inc(&p->u.count);
		spin_unlock(&dentry->d_lock);
		name->name = p->name;
	} else {
		memcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);
		spin_unlock(&dentry->d_lock);
		name->name = name->inline_name;
	}
}
EXPORT_SYMBOL(take_dentry_name_snapshot);

void release_dentry_name_snapshot(struct name_snapshot *name)
{
	if (unlikely(name->name != name->inline_name)) {
		struct external_name *p;
		p = container_of(name->name, struct external_name, name[0]);
		if (unlikely(atomic_dec_and_test(&p->u.count)))
			kfree_rcu(p, u.head);
	}
}
EXPORT_SYMBOL(release_dentry_name_snapshot);

 static inline void __d_set_inode_and_type(struct dentry *dentry,
 					  struct inode *inode,
 					  unsigned type_flags)",Race condition in the fsnotify implementation in the Linux kernel through 4.12.4 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted application that leverages simultaneous execution of the inotify_handle_event and vfs_rename functions.
1168,CVE-2017-7501,"  static int fsmSetFCaps(const char *path, const char *captxt)
     return rc;
 }
 
 
static int linkSane(FD_t wfd, const char *dest)
{
    struct stat sb, lsb;

    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&
	    (sb.st_mode & ~S_IFMT) == S_IWUSR &&
	    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&
	    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);
}

  
static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)
 {
     FD_t wfd = NULL;
     int rc = 0;
 
      
     {
 	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, exclusive ? ""wx.ufdio"" : ""a.ufdio"");
 	umask(old_umask);

	 
	if (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {
	    rc = RPMERR_OPEN_FAILED;
	    goto exit;
	}
     }
     if (Ferror(wfd)) {
 	rc = RPMERR_OPEN_FAILED;
  static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
 	 
 	if (*firsthardlink < 0) {
 	    *firsthardlink = rpmfiFX(fi);
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
 	} else {
 	     
 	    char *fn = rpmfilesFN(files, *firsthardlink);
  static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
        existing) file with content */
     if (numHardlinks<=1) {
 	if (!rc)
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
     } else if (rpmfiArchiveHasContent(fi)) {
 	if (!rc)
	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
 	*firsthardlink = -1;
     } else {
 	*setmeta = 0;
  int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	     
 	     
 	    char *fn = rpmfilesFN(files, firsthardlink);
	    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);
 	    firsthardlink = -1;
 	    free(fn);
 	}","It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation."
1169,CVE-2017-7495,"  int ext4_map_blocks(handle_t *handle, struct inode *inode,
 		ret = check_block_validity(inode, map);
 		if (ret != 0)
 			return ret;

		 
		if (map->m_flags & EXT4_MAP_NEW &&
		    !(map->m_flags & EXT4_MAP_UNWRITTEN) &&
		    !(flags & EXT4_GET_BLOCKS_ZERO) &&
		    !IS_NOQUOTA(inode) &&
		    ext4_should_order_data(inode)) {
			ret = ext4_jbd2_file_inode(handle, inode);
			if (ret)
				return ret;
		}
 	}
 	return retval;
 }
  static int ext4_write_end(struct file *file,
 	int i_size_changed = 0;
 
 	trace_ext4_write_end(inode, pos, len, copied);
 	if (ext4_has_inline_data(inode)) {
 		ret = ext4_write_inline_data_end(inode, pos, len,
 						 copied, page);","fs/ext4/inode.c in the Linux kernel before 4.6.2, when ext4 data=ordered mode is used, mishandles a needs-flushing-before-commit list, which allows local users to obtain sensitive information from other users' files in opportunistic circumstances by waiting for a hardware reset, creating a new file, making write system calls, and reading this file."
1170,CVE-2017-7487,"  static int ipxitf_ioctl(unsigned int cmd, void __user *arg)
 		sipx->sipx_network	= ipxif->if_netnum;
 		memcpy(sipx->sipx_node, ipxif->if_node,
 			sizeof(sipx->sipx_node));
		rc = 0;
 		if (copy_to_user(arg, &ifr, sizeof(ifr)))
			rc = -EFAULT;
 		ipxitf_put(ipxif);
 		break;
 	}
 	case SIOCAIPXITFCRT:","The ipxitf_ioctl function in net/ipx/af_ipx.c in the Linux kernel through 4.11.1 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a failed SIOCGIFADDR ioctl call for an IPX interface."
1171,CVE-2017-7472,"  long keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,
  * Read or set the default keyring in which request_key() will cache keys and
  * return the old setting.
  *
 * If a thread or process keyring is specified then it will be created if it
 * doesn't yet exist.  The old setting will be returned if successful.
  */
 long keyctl_set_reqkey_keyring(int reqkey_defl)
 {
  long keyctl_set_reqkey_keyring(int reqkey_defl)
 
 	case KEY_REQKEY_DEFL_PROCESS_KEYRING:
 		ret = install_process_keyring_to_cred(new);
		if (ret < 0)
			goto error;
 		goto set;
 
 	case KEY_REQKEY_DEFL_DEFAULT:",The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.
1172,CVE-2017-7418,"  static const char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
  int res, xerrno = 0;
  struct stat st;
  char *ptr;

  if (pathlen == 0) {
    return 0;
  }

  pr_fs_clear_cache2(path);
  res = pr_fsio_lstat(path, &st);
  if (res < 0) {
    xerrno = errno;

    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
      strerror(xerrno));

    errno = xerrno;
    return -1;
  }

  if (S_ISLNK(st.st_mode)) {
    errno = EPERM;
    return -1;
  }

   

  ptr = strrchr(path, '/');
  if (ptr != NULL) {
    char *new_path;
    size_t new_pathlen;

    pr_signals_handle();

    new_pathlen = ptr - path;
    new_path = pstrndup(p, path, new_pathlen);

    pr_log_debug(DEBUG10,
      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
      new_path);
    res = is_symlink_path(p, new_path, new_pathlen);
    if (res < 0) {
      return -1;
    }
  }

  return 0;
}

  
 static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  static int get_default_root(pool *p, int allow_symlinks, const char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
  static int get_default_root(pool *p, int allow_symlinks, const char **root) {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }","ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user."
1173,CVE-2017-7407,"  void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)
   double doubleinfo;
 
   while(ptr && *ptr) {
    if('%' == *ptr && ptr[1]) {
       if('%' == ptr[1]) {
          
         fputc('%', stream);","The ourWriteOut function in tool_writeout.c in curl 7.53.1 might allow physically proximate attackers to obtain sensitive information from process memory in opportunistic circumstances by reading a workstation screen during use of a --write-out argument ending in a '%' character, which leads to a heap-based buffer over-read."
1174,CVE-2017-7396,"  CConnection::CConnection()
     state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false),
     framebuffer(NULL), decoder(this)
 {
 }
 
 CConnection::~CConnection()
  void CConnection::processSecurityTypesMsg()
   int secType = secTypeInvalid;
 
   std::list<rdr::U8> secTypes;
  secTypes = security.GetEnabledSecTypes();
 
   if (cp.isVersion(3,3)) {
 
  void CConnection::processSecurityTypesMsg()
   }
 
   state_ = RFBSTATE_SECURITY;
  csecurity = security.GetCSecurity(secType);
   processSecurityMsg();
 }
 ","In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server."
1175,CVE-2017-7395,"  void SMsgReader::readClientCutText()
 {
   is->skip(3);
   int len = is->readU32();
  if (len < 0) {
    throw Exception(""Cut text too long."");
  }
   if (len > maxCutText) {
     is->skip(len);
     vlog.error(""Cut text too long (%d bytes) - ignoring"", len);","In TigerVNC 1.7.1 (SMsgReader.cxx SMsgReader::readClientCutText), by causing an integer overflow, an authenticated client can crash the server."
1176,CVE-2017-7374,"  EXPORT_SYMBOL(fscrypt_decrypt_page);
 static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)
 {
 	struct dentry *dir;
 	int dir_has_key, cached_with_key;
 
 	if (flags & LOOKUP_RCU)
  static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)
 		return 0;
 	}
 
 	 
 	spin_lock(&dentry->d_lock);
 	cached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;
 	spin_unlock(&dentry->d_lock);
	dir_has_key = (d_inode(dir)->i_crypt_info != NULL);
 	dput(dir);
 
 	/*","Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely."
1177,CVE-2017-7277,"  static void sock_rmem_free(struct sk_buff *skb)
 	atomic_sub(skb->truesize, &sk->sk_rmem_alloc);
 }
 
static void skb_set_err_queue(struct sk_buff *skb)
{
	 
	skb->pkt_type = PACKET_OUTGOING;
	BUILD_BUG_ON(PACKET_OUTGOING == 0);
}

  
  int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)
 	skb->sk = sk;
 	skb->destructor = sock_rmem_free;
 	atomic_add(skb->truesize, &sk->sk_rmem_alloc);
	skb_set_err_queue(skb);
 
 	 
 	skb_dst_force(skb);","The TCP stack in the Linux kernel through 4.10.6 mishandles the SCM_TIMESTAMPING_OPT_STATS feature, which allows local users to obtain sensitive information from the kernel's internal socket data structures or cause a denial of service (out-of-bounds read) via crafted system calls, related to net/core/skbuff.c and net/socket.c."
1178,CVE-2017-7274,"  RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
 		return NULL;
 	}
 	object = r_asn1_create_object (buffer, length);
	if (!object || object->list.length != 2 || !object->list.objects ||
		!object->list.objects[0] || !object->list.objects[1] ||
		object->list.objects[1]->list.length != 1) {
 		r_asn1_free_object (object);
 		free (container);
 		return NULL;",The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.
1179,CVE-2017-7273,"  static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 	if (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))
 		return rdesc;
 
	if (*rsize < 4)
		return rdesc;

 	for (i = 0; i < *rsize - 4; i++)
 		if (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {
 			rdesc[i] = 0x19;",The cp_report_fixup function in drivers/hid/hid-cypress.c in the Linux kernel 4.x before 4.9.4 allows physically proximate attackers to cause a denial of service (integer underflow) or possibly have unspecified other impact via a crafted HID report.
1180,CVE-2017-7191,"  static void read_settings(void)
 	}
 }
 
static void sig_server_disconnected(IRC_SERVER_REC *server)
{
	NETJOIN_SERVER_REC *netjoin_server;

	g_return_if_fail(server != NULL);

	if (!IS_IRC_SERVER(server))
		return;

	if ((netjoin_server = netjoin_find_server(server))) {
		netjoin_server_remove(netjoin_server);
	}
}

 void fe_netjoin_init(void)
 {
 	settings_add_bool(""misc"", ""hide_netsplit_quits"", TRUE);
  void fe_netjoin_init(void)
 
 	read_settings();
 	signal_add(""setup changed"", (SIGNAL_FUNC) read_settings);
	signal_add(""server disconnected"", (SIGNAL_FUNC) sig_server_disconnected);
 }
 
 void fe_netjoin_deinit(void)
  void fe_netjoin_deinit(void)
 	}
 
 	signal_remove(""setup changed"", (SIGNAL_FUNC) read_settings);
	signal_remove(""server disconnected"", (SIGNAL_FUNC) sig_server_disconnected);
 
 	signal_remove(""message quit"", (SIGNAL_FUNC) msg_quit);
 	signal_remove(""message join"", (SIGNAL_FUNC) msg_join);",The netjoin processing in Irssi 1.x before 1.0.2 allows attackers to cause a denial of service (use-after-free) and possibly execute arbitrary code via unspecified vectors.
1181,CVE-2017-7185,"  static int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {
   struct mbuf *io = &c->recv_mbuf;
   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);
 
  if (pd->mp_stream.boundary == NULL) {
    pd->mp_stream.state = MPS_FINALIZE;
    DBG((""Invalid request: boundary not initilaized""));
    return 0;
  }

   if ((int) io->len < pd->mp_stream.boundary_len + 2) {
     return 0;
   }",Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.
1182,CVE-2017-7184,"  static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_es
 	up = nla_data(rp);
 	ulen = xfrm_replay_state_esn_len(up);
 
	 
	if (nla_len(rp) < ulen ||
	    xfrm_replay_state_esn_len(replay_esn) != ulen ||
	    replay_esn->bmp_len != up->bmp_len)
 		return -EINVAL;
 
 	if (up->replay_window > up->bmp_len * sizeof(__u32) * 8)","The xfrm_replay_verify_len function in net/xfrm/xfrm_user.c in the Linux kernel through 4.10.6 does not validate certain size data after an XFRM_MSG_NEWAE update, which allows local users to obtain root privileges or cause a denial of service (heap-based out-of-bounds access) by leveraging the CAP_NET_ADMIN capability, as demonstrated during a Pwn2Own competition at CanSecWest 2017 for the Ubuntu 16.10 linux-image-* package 4.8.0.41.52."
1183,CVE-2017-7177,"  static void DefragTrackerInit(DefragTracker *dt, Packet *p)
         dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);
         dt->af = AF_INET6;
     }
    dt->proto = IP_GET_IPPROTO(p);
     dt->vlan_id[0] = p->vlan_id[0];
     dt->vlan_id[1] = p->vlan_id[1];
     dt->policy = DefragGetOsPolicy(p);
  static inline uint32_t DefragHashGetKey(Packet *p)
        CMP_ADDR(&(d1)->dst_addr, &(d2)->dst)) || \
       (CMP_ADDR(&(d1)->src_addr, &(d2)->dst) && \
        CMP_ADDR(&(d1)->dst_addr, &(d2)->src))) && \
     (d1)->proto == IP_GET_IPPROTO(p) &&        \
      (d1)->id == (id) && \
      (d1)->vlan_id[0] == (d2)->vlan_id[0] && \
      (d1)->vlan_id[1] == (d2)->vlan_id[1])",Suricata before 3.2.1 has an IPv4 defragmentation evasion issue caused by lack of a check for the IP protocol during fragment matching.
1184,CVE-2017-6952," 
 
 #include ""winkernel_mm.h""
 #include <ntddk.h>
#include <Ntintsafe.h>
 
  
 static const ULONG CS_WINKERNEL_POOL_TAG = 'kwsC';
  void * CAPSTONE_API cs_winkernel_malloc(size_t size)
 
 	 
 #pragma prefast(suppress : 30030)		 
	size_t number_of_bytes = 0;
	CS_WINKERNEL_MEMBLOCK *block = NULL;
	 
	 
	 
	if (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {
		return NULL;
	}
	block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(
			NonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);
 	if (!block) {
 		return NULL;
 	}",Integer overflow in the cs_winkernel_malloc function in winkernel_mm.c in Capstone 3.0.4 and earlier allows attackers to cause a denial of service (heap-based buffer overflow in a kernel driver) or possibly have unspecified other impact via a large value.
1185,CVE-2017-6903,"  void CL_InitRef( void ) {
 	GetRefAPI_t	GetRefAPI;
 
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
    cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED );
 
 	Com_sprintf( dllName, sizeof( dllName ), ""%s_"" ARCH_STRING DLL_EXT, cl_renderer->string );
 ","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
1186,CVE-2017-6892,"  aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)
 		psf_binheader_readf (psf, ""j"", dword - bytesread) ;
 
 	if (map_info->channel_map != NULL)
	{	size_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;
 
 		free (psf->channel_map) ;
 ","In libsndfile version 1.0.28, an error in the *aiff_read_chanmap()* function (aiff.c) can be exploited to cause an out-of-bounds read memory access via a specially crafted AIFF file."
1187,CVE-2017-6890,"  void CLASS foveon_huff (ushort *huff)
 void CLASS foveon_dp_load_raw()
 {
   unsigned c, roff[4], row, col, diff;
  ushort huff[1024], vpred[2][2], hpred[2];
 
   fseek (ifp, 8, SEEK_CUR);
   foveon_huff (huff);
  void CLASS foveon_dp_load_raw()
 void CLASS foveon_load_camf()
 {
   unsigned type, wide, high, i, j, row, col, diff;
  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];
 
   fseek (ifp, meta_offset, SEEK_SET);
   type = get4();  get4();  get4();
   wide = get4();
   high = get4();
#ifdef LIBRAW_LIBRARY_BUILD
  if(wide>32767 || high > 32767 || wide*high > 20000000)
     throw LIBRAW_EXCEPTION_IO_CORRUPT;
#endif
   if (type == 2) {
     fread (meta_data, 1, meta_length, ifp);
     for (i=0; i < meta_length; i++) {",A boundary error within the *foveon_load_camf()* function (dcraw_foveon.c) when initializing a huffman table in LibRaw-demosaic-pack-GPL2 before 0.18.2 can be exploited to cause a stack-based buffer overflow.
1188,CVE-2017-6887,"  int CLASS parse_tiff_ifd(int base)
         load_raw = &CLASS sony_arw_load_raw;
         data_offset = get4() + base;
         ifd++;
#ifdef LIBRAW_LIBRARY_BUILD
	if (ifd >= sizeof tiff_ifd / sizeof tiff_ifd[0])
	  throw LIBRAW_EXCEPTION_IO_CORRUPT;
#endif    
         break;
       }
 #ifdef LIBRAW_LIBRARY_BUILD
  int CLASS parse_tiff_ifd(int base)
       break;
     case 50454:  
     case 50455:
      if (len < 1 || len > 2560000 || !(cbuf = (char *)malloc(len)))
         break;
 #ifndef LIBRAW_LIBRARY_BUILD
       fread(cbuf, 1, len, ifp);
  int CLASS parse_jpeg(int offset)
     }
     order = get2();
     hlen = get4();
    if (get4() == 0x48454150
#ifdef LIBRAW_LIBRARY_BUILD
	&& (save+hlen) >= 0 && (save+hlen)<=ifp->size()
#endif
	)  
     {
 #ifdef LIBRAW_LIBRARY_BUILD
       imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;",A boundary error within the *parse_tiff_ifd()* function (internal/dcraw_common.cpp) in LibRaw versions before 0.18.2 can be exploited to cause a memory corruption via e.g. a specially crafted KDC file with model set to *DSLR-A100* and containing multiple sequences of 0x100 and 0x14A TAGs.
1189,CVE-2017-6874,"  struct ucounts {
 	struct hlist_node node;
 	struct user_namespace *ns;
 	kuid_t uid;
	int count;
 	atomic_t ucount[UCOUNT_COUNTS];
 };
 ",Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.
1190,CVE-2017-6850,"  int jas_stream_ungetc(jas_stream_t *stream, int c)
 	return 0;
 }
 
 
 int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)
 {
 	int n;
  int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)
 	return n;
 }
 
 
 int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)
 {
 	int n;
  int jas_stream_puts(jas_stream_t *stream, const char *s)
 	return 0;
 }
 
 
 char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)
 {
 	int c;
  char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)
 	return buf;
 }
 
 
 int jas_stream_gobble(jas_stream_t *stream, int n)
 {
 	int m;
  int jas_stream_gobble(jas_stream_t *stream, int n)
 	return n;
 }
 
 
 int jas_stream_pad(jas_stream_t *stream, int n, int c)
 {
 	int m;
  long jas_stream_tell(jas_stream_t *stream)
 * Buffer initialization code.
 \******************************************************************************/
 
 
 static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,
   int bufsize)
 {
  static int jas_strtoopenmode(const char *s)
 	return openmode;
 }
 
 
 int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)
 {
 	int all;
  int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)
 	return 0;
 }
 
 
 long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)
 {
 	int old;
  long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)
 	return old;
 }
 
 
 int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)
 {
 	unsigned char buf[16];
  long jas_stream_length(jas_stream_t *stream)
 * Memory stream object.
 \******************************************************************************/
 
 
 static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)
 {
 	ssize_t n;
  static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)
 	return 0;
 }
 
 
 static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)
 {
 	size_t n;
  static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)
 	return ret;
 }
 
 
 static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)
 {
 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
  static int mem_close(jas_stream_obj_t *obj)
 * File stream object.
 \******************************************************************************/
 
 
 static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)
 {
 	jas_stream_fileobj_t *fileobj;
  static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)
 	return read(fileobj->fd, buf, cnt);
 }
 
 
 static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)
 {
 	jas_stream_fileobj_t *fileobj;
  static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)
 	return write(fileobj->fd, buf, cnt);
 }
 
 
 static long file_seek(jas_stream_obj_t *obj, long offset, int origin)
 {
 	jas_stream_fileobj_t *fileobj;
  static int file_close(jas_stream_obj_t *obj)
 * Stdio file stream object.
 \******************************************************************************/
 
 
 static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)
 {
 	FILE *fp;
  static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)
 	return result;
 }
 
 
 static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)
 {
 	FILE *fp;
  static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)
 	return (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;
 }
 
 
 static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)
 {
 	FILE *fp;",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.
1191,CVE-2017-6839,"  void BlockCodec::runPull()
 	 
 	for (int i=0; i<blocksRead; i++)
 	{
		if (decodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,
			static_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount)==0)
			break;
 
 		framesRead += m_framesPerPacket;
 	}",Integer overflow in modules/MSADPCM.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.
1192,CVE-2017-6838,"  void printusage (void);
 void usageerror (void);
 bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid);
 
int firstBitSet(int x)
{
        int position=0;
        while (x!=0)
        {
                x>>=1;
                ++position;
        }
        return position;
}

#ifndef __has_builtin
#define __has_builtin(x) 0
#endif

int multiplyCheckOverflow(int a, int b, int *result)
{
#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))
	return __builtin_mul_overflow(a, b, result);
#else
	if (firstBitSet(a)+firstBitSet(b)>31)  
		return true;
	*result = a * b;
	return false;
#endif
}

 int main (int argc, char **argv)
 {
 	if (argc == 2)
  bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)
 {
 	int frameSize = afGetVirtualFrameSize(infile, trackid, 1);
 
	int kBufferFrameCount = 65536;
	int bufferSize;
	while (multiplyCheckOverflow(kBufferFrameCount, frameSize, &bufferSize))
		kBufferFrameCount /= 2;
	void *buffer = malloc(bufferSize);
 
 	AFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);
 	AFframecount totalFramesWritten = 0;",Integer overflow in sfcommands/sfconvert.c in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.
1193,CVE-2017-6837,"  status WAVEFile::parseFormat(const Tag &id, uint32_t size)
 
 			 
 			assert(numCoefficients >= 7 && numCoefficients <= 255);
			if (numCoefficients < 7 || numCoefficients > 255)
			{
				_af_error(AF_BAD_HEADER,
						""Bad number of coefficients"");
				return AF_FAIL;
			}
 
 			m_msadpcmNumCoefficients = numCoefficients;
 ",WAVE.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via vectors related to a large number of coefficients.
1194,CVE-2017-6831,"  status WAVEFile::parseFormat(const Tag &id, uint32_t size)
 			{
 				_af_error(AF_BAD_NOT_IMPLEMENTED,
 					""IMA ADPCM compression supports only 4 bits per sample"");
				return AF_FAIL;
 			}
 
 			int bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;
 			if (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)
 			{
 				_af_error(AF_BAD_CODEC_CONFIG,
 					""Invalid samples per block for IMA ADPCM compression"");
				return AF_FAIL;
 			}
 
 			track->f.sampleWidth = 16;",Heap-based buffer overflow in the decodeBlockWAVE function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.
1195,CVE-2017-6829,"  int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)
 		if (encoded[1] & 0x80)
 			m_adpcmState[c].previousValue -= 0x10000;
 
		m_adpcmState[c].index = clamp(encoded[2], 0, 88);
 
 		*decoded++ = m_adpcmState[c].previousValue;
 
  int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)
 			predictor -= 0x10000;
 
 		state.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);
		state.index = clamp(encoded[1] & 0x7f, 0, 88);
 		encoded += 2;
 
 		for (int n=0; n<m_framesPerPacket; n+=2)",The decodeSample function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.
1196,CVE-2017-6504,"  namespace Http
     const QString HEADER_CONTENT_ENCODING = ""Content-Encoding"";
     const QString HEADER_CONTENT_LENGTH = ""Content-Length"";
     const QString HEADER_CACHE_CONTROL = ""Cache-Control"";
    const QString HEADER_X_FRAME_OPTIONS = ""X-Frame-Options"";
 
     const QString CONTENT_TYPE_CSS = ""text/css; charset=UTF-8"";
     const QString CONTENT_TYPE_GIF = ""image/gif"";","WebUI in qBittorrent before 3.3.11 did not set the X-Frame-Options header, which could potentially lead to clickjacking."
1197,CVE-2017-6503," 
 #include ""logger.h""
 
 #include <QDateTime>
#include ""base/utils/string.h""
 
 Logger* Logger::m_instance = 0;
 
  void Logger::addMessage(const QString &message, const Log::MsgType &type)
 {
     QWriteLocker locker(&lock);
 
    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };
     m_messages.push_back(temp);
 
     if (m_messages.size() >= MAX_LOG_MESSAGES)
  void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)
 {
     QWriteLocker locker(&lock);
 
    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };
     m_peers.push_back(temp);
 
     if (m_peers.size() >= MAX_LOG_MESSAGES)","WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS."
1198,CVE-2017-6501,"  static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
   }
 
   (void) CloseBlob(image);
  if (GetNextImageInList(image) != (Image *) NULL)
    DestroyImage(RemoveFirstImageFromList(&image));
   if (image_type == GIMP_GRAY)
     image->type=GrayscaleType;
   return(GetFirstImageInList(image));",An issue was discovered in ImageMagick 6.9.7. A specially crafted xcf file could lead to a NULL pointer dereference.
1199,CVE-2017-6500,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
         ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
       }
     pixels_length=height*bytes_per_line;
    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,
       sizeof(*sun_pixels));
     if (sun_pixels == (unsigned char *) NULL)
       {",An issue was discovered in ImageMagick 6.9.7. A specially crafted sun file triggers a heap-based buffer over-read.
1200,CVE-2017-6498,"  static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)
     compression;
 
   const char
    *comment,
     *value;
 
   const double
  static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)
     compression=image_info->compression;
   range=GetQuantumRange(5UL);
   tga_info.id_length=0;
  comment=GetImageProperty(image,""comment"");
  if (comment != (const char *) NULL)
    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);
   tga_info.colormap_type=0;
   tga_info.colormap_index=0;
   tga_info.colormap_length=0;
  static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)
   (void) WriteBlobByte(image,tga_info.bits_per_pixel);
   (void) WriteBlobByte(image,tga_info.attributes);
   if (tga_info.id_length != 0)
    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);
   if (tga_info.colormap_type != 0)
     {
       unsigned char","An issue was discovered in ImageMagick 6.9.7. Incorrect TGA files could trigger assertion failures, thus leading to DoS."
1201,CVE-2017-6497,"  static MagickBooleanType ReadPSDChannel(Image *image,
       }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
      if (mask != (Image *) NULL)
        {
          mask->matte=MagickFalse;
          channel_image=mask;
        }
     }
 
   offset=TellBlob(image);","An issue was discovered in ImageMagick 6.9.7. A specially crafted psd file could lead to a NULL pointer dereference (thus, a DoS)."
1202,CVE-2017-6448,"  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			{
 				unsigned short array_size = buf[2] | (buf[3] << 8);
 				int first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);
				snprintf (op->buf_asm, sizeof(op->buf_asm), ""packed-switch-payload %d, %d"", array_size, first_key);
 				size = 8;
 				payload = 2 * (array_size * 2);
 				len = 0;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			 
 			{
 				unsigned short array_size = buf[2] | (buf[3] << 8);
				snprintf (op->buf_asm, sizeof (op->buf_asm), ""sparse-switch-payload %d"", array_size);
 				size = 4;
 				payload = 2 * (array_size*4);
 				len = 0;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 		case fmtopvAvB:
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAvBBBB:
 			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAAAvBBBB:  
 			vA = (buf[3] << 8) | buf[2];
 			vB = (buf[5] << 8) | buf[4];
			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAA:
 			vA = (int) buf[1];
			snprintf (str, sizeof (str), "" v%i"", vA);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAcB:
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
			snprintf (str, sizeof (str), "" v%i, %#x"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAcBBBB:
 			vA = (int) buf[1];
 			{
 				short sB = (buf[3] << 8) | buf[2];
				snprintf (str, sizeof (str), "" v%i, %#04hx"", vA, sB);
 				strasm = r_str_concat (strasm, str);
 			}
 			break;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 				((llint)buf[6] << 32) | ((llint)buf[7] << 40)|
 				((llint)buf[8] << 48) | ((llint)buf[9] << 56);
 			#undef llint
			snprintf (str, sizeof (str), "" v%i:v%i, 0x%""PFMT64x, vA, vA + 1, lB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAvBBvCC:
 			vA = (int) buf[1];
 			vB = (int) buf[2];
 			vC = (int) buf[3];
			snprintf (str, sizeof (str), "" v%i, v%i, v%i"", vA, vB, vC);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAvBBcCC:
 			vA = (int) buf[1];
 			vB = (int) buf[2];
 			vC = (int) buf[3];
			snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAvBcCCCC:
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
 			vC = (buf[3] << 8) | buf[2];
			snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoppAA:
 			vA = (char) buf[1];
			 
 			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA * 2));  
 			strasm = r_str_concat (strasm, str);
 			break;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 		case fmtopvAApBBBB:  
 			vA = (int) buf[1];
 			vB = (int) (buf[3] << 8 | buf[2]);
			 
 			snprintf (str, sizeof (str), "" v%i, 0x%08""PFMT64x, vA, a->pc + (vB * 2));
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoppAAAAAAAA:
 			vA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));
			 
 			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA*2));  
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAvBpCCCC:  
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
 			vC = (int) (buf[3] << 8 | buf[2]);
			 
 			snprintf (str, sizeof (str),"" v%i, v%i, 0x%08""PFMT64x, vA, vB, a->pc + (vC * 2));
 			strasm = r_str_concat (strasm, str);
 			break;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			*str = 0;
 			switch (vA) {
 			case 1:
				snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
 				break;
 			case 2:
				snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 				break;
 			case 3:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 				break;
 			case 4:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
 				break;
 			default:
				snprintf (str, sizeof (str), "" {}"");
 			}
 			strasm = r_str_concat (strasm, str);
			snprintf (str, sizeof (str), "", [%04x]"", vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptinlineIR:
 		case fmtoptinvokeVSR:
 			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
 			vC = (buf[5] << 8) | buf[4];
			snprintf (str, sizeof (str), "" {v%i..v%i}, [%04x]"", vC, vC + vA - 1, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptinvokeVS:
 			vA = (int) (buf[1] & 0xf0) >> 4;
 			vB = (buf[3] << 8) | buf[2];
 			switch (vA) {
 			case 1:
				snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
 				break;
 			case 2:
				snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 				break;
 			case 3:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
 						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 				break;
 			case 4:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
 				break;
 			default:
				snprintf (str, sizeof (str), "" {}"");
 				break;
 			}
 			strasm = r_str_concat (strasm, str);
			snprintf (str, sizeof (str), "", [%04x]"", vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAtBBBB:  
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			if (buf[0] == 0x1a) {
 				offset = R_ASM_GET_OFFSET (a, 's', vB);
 				if (offset == -1) {
					snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
 				} else {
					snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
 				}
 			} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {
 				flag_str = R_ASM_GET_NAME (a, 'c', vB);
 				if (!flag_str) {
					snprintf (str, sizeof (str), "" v%i, class+%i"", vA, vB);
 				} else {
					snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'f', vB);
 				if (!flag_str) {
					snprintf (str, sizeof (str), "" v%i, field+%i"", vA, vB);
 				} else {
					snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
 				}
 			}
 			strasm = r_str_concat (strasm, str);
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			vC = (buf[3]<<8) | buf[2];
 			offset = R_ASM_GET_OFFSET (a, 'o', vC);
 			if (offset == -1) {
				snprintf (str, sizeof (str), "" v%i, v%i, [obj+%04x]"", vA, vB, vC);
 			} else {
				snprintf (str, sizeof (str), "" v%i, v%i, [0x%""PFMT64x""]"", vA, vB, offset);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			vB = (buf[3] << 8) | buf[2];
 			offset = R_ASM_GET_OFFSET (a, 't', vB);
 			if (offset == -1) {
				snprintf (str, sizeof (str), "" v%i, thing+%i"", vA, vB);
 			} else {
				snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			if (buf[0] == 0x20 || buf[0] == 0x23) {  
 				flag_str = R_ASM_GET_NAME (a, 'c', vC);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" v%i, v%i, %s"", vA, vB, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" v%i, v%i, class+%i"", vA, vB, vC);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'f', vC);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" v%i, v%i, %s"", vA, vB, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" v%i, v%i, field+%i"", vA, vB, vC);
 				}
 			}
 			strasm = r_str_concat (strasm, str);
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			vB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));
 			offset = R_ASM_GET_OFFSET (a, 's', vB);
 			if (offset == -1) {
				snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
 			}
 			else {
				snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			if (buf[0] == 0x25) {  
 				flag_str = R_ASM_GET_NAME (a, 'c', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" {v%i..v%i}, class+%i"", vC, vC + vA - 1, vB);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'm', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" {v%i..v%i}, method+%i"", vC, vC + vA - 1, vB);
 				}
 			}
 			strasm = r_str_concat (strasm, str);
  static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
 			vB = (buf[3] << 8) | buf[2];
 			switch (vA) {
 				case 1:
					snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
 					break;
 				case 2:
					snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 					break;
 				case 3:
					snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
 							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 					break;
 				case 4:
					snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
 					break;
 				case 5:
					snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f);  
 					break;
 				default:
					snprintf (str, sizeof (str), "" {}"");
 			}
 			strasm = r_str_concat (strasm, str);
 			if (buf[0] == 0x24) {  
 				flag_str = R_ASM_GET_NAME (a, 'c', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
 				} else {
					snprintf (str, sizeof (str), "", class+%i"", vB);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'm', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
 				} else {
					snprintf (str, sizeof (str), "", method+%i"", vB);
 				}
 
 			}",The dalvik_disassemble function in libr/asm/p/asm_dalvik.c in radare2 1.2.1 allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file.
1203,CVE-2017-6439,"  static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
  static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
  static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);",Heap-based buffer overflow in the parse_string_node function in bplist.c in libimobiledevice libplist 1.12 allows local users to cause a denial of service (out-of-bounds write) via a crafted plist file.
1204,CVE-2017-6435,"  static plist_t parse_string_node(const char **bnode, uint64_t size)
 
     data->type = PLIST_STRING;
     data->strval = (char *) malloc(sizeof(char) * (size + 1));
    if (!data->strval) {
        plist_free_data(data);
        PLIST_BIN_ERR(""%s: Could not allocate %"" PRIu64 "" bytes\n"", __func__, sizeof(char) * (size + 1));
        return NULL;
    }
     memcpy(data->strval, *bnode, size);
     data->strval[size] = '\0';
     data->length = strlen(data->strval);",The parse_string_node function in bplist.c in libimobiledevice libplist 1.12 allows local users to cause a denial of service (memory corruption) via a crafted plist file.
1205,CVE-2017-6430,"  size_t compile_tree(struct filter_op **fop)
    struct filter_op *array = NULL;
    struct unfold_elm *ue;
 
    
   if (tree_root == NULL)
      return 0;
   
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);",The compile_tree function in ef_compiler.c in the Etterfilter utility in Ettercap 0.8.2 and earlier allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted filter.
1206,CVE-2017-6420,"  int wwunpack(uint8_t *exe, uint32_t exesz, uint8_t *wwsect, struct cli_exe_secti
 	return CL_EFORMAT;
     exe[pe+6]=(uint8_t)scount;
     exe[pe+7]=(uint8_t)(scount>>8);
    if (!CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295, 4) ||
        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva, 4) ||
        !CLI_ISCONTAINED(wwsect, sects[scount].rsz, wwsect+0x295+sects[scount].rva+0x299, 4)) {
        cli_dbgmsg(""WWPack: unpack memory address out of bounds.\n"");
        return CL_EFORMAT;
    }
     cli_writeint32(&exe[pe+0x28], cli_readint32(wwsect+0x295)+sects[scount].rva+0x299);
     cli_writeint32(&exe[pe+0x50], cli_readint32(&exe[pe+0x50])-sects[scount].vsz);
 ",The wwunpack function in libclamav/wwunpack.c in ClamAV 0.99.2 allows remote attackers to cause a denial of service (use-after-free) via a crafted PE file with WWPack compression.
1207,CVE-2017-6419,"  int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {
       case LZX_BLOCKTYPE_UNCOMPRESSED:
 	 
        if (window_posn + this_run > lzx->window_size) {
                D((""match ran over window boundary""))
                return lzx->error = MSPACK_ERR_DECRUNCH;
        }
 	rundest = &window[window_posn];
 	window_posn += this_run;

 	while (this_run > 0) {
 	  if ((i = i_end - i_ptr) == 0) {
 	    READ_IF_NEEDED;
  void lzxd_free(struct lzxd_stream *lzx) {
   struct mspack_system *sys;
   if (lzx) {
     sys = lzx->sys;
    if(lzx->inbuf)
        sys->free(lzx->inbuf);
    if(lzx->window)
        sys->free(lzx->window);
     sys->free(lzx);
   }
 }","mspack/lzxd.c in libmspack 0.5alpha, as used in ClamAV 0.99.2, allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted CHM file."
1208,CVE-2017-6418,"  messageAddArgument(message *m, const char *arg)
 			 * FIXME: Bounce message handling is corrupting the in
 			 * core copies of headers
 			 */
                        if (strlen(p) > 8) {
                            cli_dbgmsg(""Possible data corruption fixed\n"");
                            p[8] = '=';
                        } else {
                            cli_dbgmsg(""Possible data corruption not fixed\n"");
                        }
 		} else {
 			if(*p)
 				cli_dbgmsg(""messageAddArgument, '%s' contains no '='\n"", p);
  messageFindArgument(const message *m, const char *variable)
 				cli_dbgmsg(""messageFindArgument: no '=' sign found in MIME header '%s' (%s)\n"", variable, messageGetArgument(m, i));
 				return NULL;
 			}
			if((strlen(ptr) > 2) && (*++ptr == '""') && (strchr(&ptr[1], '""') != NULL)) {
 				 
 				char *ret = cli_strdup(++ptr);
 				char *p;",libclamav/message.c in ClamAV 0.99.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted e-mail message.
1209,CVE-2017-6415,"  static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,
 		--parameters_size;
 	}
 
	if (p4 <= 0) {
		return;
	}
 	ut8 opcode = *(p4++) & 0xff;
 	while (keep) {
 		switch (opcode) {",The dex_parse_debug_item function in libr/bin/p/bin_dex.c in radare2 1.2.1 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted DEX file.
1210,CVE-2017-6387,"  static int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {
 				continue;
 			}
 
			if (bin->methods[i].class_id > bin->header.types_size) {
 				continue;
 			}
 ",The dex_loadcode function in libr/bin/p/bin_dex.c in radare2 1.2.1 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted DEX file.
1211,CVE-2017-6353,"  int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 	if (!asoc)
 		return -EINVAL;
 
	 
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

 	 
  static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;","net/sctp/socket.c in the Linux kernel through 4.10.1 does not properly restrict association peel-off operations during certain wait states, which allows local users to cause a denial of service (invalid unlock and double free) via a multithreaded application.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2017-5986."
1212,CVE-2017-6348,"  EXPORT_SYMBOL(hashbin_new);
  *    for deallocating this structure if it's complex. If not the user can
  *    just supply kfree, which should take care of the job.
  */
 int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
 {
 	irda_queue_t* queue;
  int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
 	IRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);
 
 	 
	if (hashbin->hb_type & HB_LOCK)
		spin_lock_irqsave(&hashbin->hb_spinlock, flags);
 
 	 
 	for (i = 0; i < HASHBIN_SIZE; i ++ ) {
		while (1) {
			queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);

			if (!queue)
				break;

			if (free_func) {
				if (hashbin->hb_type & HB_LOCK)
					spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
				free_func(queue);
				if (hashbin->hb_type & HB_LOCK)
					spin_lock_irqsave(&hashbin->hb_spinlock, flags);
			}
 		}
 	}
 
  int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
 	hashbin->magic = ~HB_MAGIC;
 
 	 
	if (hashbin->hb_type & HB_LOCK)
 		spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
 
 	/*
 	 *  Free the hashbin structure","The hashbin_delete function in net/irda/irqueue.c in the Linux kernel before 4.9.13 improperly manages lock dropping, which allows local users to cause a denial of service (deadlock) via crafted operations on IrDA devices."
1213,CVE-2017-6347,"  static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,
 	if (skb->ip_summed != CHECKSUM_COMPLETE)
 		return;
 
	if (offset != 0) {
		int tend_off = skb_transport_offset(skb) + tlen;
		csum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0));
	}
 
 	put_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);
 }","The ip_cmsg_recv_checksum function in net/ipv4/ip_sockglue.c in the Linux kernel before 4.10.1 has incorrect expectations about skb data layout, which allows local users to cause a denial of service (buffer over-read) or possibly have unspecified other impact via crafted system calls, as demonstrated by use of the MSG_MORE flag in conjunction with loopback UDP transmission."
1214,CVE-2017-6346,"  static void fanout_release_data(struct packet_fanout *f)
 
 static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 {
	struct packet_rollover *rollover = NULL;
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f, *match;
 	u8 type = type_flags & 0xff;
  static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		return -EINVAL;
 	}
 
	mutex_lock(&fanout_mutex);

	err = -EINVAL;
 	if (!po->running)
		goto out;
 
	err = -EALREADY;
 	if (po->fanout)
		goto out;
 
 	if (type == PACKET_FANOUT_ROLLOVER ||
 	    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
		err = -ENOMEM;
		rollover = kzalloc(sizeof(*rollover), GFP_KERNEL);
		if (!rollover)
			goto out;
		atomic_long_set(&rollover->num, 0);
		atomic_long_set(&rollover->num_huge, 0);
		atomic_long_set(&rollover->num_failed, 0);
		po->rollover = rollover;
 	}
 
 	match = NULL;
 	list_for_each_entry(f, &fanout_list, list) {
 		if (f->id == id &&
  static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		}
 	}
 out:
	if (err && rollover) {
		kfree(rollover);
 		po->rollover = NULL;
 	}
	mutex_unlock(&fanout_mutex);
 	return err;
 }
 
  static void fanout_release(struct sock *sk)
 	struct packet_sock *po = pkt_sk(sk);
 	struct packet_fanout *f;
 
 	mutex_lock(&fanout_mutex);
	f = po->fanout;
	if (f) {
		po->fanout = NULL;

		if (atomic_dec_and_test(&f->sk_ref)) {
			list_del(&f->list);
			dev_remove_pack(&f->prot_hook);
			fanout_release_data(f);
			kfree(f);
		}
 
		if (po->rollover)
			kfree_rcu(po->rollover, rcu);
 	}
 	mutex_unlock(&fanout_mutex);
 }
 
 static bool packet_extra_vlan_len_allowed(const struct net_device *dev,",Race condition in net/packet/af_packet.c in the Linux kernel before 4.9.13 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a multithreaded application that makes PACKET_FANOUT setsockopt system calls.
1215,CVE-2017-6345,"  void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)
 		 * another trick required to cope with how the PROCOM state
 		 * machine works. -acme
 		 */
		skb_orphan(skb);
		sock_hold(sk);
 		skb->sk = sk;
		skb->destructor = sock_efree;
 	}
 	if (!sock_owned_by_user(sk))
 		llc_conn_rcv(sk, skb);","The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls."
1216,CVE-2017-6319,"  static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,
 	ut64 source_file_idx = c->source_file;
 	RList *params, *debug_positions, *emitted_debug_locals = NULL; 
 	bool keep = true;
	if (argReg > regsz) {
		return;  
 	}
 	p4 = r_uleb128 (p4, p4_end - p4, &line_start);
 	p4 = r_uleb128 (p4, p4_end - p4, &parameters_size);",The dex_parse_debug_item function in libr/bin/p/bin_dex.c in radare2 1.2.1 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file.
1217,CVE-2017-6310,"  file_add_mapi_attrs (File* file, MAPI_Attr** attrs)
 	    switch (a->name)
 	    {
 	    case MAPI_ATTACH_LONG_FILENAME:
		assert(a->type == szMAPI_STRING);
 		if (file->name) XFREE(file->name);
 		file->name = strdup( (char*)a->values[0].data.buf );
 		break;
 
 	    case MAPI_ATTACH_DATA_OBJ:
		assert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));
 		file->len = a->values[0].len;
 		if (file->data) XFREE (file->data);
 		file->data = CHECKED_XMALLOC (unsigned char, file->len);
 		memmove (file->data, a->values[0].data.buf, file->len);
 		break;
 
              case MAPI_ATTACH_MIME_TAG:
		assert(a->type == szMAPI_STRING);
 		if (file->mime_type) XFREE (file->mime_type);
 		file->mime_type = CHECKED_XMALLOC (char, a->values[0].len);
 		memmove (file->mime_type, a->values[0].data.buf, a->values[0].len);
 		break;
 
                 case MAPI_ATTACH_CONTENT_ID:
                    assert(a->type == szMAPI_STRING);
                     if (file->content_id) XFREE(file->content_id);
                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);
                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);","An issue was discovered in tnef before 1.4.13. Four type confusions have been identified in the file_add_mapi_attrs() function. These might lead to invalid read and write operations, controlled by an attacker."
1218,CVE-2017-6308,"  get_alloc_limit()
     return alloc_limit;
 }
 
size_t
check_mul_overflow(size_t a, size_t b, size_t* res)
{
    size_t tmp = a * b;
    if (a != 0 && tmp / a != b) return 1;
    *res = tmp;
    return 0;
}

 static void
 alloc_limit_failure (char *fn_name, size_t size)
 {
    fprintf (stderr,
              ""%s: Maximum allocation size exceeded ""
              ""(maxsize = %lu; size = %lu).\n"",
              fn_name,
             (unsigned long)alloc_limit,
              (unsigned long)size);
 }
 
  alloc_limit_assert (char *fn_name, size_t size)
 {
     if (alloc_limit && size > alloc_limit)
     {
        alloc_limit_failure (fn_name, size);
        exit (-1);
     }
 }
 
  
 void*
xmalloc (size_t num, size_t size)
 {
    size_t res;
    if (check_mul_overflow(num, size, &res))
        abort();

    void *ptr = malloc (res);
    if (!ptr
         && (size != 0))          
     {
         perror (""xmalloc: Memory allocation failure"");
  xmalloc (size_t size)
 
  
 void*
checked_xmalloc (size_t num, size_t size)
 {
    size_t res;
    if (check_mul_overflow(num, size, &res))
        abort();

    alloc_limit_assert (""checked_xmalloc"", res);
    return xmalloc (num, size);
 }
 
  
 void*
 xcalloc (size_t num, size_t size)
 {
    size_t res;
    if (check_mul_overflow(num, size, &res))
        abort();

    void *ptr;
    ptr = malloc(res);
     if (ptr)
     {
        memset (ptr, '\0', (res));
     }
     return ptr;
 }
  xcalloc (size_t num, size_t size)
 void*
 checked_xcalloc (size_t num, size_t size)
 {
    size_t res;
    if (check_mul_overflow(num, size, &res))
        abort();

    alloc_limit_assert (""checked_xcalloc"", (res));
     return xcalloc (num, size);
 }
1219,CVE-2017-6307,"  mapi_attr_read (size_t len, unsigned char *buf)
     uint32 i,j;
     assert(len > 4);
     uint32 num_properties = GETINT32(buf+idx);
    assert((num_properties+1) != 0);
     MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));
 
     idx += 4;
  mapi_attr_read (size_t len, unsigned char *buf)
 		     
 		    a->names[i].data 
 			= CHECKED_XMALLOC(unsigned char, a->names[i].len);
		    assert((idx+(a->names[i].len*2)) <= len);
 		    for (j = 0; j < (a->names[i].len >> 1); j++)
 			a->names[i].data[j] = (buf+idx)[j*2];
 
  mapi_attr_read (size_t len, unsigned char *buf)
 	    case szMAPI_BINARY:
 		CHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;
 
		assert(v->len + idx <= len);

 		if (a->type == szMAPI_UNICODE_STRING)
 		{
		    assert(v->len != 0);
 		    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);
 		}
 		else","An issue was discovered in tnef before 1.4.13. Two OOB Writes have been identified in src/mapi_attr.c:mapi_attr_read(). These might lead to invalid read and write operations, controlled by an attacker."
1220,CVE-2017-6214,"  ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 				ret = -EAGAIN;
 				break;
 			}
			 
			if (!skb_queue_empty(&sk->sk_receive_queue))
				break;
 			sk_wait_data(sk, &timeo, NULL);
 			if (signal_pending(current)) {
 				ret = sock_intr_errno(timeo);",The tcp_splice_read function in net/ipv4/tcp.c in the Linux kernel before 4.9.11 allows remote attackers to cause a denial of service (infinite loop and soft lockup) via vectors involving a TCP packet with the URG flag.
1221,CVE-2017-6194,"  static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sd
 		return NULL;
 	}
 	RBuffer *tbuf = r_buf_new ();
	if (!tbuf) {
		return NULL;
	}
 	r_buf_set_bytes (tbuf, buf, sz);
 	struct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);
 	r_buf_free (tbuf);
  static void __patch_reloc(RBuffer *buf, ut32 addr_to_patch, ut32 data_offset) {
 	r_buf_write_at (buf, addr_to_patch, (void *)val, sizeof (val));
 }
 
static int search_old_relocation (struct reloc_struct_t *reloc_table,
				  ut32 addr_to_patch, int n_reloc) {
 	int i;
 	for (i = 0; i < n_reloc; i++) {
 		if (addr_to_patch == reloc_table[i].data_offset) {
  static RList *relocs(RBinFile *arch) {
 			if (amount < n_got || amount > UT32_MAX) {
 				goto out_error;
 			}
			struct reloc_struct_t *got_table = calloc (
				1, n_got * sizeof (struct reloc_struct_t));
 			if (got_table) {
 				ut32 offset = 0;
 				for (i = 0; i < n_got ; offset += 4, i++) {",The relocs function in libr/bin/p/bin_bflt.c in radare2 1.2.1 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.
1222,CVE-2017-6074,"  int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 			if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
 								    skb) < 0)
 				return 1;
			consume_skb(skb);
			return 0;
 		}
 		if (dh->dccph_type == DCCP_PKT_RESET)
 			goto discard;","The dccp_rcv_state_process function in net/dccp/input.c in the Linux kernel through 4.9.11 mishandles DCCP_PKT_REQUEST packet data structures in the LISTEN state, which allows local users to obtain root privileges or cause a denial of service (double free) via an application that makes an IPV6_RECVPKTINFO setsockopt system call."
1223,CVE-2017-6001,"  static int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)
 	return 0;
 }
 
 
static struct perf_event_context *
__perf_event_ctx_lock_double(struct perf_event *group_leader,
			     struct perf_event_context *ctx)
{
	struct perf_event_context *gctx;

again:
	rcu_read_lock();
	gctx = READ_ONCE(group_leader->ctx);
	if (!atomic_inc_not_zero(&gctx->refcount)) {
		rcu_read_unlock();
		goto again;
	}
	rcu_read_unlock();

	mutex_lock_double(&gctx->mutex, &ctx->mutex);

	if (group_leader->ctx != gctx) {
		mutex_unlock(&ctx->mutex);
		mutex_unlock(&gctx->mutex);
		put_ctx(gctx);
		goto again;
	}

	return gctx;
}

  
		if (!(group_leader->group_caps & PERF_EV_CAP_SOFTWARE)) {
			 
			if (gctx != ctx) {
				err = -EINVAL;
				goto err_locked;
			} else {
				perf_event_ctx_unlock(group_leader, gctx);
				move_group = 0;
			}
		}
 	} else {
 		mutex_lock(&ctx->mutex);
 	}
  SYSCALL_DEFINE5(perf_event_open,
 	perf_unpin_context(ctx);
 
 	if (move_group)
		perf_event_ctx_unlock(group_leader, gctx);
 	mutex_unlock(&ctx->mutex);
 
 	if (task) {
  SYSCALL_DEFINE5(perf_event_open,
 
 err_locked:
 	if (move_group)
		perf_event_ctx_unlock(group_leader, gctx);
 	mutex_unlock(&ctx->mutex);
  
 	fput(event_file);",Race condition in kernel/events/core.c in the Linux kernel before 4.9.7 allows local users to gain privileges via a crafted application that makes concurrent perf_event_open system calls for moving a software group into a hardware context.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-6786.
1224,CVE-2017-5986,"  static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
		if (sk != asoc->base.sk)
			goto do_error;
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;",Race condition in the sctp_wait_for_sndbuf function in net/sctp/socket.c in the Linux kernel before 4.9.11 allows local users to cause a denial of service (assertion failure and panic) via a multithreaded application that peels off an association in a certain buffer-full state.
1225,CVE-2017-5985," 
 #include ""utils.h""
 #include ""network.h""
 
#define usernic_debug_stream(stream, format, ...)                              \
	do {                                                                   \
		fprintf(stream, ""%s: %d: %s: "" format, __FILE__, __LINE__,     \
			__func__, __VA_ARGS__);                                \
	} while (false)

#define usernic_error(format, ...) usernic_debug_stream(stderr, format, __VA_ARGS__)

 static void usage(char *me, bool fail)
 {
 	fprintf(stderr, ""Usage: %s lxcpath name pid type bridge nicname\n"", me);
  static bool create_db_dir(char *fnam)
 }
 
 #define VETH_DEF_NAME ""eth%d""
 static int rename_in_ns(int pid, char *oldname, char **newnamep)
 {
	uid_t ruid, suid, euid;
	int fret = -1;
	int fd = -1, ifindex = -1, ofd = -1, ret;
 	bool grab_newname = false;
 
 	ofd = lxc_preserve_ns(getpid(), ""net"");
 	if (ofd < 0) {
		usernic_error(""Failed opening network namespace path for '%d'."", getpid());
		return fret;
 	}
 
 	fd = lxc_preserve_ns(pid, ""net"");
 	if (fd < 0) {
		usernic_error(""Failed opening network namespace path for '%d'."", pid);
		goto do_partial_cleanup;
	}

	ret = getresuid(&ruid, &euid, &suid);
	if (ret < 0) {
		usernic_error(""Failed to retrieve real, effective, and saved ""
			      ""user IDs: %s\n"",
			      strerror(errno));
		goto do_partial_cleanup;
	}

	ret = setns(fd, CLONE_NEWNET);
	close(fd);
	fd = -1;
	if (ret < 0) {
		usernic_error(""Failed to setns() to the network namespace of ""
			      ""the container with PID %d: %s.\n"",
			      pid, strerror(errno));
		goto do_partial_cleanup;
 	}
 
	ret = setresuid(ruid, ruid, 0);
	if (ret < 0) {
		usernic_error(""Failed to drop privilege by setting effective ""
			      ""user id and real user id to %d, and saved user ""
			      ""ID to 0: %s.\n"",
			      ruid, strerror(errno));
		 
		 
		 
		goto do_full_cleanup;
 	}

 	if (!*newnamep) {
 		grab_newname = true;
 		*newnamep = VETH_DEF_NAME;

		ifindex = if_nametoindex(oldname);
		if (!ifindex) {
			usernic_error(""Failed to get netdev index: %s.\n"", strerror(errno));
			goto do_full_cleanup;
 		}
 	}

	ret = lxc_netdev_rename_by_name(oldname, *newnamep);
	if (ret < 0) {
		usernic_error(""Error %d renaming netdev %s to %s in container.\n"", ret, oldname, *newnamep);
		goto do_full_cleanup;
 	}

 	if (grab_newname) {
		char ifname[IFNAMSIZ];
		char *namep = ifname;

 		if (!if_indextoname(ifindex, namep)) {
			usernic_error(""Failed to get new netdev name: %s.\n"", strerror(errno));
			goto do_full_cleanup;
 		}

 		*newnamep = strdup(namep);
 		if (!*newnamep)
			goto do_full_cleanup;
 	}

	fret = 0;

do_full_cleanup:
	ret = setresuid(ruid, euid, suid);
	if (ret < 0) {
		usernic_error(""Failed to restore privilege by setting effective ""
			      ""user id to %d, real user id to %d, and saved user ""
			      ""ID to %d: %s.\n"",
			      ruid, euid, suid, strerror(errno));
		fret = -1;
		 
		 
		 
 	}
 
	ret = setns(ofd, CLONE_NEWNET);
	if (ret < 0) {
		usernic_error(""Failed to setns() to original network namespace ""
			      ""of PID %d: %s.\n"",
			      ofd, strerror(errno));
		fret = -1;
	}
 
do_partial_cleanup:
 	if (fd >= 0)
 		close(fd);
	close(ofd);

	return fret;
 }
 
 /*",lxc-user-nic in Linux Containers (LXC) allows local users with a lxc-usernet allocation to create network interfaces on the host and choose the name of those interfaces by leveraging lack of netns ownership check.
1226,CVE-2017-5970,"  void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
 		pktinfo->ipi_ifindex = 0;
 		pktinfo->ipi_spec_dst.s_addr = 0;
 	}
	 
	if (unlikely(IPCB(skb)->opt.optlen))
		skb_dst_force(skb);
	else
		skb_dst_drop(skb);
 }
 
 int ip_setsockopt(struct sock *sk, int level,",The ipv4_pktinfo_prepare function in net/ipv4/ip_sockglue.c in the Linux kernel through 4.9.9 allows attackers to cause a denial of service (system crash) via (1) an application that makes crafted system calls or possibly (2) IPv4 traffic with invalid IP options.
1227,CVE-2017-5940,"  static void skel(const char *homedir, uid_t u, gid_t g) {
 		 
 		if (stat(fname, &s) == 0)
 			return;
		if (is_link(fname)) {  
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
 		}
 		else {
  static void skel(const char *homedir, uid_t u, gid_t g) {
 		 
 		if (stat(fname, &s) == 0)
 			return;
		if (is_link(fname)) {  
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
 		}
 		else {
  static void skel(const char *homedir, uid_t u, gid_t g) {
 		 
 		if (stat(fname, &s) == 0) 
 			return;
		if (is_link(fname)) {  
			fprintf(stderr, ""Error: invalid %s file\n"", fname);
			exit(1);
		}
 		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			copy_file_as_user(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
 		}
 		free(fname);
  static int store_xauthority(void) {
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
	 
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
  static int store_asoundrc(void) {
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
	 
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");","Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."
1228,CVE-2017-5923,"  static const yytype_uint16 yyrline[] =
      347,   353,   356,   374,   387,   424,   425,   430,   446,   459,
      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,
      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,
     802,   806,   833,   871,   917,   939,   948,   957,   972,   984,
     998,  1011,  1022,  1033,  1063,  1032,  1177,  1176,  1255,  1261,
    1268,  1267,  1330,  1329,  1390,  1399,  1408,  1417,  1426,  1435,
    1444,  1448,  1456,  1457,  1462,  1484,  1496,  1512,  1511,  1517,
    1528,  1529,  1534,  1541,  1552,  1553,  1557,  1565,  1569,  1579,
    1593,  1609,  1619,  1628,  1653,  1665,  1677,  1693,  1705,  1721,
    1766,  1785,  1803,  1821,  1839,  1865,  1883,  1893,  1903,  1913,
    1923,  1933,  1943
 };
 #endif
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           case EXPRESSION_TYPE_REGEXP:
             strlcpy((yyval.c_string), ""r"", MAX_FUNCTION_ARGS);
             break;
          default:
            assert(FALSE);
         }
 
         ERROR_IF((yyval.c_string) == NULL);
       }
#line 2371 ""grammar.c""  
     break;
 
   case 52:
#line 834 ""grammar.y""  
     {
         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
             case EXPRESSION_TYPE_REGEXP:
               strlcat((yyvsp[-2].c_string), ""r"", MAX_FUNCTION_ARGS);
               break;
            default:
              assert(FALSE);
           }
         }
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
 
         (yyval.c_string) = (yyvsp[-2].c_string);
       }
#line 2409 ""grammar.c""  
     break;
 
   case 53:
#line 872 ""grammar.y""  
     {
         SIZED_STRING* sized_string = (yyvsp[0].sized_string);
         RE* re;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
       }
#line 2455 ""grammar.c""  
     break;
 
   case 54:
#line 918 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2478 ""grammar.c""  
     break;
 
   case 55:
#line 940 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2491 ""grammar.c""  
     break;
 
   case 56:
#line 949 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 0, NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2504 ""grammar.c""  
     break;
 
   case 57:
#line 958 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""matches"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, ""matches"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2523 ""grammar.c""  
     break;
 
   case 58:
#line 973 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, ""contains"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, ""contains"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2539 ""grammar.c""  
     break;
 
   case 59:
#line 985 ""grammar.y""  
     {
         int result = yr_parser_reduce_string_identifier(
             yyscanner,
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2557 ""grammar.c""  
     break;
 
   case 60:
#line 999 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""at"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2574 ""grammar.c""  
     break;
 
   case 61:
#line 1012 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2589 ""grammar.c""  
     break;
 
   case 62:
#line 1023 ""grammar.y""  
     {
         if (compiler->loop_depth > 0)
         {
           compiler->loop_depth--;
           compiler->loop_identifier[compiler->loop_depth] = NULL;
         }

        YYERROR;
       }
#line 2603 ""grammar.c""  
     break;
 
   case 63:
#line 1033 ""grammar.y""  
     {
         int var_index;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2637 ""grammar.c""  
     break;
 
   case 64:
#line 1063 ""grammar.y""  
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2676 ""grammar.c""  
     break;
 
   case 65:
#line 1098 ""grammar.y""  
     {
         int mem_offset;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2759 ""grammar.c""  
     break;
 
   case 66:
#line 1177 ""grammar.y""  
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2793 ""grammar.c""  
     break;
 
   case 67:
#line 1207 ""grammar.y""  
     {
         int mem_offset;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2846 ""grammar.c""  
     break;
 
   case 68:
#line 1256 ""grammar.y""  
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2856 ""grammar.c""  
     break;
 
   case 69:
#line 1262 ""grammar.y""  
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2866 ""grammar.c""  
     break;
 
   case 70:
#line 1268 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2896 ""grammar.c""  
     break;
 
   case 71:
#line 1294 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2936 ""grammar.c""  
     break;
 
   case 72:
#line 1330 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2965 ""grammar.c""  
     break;
 
   case 73:
#line 1355 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3005 ""grammar.c""  
     break;
 
   case 74:
#line 1391 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3018 ""grammar.c""  
     break;
 
   case 75:
#line 1400 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3031 ""grammar.c""  
     break;
 
   case 76:
#line 1409 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3044 ""grammar.c""  
     break;
 
   case 77:
#line 1418 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3057 ""grammar.c""  
     break;
 
   case 78:
#line 1427 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3070 ""grammar.c""  
     break;
 
   case 79:
#line 1436 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3083 ""grammar.c""  
     break;
 
   case 80:
#line 1445 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3091 ""grammar.c""  
     break;
 
   case 81:
#line 1449 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3099 ""grammar.c""  
     break;
 
   case 82:
#line 1456 ""grammar.y""  
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3105 ""grammar.c""  
     break;
 
   case 83:
#line 1457 ""grammar.y""  
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3111 ""grammar.c""  
     break;
 
   case 84:
#line 1463 ""grammar.y""  
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3133 ""grammar.c""  
     break;
 
   case 85:
#line 1485 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3149 ""grammar.c""  
     break;
 
   case 86:
#line 1497 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3164 ""grammar.c""  
     break;
 
   case 87:
#line 1512 ""grammar.y""  
     {
          
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3173 ""grammar.c""  
     break;
 
   case 89:
#line 1518 ""grammar.y""  
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3184 ""grammar.c""  
     break;
 
   case 92:
#line 1535 ""grammar.y""  
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3195 ""grammar.c""  
     break;
 
   case 93:
#line 1542 ""grammar.y""  
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3206 ""grammar.c""  
     break;
 
   case 95:
#line 1554 ""grammar.y""  
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3214 ""grammar.c""  
     break;
 
   case 96:
#line 1558 ""grammar.y""  
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3222 ""grammar.c""  
     break;
 
   case 97:
#line 1566 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3230 ""grammar.c""  
     break;
 
   case 98:
#line 1570 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3244 ""grammar.c""  
     break;
 
   case 99:
#line 1580 ""grammar.y""  
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3262 ""grammar.c""  
     break;
 
   case 100:
#line 1594 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3282 ""grammar.c""  
     break;
 
   case 101:
#line 1610 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3296 ""grammar.c""  
     break;
 
   case 102:
#line 1620 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3309 ""grammar.c""  
     break;
 
   case 103:
#line 1629 ""grammar.y""  
     {
         SIZED_STRING* sized_string;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3338 ""grammar.c""  
     break;
 
   case 104:
#line 1654 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3354 ""grammar.c""  
     break;
 
   case 105:
#line 1666 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3370 ""grammar.c""  
     break;
 
   case 106:
#line 1678 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3390 ""grammar.c""  
     break;
 
   case 107:
#line 1694 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3406 ""grammar.c""  
     break;
 
   case 108:
#line 1706 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3426 ""grammar.c""  
     break;
 
   case 109:
#line 1722 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3475 ""grammar.c""  
     break;
 
   case 110:
#line 1767 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3498 ""grammar.c""  
     break;
 
   case 111:
#line 1786 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3520 ""grammar.c""  
     break;
 
   case 112:
#line 1804 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3542 ""grammar.c""  
     break;
 
   case 113:
#line 1822 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3564 ""grammar.c""  
     break;
 
   case 114:
#line 1840 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3594 ""grammar.c""  
     break;
 
   case 115:
#line 1866 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3616 ""grammar.c""  
     break;
 
   case 116:
#line 1884 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3630 ""grammar.c""  
     break;
 
   case 117:
#line 1894 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3644 ""grammar.c""  
     break;
 
   case 118:
#line 1904 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3658 ""grammar.c""  
     break;
 
   case 119:
#line 1914 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3672 ""grammar.c""  
     break;
 
   case 120:
#line 1924 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3686 ""grammar.c""  
     break;
 
   case 121:
#line 1934 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3700 ""grammar.c""  
     break;
 
   case 122:
#line 1944 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3708 ""grammar.c""  
     break;
 
 
#line 3712 ""grammar.c""  
       default: break;
     }
    
#line 1949 ""grammar.y""  
 ",libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted rule that is mishandled in the yara_yyparse function.
1229,CVE-2017-5850," 
 
 
  
 #define MEDIATYPE_TYPEMAX	64	 
  enum httpchunk {
 	TOREAD_HTTP_HEADER		= -2,
 	TOREAD_HTTP_CHUNK_LENGTH	= -3,
 	TOREAD_HTTP_CHUNK_TRAILER	= -4,
	TOREAD_HTTP_NONE		= -5,
	TOREAD_HTTP_RANGE		= TOREAD_HTTP_CHUNK_LENGTH
 };
 
 #if DEBUG
  struct fcgi_data {
 	int			 headersdone;
 };
 
struct range {
	off_t	start;
	off_t	end;
};

struct range_data {
	struct range		 range[SERVER_MAX_RANGES];
	int			 range_count;
	int			 range_index;
	off_t			 range_toread;

	 
	struct media_type	*range_media;
	size_t			 range_total;
};

 struct client {
 	uint32_t		 clt_id;
 	pid_t			 clt_pid;
  struct client {
 	void			*clt_descreq;
 	void			*clt_descresp;
 	int			 clt_sndbufsiz;
	uint64_t		 clt_boundary;
 
 	int			 clt_fd;
 	struct tls		*clt_tls_ctx;
  struct client {
 	int			 clt_done;
 	int			 clt_chunk;
 	int			 clt_inflight;
	struct range_data	 clt_ranges;
 	struct fcgi_data	 clt_fcgi;
 	char			*clt_remote_user;
 	struct evbuffer		*clt_srvevb;
  const char
 	*server_httperror_byid(unsigned int);
 void	 server_read_httpcontent(struct bufferevent *, void *);
 void	 server_read_httpchunks(struct bufferevent *, void *);
void	 server_read_httprange(struct bufferevent *, void *);
 int	 server_writeheader_http(struct client *clt, struct kv *, void *);
 int	 server_headers(struct client *, void *,
 	    int (*)(struct client *, struct kv *, void *), void *);",httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.
1230,CVE-2017-5847,"  gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,
           break;
         }
         case ASF_DEMUX_DATA_TYPE_DWORD:{
          guint uint_val;

          if (value_len < 4)
            break;

          uint_val = GST_READ_UINT32_LE (value);
 
            
           g_value_init (&tag_value, G_TYPE_UINT);
  gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,
         }
            
         case ASF_DEMUX_DATA_TYPE_BOOL:{
          gboolean bool_val;

          if (value_len < 4)
            break;

          bool_val = GST_READ_UINT32_LE (value);
 
           if (strncmp (""Stereoscopic"", name_utf8, strlen (name_utf8)) == 0) {
             if (bool_val) {",The gst_asf_demux_process_ext_content_desc function in gst/asfdemux/gstasfdemux.c in gst-plugins-ugly in GStreamer allows remote attackers to cause a denial of service (out-of-bounds heap read) via vectors involving extended content descriptors.
1231,CVE-2017-5669,"  SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
  * ""raddr"" thing points to kernel space, and there has to be a wrapper around
  * this.
  */
long do_shmat(int shmid, char __user *shmaddr, int shmflg,
	      ulong *raddr, unsigned long shmlba)
 {
 	struct shmid_kernel *shp;
 	unsigned long addr;
  long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,
 		goto out;
 	else if ((addr = (ulong)shmaddr)) {
 		if (addr & (shmlba - 1)) {
			 
			if ((shmflg & SHM_RND) && addr >= shmlba)
				addr &= ~(shmlba - 1);
 			else
 #ifndef __ARCH_FORCE_SHMLBA
 				if (addr & ~PAGE_MASK)","The do_shmat function in ipc/shm.c in the Linux kernel through 4.9.12 does not restrict the address calculated by a certain rounding operation, which allows local users to map page zero, and consequently bypass a protection mechanism that exists for the mmap system call, by making crafted shmget and shmat system calls in a privileged context."
1232,CVE-2017-5668,"  static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_conditio
 	 
 	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);

	if (!px->ft) {
		return FALSE;
	}
 	px->ft->data = px;
 
 	px->ft->accept = prpl_xfer_accept;",bitlbee-libpurple before 3.5.1 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-10189.
1233,CVE-2017-5601,"  lha_read_file_header_1(struct archive_read *a, struct lha *lha)
 	 
 	lha->compsize -= extdsize - 2;
 
	if (lha->compsize < 0)
		goto invalid;	 

 	if (sum_calculated != headersum) {
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
 		    ""LHa header sum error"");",An error in the lha_read_file_header_1() function (archive_read_support_format_lha.c) in libarchive 3.2.2 allows remote attackers to trigger an out-of-bounds read memory access and subsequently cause a crash via a specially crafted archive.
1234,CVE-2017-5593,"  bool JT_PushMessage::take(const QDomElement &e)
 	QDomElement forward;
 	Message::CarbonDir cd = Message::NoCarbon;
 
	Jid fromJid = Jid(e1.attribute(QLatin1String(""from"")));
 	 
 	QDomNodeList list = e1.childNodes();
 	for (int i = 0; i < list.size(); ++i) {
 		QDomElement el = list.at(i).toElement();
 
		if (el.attribute(""xmlns"") == QLatin1String(""urn:xmpp:carbons:2"")
		    && (el.tagName() == QLatin1String(""received"") || el.tagName() == QLatin1String(""sent""))
		    && fromJid.compare(Jid(e1.attribute(QLatin1String(""to""))), false)) {
 			QDomElement el1 = el.firstChildElement();
			if (el1.tagName() == QLatin1String(""forwarded"")
			    && el1.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) {
 				QDomElement el2 = el1.firstChildElement(QLatin1String(""message""));
 				if (!el2.isNull()) {
 					forward = el2;
  bool JT_PushMessage::take(const QDomElement &e)
 				}
 			}
 		}
		else if (el.tagName() == QLatin1String(""forwarded"")
			 && el.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) {
 			forward = el.firstChildElement(QLatin1String(""message""));  
 			 
 			if (!forward.isNull()) {
  bool JT_PushMessage::take(const QDomElement &e)
 		}
 	}
 
 	Stanza s = client()->stream().createStanza(addCorrectNS(forward.isNull()? e1 : forward));
 	if(s.isNull()) {
 		 
  bool JT_PushMessage::take(const QDomElement &e)
 		return false;
 	}
 	if (!forward.isNull()) {
		m.setForwardedFrom(fromJid);
 		m.setCarbonDirection(cd);
 	}
 ","An incorrect implementation of *XEP-0280: Message Carbons* in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for Psi+ (0.16.563.580 - 0.16.571.627)."
1235,CVE-2017-5592,"  _handle_carbons(xmpp_stanza_t *const stanza)
         return TRUE;
     }
 
    Jid *my_jid = jid_create(connection_get_fulljid());
    const char *const stanza_from = xmpp_stanza_get_from(stanza);
    Jid *msg_jid = jid_create(stanza_from);
    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {
        log_warning(""Invalid carbon received, from: %s"", stanza_from);
        return TRUE;
    }

     const gchar *to = xmpp_stanza_get_to(message);
     const gchar *from = xmpp_stanza_get_from(message);
 
  _handle_carbons(xmpp_stanza_t *const stanza)
 
     Jid *jid_from = jid_create(from);
     Jid *jid_to = jid_create(to);
 
      
     char *enc_message = NULL;","An incorrect implementation of *XEP-0280: Message Carbons* in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0)."
1236,CVE-2017-5581,"  void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)
   int stride;
   U8 *buf;
   int w, h, b;
  Rect drect;
 
  drect = r;
  if (!drect.enclosed_by(getRect())) {
    vlog.error(""Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d"",
               drect.width(), drect.height(), drect.tl.x, drect.tl.y, width_, height_);
    drect = drect.intersect(getRect());
  }

  if (drect.is_empty())
    return;

  w = drect.width();
  h = drect.height();
   b = format.bpp/8;
 
   if (h == 0)
     return;
 
  buf = getBufferRW(drect, &stride);
 
   if (b == 1) {
     while (h--) {
  void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)
     }
   }
 
  commitBufferRW(drect);
 }
 
 void ModifiablePixelBuffer::imageRect(const Rect& r,",Buffer overflow in the ModifiablePixelBuffer::fillRect function in TigerVNC before 1.7.1 allows remote servers to execute arbitrary code via an RRE message with subrectangle outside framebuffer boundaries.
1237,CVE-2017-5577,"  vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)
 					  sizeof(struct vc4_shader_state)) ||
 	    temp_size < exec_size) {
 		DRM_ERROR(""overflow in exec arguments\n"");
		ret = -EINVAL;
 		goto fail;
 	}
 ","The vc4_get_bcl function in drivers/gpu/drm/vc4/vc4_gem.c in the VideoCore DRM driver in the Linux kernel before 4.9.7 does not set an errno value upon certain overflow detections, which allows local users to cause a denial of service (incorrect pointer dereference and OOPS) via inconsistent size values in a VC4_SUBMIT_CL ioctl call."
1238,CVE-2017-5576,"  vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)
 					  args->shader_rec_count);
 	struct vc4_bo *bo;
 
	if (shader_rec_offset < args->bin_cl_size ||
	    uniforms_offset < shader_rec_offset ||
 	    exec_size < uniforms_offset ||
 	    args->shader_rec_count >= (UINT_MAX /
 					  sizeof(struct vc4_shader_state)) ||",Integer overflow in the vc4_get_bcl function in drivers/gpu/drm/vc4/vc4_gem.c in the VideoCore DRM driver in the Linux kernel before 4.9.7 allows local users to cause a denial of service or possibly have unspecified other impact via a crafted size value in a VC4_SUBMIT_CL ioctl call.
1239,CVE-2017-5551,"  int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	int error;
 
 	if (type == ACL_TYPE_ACCESS) {
		error = posix_acl_update_mode(inode,
				&inode->i_mode, &acl);
		if (error)
			return error;
 	}
 
 	inode->i_ctime = current_time(inode);","The simple_set_acl function in fs/posix_acl.c in the Linux kernel before 4.9.6 preserves the setgid bit during a setxattr call involving a tmpfs filesystem, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-7097."
1240,CVE-2017-5550,"  size_t iov_iter_copy_from_user_atomic(struct page *page,
 }
 EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);
 
static inline void pipe_truncate(struct iov_iter *i)
{
	struct pipe_inode_info *pipe = i->pipe;
	if (pipe->nrbufs) {
		size_t off = i->iov_offset;
		int idx = i->idx;
		int nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);
		if (off) {
			pipe->bufs[idx].len = off - pipe->bufs[idx].offset;
			idx = next_idx(idx, pipe);
			nrbufs++;
		}
		while (pipe->nrbufs > nrbufs) {
			pipe_buf_release(pipe, &pipe->bufs[idx]);
			idx = next_idx(idx, pipe);
			pipe->nrbufs--;
		}
	}
}

 static void pipe_advance(struct iov_iter *i, size_t size)
 {
 	struct pipe_inode_info *pipe = i->pipe;
 	if (unlikely(i->count < size))
 		size = i->count;
 	if (size) {
		struct pipe_buffer *buf;
		size_t off = i->iov_offset, left = size;
		int idx = i->idx;
 		if (off)  
			left += off - pipe->bufs[idx].offset;
 		while (1) {
 			buf = &pipe->bufs[idx];
			if (left <= buf->len)
 				break;
			left -= buf->len;
 			idx = next_idx(idx, pipe);
 		}
 		i->idx = idx;
		i->iov_offset = buf->offset + left;
 	}
	i->count -= size;
	 
	pipe_truncate(i);
 }
 
 void iov_iter_advance(struct iov_iter *i, size_t size)
  void iov_iter_pipe(struct iov_iter *i, int direction,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
	WARN_ON(pipe->nrbufs == pipe->buffers);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);",Off-by-one error in the pipe_advance function in lib/iov_iter.c in the Linux kernel before 4.9.5 allows local users to obtain sensitive information from uninitialized heap-memory locations in opportunistic circumstances by reading from a pipe after an incorrect buffer-release decision.
1241,CVE-2017-5549,"  static int klsi_105_get_line_state(struct usb_serial_port *port,
 			     status_buf, KLSI_STATUSBUF_LEN,
 			     10000
 			     );
	if (rc != KLSI_STATUSBUF_LEN) {
		dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
		if (rc >= 0)
			rc = -EIO;
	} else {
 		status = get_unaligned_le16(status_buf);
 
 		dev_info(&port->serial->dev->dev, ""read status %x %x\n"",","The klsi_105_get_line_state function in drivers/usb/serial/kl5kusb105.c in the Linux kernel before 4.9.5 places uninitialized heap-memory contents into a log entry upon a failure to read the line status, which allows local users to obtain sensitive information by reading the log."
1242,CVE-2017-5548,"  static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
 	int ret;
	uint8_t *buffer;
 	uint8_t value;
 
	buffer = kmalloc(1, GFP_KERNEL);
	if (!buffer)
		return -ENOMEM;

 	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, buffer, 1, 1000);

	if (ret >= 0) {
		value = buffer[0];
		kfree(buffer);
		return value;
	} else {
		kfree(buffer);
		return ret;
	}
 }
 
 static int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,
  static const struct ieee802154_ops atusb_ops = {
 static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char *buffer;
 	int ret;
 
	buffer = kmalloc(3, GFP_KERNEL);
	if (!buffer)
		return -ENOMEM;

 	 
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
  static int atusb_get_and_show_revision(struct atusb *atusb)
 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 
	kfree(buffer);
 	return ret;
 }
 
 static int atusb_get_and_show_build(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	char *build;
 	int ret;
 
	build = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);
	if (!build)
		return -ENOMEM;

 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,
 				build, ATUSB_BUILD_SIZE, 1000);
  static int atusb_get_and_show_build(struct atusb *atusb)
 		dev_info(&usb_dev->dev, ""Firmware: build %s\n"", build);
 	}
 
	kfree(build);
 	return ret;
 }
 ","drivers/net/ieee802154/atusb.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1243,CVE-2017-5547,"  static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)
 	struct usb_interface *usbif = to_usb_interface(dev->parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int brightness;
	char *data;

	data = kmalloc(8, GFP_KERNEL);
	if (!data)
		return -ENOMEM;
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
  static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)
 	if (ret < 0) {
 		dev_warn(dev, ""Failed to get K90 initial state (error %d).\n"",
 			 ret);
		ret = -EIO;
		goto out;
 	}
 	brightness = data[4];
 	if (brightness < 0 || brightness > 3) {
 		dev_warn(dev,
 			 ""Read invalid backlight brightness: %02hhx.\n"",
 			 data[4]);
		ret = -EIO;
		goto out;
 	}
	ret = brightness;
out:
	kfree(data);

	return ret;
 }
 
 static enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)
  static ssize_t k90_show_macro_mode(struct device *dev,
 	struct usb_interface *usbif = to_usb_interface(dev->parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	const char *macro_mode;
	char *data;

	data = kmalloc(2, GFP_KERNEL);
	if (!data)
		return -ENOMEM;
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_GET_MODE,
  static ssize_t k90_show_macro_mode(struct device *dev,
 	if (ret < 0) {
 		dev_warn(dev, ""Failed to get K90 initial mode (error %d).\n"",
 			 ret);
		ret = -EIO;
		goto out;
 	}
 
 	switch (data[0]) {
  static ssize_t k90_show_macro_mode(struct device *dev,
 	default:
 		dev_warn(dev, ""K90 in unknown mode: %02hhx.\n"",
 			 data[0]);
		ret = -EIO;
		goto out;
 	}
 
	ret = snprintf(buf, PAGE_SIZE, ""%s\n"", macro_mode);
out:
	kfree(data);

	return ret;
 }
 
 static ssize_t k90_store_macro_mode(struct device *dev,
  static ssize_t k90_show_current_profile(struct device *dev,
 	struct usb_interface *usbif = to_usb_interface(dev->parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int current_profile;
	char *data;

	data = kmalloc(8, GFP_KERNEL);
	if (!data)
		return -ENOMEM;
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
  static ssize_t k90_show_current_profile(struct device *dev,
 	if (ret < 0) {
 		dev_warn(dev, ""Failed to get K90 initial state (error %d).\n"",
 			 ret);
		ret = -EIO;
		goto out;
 	}
 	current_profile = data[7];
 	if (current_profile < 1 || current_profile > 3) {
 		dev_warn(dev, ""Read invalid current profile: %02hhx.\n"",
 			 data[7]);
		ret = -EIO;
		goto out;
 	}
 
	ret = snprintf(buf, PAGE_SIZE, ""%d\n"", current_profile);
out:
	kfree(data);

	return ret;
 }
 
 static ssize_t k90_store_current_profile(struct device *dev,","drivers/hid/hid-corsair.c in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
1244,CVE-2017-5546,"  union freelist_init_state {
 		unsigned int pos;
 		unsigned int *list;
 		unsigned int count;
 	};
 	struct rnd_state rnd_state;
 };
  static bool freelist_state_initialize(union freelist_init_state *state,
 	} else {
 		state->list = cachep->random_seq;
 		state->count = count;
		state->pos = rand % count;
 		ret = true;
 	}
 	return ret;
  static bool freelist_state_initialize(union freelist_init_state *state,
  
 static freelist_idx_t next_random_slot(union freelist_init_state *state)
 {
	if (state->pos >= state->count)
		state->pos = 0;
	return state->list[state->pos++];
 }
 
  ",The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.
1245,CVE-2017-5545,"  int main(int argc, char *argv[])
     }
 
     stat(options->in_file, &filestats);

    if (filestats.st_size < 8) {
        printf(""ERROR: Input file is too small to contain valid plist data.\n"");
        return -1;
    }

     plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));
     read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);
     fclose(iplist);",The main function in plistutil.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via Apple Property List data that is too short.
1246,CVE-2017-5522,"  char *FLTGetIsLikeComparisonExpression(FilterEncodingNode *psFilterNode)
 
   pszValue = psFilterNode->psRightNode->pszValue;
   nLength = strlen(pszValue);
  if( 1 + 2 * nLength + 1 + 1 >= sizeof(szTmp) )
      return NULL;
 
   iTmp =0;
   if (nLength > 0 && pszValue[0] != pszWild[0] &&","Stack-based buffer overflow in MapServer before 6.0.6, 6.2.x before 6.2.4, 6.4.x before 6.4.5, and 7.0.x before 7.0.4 allows remote attackers to cause a denial of service (crash) or execute arbitrary code via vectors involving WFS get feature requests."
1247,CVE-2017-5511,"  ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
              
            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
             combined_length+=length+1;
             if (length > 0)
               (void) ReadBlob(image,(size_t) length++,layer_info[i].name);","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact by leveraging an improper cast, which triggers a heap-based buffer overflow."
1248,CVE-2017-5510,"  static size_t WritePSDChannel(const PSDInfo *psd_info,
     next_image->depth=16;
   monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
     MagickTrue : MagickFalse;
  quantum_info=AcquireQuantumInfo(image_info,next_image);
   if (quantum_info == (QuantumInfo *) NULL)
     return(0);
   pixels=(unsigned char *) GetQuantumPixels(quantum_info);","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."
1249,CVE-2017-5509,"  static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,
   if (length > row_size + 256)  
     {
       pixels=(unsigned char *) RelinquishMagickMemory(pixels);
      ThrowBinaryException(ResourceLimitError,""InvalidLength"",image->filename);
     }
 
   compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));
  ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
                 if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                   {
                     layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                   }
               }
             length=ReadBlobLong(image);
  static unsigned char *AcquireCompactPixels(const Image *image,
   if (compact_pixels == (unsigned char *) NULL)
     {
       (void) ThrowMagickException(exception,GetMagickModule(),
        ResourceLimitError,""MemoryAllocationFailed"",""`%s'"",image->filename);
     }
   return(compact_pixels);
 }
  static size_t WritePSDChannels(const PSDInfo *psd_info,
   compact_pixels=(unsigned char *) NULL;
   if (next_image->compression == RLECompression)
     {
      compact_pixels=AcquireCompactPixels(next_image,exception);
       if (compact_pixels == (unsigned char *) NULL)
         return(0);
     }","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."
1250,CVE-2017-5506,"  static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)
             The directory entry contains an offset.
           */
           offset=(ssize_t) ReadProfileLong(endian,q+8);
          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))
             continue;
          if (~length < number_bytes)
            continue;   
           p=(unsigned char *) (exif+offset);
         }
       switch (tag_value)",Double free vulnerability in magick/profile.c in ImageMagick allows remote attackers to have unspecified impact via a crafted file.
1251,CVE-2017-5340,"  ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_
 	GC_REFCOUNT(ht) = 1;
 	GC_TYPE_INFO(ht) = IS_ARRAY;
 	ht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;
 	ht->nTableMask = HT_MIN_MASK;
 	HT_SET_DATA_ADDR(ht, &uninitialized_bucket);
 	ht->nNumUsed = 0;
 	ht->nNumOfElements = 0;
 	ht->nInternalPointer = HT_INVALID_IDX;
 	ht->nNextFreeElement = 0;
 	ht->pDestructor = pDestructor;
	ht->nTableSize = zend_hash_check_size(nSize);
 }
 
 static void ZEND_FASTCALL zend_hash_packed_grow(HashTable *ht)","Zend/zend_hash.c in PHP before 7.0.15 and 7.1.x before 7.1.1 mishandles certain cases that require large array allocations, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow, uninitialized memory access, and use of arbitrary destructor function pointers) via crafted serialized data."
1252,CVE-2017-5226,"  main (int    argc,
    
   unblock_sigchild ();
 
  if (setsid () == (pid_t) -1)
    die_with_error (""setsid"");

   if (label_exec (opt_exec_label) == -1)
     die_with_error (""label_exec %s"", argv[0]);
 ","When executing a program via the bubblewrap sandbox, the nonpriv session can escape to the parent session by using the TIOCSTI ioctl to push characters into the terminal's input buffer, allowing an attacker to escape the sandbox."
1253,CVE-2017-5209,"  static const signed char base64_table[256] = {
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
 	-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
 	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
 	-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
  size_t base64encode(char *outbuf, const unsigned char *buf, size_t size)
 	return m;
 }
 
 unsigned char *base64decode(const char *buf, size_t *size)
 {
 	if (!buf || !size) return NULL;
  unsigned char *base64decode(const char *buf, size_t *size)
 	unsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);
 	const char *ptr = buf;
 	int p = 0;
	int wv, w1, w2, w3, w4;
	int tmpval[4];
	int tmpcnt = 0;
 
 	do {
		while (ptr < buf+len && (*ptr == ' ' || *ptr == '\t' || *ptr == '\n' || *ptr == '\r')) {
			ptr++;
		}
 		if (*ptr == '\0' || ptr >= buf+len) {
 			break;
 		}
		if ((wv = base64_table[(int)(unsigned char)*ptr++]) == -1) {
			continue;
		}
		tmpval[tmpcnt++] = wv;
		if (tmpcnt == 4) {
			tmpcnt = 0;
			w1 = tmpval[0];
			w2 = tmpval[1];
			w3 = tmpval[2];
			w4 = tmpval[3];

			if (w2 >= 0) {
				outbuf[p++] = (unsigned char)(((w1 << 2) + (w2 >> 4)) & 0xFF);
			}
			if (w3 >= 0) {
				outbuf[p++] = (unsigned char)(((w2 << 4) + (w3 >> 2)) & 0xFF);
			}
			if (w4 >= 0) {
				outbuf[p++] = (unsigned char)(((w3 << 6) + w4) & 0xFF);
			}
 		}
 	} while (1);
 ",The base64decode function in base64.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via split encoded Apple Property List data.
1254,CVE-2017-3737,"  extern ""C"" {
 # define SSL_ST_BEFORE                   0x4000
 # define SSL_ST_OK                       0x03
 # define SSL_ST_RENEGOTIATE              (0x04|SSL_ST_INIT)
# define SSL_ST_ERR                      (0x05|SSL_ST_INIT)
 
 # define SSL_CB_LOOP                     0x01
 # define SSL_CB_EXIT                     0x02","OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an *error state* mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected."
1255,CVE-2017-3735,"  static int length_from_afi(const unsigned afi)
  */
 unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)
 {
    if (f == NULL
            || f->addressFamily == NULL
            || f->addressFamily->data == NULL
            || f->addressFamily->length < 2)
        return 0;
    return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1];
 }
 
 /*","While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g."
1256,CVE-2017-3733,"  extern ""C"" {
 # define TLS1_FLAGS_SKIP_CERT_VERIFY             0x0010
 
  
# define TLS1_FLAGS_ENCRYPT_THEN_MAC_READ        0x0100
# define TLS1_FLAGS_ENCRYPT_THEN_MAC             TLS1_FLAGS_ENCRYPT_THEN_MAC_READ
 
  
 # define TLS1_FLAGS_RECEIVED_EXTMS               0x0200
 
# define TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE       0x0400

 # define SSL3_MT_HELLO_REQUEST                   0
 # define SSL3_MT_CLIENT_HELLO                    1
 # define SSL3_MT_SERVER_HELLO                    2",During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected.
1257,CVE-2017-3731,"  static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8
                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];
              
            if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)
                return 0;
             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
              
            if (!EVP_CIPHER_CTX_encrypting(c)) {
                if (len < EVP_GCM_TLS_TAG_LEN)
                    return 0;
                 len -= EVP_GCM_TLS_TAG_LEN;
            }
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;
         }
  static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8
                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];
              
            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)
                return 0;
             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;
              
            if (!EVP_CIPHER_CTX_encrypting(c)) {
                if (len < cctx->M)
                    return 0;
                 len -= cctx->M;
            }
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;
             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;
         }","If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k."
1258,CVE-2017-3730,"  static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)
         return 0;
     }
     ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);
        return 0;
    }

     dh_clnt = EVP_PKEY_get0_DH(ckey);
 
     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {
  static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
     }
 
     ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        goto err;
    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);","In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack."
1259,CVE-2017-2920,"  int ofx_proc_file(LibofxContextPtr ctx, const char * p_filename)
 string sanitize_proprietary_tags(string input_string)
 {
   unsigned int i;
   bool strip = false;
   bool tag_open = false;
   int tag_open_idx = 0;  
  string sanitize_proprietary_tags(string input_string)
     close_tagname[i] = 0;
   }
 
  size_t input_string_size = input_string.size();

   
   
   
   
   
   
   
   
  for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)
   {
     if (input_string.c_str()[i] == '<')
     {","An memory corruption vulnerability exists in the .SVG parsing functionality of Computerinsel Photoline 20.02. A specially crafted .SVG file can cause a vulnerability resulting in memory corruption, which can potentially lead to arbitrary code execution. An attacker can send a specific .SVG file to trigger this vulnerability."
1260,CVE-2017-2671,"  int ping_hash(struct sock *sk)
 void ping_unhash(struct sock *sk)
 {
 	struct inet_sock *isk = inet_sk(sk);

 	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	write_lock_bh(&ping_table.lock);
 	if (sk_hashed(sk)) {
 		hlist_nulls_del(&sk->sk_nulls_node);
 		sk_nulls_node_init(&sk->sk_nulls_node);
 		sock_put(sk);
 		isk->inet_num = 0;
 		isk->inet_sport = 0;
 		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
 	}
	write_unlock_bh(&ping_table.lock);
 }
 EXPORT_SYMBOL_GPL(ping_unhash);
 ","The ping_unhash function in net/ipv4/ping.c in the Linux kernel through 4.10.8 is too late in obtaining a certain lock and consequently cannot ensure that disconnect function calls are safe, which allows local users to cause a denial of service (panic) by leveraging access to the protocol value of IPPROTO_ICMP in a socket system call."
1261,CVE-2017-2647,"  EXPORT_SYMBOL_GPL(asymmetric_keyid_match);
  *	""id:<id>""	- request a key matching the ID
  *	""<subtype>:<id>"" - request a key of a subtype
  */
static int asymmetric_key_cmp(const struct key *key,
			      const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
  static int asymmetric_key_match(const struct key *key,
 static int asymmetric_key_match_preparse(struct key_match_data *match_data)
 {
 	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
	match_data->cmp = asymmetric_key_cmp;
 	return 0;
 }
 
  struct key_type key_type_asymmetric = {
 	.free_preparse	= asymmetric_key_free_preparse,
 	.instantiate	= generic_key_instantiate,
 	.match_preparse	= asymmetric_key_match_preparse,
 	.match_free	= asymmetric_key_match_free,
 	.destroy	= asymmetric_key_destroy,
 	.describe	= asymmetric_key_describe,","The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c."
1262,CVE-2017-2584,"  static int segmented_read_std(struct x86_emulate_ctxt *ctxt,
 	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);
 }
 
static int segmented_write_std(struct x86_emulate_ctxt *ctxt,
			       struct segmented_address addr,
			       void *data,
			       unsigned int size)
{
	int rc;
	ulong linear;

	rc = linearize(ctxt, addr, size, true, &linear);
	if (rc != X86EMUL_CONTINUE)
		return rc;
	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);
}

  
 	ctxt->dst.type = OP_NONE;
	return segmented_write_std(ctxt, ctxt->dst.addr.mem,
				   &desc_ptr, 2 + ctxt->op_bytes);
 }
 
 static int em_sgdt(struct x86_emulate_ctxt *ctxt)
  static int em_fxsave(struct x86_emulate_ctxt *ctxt)
 	else
 		size = offsetof(struct fxregs_state, xmm_space[0]);
 
	return segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);
 }
 
 static int fxrstor_fixup(struct x86_emulate_ctxt *ctxt,
  static int em_fxrstor(struct x86_emulate_ctxt *ctxt)
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 
	rc = segmented_read_std(ctxt, ctxt->memop.addr.mem, &fx_state, 512);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 ","arch/x86/kvm/emulate.c in the Linux kernel through 4.9.3 allows local users to obtain sensitive information from kernel memory or cause a denial of service (use-after-free) via a crafted application that leverages instruction emulation for fxrstor, fxsave, sgdt, and sidt."
1263,CVE-2017-2583,"  static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				    &ctxt->exception);
 }
 
 static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				     u16 selector, int seg, u8 cpl,
 				     enum x86_transfer_type transfer,
  static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 
 	rpl = selector & 3;
 
 	 
 	if (seg == VCPU_SREG_TR && (selector & (1 << 2)))
 		goto exception;
 
	 
	if (null_selector) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)
			goto exception;

		if (seg == VCPU_SREG_SS) {
			if (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)
				goto exception;

			 
			seg_desc.type = 3;
			seg_desc.p = 1;
			seg_desc.s = 1;
			seg_desc.dpl = cpl;
			seg_desc.d = 1;
			seg_desc.g = 1;
		}

		 
 		goto load;
	}
 
 	ret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);
 	if (ret != X86EMUL_CONTINUE)
  static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				   u16 selector, int seg)
 {
 	u8 cpl = ctxt->ops->cpl(ctxt);

	 
	if (seg == VCPU_SREG_SS && selector == 3 &&
	    ctxt->mode == X86EMUL_MODE_PROT64)
		return emulate_exception(ctxt, GP_VECTOR, 0, true);

 	return __load_segment_descriptor(ctxt, selector, seg, cpl,
 					 X86_TRANSFER_NONE, NULL);
 }","The load_segment_descriptor implementation in arch/x86/kvm/emulate.c in the Linux kernel before 4.9.5 improperly emulates a *MOV SS, NULL selector* instruction, which allows guest OS users to cause a denial of service (guest OS crash) or gain guest OS privileges via a crafted application."
1264,CVE-2017-0576," 
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>


 


static const char *dev = ""/dev/qce"";

#define QCEDEV_MAX_KEY_SIZE     64
#define QCEDEV_MAX_IV_SIZE      32
#define QCEDEV_MAX_BUFFERS      16


struct  buf_info {
        union {
                uint32_t        offset;
                uint8_t         *vaddr;
        };
        uint32_t        len;
};
struct  qcedev_vbuf_info {
        struct buf_info src[QCEDEV_MAX_BUFFERS];
        struct buf_info dst[QCEDEV_MAX_BUFFERS];
};

struct  qcedev_pmem_info {
        int             fd_src;
        struct buf_info src[QCEDEV_MAX_BUFFERS];
        int             fd_dst;
        struct buf_info dst[QCEDEV_MAX_BUFFERS];
};

enum qcedev_oper_enum {
        QCEDEV_OPER_DEC         = 0,
        QCEDEV_OPER_ENC         = 1,
        QCEDEV_OPER_DEC_NO_KEY  = 2,
        QCEDEV_OPER_ENC_NO_KEY  = 3,
        QCEDEV_OPER_LAST
};

enum qcedev_cipher_alg_enum {
        QCEDEV_ALG_DES          = 0,
        QCEDEV_ALG_3DES         = 1,
        QCEDEV_ALG_AES          = 2,
        QCEDEV_ALG_LAST
};

enum qcedev_cipher_mode_enum {
        QCEDEV_AES_MODE_CBC     = 0,
        QCEDEV_AES_MODE_ECB     = 1,
        QCEDEV_AES_MODE_CTR     = 2,
        QCEDEV_AES_MODE_XTS     = 3,
        QCEDEV_AES_MODE_CCM     = 4,
        QCEDEV_DES_MODE_CBC     = 5,
        QCEDEV_DES_MODE_ECB     = 6,
        QCEDEV_AES_DES_MODE_LAST
};

struct  qcedev_cipher_op_req {
        uint8_t                         use_pmem;
        union {
                struct qcedev_pmem_info pmem;
                struct qcedev_vbuf_info vbuf;
        };
        uint32_t                        entries;
        uint32_t                        data_len;
        uint8_t                         in_place_op;
        uint8_t                         enckey[QCEDEV_MAX_KEY_SIZE];
        uint32_t                        encklen;
        uint8_t                         iv[QCEDEV_MAX_IV_SIZE];
        uint32_t                        ivlen;
        uint32_t                        byteoffset;
        enum qcedev_cipher_alg_enum     alg;
        enum qcedev_cipher_mode_enum    mode;
        enum qcedev_oper_enum           op;
};

#define QCEDEV_IOC_MAGIC        0x87

#define QCEDEV_IOCTL_ENC_REQ            \
        _IOWR(QCEDEV_IOC_MAGIC, 1, struct qcedev_cipher_op_req)
#define QCEDEV_IOCTL_DEC_REQ            \
        _IOWR(QCEDEV_IOC_MAGIC, 2, struct qcedev_cipher_op_req)



void thread_func(unsigned int start, unsigned int end, int fd)
{
	struct qcedev_cipher_op_req req = { 0 };
	unsigned int i;
	char *data;

	data = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);
	if (data == MAP_FAILED) {
		printf(""mmap failed, get a better phone\n"");
		exit(0);
	}
	for (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))
		*((unsigned long *)(data + i)) = 0xABADACC355001337;


	req.in_place_op = 1;
	 
	req.entries = 2;
	req.byteoffset = 15;
	req.mode = QCEDEV_AES_MODE_CTR;

	req.op = QCEDEV_OPER_ENC; 
	req.ivlen = 1;
	req.data_len = 0xFFFFFFFE;
	req.vbuf.src[0].len = 4;
	req.vbuf.src[1].len = 0xFFFFFFFE - 4;
	req.vbuf.src[0].vaddr = (uint8_t*)data;
	req.vbuf.src[1].vaddr = (uint8_t*)data;
	req.vbuf.dst[0].len = 4;
	req.vbuf.dst[1].len = 0xFFFFFFFE - 4;
	req.vbuf.dst[0].vaddr = (uint8_t*)data;
	req.vbuf.dst[1].vaddr = (uint8_t*)data;

	
	ioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);

	printf(""exiting\n"");
	exit(0);
}

int main(void)
{
	int fd;
	unsigned int i;
	unsigned int start = 0;
	unsigned int _gap = ~0;
	unsigned int gap = _gap / 8;
	struct qcedev_cipher_op_req req = { 0 };
	 
	char *data;
	fd = open(dev, O_RDWR);
	if (fd < 0) {
		printf(""Failed to open %s with errno %s\n"", dev,
		       strerror(errno));
		return EXIT_FAILURE;

	}
	thread_func(start, start + gap, fd);

	sleep(1000000);
	return EXIT_FAILURE;
}","An elevation of privilege vulnerability in the Qualcomm crypto engine driver could enable a local malicious application to execute arbitrary code within the context of the kernel. This issue is rated as High because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-33544431. References: QC-CR#1103089."
1265,CVE-2016-10517,"  void processInputBuffer(client *c) {
 
          
         * this flag has been set (i.e. don't process more commands).
         *
         * The same applies for clients we want to terminate ASAP. */
        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;
 
          
         if (!c->reqtype) {
  void clientCommand(client *c) {
     }
 }
 
 
void securityWarningCommand(client *c) {
    static time_t logged_time;
    time_t now = time(NULL);

    if (labs(now-logged_time) > 60) {
        serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."");
        logged_time = now;
    }
    freeClientAsync(c);
}

  ","networking.c in Redis before 3.2.7 allows *Cross Protocol Scripting* because it lacks a check for POST and Host: strings, which are not valid in the Redis protocol (but commonly occur when an attack triggers an HTTP request to the Redis TCP port)."
1266,CVE-2016-10507,"  opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)
 		}
 	}
 	
	if (Info_h.biWidth == 0 || Info_h.biHeight == 0) {
		fclose(IN);
		return NULL;
	}
	
	if (Info_h.biBitCount > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {
		fclose(IN);
		return NULL;
	}
 	stride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U;  
 	if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) {  
		if (8 > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {
			fclose(IN);
			return NULL;
		}
 		stride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;
 	}
	
	if (stride > ((OPJ_UINT32)-1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {
		fclose(IN);
		return NULL;
	}
 	pData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));
 	if (pData == NULL) {
 		fclose(IN);",Integer overflow vulnerability in the bmp24toimage function in convertbmp.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted bmp file.
1267,CVE-2016-10506,"  static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi)
                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;

                     
                     
                     
                     
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                     
                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
  static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi)
                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;

                     
                     
                     
                     
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                     
                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
  static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi)
                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;

                     
                     
                     
                     
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                     
                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;","Division-by-zero vulnerabilities in the functions opj_pi_next_cprl, opj_pi_next_pcrl, and opj_pi_next_rpcl in pi.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files."
1268,CVE-2016-10504,"  static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *
 {
     OPJ_UINT32 l_data_size;
 
     
    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *
                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));
 
     if (l_data_size > p_code_block->data_size) {
         if (p_code_block->data) {",Heap-based buffer overflow vulnerability in the opj_mqc_byteout function in mqc.c in OpenJPEG before 2.2.0 allows remote attackers to cause a denial of service (application crash) via a crafted bmp file.
1269,CVE-2016-10351,"  DeclareReadSetting(LaunchMode, LaunchMode);
 DeclareSetting(QString, WorkingDir);
 inline void cForceWorkingDir(const QString &newDir) {
 	cSetWorkingDir(newDir);
	if (!gWorkingDir.isEmpty()) {
		QDir().mkpath(gWorkingDir);
		QFile::setPermissions(gWorkingDir,
			QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser);
	}

 }
 DeclareReadSetting(QString, ExeName);
 DeclareReadSetting(QString, ExeDir);","Telegram Desktop 0.10.19 uses 0755 permissions for $HOME/.TelegramDesktop, which allows local users to obtain sensitive authentication information via standard filesystem operations."
1270,CVE-2016-10318,"  static int create_encryption_context_from_policy(struct inode *inode,
 int fscrypt_process_policy(struct inode *inode,
 				const struct fscrypt_policy *policy)
 {
	if (!inode_owner_or_capable(inode))
		return -EACCES;

 	if (policy->version != 0)
 		return -EINVAL;
 ","A missing authorization check in the fscrypt_process_policy function in fs/crypto/policy.c in the ext4 and f2fs filesystem encryption support in the Linux kernel before 4.7.4 allows a user to assign an encryption policy to a directory owned by a different user, potentially creating a denial of service."
1271,CVE-2016-10251,"  static int jpc_pi_nextcprl(register jpc_pi_t *pi)
 	  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,
 	  ++pi->picomp) {
 		pirlvl = pi->picomp->pirlvls;
		pi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
		  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));
		pi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
		  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));
 		for (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];
 		  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {
			pi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *
			  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +
			  pi->picomp->numrlvls - rlvlno - 1)));
			pi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *
			  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +
			  pi->picomp->numrlvls - rlvlno - 1)));
 		}
 		for (pi->y = pi->ystart; pi->y < pi->yend;
 		  pi->y += pi->ystep - (pi->y % pi->ystep)) {","Integer overflow in the jpc_pi_nextcprl function in jpc_t2cod.c in JasPer before 1.900.20 allows remote attackers to have unspecified impact via a crafted file, which triggers use of an uninitialized value."
1272,CVE-2016-10250,"  jp2_box_t *jp2_box_get(jas_stream_t *in)
 	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
 		goto error;
 	}

	 
	 
 	box->ops = &jp2_boxinfo_unk.ops;

 	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
 		goto error;
 	}
 	boxinfo = jp2_boxinfolookup(box->type);
 	box->info = boxinfo;
 	box->len = len;
 	JAS_DBGLOG(10, (
 	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
  jp2_box_t *jp2_box_get(jas_stream_t *in)
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}
 		jas_stream_rewind(tmpstream);
 
		 
		 
		box->ops = &boxinfo->ops;

 		if (box->ops->getdata) {
 			if ((*box->ops->getdata)(box, tmpstream)) {
 				jas_eprintf(""cannot parse box data\n"");
  void jp2_box_dump(jp2_box_t *box, FILE *out)
 	assert(boxinfo);
 
 	fprintf(out, ""JP2 box: "");
	fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""',
	  boxinfo->name, '""', box->type, box->len);
 	if (box->ops->dumpdata) {
 		(*box->ops->dumpdata)(box, out);
 	}",The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.
1273,CVE-2016-10249,"  void jas_free(void *ptr)
 void *jas_malloc(size_t size)
 {
 	void *result;
	JAS_DBGLOG(101, (""jas_malloc(%zu)\n"", size));
 	result = malloc(size);
 	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
 	return result;
  void *jas_malloc(size_t size)
 void *jas_realloc(void *ptr, size_t size)
 {
 	void *result;
	JAS_DBGLOG(101, (""jas_realloc(%x, %zu)\n"", ptr, size));
 	result = realloc(ptr, size);
 	JAS_DBGLOG(100, (""jas_realloc(%p, %zu) -> %p\n"", ptr, size, result));
 	return result;","Integer overflow in the jpc_dec_tiledecode function in jpc_dec.c in JasPer before 1.900.12 allows remote attackers to have unspecified impact via a crafted image file, which triggers a heap-based buffer overflow."
1274,CVE-2016-10248,"  extern ""C"" {
 #define	JAS_ONES(n) \
   ((1 << (n)) - 1)
 
 

__attribute__((no_sanitize(""undefined"")))
inline static jas_int_asr(int x, int n)
{
	assert(n >= 0);
	return x >> n;
}

__attribute__((no_sanitize(""undefined"")))
inline static jas_int_asl(int x, int n)
{
	assert(n >= 0);
	return x << n;
}

  ",The jpc_tsfb_synthesize function in jpc_tsfb.c in JasPer before 1.900.9 allows remote attackers to cause a denial of service (NULL pointer dereference) via vectors involving an empty sequence.
1275,CVE-2016-10229,"  int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
	bool checksum_valid = false;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
  int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		checksum_valid = !udp_lib_checksum_complete(skb);
		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {",udp.c in the Linux kernel before 4.5 allows remote attackers to execute arbitrary code via UDP traffic that triggers an unsafe second checksum calculation during execution of a recv system call with the MSG_PEEK flag.
1276,CVE-2016-10211,"  union yyalloc
  
 #define YYFINAL  2
  
#define YYLAST   406
 
  
 #define YYNTOKENS  72
  
 #define YYNNTS  41
  
#define YYNRULES  122
  
#define YYNSTATES  210
 
  
  static const yytype_uint16 yyrline[] =
      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,
      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,
      802,   806,   831,   867,   913,   935,   944,   953,   968,   980,
     994,  1007,  1018,  1024,  1054,  1023,  1168,  1167,  1246,  1252,
    1259,  1258,  1321,  1320,  1381,  1390,  1399,  1408,  1417,  1426,
    1435,  1439,  1447,  1448,  1453,  1475,  1487,  1503,  1502,  1508,
    1519,  1520,  1525,  1532,  1543,  1544,  1548,  1556,  1560,  1570,
    1584,  1600,  1610,  1619,  1644,  1656,  1668,  1684,  1696,  1712,
    1757,  1776,  1794,  1812,  1830,  1856,  1874,  1884,  1894,  1904,
    1914,  1924,  1934
 };
 #endif
 
  static const yytype_uint16 yytoknum[] =
 #define yypact_value_is_default(Yystate) \
   (!!((Yystate) == (-73)))
 
#define YYTABLE_NINF -95
 
 #define yytable_value_is_error(Yytable_value) \
   0
  static const yytype_uint16 yytoknum[] =
      STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
     -73,    90,   -73,   -32,   -10,   -73,   -73,    93,   -73,   -73,
     -73,   -73,     1,   -73,   -73,   -73,   -73,   -49,     7,   -36,
     -73,    20,    26,   -73,   -28,    92,    46,     4,   -73,    40,
      46,   -73,   100,   119,    16,   -73,    72,   100,   -73,    77,
      83,   -73,   -73,   -73,   -73,   134,    59,   -73,    48,   -73,
     -73,   -73,   133,   136,   -73,   -18,   -73,    88,    95,   -73,
     -73,    91,   -73,   -73,   -73,   -73,   -73,   -73,   102,   -73,
     -73,   126,    48,   126,    48,   -44,   -73,    85,   -73,   127,
     297,   -73,   -73,   126,   110,   126,   126,   126,   126,     2,
     313,   -73,   -73,   -73,    85,   111,   154,   172,   126,    48,
     -73,   -73,    -6,   162,   126,   126,   126,   126,   126,   126,
     126,   126,   126,   126,   126,   126,   126,   126,   126,   126,
     126,    60,    60,   313,   126,   -73,   234,   252,   174,   194,
     -73,   153,    -6,   -73,   -73,   -73,   270,   117,   120,   108,
      48,    48,   -73,   -73,   -73,   -73,   313,   328,   342,   349,
     313,   313,   313,   313,   313,   313,   113,   113,    53,    53,
     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   121,   -73,
     -73,   -73,   -73,   124,   -73,   -73,    48,   151,   -73,    -1,
     126,   125,   -73,   108,   -73,   -73,    18,   -73,   214,   126,
     129,   -73,   143,   -73,    -1,   -73,    63,   121,   -73,    48,
     -73,   -73,   126,   144,    31,   313,    48,   -73,    33,   -73
 };
 
    
 static const yytype_int16 yypgoto[] =
 {
     -73,   -73,   211,   212,   -73,   -73,   -73,   -73,   -73,   -73,
     -73,   -73,   -73,   -73,   189,   -73,   183,   -73,   -73,   139,
     -73,   -73,   -73,   -73,   130,   -48,   -72,   -73,   -73,   -73,
     -73,   -73,   -73,    41,   -73,   103,   -73,   -73,    29,   164,
      -67
 };
 
  static const yytype_int16 yydefgoto[] =
 {
       -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,
       15,    19,    21,    30,    31,    37,    38,    52,    53,   121,
     167,    75,   137,   138,    76,    94,    78,   181,   203,   192,
     141,   140,   190,   125,   196,   144,   179,   186,   187,    79,
       80
 };
 
  static const yytype_int16 yydefgoto[] =
      number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_int16 yytable[] =
 {
      77,    90,    95,   130,    91,     4,    93,    96,    83,    11,
     184,    16,   131,    84,   185,    18,   123,    20,   126,   127,
     128,   129,    97,    98,    92,    99,    22,   139,   142,     8,
      23,   136,    41,    24,   132,    42,    26,   146,   147,   148,
     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,
     159,   160,   161,   162,    43,    44,    29,   168,    54,    55,
      56,    57,    58,   143,    59,    60,    61,    62,    32,    63,
      45,   100,   101,   100,   101,    64,    65,    66,    67,    51,
     -36,    68,   163,   164,   165,   166,    69,    70,   193,   194,
       2,     3,   177,   178,   -17,   -17,   -17,    12,    13,    14,
      27,   207,    71,   209,   183,    34,    72,    73,   118,   119,
     120,    36,    54,   188,    56,    57,    58,    74,    59,    60,
      61,    62,   197,    63,   180,   100,   101,     4,    39,    64,
      65,    66,    67,   201,   202,   205,    54,    46,    56,    57,
      58,    48,    59,    60,    61,    62,    49,    63,   -54,   -54,
      50,   204,    81,    64,    65,    85,    71,    82,   208,   102,
      87,    73,    86,   105,   106,   107,   116,   117,   118,   119,
     120,    88,   114,   115,   116,   117,   118,   119,   120,   124,
      71,   133,   135,    63,   172,    73,   -94,   175,   182,   103,
     104,   176,   101,   198,   189,    88,   105,   106,   107,   108,
     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
     119,   120,   199,   206,     9,    10,   105,   106,   107,    35,
      47,   122,   191,   200,   134,   114,   115,   116,   117,   118,
     119,   120,    89,   145,     0,   173,   105,   106,   107,     0,
       0,     0,     0,     0,   171,   114,   115,   116,   117,   118,
     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,
       0,     0,     0,     0,   134,   114,   115,   116,   117,   118,
     119,   120,     0,     0,     0,     0,   105,   106,   107,     0,
       0,     0,     0,     0,   195,   114,   115,   116,   117,   118,
     119,   120,     0,     0,   105,   106,   107,     0,     0,     0,
       0,     0,   169,   114,   115,   116,   117,   118,   119,   120,
       0,     0,   105,   106,   107,     0,     0,     0,     0,     0,
     170,   114,   115,   116,   117,   118,   119,   120,     0,   -94,
       0,     0,   103,   104,     0,     0,     0,     0,   174,   105,
     106,   107,   108,   109,   110,   111,   112,   113,   114,   115,
     116,   117,   118,   119,   120,   105,   106,   107,     0,     0,
       0,     0,     0,     0,   114,   115,   116,   117,   118,   119,
     120,   106,   107,     0,     0,     0,     0,     0,     0,   114,
     115,   116,   117,   118,   119,   120,   107,     0,     0,     0,
        0,     0,     0,   114,   115,   116,   117,   118,   119,   120,
     114,   115,   116,   117,   118,   119,   120
 };
 
 static const yytype_int16 yycheck[] =
 {
      48,    68,    74,     1,    71,    37,    73,    74,    26,    19,
      11,    10,    10,    31,    15,    64,    83,    10,    85,    86,
      87,    88,    66,    67,    72,    69,    62,    99,    34,    61,
      10,    98,    16,     7,    32,    19,    64,   104,   105,   106,
      107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
     117,   118,   119,   120,    38,    39,    10,   124,    10,    11,
      12,    13,    14,    69,    16,    17,    18,    19,    64,    21,
      54,    40,    41,    40,    41,    27,    28,    29,    30,    20,
      21,    33,    22,    23,    24,    25,    38,    39,    70,    71,
       0,     1,   140,   141,     4,     5,     6,     4,     5,     6,
       8,    70,    54,    70,   176,    65,    58,    59,    55,    56,
      57,    11,    10,   180,    12,    13,    14,    69,    16,    17,
      18,    19,   189,    21,     3,    40,    41,    37,     9,    27,
      28,    29,    30,    70,    71,   202,    10,    65,    12,    13,
      14,    64,    16,    17,    18,    19,    63,    21,    40,    41,
      16,   199,    19,    27,    28,    67,    54,    21,   206,    32,
      69,    59,    67,    42,    43,    44,    53,    54,    55,    56,
      57,    69,    51,    52,    53,    54,    55,    56,    57,    69,
      54,    70,    10,    21,    31,    59,    32,    70,    64,    35,
      36,    71,    41,    64,    69,    69,    42,    43,    44,    45,
      46,    47,    48,    49,    50,    51,    52,    53,    54,    55,
      56,    57,    69,    69,     3,     3,    42,    43,    44,    30,
      37,    82,   181,   194,    70,    51,    52,    53,    54,    55,
      56,    57,    68,   103,    -1,   132,    42,    43,    44,    -1,
      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,
      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
      56,    57,    -1,    -1,    -1,    -1,    42,    43,    44,    -1,
      -1,    -1,    -1,    -1,    70,    51,    52,    53,    54,    55,
      56,    57,    -1,    -1,    42,    43,    44,    -1,    -1,    -1,
      -1,    -1,    68,    51,    52,    53,    54,    55,    56,    57,
      -1,    -1,    42,    43,    44,    -1,    -1,    -1,    -1,    -1,
      68,    51,    52,    53,    54,    55,    56,    57,    -1,    32,
      -1,    -1,    35,    36,    -1,    -1,    -1,    -1,    68,    42,
      43,    44,    45,    46,    47,    48,    49,    50,    51,    52,
      53,    54,    55,    56,    57,    42,    43,    44,    -1,    -1,
      -1,    -1,    -1,    -1,    51,    52,    53,    54,    55,    56,
      57,    43,    44,    -1,    -1,    -1,    -1,    -1,    -1,    51,
      52,    53,    54,    55,    56,    57,    44,    -1,    -1,    -1,
       -1,    -1,    -1,    51,    52,    53,    54,    55,    56,    57,
      51,    52,    53,    54,    55,    56,    57
 };
 
    
  static const yytype_uint8 yyr1[] =
       86,    86,    87,    87,    89,    88,    90,    88,    88,    91,
       91,    92,    92,    92,    92,    93,    93,    93,    93,    94,
       94,    95,    95,    96,    97,    98,    98,    98,    98,    98,
      98,    98,    98,    99,   100,    98,   101,    98,    98,    98,
     102,    98,   103,    98,    98,    98,    98,    98,    98,    98,
      98,    98,   104,   104,   105,   106,   106,   108,   107,   107,
     109,   109,   110,   110,   111,   111,   111,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
      112,   112,   112,   112,   112,   112,   112,   112,   112,   112,
     112,   112,   112
 };
 
    
  static const yytype_uint8 yyr2[] =
        3,     3,     1,     2,     0,     5,     0,     5,     3,     0,
        2,     1,     1,     1,     1,     1,     3,     4,     4,     0,
        1,     1,     3,     1,     1,     1,     1,     3,     3,     1,
       3,     3,     3,     0,     0,    11,     0,     9,     3,     2,
       0,     4,     0,     4,     3,     3,     3,     3,     3,     3,
       1,     3,     3,     1,     5,     1,     3,     0,     4,     1,
       1,     3,     1,     1,     1,     1,     1,     3,     1,     1,
       4,     1,     1,     1,     1,     4,     1,     4,     1,     1,
       2,     3,     3,     3,     3,     3,     3,     3,     3,     2,
       3,     3,     1
 };
 
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
   case 62:
 #line 1019 ""grammar.y""  
    {
        compiler->loop_depth--;
        compiler->loop_identifier[compiler->loop_depth] = NULL;
      }
#line 2594 ""grammar.c""  
    break;

  case 63:
#line 1024 ""grammar.y""  
     {
         int var_index;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 2628 ""grammar.c""  
     break;
 
  case 64:
#line 1054 ""grammar.y""  
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
         compiler->loop_depth++;
       }
#line 2667 ""grammar.c""  
     break;
 
  case 65:
#line 1089 ""grammar.y""  
     {
         int mem_offset;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2750 ""grammar.c""  
     break;
 
  case 66:
#line 1168 ""grammar.y""  
     {
         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
         uint8_t* addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         compiler->loop_identifier[compiler->loop_depth] = NULL;
         compiler->loop_depth++;
       }
#line 2784 ""grammar.c""  
     break;
 
  case 67:
#line 1198 ""grammar.y""  
     {
         int mem_offset;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
 
       }
#line 2837 ""grammar.c""  
     break;
 
  case 68:
#line 1247 ""grammar.y""  
     {
         yr_parser_emit(yyscanner, OP_OF, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2847 ""grammar.c""  
     break;
 
  case 69:
#line 1253 ""grammar.y""  
     {
         yr_parser_emit(yyscanner, OP_NOT, NULL);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2857 ""grammar.c""  
     break;
 
  case 70:
#line 1259 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2887 ""grammar.c""  
     break;
 
  case 71:
#line 1285 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         uint8_t* and_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2927 ""grammar.c""  
     break;
 
  case 72:
#line 1321 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         void* jmp_destination_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         fixup->next = compiler->fixup_stack_head;
         compiler->fixup_stack_head = fixup;
       }
#line 2956 ""grammar.c""  
     break;
 
  case 73:
#line 1346 ""grammar.y""  
     {
         YR_FIXUP* fixup;
         uint8_t* or_addr;
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 2996 ""grammar.c""  
     break;
 
  case 74:
#line 1382 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3009 ""grammar.c""  
     break;
 
  case 75:
#line 1391 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3022 ""grammar.c""  
     break;
 
  case 76:
#line 1400 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""<="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3035 ""grammar.c""  
     break;
 
  case 77:
#line 1409 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, "">="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3048 ""grammar.c""  
     break;
 
  case 78:
#line 1418 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""=="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3061 ""grammar.c""  
     break;
 
  case 79:
#line 1427 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""!="", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
       }
#line 3074 ""grammar.c""  
     break;
 
  case 80:
#line 1436 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3082 ""grammar.c""  
     break;
 
  case 81:
#line 1440 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3090 ""grammar.c""  
     break;
 
  case 82:
#line 1447 ""grammar.y""  
     { (yyval.integer) = INTEGER_SET_ENUMERATION; }
#line 3096 ""grammar.c""  
     break;
 
  case 83:
#line 1448 ""grammar.y""  
     { (yyval.integer) = INTEGER_SET_RANGE; }
#line 3102 ""grammar.c""  
     break;
 
  case 84:
#line 1454 ""grammar.y""  
     {
         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3124 ""grammar.c""  
     break;
 
  case 85:
#line 1476 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3140 ""grammar.c""  
     break;
 
  case 86:
#line 1488 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3155 ""grammar.c""  
     break;
 
  case 87:
#line 1503 ""grammar.y""  
     {
          
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3164 ""grammar.c""  
     break;
 
  case 89:
#line 1509 ""grammar.y""  
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
         yr_parser_emit_pushes_for_strings(yyscanner, ""$*"");
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3175 ""grammar.c""  
     break;
 
  case 92:
#line 1526 ""grammar.y""  
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3186 ""grammar.c""  
     break;
 
  case 93:
#line 1533 ""grammar.y""  
     {
         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
         yr_free((yyvsp[0].c_string));
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3197 ""grammar.c""  
     break;
 
  case 95:
#line 1545 ""grammar.y""  
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
       }
#line 3205 ""grammar.c""  
     break;
 
  case 96:
#line 1549 ""grammar.y""  
     {
         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
       }
#line 3213 ""grammar.c""  
     break;
 
  case 97:
#line 1557 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[-1].expression);
       }
#line 3221 ""grammar.c""  
     break;
 
  case 98:
#line 1561 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit(
             yyscanner, OP_FILESIZE, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3235 ""grammar.c""  
     break;
 
  case 99:
#line 1571 ""grammar.y""  
     {
         yywarning(yyscanner,
             ""Using deprecated \""entrypoint\"" keyword. Use the \""entry_point\"" ""
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3253 ""grammar.c""  
     break;
 
  case 100:
#line 1585 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, ""intXXXX or uintXXXX"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3273 ""grammar.c""  
     break;
 
  case 101:
#line 1601 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = (yyvsp[0].integer);
       }
#line 3287 ""grammar.c""  
     break;
 
  case 102:
#line 1611 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg_double(
             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
       }
#line 3300 ""grammar.c""  
     break;
 
  case 103:
#line 1620 ""grammar.y""  
     {
         SIZED_STRING* sized_string;
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_STRING;
         (yyval.expression).value.sized_string = sized_string;
       }
#line 3329 ""grammar.c""  
     break;
 
  case 104:
#line 1645 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3345 ""grammar.c""  
     break;
 
  case 105:
#line 1657 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3361 ""grammar.c""  
     break;
 
  case 106:
#line 1669 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3381 ""grammar.c""  
     break;
 
  case 107:
#line 1685 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_string_identifier(
             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3397 ""grammar.c""  
     break;
 
  case 108:
#line 1697 ""grammar.y""  
     {
         compiler->last_result = yr_parser_emit_with_arg(
             yyscanner, OP_PUSH, 1, NULL, NULL);
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = UNDEFINED;
       }
#line 3417 ""grammar.c""  
     break;
 
  case 109:
#line 1713 ""grammar.y""  
     {
         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   
         {
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3466 ""grammar.c""  
     break;
 
  case 110:
#line 1758 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, ""-"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
         ERROR_IF(compiler->last_result != ERROR_SUCCESS);
       }
#line 3489 ""grammar.c""  
     break;
 
  case 111:
#line 1777 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""+"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3511 ""grammar.c""  
     break;
 
  case 112:
#line 1795 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""-"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3533 ""grammar.c""  
     break;
 
  case 113:
#line 1813 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""*"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3555 ""grammar.c""  
     break;
 
  case 114:
#line 1831 ""grammar.y""  
     {
         compiler->last_result = yr_parser_reduce_operation(
             yyscanner, ""\\"", (yyvsp[-2].expression), (yyvsp[0].expression));
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
         }
       }
#line 3585 ""grammar.c""  
     break;
 
  case 115:
#line 1857 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""%"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""%"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
           ERROR_IF(compiler->last_result != ERROR_SUCCESS);
         }
       }
#line 3607 ""grammar.c""  
     break;
 
  case 116:
#line 1875 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3621 ""grammar.c""  
     break;
 
  case 117:
#line 1885 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""^"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""^"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3635 ""grammar.c""  
     break;
 
  case 118:
#line 1895 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""|"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""|"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3649 ""grammar.c""  
     break;
 
  case 119:
#line 1905 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""~"");
 
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
             UNDEFINED : ~((yyvsp[0].expression).value.integer);
       }
#line 3663 ""grammar.c""  
     break;
 
  case 120:
#line 1915 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ""<<"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3677 ""grammar.c""  
     break;
 
  case 121:
#line 1925 ""grammar.y""  
     {
         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "">>"");
         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "">>"");
  YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
       }
#line 3691 ""grammar.c""  
     break;
 
  case 122:
#line 1935 ""grammar.y""  
     {
         (yyval.expression) = (yyvsp[0].expression);
       }
#line 3699 ""grammar.c""  
     break;
 
 
#line 3703 ""grammar.c""  
       default: break;
     }
    
#line 1940 ""grammar.y""  
 ",libyara/grammar.y in YARA 3.5.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted rule that is mishandled in the yr_parser_lookup_loop_variable function.
1277,CVE-2016-10210,"  typedef size_t yy_size_t;
 
      
     int yy_bs_column;  

 	 
  YY_DECL
 			yy_size_t yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
					
     do{ yylineno++;
         yycolumn=0;
     }while(0)
  YY_RULE_SETUP
   }
   else
   {
    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
  YY_RULE_SETUP
   {
     if (!read_escaped_char(yyscanner, &end))
     {
      yyerror(yyscanner, lex_env, ""illegal escape sequence"");
       yyterminate();
     }
   }
  YY_RULE_SETUP
   }
   else
   {
    yyerror(yyscanner, lex_env, ""illegal escape sequence"");
     yyterminate();
   }
 }
  static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
 
 	if ( c == '\n' )
		
     do{ yylineno++;
         yycolumn=0;
     }while(0)
  static void re_yyensure_buffer_stack (yyscan_t yyscanner)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( ""out of dynamic memory in re_yyensure_buffer_stack()"" );

 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
  static void re_yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
  YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)
 int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

         if (! YY_CURRENT_BUFFER)
             return 0;
     
  int re_yyget_lineno  (yyscan_t yyscanner)
 int re_yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

         if (! YY_CURRENT_BUFFER)
             return 0;
     
  int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }

     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }

      
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

     re_yyset_extra (yy_user_defined, *ptr_yy_globals);

     return yy_init_globals ( *ptr_yy_globals );
 }
 
  int read_escaped_char(
   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
    if (!isxdigit(text[3]))
       return 0;
   }
 ",libyara/lexer.l in YARA 3.5.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted rule that is mishandled in the yy_get_next_buffer function.
1278,CVE-2016-10208,"  static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 			(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));
 	db_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /
 		   EXT4_DESC_PER_BLOCK(sb);
	if (ext4_has_feature_meta_bg(sb)) {
		if (le32_to_cpu(es->s_first_meta_bg) >= db_count) {
			ext4_msg(sb, KERN_WARNING,
				 ""first meta block group too large: %u ""
				 ""(group descriptor block count %u)"",
				 le32_to_cpu(es->s_first_meta_bg), db_count);
			goto failed_mount;
		}
	}
 	sbi->s_group_desc = ext4_kvmalloc(db_count *
 					  sizeof(struct buffer_head *),
 					  GFP_KERNEL);","The ext4_fill_super function in fs/ext4/super.c in the Linux kernel through 4.9.8 does not properly validate meta block groups, which allows physically proximate attackers to cause a denial of service (out-of-bounds read and system crash) via a crafted ext4 image."
1279,CVE-2016-10207,"  StringParameter CSecurityTLS::X509CRL(""X509CRL"", ""X509 CRL file"", """", ConfViewer
 
 static LogWriter vlog(""TLS"");
 
 CSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),
 						 anon(_anon), fis(0), fos(0)
 {
   cafile = X509CA.getData();
   crlfile = X509CRL.getData();

  if (gnutls_global_init() != GNUTLS_E_SUCCESS)
    throw AuthFailureException(""gnutls_global_init failed"");
 }
 
 void CSecurityTLS::setDefaults()
  void CSecurityTLS::shutdown(bool needbye)
   if (session) {
     gnutls_deinit(session);
     session = 0;
   }
 }
 
  CSecurityTLS::~CSecurityTLS()
 
   delete[] cafile;
   delete[] crlfile;

  gnutls_global_deinit();
 }
 
 bool CSecurityTLS::processMsg(CConnection* cc)
  bool CSecurityTLS::processMsg(CConnection* cc)
   rdr::OutStream* os = cc->getOutStream();
   client = cc;
 
   if (!session) {
     if (!is->checkNoWait(1))
       return false;",The Xvnc server in TigerVNC allows remote attackers to cause a denial of service (invalid memory access and crash) by terminating a TLS handshake early.
1280,CVE-2016-10200,"  static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	int ret;
 	int chk_addr_ret;
 
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
  static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 ","Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c."
1281,CVE-2016-10197,"  search_set_from_hostname(struct evdns_base *base) {
 static char *
 search_make_new(const struct search_state *const state, int n, const char *const base_name) {
 	const size_t base_len = strlen(base_name);
	char need_to_append_dot;
 	struct search_domain *dom;
 
	if (!base_len) return NULL;
	need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;

 	for (dom = state->head; dom; dom = dom->next) {
 		if (!n--) {
 			 ",The search_make_new function in evdns.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (out-of-bounds read) via an empty hostname.
1282,CVE-2016-10196,"  evutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *
 
 	cp = strchr(ip_as_string, ':');
 	if (*ip_as_string == '[') {
		size_t len;
 		if (!(cp = strchr(ip_as_string, ']'))) {
 			return -1;
 		}
		len = ( cp-(ip_as_string + 1) );
		if (len > sizeof(buf)-1) {
 			return -1;
 		}
 		memcpy(buf, ip_as_string+1, len);",Stack-based buffer overflow in the evutil_parse_sockaddr_port function in evutil.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (segmentation fault) via vectors involving a long string in brackets in the ip_as_string argument.
1283,CVE-2016-10195,"  name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {
 
 	for (;;) {
 		u8 label_len;
 		GET8(label_len);
 		if (!label_len) break;
 		if (label_len & 0xc0) {
  name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {
 			*cp++ = '.';
 		}
 		if (cp + label_len >= end) return -1;
		if (j + label_len > length) return -1;
 		memcpy(cp, packet + j, label_len);
 		cp += label_len;
 		j += label_len;","The name_parse function in evdns.c in libevent before 2.1.6-beta allows remote attackers to have unspecified impact via vectors involving the label_len variable, which triggers an out-of-bounds stack read."
1284,CVE-2016-10192,"  static int http_receive_data(HTTPContext *c)
         } else if (c->buffer_ptr - c->buffer >= 2 &&
                    !memcmp(c->buffer_ptr - 1, ""\r\n"", 2)) {
             c->chunk_size = strtol(c->buffer, 0, 16);
            if (c->chunk_size <= 0) {  
                c->chunk_size = 0;
                 goto fail;
            }
             c->buffer_ptr = c->buffer;
             break;
         } else if (++loop_run > 10)
  static int http_receive_data(HTTPContext *c)
              
             goto fail;
         else {
            av_assert0(len <= c->chunk_size);
             c->chunk_size -= len;
             c->buffer_ptr += len;
             c->data_count += len;","Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size."
1285,CVE-2016-10191,"  static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,
     if (hdr != RTMP_PS_TWELVEBYTES)
         timestamp += prev_pkt[channel_id].timestamp;
 
    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {
        av_log(NULL, AV_LOG_ERROR, ""RTMP packet size mismatch %d != %d\n"",
                size,
                prev_pkt[channel_id].size);
        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);
        prev_pkt[channel_id].read = 0;
    }

     if (!prev_pkt[channel_id].read) {
         if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                          size)) < 0)","Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches."
1286,CVE-2016-10190,"  typedef struct HTTPContext {
     int line_count;
     int http_code;
      
    uint64_t chunksize;
    uint64_t off, end_off, filesize;
     char *location;
     HTTPAuthState auth_state;
     HTTPAuthState proxy_auth_state;
  typedef struct HTTPContext {
     AVDictionary *cookie_dict;
     int icy;
      
    uint64_t icy_data_read;
      
    uint64_t icy_metaint;
     char *icy_metadata_headers;
     char *icy_metadata_packet;
     AVDictionary *metadata;
  static int http_open(URLContext *h, const char *uri, int flags,
     else
         h->is_streamed = 1;
 
    s->filesize = UINT64_MAX;
     s->location = av_strdup(uri);
     if (!s->location)
         return AVERROR(ENOMEM);
  static void parse_content_range(URLContext *h, const char *p)
 
     if (!strncmp(p, ""bytes "", 6)) {
         p     += 6;
        s->off = strtoull(p, NULL, 10);
         if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoull(slash + 1, NULL, 10);
     }
     if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
         h->is_streamed = 0;  
  static int process_line(URLContext *h, char *line, int line_count,
             if ((ret = parse_location(s, p)) < 0)
                 return ret;
             *new_location = 1;
        } else if (!av_strcasecmp(tag, ""Content-Length"") &&
                   s->filesize == UINT64_MAX) {
            s->filesize = strtoull(p, NULL, 10);
         } else if (!av_strcasecmp(tag, ""Content-Range"")) {
             parse_content_range(h, p);
         } else if (!av_strcasecmp(tag, ""Accept-Ranges"") &&
  static int process_line(URLContext *h, char *line, int line_count,
             h->is_streamed = 0;
         } else if (!av_strcasecmp(tag, ""Transfer-Encoding"") &&
                    !av_strncasecmp(p, ""chunked"", 7)) {
            s->filesize  = UINT64_MAX;
             s->chunksize = 0;
         } else if (!av_strcasecmp(tag, ""WWW-Authenticate"")) {
             ff_http_auth_handle_header(&s->auth_state, tag, p);
  static int process_line(URLContext *h, char *line, int line_count,
             if (parse_cookie(s, p, &s->cookie_dict))
                 av_log(h, AV_LOG_WARNING, ""Unable to parse '%s'\n"", p);
         } else if (!av_strcasecmp(tag, ""Icy-MetaInt"")) {
            s->icy_metaint = strtoull(p, NULL, 10);
         } else if (!av_strncasecmp(tag, ""Icy-"", 4)) {
             if ((ret = parse_icy(s, tag, p)) < 0)
                 return ret;
  static int http_read_header(URLContext *h, int *new_location)
     char line[MAX_URL_SIZE];
     int err = 0;
 
    s->chunksize = UINT64_MAX;
 
     for (;;) {
         if ((err = http_get_line(s, line, sizeof(line))) < 0)
  static int http_connect(URLContext *h, const char *path, const char *local_path,
     int post, err;
     char headers[HTTP_HEADERS_SIZE] = """";
     char *authstr = NULL, *proxyauthstr = NULL;
    uint64_t off = s->off;
     int len = 0;
     const char *method;
     int send_expect_100 = 0;
  static int http_connect(URLContext *h, const char *path, const char *local_path,
      
     if (!has_header(s->headers, ""\r\nRange: "") && !post && (s->off > 0 || s->end_off || s->seekable == -1)) {
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                           ""Range: bytes=%""PRIu64""-"", s->off);
         if (s->end_off)
             len += av_strlcatf(headers + len, sizeof(headers) - len,
                                ""%""PRId64, s->end_off - 1);
  static int http_connect(URLContext *h, const char *path, const char *local_path,
     s->line_count       = 0;
     s->off              = 0;
     s->icy_data_read    = 0;
    s->filesize         = UINT64_MAX;
     s->willclose        = 0;
     s->end_chunked_post = 0;
     s->end_header       = 0;
  static int http_buf_read(URLContext *h, uint8_t *buf, int size)
         memcpy(buf, s->buf_ptr, len);
         s->buf_ptr += len;
     } else {
        uint64_t target_end = s->end_off ? s->end_off : s->filesize;
        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)
             return AVERROR_EOF;
         len = ffurl_read(s->hd, buf, size);
        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {
             av_log(h, AV_LOG_ERROR,
                   ""Stream ends prematurely at %""PRIu64"", should be %""PRIu64""\n"",
                    s->off, target_end
                   );
             return AVERROR(EIO);
  static int http_read_stream(URLContext *h, uint8_t *buf, int size)
             return err;
     }
 
    if (s->chunksize != UINT64_MAX) {
         if (!s->chunksize) {
             char line[32];
 
  static int http_read_stream(URLContext *h, uint8_t *buf, int size)
                         return err;
                 } while (!*line);     
 
                s->chunksize = strtoull(line, NULL, 16);
 
                av_log(h, AV_LOG_TRACE,
                       ""Chunked encoding data size: %""PRIu64""'\n"",
                         s->chunksize);
 
                 if (!s->chunksize)
                     return 0;
                else if (s->chunksize == UINT64_MAX) {
                    av_log(h, AV_LOG_ERROR, ""Invalid chunk size %""PRIu64""\n"",
                           s->chunksize);
                    return AVERROR(EINVAL);
                }
         }
         size = FFMIN(size, s->chunksize);
     }
  static int http_read_stream(URLContext *h, uint8_t *buf, int size)
     read_ret = http_buf_read(h, buf, size);
     if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)
         || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {
        uint64_t target = h->is_streamed ? 0 : s->off;
 
         if (s->reconnect_delay > s->reconnect_delay_max)
             return AVERROR(EIO);
 
        av_log(h, AV_LOG_INFO, ""Will reconnect at %""PRIu64"" error=%s.\n"", s->off, av_err2str(read_ret));
         av_usleep(1000U*1000*s->reconnect_delay);
         s->reconnect_delay = 1 + 2*s->reconnect_delay;
         seek_ret = http_seek_internal(h, target, SEEK_SET, 1);
         if (seek_ret != target) {
            av_log(h, AV_LOG_ERROR, ""Failed to reconnect at %""PRIu64"".\n"", target);
             return read_ret;
         }
 
  static int store_icy(URLContext *h, int size)
 {
     HTTPContext *s = h->priv_data;
      
    uint64_t remaining;
 
    if (s->icy_metaint < s->icy_data_read)
         return AVERROR_INVALIDDATA;
    remaining = s->icy_metaint - s->icy_data_read;
 
     if (!remaining) {
         /* The metadata packet is variable sized. It has a 1 byte header
  static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo
 {
     HTTPContext *s = h->priv_data;
     URLContext *old_hd = s->hd;
    uint64_t old_off = s->off;
     uint8_t old_buf[BUFFER_SIZE];
     int old_buf_size, ret;
     AVDictionary *options = NULL;
  static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo
              ((whence == SEEK_CUR && off == 0) ||
               (whence == SEEK_SET && off == s->off)))
         return s->off;
    else if ((s->filesize == UINT64_MAX && whence == SEEK_END))
         return AVERROR(ENOSYS);
 
     if (whence == SEEK_CUR)
  static int http_proxy_open(URLContext *h, const char *uri, int flags)
     s->buf_ptr    = s->buffer;
     s->buf_end    = s->buffer;
     s->line_count = 0;
    s->filesize   = UINT64_MAX;
     cur_auth_type = s->proxy_auth_state.auth_type;
 
     /* Note: This uses buffering, potentially reading more than the","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response."
1287,CVE-2016-10189,"  file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, ch
 	bee_t *bee = ic->bee;
 	bee_user_t *bu = bee_user_by_handle(bee, ic, handle);
 
	if (bee->ui->ft_in_start && bu) {
 		return bee->ui->ft_in_start(bee, bu, file_name, file_size);
 	} else {
 		return NULL;",BitlBee before 3.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.
1288,CVE-2016-10172,"  static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)
 
      
 
    if (bytecnt >= 2) {
         wpc->file_format = *byteptr++;
         wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;
         bytecnt -= 2;
  static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)
                         for (i = 0; i < nchans; ++i)
                             if (bytecnt) {
                                 wpc->channel_reordering [i] = *byteptr++;

                                if (wpc->channel_reordering [i] >= nchans)   
                                    wpc->channel_reordering [i] = 0;

                                 bytecnt--;
                             }
                             else",The read_new_config_info function in open_utils.c in Wavpack before 5.1.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted WV file.
1289,CVE-2016-10168,"  _gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,
 	GD2_DBG (printf (""%d Chunks vertically\n"", *ncy));
 
 	if (gd2_compressed (*fmt)) {
		if (*ncx <= 0 || *ncy <= 0 || *ncx > INT_MAX / *ncy) {
			GD2_DBG(printf (""Illegal chunk counts: %d * %d\n"", *ncx, *ncy));
			goto fail1;
		}
 		nc = (*ncx) * (*ncy);
 
 		GD2_DBG (printf (""Reading %d chunk index entries\n"", nc));",Integer overflow in gd_io.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors involving the number of horizontal and vertical chunks in an image.
1290,CVE-2016-10167,"  BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)
 
 						if (im->trueColor) {
 							if (!gdGetInt (&im->tpixels[y][x], in)) {
								gd_error(""gd2: EOF while reading\n"");
								gdImageDestroy(im);
								return NULL;
 							}
 						} else {
 							int ch;
 							if (!gdGetByte (&ch, in)) {
								gd_error(""gd2: EOF while reading\n"");
								gdImageDestroy(im);
								return NULL;
 							}
 							im->pixels[y][x] = ch;
 						}",The gdImageCreateFromGd2Ctx function in gd_gd2.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (application crash) via a crafted image file.
1291,CVE-2016-10166,"  static inline LineContribType * _gdContributionsAlloc(unsigned int line_length,
 {
 	unsigned int u = 0;
 	LineContribType *res;
	size_t weights_size;
 
	if (overflow2(windows_size, sizeof(double))) {
		return NULL;
	} else {
		weights_size = windows_size * sizeof(double);
	}
 	res = (LineContribType *) gdMalloc(sizeof(LineContribType));
 	if (!res) {
 		return NULL;
  static inline LineContribType * _gdContributionsAlloc(unsigned int line_length,
 		return NULL;
 	}
 	for (u = 0 ; u < line_length ; u++) {
		res->ContribRow[u].Weights = (double *) gdMalloc(weights_size);
		if (res->ContribRow[u].Weights == NULL) {
 			unsigned int i;

			for (i=0;i<u;i++) {
 				gdFree(res->ContribRow[i].Weights);
 			}
 			gdFree(res->ContribRow);",Integer underflow in the _gdContributionsAlloc function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors related to decrementing the u variable.
1292,CVE-2016-10165,"  void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU
 
          
         if (Offset < (SizeOfHeader + 8)) goto Error;
        if ((Offset + Len) > SizeOfTag + 8) goto Error;
 
          
         BeginOfThisString = Offset - SizeOfHeader - 8;","The Type_MLU_Read function in cmstypes.c in Little CMS (aka lcms2) allows remote attackers to obtain sensitive information or cause a denial of service via an image with a crafted ICC profile, which triggers an out-of-bounds heap read."
1293,CVE-2016-10160,"  static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char
 		 
 		if (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))
 		{
 			php_stream_close(fp);
 
 			if (signature) {
 				efree(signature);
 			}
 
 			if (error) {
				spprintf(error, 0, ""cannot load phar \""%s\"" with implicit alias \""%.*s\"" under different alias \""%s\"""", fname, tmp_len, buffer, alias);
 			}
 
 			efree(savebuf);",Off-by-one error in the phar_parse_pharfile function in ext/phar/phar.c in PHP before 5.6.30 and 7.0.x before 7.0.15 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PHAR archive with an alias mismatch.
1294,CVE-2016-10159,"  static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char
 	entry.is_persistent = mydata->is_persistent;
 
 	for (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {
		if (buffer + 24 > endbuffer) {
 			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
 		}
 
  static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char
 			entry.manifest_pos = manifest_index;
 		}
 
		if (entry.filename_len > endbuffer - buffer - 20) {
 			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
 		}
 ",Integer overflow in the phar_parse_pharfile function in ext/phar/phar.c in PHP before 5.6.30 and 7.0.x before 7.0.15 allows remote attackers to cause a denial of service (memory consumption or application crash) via a truncated manifest entry in a PHAR archive.
1295,CVE-2016-10158,"  static size_t exif_convert_any_to_int(void *value, int format, int motorola_inte
 			if (s_den == 0) {
 				return 0;
 			} else {
				return (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);
 			}
 
 		case TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);","The exif_convert_any_to_int function in ext/exif/exif.c in PHP before 5.6.30, 7.0.x before 7.0.15, and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (application crash) via crafted EXIF data that triggers an attempt to divide the minimum representable negative integer by -1."
1296,CVE-2016-10156,"  int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi
         if (parents)
                 mkdir_parents(path, 0755);
 
        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,
                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);
         if (fd < 0)
                 return -errno;
 ","A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229."
1297,CVE-2016-10154," 
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
#include <linux/crypto.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/fs.h>
  str_to_key(unsigned char *str, unsigned char *key)
 static int
 smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)
 {
 	unsigned char key2[8];
	struct crypto_cipher *tfm_des;
 
 	str_to_key(key, key2);
 
	tfm_des = crypto_alloc_cipher(""des"", 0, 0);
 	if (IS_ERR(tfm_des)) {
 		cifs_dbg(VFS, ""could not allocate des crypto API\n"");
		return PTR_ERR(tfm_des);
 	}
 
	crypto_cipher_setkey(tfm_des, key2, 8);
	crypto_cipher_encrypt_one(tfm_des, out, in);
	crypto_free_cipher(tfm_des);
 
	return 0;
 }
 
 static int","The smbhash function in fs/cifs/smbencrypt.c in the Linux kernel 4.9.x before 4.9.1 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a scatterlist."
1298,CVE-2016-10153,"  int ceph_encrypt2(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,
 	}
 }
 
static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,
			  void *buf, int buf_len, int in_len, int *pout_len)
{
	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();
	SKCIPHER_REQUEST_ON_STACK(req, tfm);
	struct sg_table sgt;
	struct scatterlist prealloc_sg;
	char iv[AES_BLOCK_SIZE];
	int pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));
	int crypt_len = encrypt ? in_len + pad_byte : in_len;
	int ret;

	if (IS_ERR(tfm))
		return PTR_ERR(tfm);

	WARN_ON(crypt_len > buf_len);
	if (encrypt)
		memset(buf + in_len, pad_byte, pad_byte);
	ret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);
	if (ret)
		goto out_tfm;

	crypto_skcipher_setkey((void *)tfm, key->key, key->len);
	memcpy(iv, aes_iv, AES_BLOCK_SIZE);

	skcipher_request_set_tfm(req, tfm);
	skcipher_request_set_callback(req, 0, NULL, NULL);
	skcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);

	 
	if (encrypt)
		ret = crypto_skcipher_encrypt(req);
	else
		ret = crypto_skcipher_decrypt(req);
	skcipher_request_zero(req);
	if (ret) {
		pr_err(""%s %scrypt failed: %d\n"", __func__,
		       encrypt ? ""en"" : ""de"", ret);
		goto out_sgt;
	}
	 

	if (encrypt) {
		*pout_len = crypt_len;
	} else {
		pad_byte = *(char *)(buf + in_len - 1);
		if (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&
		    in_len >= pad_byte) {
			*pout_len = in_len - pad_byte;
		} else {
			pr_err(""%s got bad padding %d on in_len %d\n"",
			       __func__, pad_byte, in_len);
			ret = -EPERM;
			goto out_sgt;
		}
	}

out_sgt:
	teardown_sgtable(&sgt);
out_tfm:
	crypto_free_skcipher(tfm);
	return ret;
}

int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,
	       void *buf, int buf_len, int in_len, int *pout_len)
{
	switch (key->type) {
	case CEPH_CRYPTO_NONE:
		*pout_len = in_len;
		return 0;
	case CEPH_CRYPTO_AES:
		return ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,
				      pout_len);
	default:
		return -ENOTSUPP;
	}
}

 static int ceph_key_preparse(struct key_preparsed_payload *prep)
 {
 	struct ceph_crypto_key *ckey;","The crypto scatterlist API in the Linux kernel 4.9.x before 4.9.6 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging reliance on earlier net/ceph/crypto.c code."
1299,CVE-2016-10150,"  static int kvm_ioctl_create_device(struct kvm *kvm,
 
 	ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);
 	if (ret < 0) {
 		mutex_lock(&kvm->lock);
 		list_del(&dev->vm_node);
 		mutex_unlock(&kvm->lock);
		ops->destroy(dev);
 		return ret;
 	}
 ",Use-after-free vulnerability in the kvm_ioctl_create_device function in virt/kvm/kvm_main.c in the Linux kernel before 4.8.13 allows host OS users to cause a denial of service (host OS crash) or possibly gain privileges via crafted ioctl calls on the /dev/kvm device.
1300,CVE-2016-10147,"  static void *mcryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,
 	goto out;
 }
 
static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,
 					  u32 *mask)
 {
 	struct crypto_attr_type *algt;
 
 	algt = crypto_get_attr_type(tb);
 	if (IS_ERR(algt))
		return false;

	*type |= algt->type & CRYPTO_ALG_INTERNAL;
	*mask |= algt->mask & CRYPTO_ALG_INTERNAL;

	if (*type & *mask & CRYPTO_ALG_INTERNAL)
		return true;
	else
		return false;
 }
 
 static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)
  static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
 	u32 mask = 0;
 	int err;
 
	if (!mcryptd_check_internal(tb, &type, &mask))
		return -EINVAL;
 
 	halg = ahash_attr_alg(tb[1], type, mask);
 	if (IS_ERR(halg))","crypto/mcryptd.c in the Linux kernel before 4.8.15 allows local users to cause a denial of service (NULL pointer dereference and system crash) by using an AF_ALG socket with an incompatible algorithm, as demonstrated by mcryptd(md5)."
1301,CVE-2016-10145,"  static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,
   if(exception->severity != UndefinedException) goto FINISH_UNL;
   if(magic_info->name == (char *) NULL) goto FINISH_UNL;
 
  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);
 
      
    ",Off-by-one error in coders/wpg.c in ImageMagick allows remote attackers to have unspecified impact via vectors related to a string copy.
1302,CVE-2016-10144,"  static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);",coders/ipl.c in ImageMagick allows remote attackers to have unspecific impact by leveraging a missing malloc check.
1303,CVE-2016-10130,"  static int http_connect(http_subtransport *t)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {",The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.
1304,CVE-2016-10129,"  int git_pkt_parse_line(
 
 	line += PKT_LEN_SIZE;
 	 
 	if (len == PKT_LEN_SIZE) {
		giterr_set_str(GITERR_NET, ""Invalid empty packet"");
		return GIT_ERROR;
 	}
 
 	if (len == 0) {  ",The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.
1305,CVE-2016-10128,"  int git_pkt_parse_line(
 	if (bufflen > 0 && bufflen < (size_t)len)
 		return GIT_EBUFS;
 
	 
	if (len != 0 && len < PKT_LEN_SIZE)
		return GIT_ERROR;

 	line += PKT_LEN_SIZE;
 	/*
 	 * TODO: How do we deal with empty lines? Try again? with the next",Buffer overflow in the git_pkt_parse_line function in transports/smart_pkt.c in the Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to have unspecified impact via a crafted non-flush packet.
1306,CVE-2016-10071,"  RestoreMSCWarning
       }
 
    
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));     
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
 ",coders/mat.c in ImageMagick before 6.9.4-0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted mat file.
1307,CVE-2016-10070,"  RestoreMSCWarning
   }
       }
     } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
 ExitLoop:
 
 ",Heap-based buffer overflow in the CalcMinMax function in coders/mat.c in ImageMagick before 6.9.4-0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted mat file.
1308,CVE-2016-10069,"  MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       case 16: z2=z = ReadBlobXXXLong(image2);   
          if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          break;
       default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
     }",coders/mat.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a mat file with an invalid number of frames.
1309,CVE-2016-10067,"  static Image *ReadLABELImage(const ImageInfo *image_info,
   status=GetMultilineTypeMetrics(image,draw_info,&metrics);
   if ((image->columns == 0) && (image->rows == 0))
     {
      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
       image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
     }
   else
  static Image *ReadLABELImage(const ImageInfo *image_info,
       return((Image *) NULL);
     }
   if (image->columns == 0)
    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
   if (image->columns == 0)
    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
      0.5);
   if (image->rows == 0)
    image->rows=(size_t) floor(metrics.ascent-metrics.descent+
       draw_info->stroke_width+0.5);
   if (image->rows == 0)
    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
      0.5);
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {","magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving *too many exceptions,* which trigger a buffer overflow."
1310,CVE-2016-10065,"  static MagickBooleanType
 %    o quantum: the number of bytes in each quantum.
 %
 */

 static MagickBooleanType CheckMemoryOverflow(const size_t count,
   const size_t quantum)
 {",The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
1311,CVE-2016-10064," 
 #include ""magick/log.h""
 #include ""magick/magick.h""
 #include ""magick/memory_.h""
#include ""magick/memory-private.h""
 #include ""magick/module.h""
 #include ""magick/monitor.h""
 #include ""magick/monitor-private.h""
  RestoreMSCWarning
           }
         (void) SetImageStorageClass(image,DirectClass);
         number_pixels=(MagickSizeType) columns*rows;
        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,
          rows*sizeof(*tile_pixels));
         if (tile_pixels == (uint32 *) NULL)
           {
             TIFFClose(tiff);
  RestoreMSCWarning
           Convert TIFF image to DirectClass MIFF image.
         */
         number_pixels=(MagickSizeType) image->columns*image->rows;
        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixel_info=AcquireVirtualMemory(image->columns,image->rows*
          sizeof(*pixels));
         if (pixel_info == (MemoryInfo *) NULL)
           {
             TIFFClose(tiff);",Buffer overflow in coders/tiff.c in ImageMagick before 6.9.5-1 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
1312,CVE-2016-10063,"  RestoreMSCWarning
     image->columns=(size_t) width;
     image->rows=(size_t) height;
     image->depth=(size_t) bits_per_sample;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Image depth: %.20g"",
         (double) image->depth);
  RestoreMSCWarning
             }
         goto next_tiff_frame;
       }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
     method=ReadGenericMethod;
     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
       {","Buffer overflow in coders/tiff.c in ImageMagick before 6.9.5-1 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file, related to extend validity."
1313,CVE-2016-10061,"  static Image *ReadGROUP4Image(const ImageInfo *image_info,
   length=fwrite(""\000\000\000\000"",1,4,file);
   length=WriteLSBLong(file,(long) image->resolution.x);
   length=WriteLSBLong(file,1);
  status=MagickTrue;
   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
    if (fputc(c,file) != c)
      status=MagickFalse;
   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
   length=WriteLSBLong(file,(unsigned int) length);
   (void) fclose(file);
  static Image *ReadGROUP4Image(const ImageInfo *image_info,
       (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
     }
   (void) RelinquishUniqueFileResource(filename);
  if (status == MagickFalse)
    image=DestroyImage(image);
   return(image);
 }
 #endif","The ReadGROUP4Image function in coders/tiff.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (crash) via a crafted image file."
1314,CVE-2016-10060,"  static void MagickUsage(MagickBooleanType verbose)
    however the last argument provides the output filename.
 */
 static MagickBooleanType ConcatenateImages(int argc,char **argv,
  ExceptionInfo *exception )
 {
   FILE
     *input,
     *output;
 
  MagickBooleanType
    status;

   int
     c;
 
  static MagickBooleanType ConcatenateImages(int argc,char **argv,
 
   if (ExpandFilenames(&argc,&argv) == MagickFalse)
     ThrowFileException(exception,ResourceLimitError,""MemoryAllocationFailed"",
      GetExceptionMessage(errno));
   output=fopen_utf8(argv[argc-1],""wb"");
  if (output == (FILE *) NULL)
    {
      ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",
        argv[argc-1]);
      return(MagickFalse);
    }
  status=MagickTrue;
  for (i=2; i < (ssize_t) (argc-1); i++)
  {
     input=fopen_utf8(argv[i],""rb"");
    if (input == (FILE *) NULL)
      {
         ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",argv[i]);
         continue;
       }
     for (c=fgetc(input); c != EOF; c=fgetc(input))
      if (fputc((char) c,output) != c)
        status=MagickFalse;
     (void) fclose(input);
     (void) remove_utf8(argv[i]);
   }
   (void) fclose(output);
  return(status);
 }
 
 WandExport MagickBooleanType MagickImageCommand(ImageInfo *image_info,int argc,","The ConcatenateImages function in MagickWand/magick-cli.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
1315,CVE-2016-10059,"  static Image *ReadJPEGImage(const ImageInfo *image_info,
   if (option != (const char *) NULL)
     if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
     {
       size_t
         colors;",Buffer overflow in coders/tiff.c in ImageMagick before 6.9.4-1 allows remote attackers to cause a denial of service (application crash) or have unspecified other impact via a crafted TIFF file.
1316,CVE-2016-10058,"  ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
             continue;
           }
 ",Memory leak in the ReadPSDLayers function in coders/psd.c in ImageMagick before 6.9.6-3 allows remote attackers to cause a denial of service (memory consumption) via a crafted image file.
1317,CVE-2016-10052,"  static void WriteProfile(j_compress_ptr jpeg_info,Image *image)
     profile=GetImageProfile(image,name);
     p=GetStringInfoDatum(custom_profile);
     if (LocaleCompare(name,""EXIF"") == 0)
       {
        length=GetStringInfoLength(profile);
        if (length > 65533L)
          {
            (void) ThrowMagickException(&image->exception,GetMagickModule(),
              CoderWarning,""ExifProfileSizeExceedsLimit"",image->filename);
            length=65533L;
          }
        jpeg_write_marker(jpeg_info,XML_MARKER,GetStringInfoDatum(profile),
           (unsigned int) length);
       }
     if (LocaleCompare(name,""ICC"") == 0)",Buffer overflow in the WriteProfile function in coders/jpeg.c in ImageMagick before 6.9.5-6 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
1318,CVE-2016-10049,"  static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
          number_planes_filled))
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info_length=image->columns*image->rows*
      MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     if ((flags & 0x01) && !(flags & 0x02))
       {",Buffer overflow in the ReadRLEImage function in coders/rle.c in ImageMagick before 6.9.4-4 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted RLE file.
1319,CVE-2016-10044,"  static struct dentry *aio_mount(struct file_system_type *fs_type,
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
 }
 
 /* aio_setup","The aio_mount function in fs/aio.c in the Linux kernel before 4.7.7 does not properly restrict execute access, which makes it easier for local users to bypass intended SELinux W^X policy restrictions, and consequently gain privileges, via an io_setup system call."
1320,CVE-2016-10012," 
 
  
 static int
 monitor_read_log(struct monitor *pmonitor)
 {
  monitor_apply_keystate(struct monitor *pmonitor)
 		kex->host_key_index=&get_hostkey_index;
 		kex->sign = sshd_hostkey_sign;
 	}
 }
 
  
  monitor_openfds(struct monitor *mon, int do_logfds)
 struct monitor *
 monitor_init(void)
 {
 	struct monitor *mon;
 
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
 
 	return mon;
 }
 ","The shared memory manager (associated with pre-authentication compression) in sshd in OpenSSH before 7.4 does not ensure that a bounds check is enforced by all compilers, which might allows local users to gain privileges by leveraging access to a sandboxed privilege-separation process, related to the m_zback and m_zlib data structures."
1321,CVE-2016-10011," 
 
  
	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
		st.st_size = 64*1024;  
		dontmax = 1;
	}
	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
		return r;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)","authfile.c in sshd in OpenSSH before 7.4 does not properly consider the effects of realloc on buffer contents, which might allow local users to obtain sensitive private-key information by leveraging access to a privilege-separated child process."
1322,CVE-2016-10010," 
 
  
 	if ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&
	    !no_port_forwarding_flag && !options.disable_forwarding &&
	    use_privsep) {
 		c = channel_connect_to_path(target,
 		    ""direct-streamlocal@openssh.com"", ""direct-streamlocal"");
 	} else {
  server_input_global_request(int type, u_int32_t seq, void *ctxt)
 
 		 
 		if ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0
		    || no_port_forwarding_flag || options.disable_forwarding ||
		    !use_privsep) {
 			success = 0;
 			packet_send_debug(""Server has disabled port forwarding."");
 		} else {","sshd in OpenSSH before 7.4, when privilege separation is not used, creates forwarded Unix-domain sockets as root, which might allow local users to gain privileges via unspecified vectors, related to serverloop.c."
1323,CVE-2016-9934,"  void pdo_stmt_init(TSRMLS_D)
 	pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS;  
 	pdo_row_ce->create_object = pdo_row_new;
 	pdo_row_ce->serialize = pdo_row_serialize;
	pdo_row_ce->unserialize = zend_class_unserialize_deny;
 }
 
 static void free_statement(pdo_stmt_t *stmt TSRMLS_DC)","ext/wddx/wddx.c in PHP before 5.6.28 and 7.x before 7.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via crafted serialized data in a wddxPacket XML document, as demonstrated by a PDORow string."
1324,CVE-2016-9933,"  void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)
 	int leftLimit = -1, rightLimit;
 	int i, restoreAlphaBlending = 0;
 
	if (border < 0 || color < 0) {
 		 
 		return;
 	}","Stack consumption vulnerability in the gdImageFillToBorder function in gd.c in the GD Graphics Library (aka libgd) before 2.2.2, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (segmentation violation) via a crafted imagefilltoborder call that triggers use of a negative color value."
1325,CVE-2016-9843,"  local unsigned long crc32_little(crc, buf, len)
 }
 
  
#define DOBIG4 c ^= *buf4++; \
         c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
             crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
 #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
  local unsigned long crc32_big(crc, buf, len)
     }
 
     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
     while (len >= 32) {
         DOBIG32;
         len -= 32;
  local unsigned long crc32_big(crc, buf, len)
         DOBIG4;
         len -= 4;
     }
     buf = (const unsigned char FAR *)buf4;
 
     if (len) do {",The crc32_big function in crc32.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving big-endian CRC calculation.
1326,CVE-2016-9842,"  z_streamp strm;
 {
     struct inflate_state FAR *state;
 
    if (strm == Z_NULL || strm->state == Z_NULL)
        return (long)(((unsigned long)0 - 1) << 16);
     state = (struct inflate_state FAR *)strm->state;
    return (long)(((unsigned long)((long)state->back)) << 16) +
         (state->mode == COPY ? state->length :
             (state->mode == MATCH ? state->was - state->length : 0));
 }",The inflateMark function in inflate.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact via vectors involving left shifts of negative integers.
1327,CVE-2016-9841," 
 
 #ifndef ASMINF
 
  
 
      
     state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in;
     last = in + (strm->avail_in - 5);
    out = strm->next_out;
     beg = out - (start - strm->avail_out);
     end = out + (strm->avail_out - 257);
 #ifdef INFLATE_STRICT
  unsigned start;          
        input data or output space */
     do {
         if (bits < 15) {
            hold += (unsigned long)(*in++) << bits;
             bits += 8;
            hold += (unsigned long)(*in++) << bits;
             bits += 8;
         }
         here = lcode[hold & lmask];
  unsigned start;          
             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                     ""inflate:         literal '%c'\n"" :
                     ""inflate:         literal 0x%02x\n"", here.val));
            *out++ = (unsigned char)(here.val);
         }
         else if (op & 16) {                      
             len = (unsigned)(here.val);
             op &= 15;                            
             if (op) {
                 if (bits < op) {
                    hold += (unsigned long)(*in++) << bits;
                     bits += 8;
                 }
                 len += (unsigned)hold & ((1U << op) - 1);
  unsigned start;          
             }
             Tracevv((stderr, ""inflate:         length %u\n"", len));
             if (bits < 15) {
                hold += (unsigned long)(*in++) << bits;
                 bits += 8;
                hold += (unsigned long)(*in++) << bits;
                 bits += 8;
             }
             here = dcode[hold & dmask];
  unsigned start;          
                 dist = (unsigned)(here.val);
                 op &= 15;                        
                 if (bits < op) {
                    hold += (unsigned long)(*in++) << bits;
                     bits += 8;
                     if (bits < op) {
                        hold += (unsigned long)(*in++) << bits;
                         bits += 8;
                     }
                 }
  unsigned start;          
 #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                         if (len <= op - whave) {
                             do {
                                *out++ = 0;
                             } while (--len);
                             continue;
                         }
                         len -= op - whave;
                         do {
                            *out++ = 0;
                         } while (--op > whave);
                         if (op == 0) {
                             from = out - dist;
                             do {
                                *out++ = *from++;
                             } while (--len);
                             continue;
                         }
 #endif
                     }
                    from = window;
                     if (wnext == 0) {            
                         from += wsize - op;
                         if (op < len) {          
                             len -= op;
                             do {
                                *out++ = *from++;
                             } while (--op);
                             from = out - dist;   
                         }
  unsigned start;          
                         if (op < len) {          
                             len -= op;
                             do {
                                *out++ = *from++;
                             } while (--op);
                            from = window;
                             if (wnext < len) {   
                                 op = wnext;
                                 len -= op;
                                 do {
                                    *out++ = *from++;
                                 } while (--op);
                                 from = out - dist;       
                             }
  unsigned start;          
                         if (op < len) {          
                             len -= op;
                             do {
                                *out++ = *from++;
                             } while (--op);
                             from = out - dist;   
                         }
                     }
                     while (len > 2) {
                        *out++ = *from++;
                        *out++ = *from++;
                        *out++ = *from++;
                         len -= 3;
                     }
                     if (len) {
                        *out++ = *from++;
                         if (len > 1)
                            *out++ = *from++;
                     }
                 }
                 else {
                     from = out - dist;           
                     do {                         
                        *out++ = *from++;
                        *out++ = *from++;
                        *out++ = *from++;
                         len -= 3;
                     } while (len > 2);
                     if (len) {
                        *out++ = *from++;
                         if (len > 1)
                            *out++ = *from++;
                     }
                 }
             }
  unsigned start;          
     hold &= (1U << bits) - 1;
 
      
    strm->next_in = in;
    strm->next_out = out;
     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
     strm->avail_out = (unsigned)(out < end ?
                                  257 + (end - out) : 257 - (out - end));",inffast.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.
1328,CVE-2016-9840,"  unsigned short FAR *work;
     code FAR *next;              
     const unsigned short FAR *base;      
     const unsigned short FAR *extra;     
    unsigned match;              
     unsigned short count[MAXBITS+1];     
     unsigned short offs[MAXBITS+1];      
     static const unsigned short lbase[31] = {  
  unsigned short FAR *work;
     switch (type) {
     case CODES:
         base = extra = work;     
        match = 20;
         break;
     case LENS:
         base = lbase;
         extra = lext;
        match = 257;
         break;
     default:             
         base = dbase;
         extra = dext;
        match = 0;
     }
 
      
  unsigned short FAR *work;
     for (;;) {
          
         here.bits = (unsigned char)(len - drop);
        if (work[sym] + 1 < match) {
             here.op = (unsigned char)0;
             here.val = work[sym];
         }
        else if (work[sym] >= match) {
            here.op = (unsigned char)(extra[work[sym] - match]);
            here.val = base[work[sym] - match];
         }
         else {
             here.op = (unsigned char)(32 + 64);          ",inftrees.c in zlib 1.2.8 might allow context-dependent attackers to have unspecified impact by leveraging improper pointer arithmetic.
1329,CVE-2016-9754,"  int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,
 	    !cpumask_test_cpu(cpu_id, buffer->cpumask))
 		return size;
 
	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
 
 	 
	if (nr_pages < 2)
		nr_pages = 2;
 
	size = nr_pages * BUF_PAGE_SIZE;
 
 	/*
 	 * Don't succeed if resizing is disabled, as a reader might be","The ring_buffer_resize function in kernel/trace/ring_buffer.c in the profiling subsystem in the Linux kernel before 4.6.1 mishandles certain integer calculations, which allows local users to gain privileges by writing to the /sys/kernel/debug/tracing/buffer_size_kb file."
1330,CVE-2016-9560,"  static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 	uint_fast32_t tmpxend;
 	uint_fast32_t tmpyend;
 	jpc_dec_cp_t *cp;
	jpc_tsfb_band_t bnds[JPC_MAXBANDS];
 	jpc_pchg_t *pchg;
 	int pchgno;
 	jpc_dec_cmpt_t *cmpt;",Stack-based buffer overflow in the jpc_tsfb_getbands2 function in jpc_tsfb.c in JasPer before 1.900.30 allows remote attackers to have unspecified impact via a crafted image.
1331,CVE-2016-9559,"  MagickExport MagickBooleanType CloneImageProperties(Image *image,
 %
 %  DefineImageProperty() associates an assignment string of the form
 %  ""key=value"" with an artifact or options. It is equivelent to
%  SetImageProperty().
 %
 %  The format of the DefineImageProperty method is:
 %
  MagickExport MagickBooleanType SetImageProperty(Image *image,
     {
        
      */
       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
         ""SetReadOnlyProperty"",""`%s'"",property);
       return(MagickFalse);",coders/tiff.c in ImageMagick before 7.0.3.7 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted image.
1332,CVE-2016-9556,"  static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.dimension=ReadBlobMSBShort(image);
    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) 
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.columns=ReadBlobMSBShort(image);
     iris_info.rows=ReadBlobMSBShort(image);
     iris_info.depth=ReadBlobMSBShort(image);",The IsPixelGray function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3-8 allows remote attackers to cause a denial of service (out-of-bounds heap read) via a crafted image file.
1333,CVE-2016-9436,"  HTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)
     case HTML_DD:
 	CLOSE_A;
 	CLOSE_DT;
	if (h_env->envc == 0 ||
	    (h_env->envc_real < h_env->nenv &&
	     envs[h_env->envc].env != HTML_DL &&
	     envs[h_env->envc].env != HTML_DL_COMPACT)) {
	    PUSH_ENV(HTML_DL);
	}
 	if (envs[h_env->envc].env == HTML_DL_COMPACT) {
 	    if (obuf->pos > envs[h_env->envc].indent)
 		flushline(h_env, obuf, envs[h_env->envc].indent, 0,","parsetagx.c in w3m before 0.5.3+git20161009 does not properly initialize values, which allows remote attackers to crash the application via a crafted html file, related to a <i> tag."
1334,CVE-2016-9400,"  void CClient::ProcessServerPacket(CNetChunk *pPacket)
 
 			pData = (const char *)Unpacker.GetRaw(PartSize);
 
			if(Unpacker.Error() || NumParts < 1 || NumParts > CSnapshot::MAX_PARTS || Part < 0 | Part >= NumParts || PartSize < 0 || PartSize > MAX_SNAPSHOT_PACKSIZE)
 				return;
 
 			if(GameTick >= m_CurrentRecvTick)",The CClient::ProcessServerPacket method in engine/client/client.cpp in Teeworlds before 0.6.4 allows remote servers to write to arbitrary physical memory locations and possibly execute arbitrary code via vectors involving snap handling.
1335,CVE-2016-9394,"  static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
 	unsigned int i;
 	uint_fast8_t tmp;
 
	siz->comps = 0;

 	 
 	cstate = 0;
 
  static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
 	  jpc_getuint32(in, &siz->tilexoff) ||
 	  jpc_getuint32(in, &siz->tileyoff) ||
 	  jpc_getuint16(in, &siz->numcomps)) {
		goto error;
 	}
	if (!siz->width || !siz->height) {
		jas_eprintf(""reference grid cannot have zero area\n"");
		goto error;
 	}
	if (!siz->tilewidth || !siz->tileheight) {
		jas_eprintf(""tile cannot have zero area\n"");
		goto error;
	}
	if (!siz->numcomps || siz->numcomps > 16384) {
		jas_eprintf(""number of components not in permissible range\n"");
		goto error;
 	}
	if (siz->xoff >= siz->width) {
		jas_eprintf(""XOsiz not in permissible range\n"");
		goto error;
	}
	if (siz->yoff >= siz->height) {
		jas_eprintf(""YOsiz not in permissible range\n"");
		goto error;
	}
	if (siz->tilexoff > siz->xoff || siz->tilexoff + siz->tilewidth <= siz->xoff) {
		jas_eprintf(""XTOsiz not in permissible range\n"");
		goto error;
	}
	if (siz->tileyoff > siz->yoff || siz->tileyoff + siz->tileheight <= siz->yoff) {
		jas_eprintf(""YTOsiz not in permissible range\n"");
		goto error;
	}

 	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
		goto error;
 	}
 	for (i = 0; i < siz->numcomps; ++i) {
 		if (jpc_getuint8(in, &tmp) ||
 		  jpc_getuint8(in, &siz->comps[i].hsamp) ||
 		  jpc_getuint8(in, &siz->comps[i].vsamp)) {
			goto error;
 		}
 		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
 			jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
			goto error;
 		}
 		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
 			jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
			goto error;
 		}
 		siz->comps[i].sgnd = (tmp >> 7) & 1;
 		siz->comps[i].prec = (tmp & 0x7f) + 1;
 	}
 	if (jas_stream_eof(in)) {
		goto error;
 	}
 	return 0;

error:
	if (siz->comps) {
		jas_free(siz->comps);
	}
	return -1;
 }
 
 static int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)",The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.17 allows remote attackers to cause a denial of service (assertion failure) via a crafted file.
1336,CVE-2016-9391,"  long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)
 
 	 
	 
	if (n < 0 || n >= 32) {
		return -1;
	}
 
 	 
 	v = 0;
  int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
 
 	 
	 
	if (n < 0 || n >= 32) {
		return EOF;
	}
 	 
 	assert(!(v & (~JAS_ONES(n))));
 ",The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer.
1337,CVE-2016-9390,"  static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
 	  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {
 		return -1;
 	}
	if (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {
		jas_eprintf(""all tiles are outside the image area\n"");
		return -1;
	}
 	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
 		return -1;
 	}",The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.
1338,CVE-2016-9389," 
 #include <assert.h>
 #include <ctype.h>
 #include <inttypes.h>
#include <stdbool.h>
 
 #include ""jasper/jas_math.h""
 #include ""jasper/jas_image.h""
  int jas_image_fmtfromname(char *name)
 * Miscellaneous operations.
 \******************************************************************************/
 
bool jas_image_cmpt_domains_same(jas_image_t *image)
{
	int cmptno;
	jas_image_cmpt_t *cmpt;
	jas_image_cmpt_t *cmpt0;

	cmpt0 = image->cmpts_[0];
	for (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {
		cmpt = image->cmpts_[cmptno];
		if (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||
		  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||
		  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {
			return 0;
		}
	}
	return 1;
}

 uint_fast32_t jas_image_rawsize(jas_image_t *image)
 {
 	uint_fast32_t rawsize;",The jpc_irct and jpc_iict functions in jpc_mct.c in JasPer before 1.900.14 allow remote attackers to cause a denial of service (assertion failure).
1339,CVE-2016-9388,"  static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,
 	 
 	cmap = 0;
 
	assert(jas_image_numcmpts(image) <= 3);

	for (i = 0; i < 3; ++i) {
		data[i] = 0;
	}

 	for (i = 0; i < jas_image_numcmpts(image); ++i) {
		if (!(data[i] = jas_matrix_create(1, jas_image_width(image)))) {
			goto error;
		}
 	}
 
 	pad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;
  static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,
 		for (x = 0; x < hdr->width; x++) {
 			while (nz < hdr->depth) {
 				if ((c = jas_stream_getc(in)) == EOF) {
					goto error;
 				}
 				z = (z << 8) | c;
 				nz += 8;
  static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,
 		}
 		if (pad) {
 			if ((c = jas_stream_getc(in)) == EOF) {
				goto error;
 			}
 		}
 		for (i = 0; i < jas_image_numcmpts(image); ++i) {
 			if (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,
 			  data[i])) {
				goto error;
 			}
 		}
 	}
 
 	for (i = 0; i < jas_image_numcmpts(image); ++i) {
 		jas_matrix_destroy(data[i]);
		data[i] = 0;
 	}
 
 	return 0;

error:
	for (i = 0; i < 3; ++i) {
		if (data[i]) {
			jas_matrix_destroy(data[i]);
		}
	}
	return -1;
 }
 
 static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)
  static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)
 		{
 		jas_eprintf(""warning: palettized images not fully supported\n"");
 		numcolors = 1 << hdr->depth;
		if (numcolors > RAS_CMAP_MAXSIZ) {
			return -1;
		}
 		actualnumcolors = hdr->maplength / 3;
 		for (i = 0; i < numcolors; i++) {
 			cmap->data[i] = 0;",The ras_getcmap function in ras_dec.c in JasPer before 1.900.14 allows remote attackers to cause a denial of service (assertion failure) via a crafted image file.
1340,CVE-2016-9387,"  static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 	int htileno;
 	int vtileno;
 	jpc_dec_cmpt_t *cmpt;
	size_t size;
 
 	dec->xstart = siz->xoff;
 	dec->ystart = siz->yoff;
  static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 
 	dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);
 	dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);
	if (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {
		return -1;
	}
	dec->numtiles = size;
 	JAS_DBGLOG(10, (""numtiles = %d; numhtiles = %d; numvtiles = %d;\n"",
 	  dec->numtiles, dec->numhtiles, dec->numvtiles));
 	if (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {","Integer overflow in the jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.13 allows remote attackers to have unspecified impact via a crafted file, which triggers an assertion failure."
1341,CVE-2016-9317,"  BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)
 	if (overflow2(sx, sy)) {
 		return NULL;
 	}

 	if (overflow2(sizeof (unsigned char *), sy)) {
 		return NULL;
 	}",The gdImageCreate function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (system hang) via an oversized image.
1342,CVE-2016-9298,"  MagickExport Image *WaveletDenoiseImage(const Image *image,
     ThrowImageException(ResourceLimitError,""MemoryAllocationFailed"");
   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*
     sizeof(*pixels));
  kernel=(float *) AcquireQuantumMemory(MagickMax(image->rows,image->columns)+1,
     GetOpenMPMaximumThreads()*sizeof(*kernel));
   if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (float *) NULL))
     {",Heap overflow in the WaveletDenoiseImage function in MagickCore/fx.c in ImageMagick before 6.9.6-4 and 7.x before 7.0.3-6 allows remote attackers to cause a denial of service (crash) via a crafted image.
1343,CVE-2016-9262,"  int jas_memdump(FILE *out, void *data, size_t len)
 	}
 	return 0;
 }

 

void jas_deprecated(const char *s)
{
	static char message[] =
	""WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\n""
	""WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\n""
	""WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\n""
	""YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\n""
	""THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\n""
	""PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\n""
	;
	jas_eprintf(""%s"", message);
	jas_eprintf(""The specific problem is as follows:\n%s\n"", s);
	 
}","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities."
1344,CVE-2016-8887,"  jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	box->len = len;
	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
  jp2_box_t *jp2_box_get(jas_stream_t *in)
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			 
			 
			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}",The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).
1345,CVE-2016-8884,"  jas_matrix_t *jas_matrix_create(int numrows, int numcols)
 	jas_matrix_t *matrix;
 	int i;
 
	if (numrows < 0 || numcols < 0) {
		return 0;
	}

 	if (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {
 		return 0;
 	}",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) by calling the imginfo command with a crafted BMP image. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8690.
1346,CVE-2016-8693,"  static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	 
 	assert(bufsize >= 0);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
	  bufsize) {
 		return -1;
 	}
 	m->buf_ = buf;",Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command.
1347,CVE-2016-8692,"  static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
 			jas_free(siz->comps);
 			return -1;
 		}
		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
			jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
			jas_free(siz->comps);
			return -1;
		}
		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
			jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
			jas_free(siz->comps);
			return -1;
		}
 		siz->comps[i].sgnd = (tmp >> 7) & 1;
 		siz->comps[i].prec = (tmp & 0x7f) + 1;
 	}",The jpc_dec_process_siz function in libjasper/jpc/jpc_dec.c in JasPer before 1.900.4 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted YRsiz value in a BMP image to the imginfo command.
1348,CVE-2016-8690,"  typedef enum {
 	OPT_HELP,
 	OPT_VERSION,
 	OPT_VERBOSE,
	OPT_INFILE,
	OPT_DEBUG
 } optid_t;
 
  
 	while ((id = jas_getopt(argc, argv, opts)) >= 0) {
  int main(int argc, char **argv)
 			printf(""%s\n"", JAS_VERSION);
 			exit(EXIT_SUCCESS);
 			break;
		case OPT_DEBUG:
			debug = atoi(jas_optarg);
			break;
 		case OPT_INFILE:
 			infile = jas_optarg;
 			break;
  int main(int argc, char **argv)
 		}
 	}
 
	jas_setdbglevel(debug);

 	 
 	if (infile) {
 		 
  int main(int argc, char **argv)
 
 	 
 	if (!(image = jas_image_decode(instream, fmtid, 0))) {
		jas_stream_close(instream);
 		fprintf(stderr, ""cannot load image\n"");
 		return EXIT_FAILURE;
 	}",The bmp_getdata function in libjasper/bmp/bmp_dec.c in JasPer before 1.900.5 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted BMP image in an imginfo command.
1349,CVE-2016-8689,"  read_Header(struct archive_read *a, struct _7z_header_info *h,
 
 		switch (type) {
 		case kEmptyStream:
			if (h->emptyStreamBools != NULL)
				return (-1);
 			h->emptyStreamBools = calloc((size_t)zip->numFiles,
 			    sizeof(*h->emptyStreamBools));
 			if (h->emptyStreamBools == NULL)
  read_Header(struct archive_read *a, struct _7z_header_info *h,
 					return (-1);
 				break;
 			}
			if (h->emptyFileBools != NULL)
				return (-1);
 			h->emptyFileBools = calloc(empty_streams,
 			    sizeof(*h->emptyFileBools));
 			if (h->emptyFileBools == NULL)
  read_Header(struct archive_read *a, struct _7z_header_info *h,
 					return (-1);
 				break;
 			}
			if (h->antiBools != NULL)
				return (-1);
 			h->antiBools = calloc(empty_streams,
 			    sizeof(*h->antiBools));
 			if (h->antiBools == NULL)
  read_Header(struct archive_read *a, struct _7z_header_info *h,
 			if ((ll & 1) || ll < zip->numFiles * 4)
 				return (-1);
 
			if (zip->entry_names != NULL)
				return (-1);
 			zip->entry_names = malloc(ll);
 			if (zip->entry_names == NULL)
 				return (-1);
  read_Header(struct archive_read *a, struct _7z_header_info *h,
 			if ((p = header_bytes(a, 2)) == NULL)
 				return (-1);
 			allAreDefined = *p;
			if (h->attrBools != NULL)
				return (-1);
 			h->attrBools = calloc((size_t)zip->numFiles,
 			    sizeof(*h->attrBools));
 			if (h->attrBools == NULL)",The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.
1350,CVE-2016-8687,"  safe_fprintf(FILE *f, const char *fmt, ...)
 		}
 
 		 
		if (i > (sizeof(outbuff) - 128)) {
 			outbuff[i] = '\0';
 			fprintf(f, ""%s"", outbuff);
 			i = 0;",Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.
1351,CVE-2016-8677,"  RestoreMSCWarning
       case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;
       default: image->compression=RLECompression; break;
     }
    quantum_info=(QuantumInfo *) NULL;
     if ((photometric == PHOTOMETRIC_PALETTE) &&
         (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))
       {
  RestoreMSCWarning
       {
         if (image_info->number_scenes != 0)
           if (image->scene >= (image_info->scene+image_info->number_scenes-1))
            break;
         goto next_tiff_frame;
       }
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     
    quantum_info=AcquireQuantumInfo(image_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      {
        TIFFClose(tiff);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if (sample_format == SAMPLEFORMAT_UINT)
      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
    if (sample_format == SAMPLEFORMAT_INT)
      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
    if (sample_format == SAMPLEFORMAT_IEEEFP)
      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
    if (status == MagickFalse)
      {
        TIFFClose(tiff);
        quantum_info=DestroyQuantumInfo(quantum_info);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    status=MagickTrue;
    switch (photometric)
    {
      case PHOTOMETRIC_MINISBLACK:
      {
        quantum_info->min_is_white=MagickFalse;
        break;
      }
      case PHOTOMETRIC_MINISWHITE:
      {
        quantum_info->min_is_white=MagickTrue;
        break;
      }
      default:
        break;
    }
    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
      &sample_info);
    if (tiff_status == 1)
      {
        (void) SetImageProperty(image,""tiff:alpha"",""unspecified"",exception);
        if (extra_samples == 0)
          {
            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
              image->alpha_trait=BlendPixelTrait;
          }
        else
          for (i=0; i < extra_samples; i++)
          {
            image->alpha_trait=BlendPixelTrait;
            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
              {
                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
                (void) SetImageProperty(image,""tiff:alpha"",""associated"",
                  exception);
              }
            else
              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
                (void) SetImageProperty(image,""tiff:alpha"",""unassociated"",
                  exception);
          }
      }
     method=ReadGenericMethod;
     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
       {
  RestoreMSCWarning
     }
     SetQuantumImageType(image,quantum_type);
   next_tiff_frame:
    if (quantum_info != (QuantumInfo *) NULL)
      quantum_info=DestroyQuantumInfo(quantum_info);
     if (photometric == PHOTOMETRIC_CIELAB)
       DecodeLabImage(image,exception);
     if ((photometric == PHOTOMETRIC_LOGL) ||","The AcquireQuantumPixels function in MagickCore/quantum.c in ImageMagick before 7.0.3-1 allows remote attackers to have unspecified impact via a crafted image file, which triggers a memory allocation failure."
1352,CVE-2016-8675,"  static int mpeg4video_probe(AVProbeData *probe_packet)
 
     for (i = 0; i < probe_packet->buf_size; i++) {
         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];
        if (temp_buffer & 0xfffffe00)
            continue;
        if (temp_buffer < 2)
             continue;
 
         if (temp_buffer == VOP_START_CODE)
             VOP++;
         else if (temp_buffer == VISUAL_OBJECT_START_CODE)
             VISO++;
        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)
             VO++;
        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)
             VOL++;
         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&
                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))","The get_vlc2 function in get_bits.h in Libav before 11.9 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a crafted mp3 file, possibly related to startcode sequences during m4v detection."
1353,CVE-2016-8670,"  static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
 	if(remain >= len) {
 		rlen = len;
 	} else {
		if(remain <= 0) {
 			/* 2.0.34: EOF is incorrect. We use 0 for
 			 * errors and EOF, just like fileGetbuf,
 			 * which is a simple fread() wrapper.","Integer signedness error in the dynamicGetbuf function in gd_io_dp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted imagecreatefromstring call."
1354,CVE-2016-8649," 
 
 #include ""namespace.h""
 #include ""log.h""
#include ""af_unix.h""
 #include ""attach.h""
 #include ""caps.h""
 #include ""config.h""
 
 
 lxc_log_define(lxc_attach, lxc);
 
static int lsm_openat(int procfd, pid_t pid, int on_exec)
{
	int ret = -1;
 	int labelfd = -1;
 	const char* name;
#define __LSMATTRLEN   (5 +   21 +   7 +   1)
	char path[__LSMATTRLEN];
 
 	name = lsm_name();
 
 	if (strcmp(name, ""nop"") == 0)
		return 0;
 
 	if (strcmp(name, ""none"") == 0)
		return 0;
 
 	 
 	if (strcmp(name, ""AppArmor"") == 0)
 		on_exec = 0;
 
 	if (on_exec) {
		ret = snprintf(path, __LSMATTRLEN, ""%d/attr/exec"", pid);
		if (ret < 0 || ret >= __LSMATTRLEN)
			return -1;
		labelfd = openat(procfd, path, O_RDWR);
	} else {
		ret = snprintf(path, __LSMATTRLEN, ""%d/attr/current"", pid);
		if (ret < 0 || ret >= __LSMATTRLEN)
			return -1;
		labelfd = openat(procfd, path, O_RDWR);
 	}
 
 	if (labelfd < 0) {
 		SYSERROR(""Unable to open LSM label"");
		return -1;
 	}
 
	return labelfd;
}

static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)
{
	int fret = -1;
	const char* name;
	char *command = NULL;

	name = lsm_name();

	if (strcmp(name, ""nop"") == 0)
		return 0;

	if (strcmp(name, ""none"") == 0)
		return 0;

	 
	if (strcmp(name, ""AppArmor"") == 0)
		on_exec = 0;

 	if (strcmp(name, ""AppArmor"") == 0) {
 		int size;
 
 		command = malloc(strlen(lsm_label) + strlen(""changeprofile "") + 1);
 		if (!command) {
 			SYSERROR(""Failed to write apparmor profile"");
 			goto out;
 		}
 
 		size = sprintf(command, ""changeprofile %s"", lsm_label);
 		if (size < 0) {
 			SYSERROR(""Failed to write apparmor profile"");
 			goto out;
 		}
 
		if (write(lsm_labelfd, command, size + 1) < 0) {
			SYSERROR(""Unable to set LSM label: %s."", command);
 			goto out;
 		}
		INFO(""Set LSM label to: %s."", command);
	} else if (strcmp(name, ""SELinux"") == 0) {
		if (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {
 			SYSERROR(""Unable to set LSM label"");
 			goto out;
 		}
		INFO(""Set LSM label to: %s."", lsm_label);
	} else {
 		ERROR(""Unable to restore label for unknown LSM: %s"", name);
 		goto out;
 	}
	fret = 0;
 
 out:
 	free(command);
 
	if (lsm_labelfd != -1)
		close(lsm_labelfd);
 
	return fret;
 }
 
 static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)
  struct attach_clone_payload {
 	struct lxc_proc_context_info* init_ctx;
 	lxc_attach_exec_t exec_function;
 	void* exec_payload;
 };
 
 static int attach_child_main(void* data);
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	char* cwd;
 	char* new_cwd;
 	int ipc_sockets[2];
 	signed long personality;
 
 	if (!options)
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	 *        X  <------------------------------------  send 1
 	 *   [add to cgroup, ...]
 	 *    send 2 ------------------------------------>    X
	 *						[set LXC_ATTACH_NO_NEW_PRIVS]
	 *        X  <------------------------------------  send 3
	 *   [open LSM label fd]
	 *    send 4 ------------------------------------>    X
	 *   						[set LSM label]
 	 *   close socket                                 close socket
 	 *                                                run program
 	 */
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	}
 
 	if (pid) {
		int procfd = -1;
 		pid_t to_cleanup_pid = pid;
 
 		 
		procfd = open(""/proc"", O_DIRECTORY | O_RDONLY | O_CLOEXEC);
		if (procfd < 0) {
			SYSERROR(""Unable to open /proc."");
			goto cleanup_error;
		}

 		 
 		status = 0;
 		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 		ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);
 		if (ret <= 0) {
 			if (ret != 0)
				ERROR(""error using IPC to receive notification ""
				      ""from attached process (1)"");
 			goto cleanup_error;
 		}
 
 		 
 		status = 2;
 		ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));
 		if (ret <= 0) {
			ERROR(""Error using IPC to notify attached process for ""
			      ""initialization (2): %s."", strerror(errno));
 			goto cleanup_error;
 		}
 
		 
		expected = 3;
		ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);
		if (ret <= 0) {
			ERROR(""Error using IPC for the child to tell us to open LSM fd (3): %s."",
			      strerror(errno));
			goto cleanup_error;
		}

		 
		if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
			int on_exec, labelfd;
			on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
			 
			labelfd = lsm_openat(procfd, attached_pid, on_exec);
			if (labelfd < 0)
				goto cleanup_error;

			 
			ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);
			if (ret <= 0) {
				ERROR(""Error using IPC to send child LSM fd (4): %s."",
						strerror(errno));
				goto cleanup_error;
			}
		}

 		 
 		shutdown(ipc_sockets[0], SHUT_RDWR);
 		close(ipc_sockets[0]);
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 		 
		if (procfd >= 0)
			close(procfd);
 		shutdown(ipc_sockets[0], SHUT_RDWR);
 		close(ipc_sockets[0]);
 		if (to_cleanup_pid)
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 	if ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())
 		options->namespaces |= CLONE_NEWCGROUP;
 
 	 
  int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun
 			.init_ctx = init_ctx,
 			.exec_function = exec_function,
 			.exec_payload = exec_payload,
 		};
 		 
	 
	status = 3;
	ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));
	if (ret <= 0) {
		ERROR(""Error using IPC to tell parent to set up LSM labels (3): %s."", strerror(errno));
		shutdown(ipc_socket, SHUT_RDWR);
		rexit(-1);
	}

 	if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
 		int on_exec;
		 
		ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);
		if (ret <= 0) {
			ERROR(""Error using IPC for parent to tell us LSM label fd (4): %s."", strerror(errno));
			shutdown(ipc_socket, SHUT_RDWR);
			rexit(-1);
		}
 
		 
 		on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
		if (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {
			SYSERROR(""Failed to set LSM label."");
			shutdown(ipc_socket, SHUT_RDWR);
			close(lsm_labelfd);
 			rexit(-1);
 		}
		close(lsm_labelfd);
 	}

 	if (init_ctx->container && init_ctx->container->lxc_conf &&
 	    init_ctx->container->lxc_conf->seccomp &&
 	    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {
 		ERROR(""Loading seccomp policy"");
		shutdown(ipc_socket, SHUT_RDWR);
 		rexit(-1);
 	}

	shutdown(ipc_socket, SHUT_RDWR);
	close(ipc_socket);
 	lxc_proc_put_context_info(init_ctx);
 
 	 
 	 
 	rexit(payload->exec_function(payload->exec_payload));
 }","lxc-attach in LXC before 1.0.9 and 2.x before 2.0.6 allows an attacker inside of an unprivileged container to use an inherited file descriptor, of the host's /proc, to access the rest of the host's filesystem via the openat() family of syscalls."
1355,CVE-2016-8636,"  int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)
 
 	case RXE_MEM_TYPE_MR:
 	case RXE_MEM_TYPE_FMR:
		if (iova < mem->iova ||
		    length > mem->length ||
		    iova > mem->iova + mem->length - length)
			return -EFAULT;
		return 0;
 
 	default:
 		return -EFAULT;","Integer overflow in the mem_check_range function in drivers/infiniband/sw/rxe/rxe_mr.c in the Linux kernel before 4.9.10 allows local users to cause a denial of service (memory corruption), obtain sensitive information from kernel memory, or possibly have unspecified other impact via a write or read request involving the *RDMA protocol over infiniband* (aka Soft RoCE) technology."
1356,CVE-2016-7972,"  static bool check_allocations(ASS_Shaper *shaper, size_t new_size)
             !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||
             !ASS_REALLOC_ARRAY(shaper->cmap, new_size))
             return false;
        shaper->n_glyphs = new_size;
     }
     return true;
 }",The check_allocations function in libass/ass_shaper.c in libass before 0.13.4 allows remote attackers to cause a denial of service (memory allocation failure) via unspecified vectors.
1357,CVE-2016-7970,"  static void calc_coeff(double mu[4], const int index[4], int prefilter, double r
         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
     };
 
    double mat_freq[14];
     memcpy(mat_freq, kernel, sizeof(kernel));
     memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
     int n = 6;",Buffer overflow in the calc_coeff function in libass/ass_blur.c in libass before 0.13.4 allows remote attackers to cause a denial of service via unspecified vectors.
1358,CVE-2016-7969,"  wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
                         ((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -
                         (w->bbox.xMin + w->pos.x));
 
                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2) && w > text_info->glyphs) {
                        if (w->linebreak)
                            text_info->n_lines--;
                         w->linebreak = 1;
                         s2->linebreak = 0;
                         exit = 0;","The wrap_lines_smart function in ass_render.c in libass before 0.13.4 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors, related to *0/3 line wrapping equalization.*"
1359,CVE-2016-7906,"  MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type)
           status=QuantizeImage(quantize_info,image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
      status=AcquireImageColormap(image,2);
       image->matte=MagickFalse;
       break;
     }",magick/attribute.c in ImageMagick 7.0.3-2 allows remote attackers to cause a denial of service (use-after-free) via a crafted file.
1360,CVE-2016-7838,"  namespace winsparkle
 namespace
 {
 
std::wstring GetUniqueTempDirectoryPrefix()
{
    wchar_t tmpdir[MAX_PATH + 1];
    if (GetTempPath(MAX_PATH + 1, tmpdir) == 0)
        throw Win32Exception(""Cannot create temporary directory"");

    std::wstring dir(tmpdir);
    dir += L""Update-"";
    return dir;
}

 std::wstring CreateUniqueTempDirectory()
 {
      
  std::wstring CreateUniqueTempDirectory()
      
      
      
    const std::wstring tmpdir = GetUniqueTempDirectoryPrefix();
 
     for ( ;; )
     {
         std::wstring dir(tmpdir);
         UUID uuid;
         UuidCreate(&uuid);
         RPC_WSTR uuidStr;
  void UpdateDownloader::CleanLeftovers()
     if ( !Settings::ReadConfigValue(""UpdateTempDir"", tmpdir) )
         return;
 
     
     
    try
    {
        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)
        {
            Settings::DeleteConfigValue(""UpdateTempDir"");
            return;
        }
    }
    catch (Win32Exception&)  
    {
        return;
    }

     tmpdir.append(1, '\0');  
 
     SHFILEOPSTRUCT fos = {0};",Untrusted search path vulnerability in WinSparkle versions prior to 0.5.3 allows remote attackers to execute arbitrary code via a specially crafted executable file in an unspecified directory.
1361,CVE-2016-7799,"  MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)
         break;   
       tag_value=(ssize_t) ReadProfileShort(endian,q);
       format=(ssize_t) ReadProfileShort(endian,q+2);
      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))
         break;
       components=(ssize_t) ReadProfileLong(endian,q+4);
       if (components < 0)",MagickCore/profile.c in ImageMagick before 7.0.3-2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
1362,CVE-2016-7798," 
  */
 VALUE cCipher;
 VALUE eCipherError;
static ID id_auth_tag_len, id_key_set;
 
 static VALUE ossl_cipher_alloc(VALUE klass);
 static void ossl_cipher_free(void *ptr);
  ossl_cipher_initialize(VALUE self, VALUE str)
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
  ossl_cipher_initialize(VALUE self, VALUE str)
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
  ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)
 	ossl_raise(eCipherError, NULL);
     }
 
    if (p_key)
	rb_ivar_set(self, id_key_set, Qtrue);

     return self;
 }
 
  ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
     OPENSSL_cleanse(key, sizeof key);
     OPENSSL_cleanse(iv, sizeof iv);
 
    rb_ivar_set(self, id_key_set, Qtrue);

     return Qnil;
 }
 
  ossl_cipher_update(int argc, VALUE *argv, VALUE self)
 
     rb_scan_args(argc, argv, ""11"", &data, &str);
 
    if (!RTEST(rb_attr_get(self, id_key_set)))
	ossl_raise(eCipherError, ""key not set"");

     StringValue(data);
     in = (unsigned char *)RSTRING_PTR(data);
     if ((in_len = RSTRING_LEN(data)) == 0)
  ossl_cipher_set_key(VALUE self, VALUE key)
     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
    rb_ivar_set(self, id_key_set, Qtrue);

     return key;
 }
 
  Init_ossl_cipher(void)
     rb_define_method(cCipher, ""padding="", ossl_cipher_set_padding, 1);
 
     id_auth_tag_len = rb_intern_const(""auth_tag_len"");
    id_key_set = rb_intern_const(""key_set"");
 }","The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism."
1363,CVE-2016-7797,"  lrmd_remote_client_msg(gpointer data)
                 g_source_remove(client->remote->auth_timeout);
             }
             client->remote->auth_timeout = 0;

             
            notify_of_new_client(client);
         }
         return 0;
     }
  lrmd_remote_listen(gpointer data)
                         &lrmd_remote_fd_cb);
     g_hash_table_insert(client_connections, new_client->id, new_client);
 
     return TRUE;
 }
 ","Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection."
1364,CVE-2016-7540," 
   Forward declarations.
 */
 static MagickBooleanType
  WriteRGFImage(const ImageInfo *,Image *);
 
  
static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;
  static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
  static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,
   y=0;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     bit=0;",coders/rgf.c in ImageMagick before 6.9.4-10 allows remote attackers to cause a denial of service (assertion failure) by converting an image to rgf format.
1365,CVE-2016-7539,"  static MagickBooleanType MaskPixelCacheNexus(Image *image,NexusInfo *nexus_info,
 %
 */
 
 #if defined(__cplusplus) || defined(c_plusplus)
 extern ""C"" {
 #endif
  static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
       if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||
           (cache_info->type == MemoryCache))
         {
          cache_info->mapped=MagickFalse;
          cache_info->pixels=(PixelPacket *) MagickAssumeAligned(
            AcquireAlignedMemory(1,(size_t) cache_info->length));
           if (cache_info->pixels == (PixelPacket *) NULL)
             cache_info->pixels=source_info.pixels;
           else",Memory leak in AcquireVirtualMemory in ImageMagick before 7 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors.
1366,CVE-2016-7538,"  static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)
     p=PushLongPixel(MSBEndian,p,&count);
     if (id == 0x0000040f)
       {
        if ((q+PSDQuantum(count)+12) < (datum+length-16))
          {
            (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-
              (PSDQuantum(count)+12)-(q-datum));
            SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));
          }
         break;
       }
     p+=count;",coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds write) via a crafted file.
1367,CVE-2016-7537,"  static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
       return(DestroyImageList(image));
     }
   packets=(bits_per_pixel*image->columns+7)/8;
  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)
     image->rows*sizeof(*runlength));
   if (runlength == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  buffer=(unsigned char *) AcquireQuantumMemory(257,sizeof(*buffer));
   if (buffer == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   packet_size=(size_t) (image->depth > 8 ? 2: 1);",MagickCore/memory.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted PDB file.
1368,CVE-2016-7536,"  static void WriteTo8BimProfile(Image *image,const char *name,
     count=(ssize_t) value;
     if ((count & 0x01) != 0)
       count++;
    if ((count < 0) || (p > (datum+length-count)) ||
        (count > (ssize_t) length))
       break;
     if (id != profile_id)
       p+=count;",magick/profile.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via a crafted profile.
1369,CVE-2016-7534,"  static void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,
 
           n=0;
           quantum=0;
          for (x=0; x < (ssize_t) number_pixels; x+=4)
           {
             for (i=0; i < 4; i++)
             {",The generic decoder in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted file.
1370,CVE-2016-7533,"  static Image *ReadWPGImage(const ImageInfo *image_info,
                   {
                     ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                     BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                      ldblk+1,sizeof(*BImgBuff));
                     if (BImgBuff == (unsigned char *) NULL)
                       goto NoMemory;
 ",The ReadWPGImage function in coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted WPG file.
1371,CVE-2016-7532,"  static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)
     register unsigned char
       *q;
 
    ssize_t
      cnt;

     q=(unsigned char *) p;
     if (LocaleNCompare((const char *) p,""8BIM"",4) != 0)
      return;
     p=PushLongPixel(MSBEndian,p,&long_sans);
     p=PushShortPixel(MSBEndian,p,&id);
     p=PushShortPixel(MSBEndian,p,&short_sans);
     p=PushLongPixel(MSBEndian,p,&count);
    cnt=PSDQuantum(count);
    if (cnt < 0)
      return;
    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))
       {
        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));
        SetStringInfoLength(bim_profile,length-(cnt+12));
         break;
       }
     p+=count;
  static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)
   }
 }
 
static MagickBooleanType WritePSDImage(const ImageInfo *image_info,
  Image *image,ExceptionInfo *exception)
 {
   const char
     *property;",coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
1372,CVE-2016-7530,"  MagickExport size_t GetQuantumExtent(const Image *image,
   const QuantumInfo *quantum_info,const QuantumType quantum_type)
 {
   size_t
    extent,
     packet_size;
 
   assert(quantum_info != (QuantumInfo *) NULL);
  MagickExport size_t GetQuantumExtent(const Image *image,
     case CMYKAQuantum: packet_size=5; break;
     default: break;
   }
  extent=MagickMax(image->columns,image->rows);
   if (quantum_info->pack == MagickFalse)
    return((size_t) (packet_size*extent*((quantum_info->depth+7)/8)));
  return((size_t) ((packet_size*extent*quantum_info->depth+7)/8));
 }
 
 /*
  MagickExport MagickBooleanType SetQuantumDepth(const Image *image,
   if (quantum_info->pixels != (unsigned char **) NULL)
     DestroyQuantumPixels(quantum_info);
   quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;
  extent=MagickMax(image->columns,image->rows)*quantum;
  if ((MagickMax(image->columns,image->rows) != 0) &&
      (quantum != (extent/MagickMax(image->columns,image->rows))))
     return(MagickFalse);
   return(AcquireQuantumPixels(quantum_info,extent));
 }",The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.
1373,CVE-2016-7529,"  static MagickBooleanType load_tile(Image *image,Image *tile_image,
     *xcfdata,
     *xcfodata;
 
  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(MagickMax(data_length,
    tile_image->columns*tile_image->rows),sizeof(*xcfdata));
   if (xcfdata == (XCFPixelInfo *) NULL)
     ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
       image->filename);",coders/xcf.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted XCF file.
1374,CVE-2016-7528,"  static Image *ReadVIFFImage(const ImageInfo *image_info,
       max_packets=((image->columns+7UL) >> 3UL)*image->rows;
     else
       max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,
      max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);",The ReadVIFFImage function in coders/viff.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via a crafted VIFF file.
1375,CVE-2016-7527,"  static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,
   if(exception->severity != UndefinedException) goto FINISH_UNL;
   if(magic_info->name == (char *) NULL) goto FINISH_UNL;
 
  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);
 
      
    ",coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
1376,CVE-2016-7526,"  static void InsertRow(unsigned char *p,ssize_t y,Image *image, int bpp)
         if (q == (PixelPacket *) NULL)
           break;
         indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-1); x+=4)
         {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);
             SetPixelIndex(indexes+x,index);",coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds write) via a crafted file.
1377,CVE-2016-7525,"  static inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)
 static inline size_t GetPSDRowSize(Image *image)
 {
   if (image->depth == 1)
    return(((image->columns+7)/8)*GetPSDPacketSize(image));
   else
     return(image->columns*GetPSDPacketSize(image));
 }",Heap-based buffer overflow in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
1378,CVE-2016-7522,"  static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)
       if (blocks == (unsigned char *) NULL)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       count=ReadBlob(image,(size_t) length,blocks);
      if ((count != (ssize_t) length) || (length < 4) ||
           (LocaleNCompare((char *) blocks,""8BIM"",4) != 0))
         {
           blocks=(unsigned char *) RelinquishMagickMemory(blocks);",The ReadPSDImage function in MagickCore/locale.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
1379,CVE-2016-7521,"  static ssize_t DecodePSDPixels(const size_t number_compact_pixels,
     length++;
     for (j=0; j < (ssize_t) length; j++)
     {
      CheckNumberCompactPixels;
       switch (depth)
       {
         case 1:
  static ssize_t DecodePSDPixels(const size_t number_compact_pixels,
           break;
         }
       }
       compact_pixels++;
     }
   }",Heap-based buffer overflow in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
1380,CVE-2016-7520,"  static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,
     }
   if (image->gamma != 0.0)
     {
      count=FormatLocaleString(header,MagickPathExtent,""GAMMA=%g\n"",
        image->gamma);
       (void) WriteBlob(image,(size_t) count,(unsigned char *) header);
     }
   count=FormatLocaleString(header,MagickPathExtent,
  static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,
    
  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  (void) ResetMagickMemory(pixels,0,4*(image->columns+128)*sizeof(*pixels));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,exception);",Heap-based buffer overflow in coders/hdr.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted HDR file.
1381,CVE-2016-7515,"  static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
     map_length,
     number_colormaps,
     number_planes,
    number_planes_filled,
     one,
     offset,
     pixel_info_length;
  static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if (image->alpha_trait != UndefinedPixelTrait)
       number_planes++;
     number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info_length=image->columns*image->rows*number_planes_filled;
     pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");",The ReadRLEImage function in coders/rle.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via vectors related to the number of pixels.
1382,CVE-2016-7514,"  static MagickBooleanType ReadPSDChannelPixels(Image *image,
                   SetPixelIndex(image,(((unsigned char) pixel) &
                     (0x01 << (7-bit))) != 0 ? 0 : 255,q);
                   SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
                    ConstrainColormapIndex(image,GetPixelIndex(image,q),
                      exception),q);
                   q+=GetPixelChannels(image);
                   x++;
                 }",The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
1383,CVE-2016-7513,"  MagickExport void ClonePixelCacheMethods(Cache clone,const Cache cache)
 %
 */
 
 static inline MagickSizeType MagickMin(const MagickSizeType x,
   const MagickSizeType y)
 {
  static MagickBooleanType ClonePixelCacheRepository(
        
      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*
        cache_info->rows*sizeof(*cache_info->pixels));
       if ((cache_info->active_index_channel != MagickFalse) &&
           (clone_info->active_index_channel != MagickFalse))
         (void) memcpy(clone_info->indexes,cache_info->indexes,",Off-by-one error in magick/cache.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via unspecified vectors.
1384,CVE-2016-7480,"  SPL_METHOD(SplObjectStorage, unserialize)
 	--p;  
 	count = Z_LVAL_P(pcount);
 
	ZVAL_UNDEF(&entry);
	ZVAL_UNDEF(&inf);

 	while (count-- > 0) {
 		spl_SplObjectStorageElement *pelement;
 		zend_string *hash;
  SPL_METHOD(SplObjectStorage, unserialize)
 		if (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) {
 			goto outexcept;
 		}
 		if (*p == ',') {  
 			++p;
 			if (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) {
 				zval_ptr_dtor(&entry);
 				goto outexcept;
 			}
		}
		if (Z_TYPE(entry) != IS_OBJECT) {
			zval_ptr_dtor(&entry);
			zval_ptr_dtor(&inf);
			goto outexcept;
 		}
 
 		hash = spl_object_storage_get_hash(intern, getThis(), &entry);","The SplObjectStorage unserialize implementation in ext/spl/spl_observer.c in PHP before 7.0.12 does not verify that a key is an object, which allows remote attackers to execute arbitrary code or cause a denial of service (uninitialized memory access) via crafted serialized data."
1385,CVE-2016-7145,"  int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* par
 
   if (acptr) {
     if (first) {
      if (*parv[1] == ':' || strchr(parv[1], ' '))
		return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_one(&me, CMD_SASL, acptr, ""%C %C!%u.%u S %s :%s"", acptr, &me,
                       cli_fd(cptr), cli_saslcookie(cptr),
  int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* par
     }
   } else {
     if (first) {
      if (*parv[1] == ':' || strchr(parv[1], ' '))
        return exit_client(cptr, sptr, sptr, ""Malformed AUTHENTICATE"");
       if (!EmptyString(cli_sslclifp(cptr)))
         sendcmdto_serv_butone(&me, CMD_SASL, cptr, ""* %C!%u.%u S %s :%s"", &me,
                               cli_fd(cptr), cli_saslcookie(cptr),",The m_authenticate function in ircd/m_authenticate.c in nefarious2 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.
1386,CVE-2016-7144,"  CMD_FUNC(m_authenticate)
 		return 0;
 	}
 
	if ((parv[1][0] == ':') || strchr(parv[1], ' '))
	{
		sendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, ""*"", ""AUTHENTICATE"", ""Invalid parameter"");
		return 0;
	}

 	if (strlen(parv[1]) > 400)
 	{
 		sendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? ""*"" : sptr->name);",The m_authenticate function in modules/m_sasl.c in UnrealIRCd before 3.2.10.7 and 4.x before 4.0.6 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.
1387,CVE-2016-6912,"  BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)
 	return im;
 }
 
 
static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
    int ret = 0;
 
 	if (im == NULL) {
		return 1;
 	}
 
 	if (!gdImageTrueColor(im)) {
		gd_error(""Palette image not supported by webp"");
		return 1;
 	}
 
 	if (quality == -1) {
 		quality = 80;
 	}
 
 	if (overflow2(gdImageSX(im), 4)) {
		return 1;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
		return 1;
 	}
 
 	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
 	if (!argb) {
		return 1;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
  BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);
 	if (out_size == 0) {
 		gd_error(""gd-webp encoding failed"");
        ret = 1;
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);

    return ret;
}


 
BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
{
	_gdImageWebpCtx(im, outfile, quality);
 }
 
 /*
  BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)
 	if (out == NULL) {
 		return;
 	}
	_gdImageWebpCtx(im, out, quality);
 	out->gd_free(out);
 }
 
  BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
 	if (out == NULL) {
 		return;
 	}
	_gdImageWebpCtx(im, out, -1);
 	out->gd_free(out);
 }
 
  BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
 	if (out == NULL) {
 		return NULL;
 	}
	if (_gdImageWebpCtx(im, out, -1)) {
		rv = NULL;
	} else {
		rv = gdDPExtractData(out, size);
	}
 	out->gd_free(out);
 
 	return rv;
  BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
 	if (out == NULL) {
 		return NULL;
 	}
	if (_gdImageWebpCtx(im, out, quality)) {
        rv = NULL;
    } else {
        rv = gdDPExtractData(out, size);
    }
 	out->gd_free(out);
 	return rv;
 }",Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.
1388,CVE-2016-6911,"  static void dynamicPutchar(struct gdIOCtx *ctx, int a)
 	appendDynamic(dctx->dp, &b, 1);
 }
 
 
 static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
 {
 	int rlen, remain;
  static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
 	dctx = (dpIOCtxPtr) ctx;
 	dp = dctx->dp;
 
	if (dp->pos < 0 || dp->pos >= dp->realSize) {
		return 0;
	}

 	remain = dp->logicalSize - dp->pos;
 	if(remain >= len) {
 		rlen = len;
 	} else {
 		if(remain <= 0) {
			return 0;
 		}
 
 		rlen = remain;
 	}
 
	if (dp->pos + rlen > dp->realSize) {
		rlen = dp->realSize - dp->pos;
	}

 	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
 	dp->pos += rlen;
 ",The dynamicGetbuf function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TIFF image.
1389,CVE-2016-6906,"  int read_image_tga( gdIOCtx *ctx, oTga *tga )
 				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;
 
				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
						|| buffer_caret + pixel_block_size > rle_size) {
 					gdFree( decompression_buffer );
 					gdFree( conversion_buffer );
 					return -1;
  int read_image_tga( gdIOCtx *ctx, oTga *tga )
 				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
 				buffer_caret++;
 
				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size
						|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {
 					gdFree( decompression_buffer );
 					gdFree( conversion_buffer );
 					return -1;","The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file, related to the decompression buffer."
1390,CVE-2016-6875,"  bool WddxPacket::serialize_value(const Variant& varVariant) {
 bool WddxPacket::recursiveAddVar(const String& varName,
                                  const Variant& varVariant,
                                  bool hasVarTag) {
  SeenContainers seen;
  return recursiveAddVarImpl(varName, varVariant, hasVarTag, seen);
}
 
bool WddxPacket::recursiveAddVarImpl(const String& varName,
                                     const Variant& varVariant,
                                     bool hasVarTag,
                                     SeenContainers& seen) {
   bool isArray = varVariant.isArray();
   bool isObject = varVariant.isObject();
 
   if (isArray || isObject) {
    Array varAsArray;
    Object varAsObject;
    ArrayOrObject ptr;
    if (isArray) {
      varAsArray = varVariant.toArray();
      ptr = varAsArray.get();
    }
    if (isObject) {
      varAsObject = varVariant.toObject();
      varAsArray = varAsObject.toArray();
      ptr = varAsObject.get();
    }
    assert(!ptr.isNull());
    if (!seen.emplace(ptr).second) {
      raise_warning(""recursion detected"");
      return false;
    }
    SCOPE_EXIT { seen.erase(ptr); };

     if (hasVarTag) {
       m_packetString.append(""<var name='"");
       m_packetString.append(varName.data());
       m_packetString.append(""'>"");
     }
 
     int length = varAsArray.length();
     if (length > 0) {
       ArrayIter it = ArrayIter(varAsArray);
  bool WddxPacket::recursiveAddVar(const String& varName,
         m_packetString.append(""'>"");
       }
       for (ArrayIter it(varAsArray); it; ++it) {
        auto key = it.first();
        auto const& value = it.secondRef();
        recursiveAddVarImpl(key.toString(), value, isObject, seen);
       }
       if (isObject) {
         m_packetString.append(""</struct>"");",Infinite recursion in wddx in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.
1391,CVE-2016-6874,"  static void php_array_merge(Array &arr1, const Array& arr2) {
   arr1.merge(arr2);
 }
 
static bool couldRecur(const Variant& v, const Array& arr) {
  return v.isReferenced() ||
    arr.get()->kind() == ArrayData::kGlobalsKind ||
    arr.get()->kind() == ArrayData::kProxyKind;
}

 static void php_array_merge_recursive(PointerSet &seen, bool check,
                                       Array &arr1, const Array& arr2) {
  if (check && !seen.insert((void*)arr1.get()).second) {
    raise_warning(""array_merge_recursive(): recursion detected"");
    return;
   }
 
   for (ArrayIter iter(arr2); iter; ++iter) {
  static void php_array_merge_recursive(PointerSet &seen, bool check,
        
       Variant &v = arr1.lvalAt(key, AccessFlags::Key);
       auto subarr1 = v.toArray().copy();
      php_array_merge_recursive(seen,
                                couldRecur(v, subarr1),
                                subarr1,
                                 value.toArray());
       v.unset();  
       v = subarr1;
  static void php_array_replace(Array &arr1, const Array& arr2) {
 
 static void php_array_replace_recursive(PointerSet &seen, bool check,
                                         Array &arr1, const Array& arr2) {
  if (arr1.get() == arr2.get()) {
     
     
     
     
     
    return;
  }

  if (check && !seen.insert((void*)arr1.get()).second) {
    raise_warning(""array_replace_recursive(): recursion detected"");
    return;
   }
 
   for (ArrayIter iter(arr2); iter; ++iter) {
  static void php_array_replace_recursive(PointerSet &seen, bool check,
       if (v.isArray()) {
         Array subarr1 = v.toArray();
         const ArrNR& arr_value = value.toArrNR();
        php_array_replace_recursive(seen, couldRecur(v, subarr1),
                                    subarr1, arr_value);
         v = subarr1;
       } else {
         arr1.set(key, value, true);","The array_*_recursive functions in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, related to recursion."
1392,CVE-2016-6873,"  static void php_array_merge(Array &arr1, const Array& arr2) {
   arr1.merge(arr2);
 }
 
static bool couldRecur(const Variant& v, const ArrayData* arr) {
   return v.isReferenced() ||
    arr->kind() == ArrayData::kGlobalsKind ||
    arr->kind() == ArrayData::kProxyKind;
 }
 
 static void php_array_merge_recursive(PointerSet &seen, bool check,
  static void php_array_merge_recursive(PointerSet &seen, bool check,
       Variant &v = arr1.lvalAt(key, AccessFlags::Key);
       auto subarr1 = v.toArray().copy();
       php_array_merge_recursive(seen,
                                couldRecur(v, subarr1.get()),
                                 subarr1,
                                 value.toArray());
       v.unset();  
  static void php_array_replace_recursive(PointerSet &seen, bool check,
       if (v.isArray()) {
         Array subarr1 = v.toArray();
         const ArrNR& arr_value = value.toArrNR();
        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),
                                     subarr1, arr_value);
         v = subarr1;
       } else {
  bool HHVM_FUNCTION(array_walk,
   return true;
 }
 
static void compact(PointerSet& seen,
                    VarEnv* v, Array &ret, const Variant& var) {
   if (var.isArray()) {
    auto adata = var.getArrayData();
    auto check = couldRecur(var, adata);
    if (check && !seen.insert(adata).second) {
      raise_warning(""compact(): recursion detected"");
      return;
     }
    for (ArrayIter iter(adata); iter; ++iter) {
      compact(seen, v, ret, iter.secondRef());
    }
    if (check) seen.erase(adata);
   } else {
     String varname = var.toString();
     if (!varname.empty() && v->lookup(varname.get()) != NULL) {
  Array HHVM_FUNCTION(compact,
   Array ret = Array::attach(PackedArray::MakeReserve(args.size() + 1));
   VarEnv* v = g_context->getOrCreateVarEnv();
   if (v) {
    PointerSet seen;
    compact(seen, v, ret, varname);
    if (!args.empty()) compact(seen, v, ret, args);
   }
   return ret;
 }
  Array HHVM_FUNCTION(__SystemLib_compact_sl,
   Array ret = Array::attach(PackedArray::MakeReserve(args.size() + 1));
   VarEnv* v = g_context->getOrCreateVarEnv();
   if (v) {
    PointerSet seen;
    compact(seen, v, ret, varname);
    if (!args.empty()) compact(seen, v, ret, args);
   }
   return ret;
 }",Self recursion in compact in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.
1393,CVE-2016-6872,"  String StringUtil::Implode(const Variant& items, const String& delim,
 
   req::vector<String> sitems;
   sitems.reserve(size);
  size_t len = 0;
  size_t lenDelim = delim.size();
   for (ArrayIter iter(items); iter; ++iter) {
     sitems.emplace_back(iter.second().toString());
     len += sitems.back().size() + lenDelim;",Integer overflow in StringUtil::implode in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.
1394,CVE-2016-6871,"  static IMPLEMENT_THREAD_LOCAL(bcmath_data, s_globals);
 
  
 
static int64_t adjust_scale(int64_t scale) {
  if (scale < 0) {
    scale = BCG(bc_precision);
    if (scale < 0) scale = 0;
  }
  if ((uint64_t)scale > StringData::MaxSize) return StringData::MaxSize;
  return scale;
}

 static void php_str2num(bc_num *num, const char *str) {
   const char *p;
   if (!(p = strchr(str, '.'))) {
  static bool HHVM_FUNCTION(bcscale, int64_t scale) {
 
 static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
                             int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);
  static String HHVM_FUNCTION(bcadd, const String& left, const String& right,
 
 static String HHVM_FUNCTION(bcsub, const String& left, const String& right,
                             int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);
  static String HHVM_FUNCTION(bcsub, const String& left, const String& right,
 
 static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,
                              int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second;
   bc_init_num(&first);
   bc_init_num(&second);
  static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,
 
 static String HHVM_FUNCTION(bcmul, const String& left, const String& right,
                             int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);
  static String HHVM_FUNCTION(bcmul, const String& left, const String& right,
 
 static Variant HHVM_FUNCTION(bcdiv, const String& left, const String& right,
                int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);
  static Variant HHVM_FUNCTION(bcmod, const String& left, const String& right) {
 
 static String HHVM_FUNCTION(bcpow, const String& left, const String& right,
                            int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second, result;
   bc_init_num(&first);
   bc_init_num(&second);
  static String HHVM_FUNCTION(bcpow, const String& left, const String& right,
 
 static Variant HHVM_FUNCTION(bcpowmod, const String& left, const String& right,
                              const String& modulus, int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num first, second, mod, result;
   bc_init_num(&first);
   bc_init_num(&second);
  static Variant HHVM_FUNCTION(bcpowmod, const String& left, const String& right,
 
 static Variant HHVM_FUNCTION(bcsqrt, const String& operand,
                              int64_t scale  ) {
  scale = adjust_scale(scale);
   bc_num result;
   bc_init_num(&result);
   SCOPE_EXIT {","Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow."
1395,CVE-2016-6870,"  static int php_mb_parse_encoding_list(const char *value, int value_length,
 
      
     if (value[0]=='""' && value[value_length-1]=='""' && value_length>2) {
      tmpstr = req::strndup(value + 1, value_length - 2);
       value_length -= 2;
    } else {
      tmpstr = req::strndup(value, value_length);
     }
     if (tmpstr == nullptr) {
       return 0;
     }
  static int php_mb_parse_encoding_list(const char *value, int value_length,
       }
       ret = 0;
     }
    req::free(tmpstr);
   }
 
   return ret;
  bool HHVM_FUNCTION(mb_parse_str,
   info.num_from_encodings     = MBSTRG(http_input_list_size);
   info.from_language          = MBSTRG(current_language);
 
  char *encstr = req::strndup(encoded_string.data(), encoded_string.size());
   Array resultArr = Array::Create();
   mbfl_encoding *detected =
     _php_mb_encoding_handler_ex(&info, resultArr, encstr);
  req::free(encstr);
   result.assignIfRef(resultArr);
 
   MBSTRG(http_input_identify) = detected;
  bool HHVM_FUNCTION(mb_send_mail,
   if (!to.empty()) {
     int to_len = to.size();
     if (to_len > 0) {
      to_r = req::strndup(to.data(), to_len);
       for (; to_len; to_len--) {
         if (!isspace((unsigned char)to_r[to_len - 1])) {
           break;
  bool HHVM_FUNCTION(mb_send_mail,
                                encoded_message.data(),
                                all_headers, cmd.data()));
   mbfl_memory_device_clear(&device);
  if (to_r != to.data()) {
    req::free(to_r);
  }
   return ret;
 }
 ","Out-of-bounds write in the (1) mb_detect_encoding, (2) mb_send_mail, and (3) mb_detect_order functions in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors."
1396,CVE-2016-6561," 
 
  
 
  
	smb_ofile_flush(sr, sr->fid_ofile);
 
 	/*
 	 * SMB2 Flush reply",illumos smbsrv NULL pointer dereference allows system crash.
1397,CVE-2016-6271," 
 #define		BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN	0xa080
 #define		BZRTP_PARSER_ERROR_UNMATCHINGMAC		0xa100
 #define		BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE	0xa200
#define		BZRTP_PARSER_ERROR_UNMATCHINGHVI		0xa400
 
 #define		BZRTP_BUILDER_ERROR_INVALIDPACKET		0x5001
 #define		BZRTP_BUILDER_ERROR_INVALIDMESSAGE		0x5002",The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.
1398,CVE-2016-6129,"  int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,
   } else {
      
     unsigned char *out;
    unsigned long outlen, loid[16], reallen;
     int           decoded;
     ltc_asn1_list digestinfo[2], siginfo[2];
 
  int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,
        goto bail_2;
     }
 
    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {
       XFREE(out);
       goto bail_2;
    }

      
    if ((reallen == outlen) &&
        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&
         (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&
         (siginfo[1].size == hashlen) &&
         (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {","The rsa_verify_hash_ex function in rsa_verify_hash.c in LibTomCrypt, as used in OP-TEE before 2.2.0, does not validate that the message length is equal to the ASN.1 encoded data length, which makes it easier for remote attackers to forge RSA signatures or public certificates by leveraging a Bleichenbacher signature forgery attack."
1399,CVE-2016-5735,"  static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainp
     png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height,
                  &bit_depth, &color_type, NULL, NULL, NULL);
 
      
  static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainp
 
     rowbytes = png_get_rowbytes(png_ptr, info_ptr);
 
     
    if (rowbytes > INT_MAX/mainprog_ptr->height) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return PNG_OUT_OF_MEMORY_ERROR;
    }

     if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) {
         fprintf(stderr, ""pngquant readpng:  unable to allocate image data\n"");
         png_destroy_read_struct(&png_ptr, &info_ptr, NULL);","Integer overflow in the rwpng_read_image24_libpng function in rwpng.c in pngquant 2.7.0 allows remote attackers to have unspecified impact via a crafted PNG file, which triggers a buffer overflow."
1400,CVE-2016-4797,"  static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,
 		
 		 
 		l_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);
		 
		if ((l_data_size > 0U) && ((((OPJ_UINT32)-1) / l_data_size) < (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0))) {
 			opj_event_msg(manager, EVT_ERROR, ""Not enough memory for tile data\n"");
 			return OPJ_FALSE;
 		}",Divide-by-zero vulnerability in the opj_tcd_init_tile function in tcd.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (application crash) via a crafted jp2 file.  NOTE: this issue exists because of an incorrect fix for CVE-2014-7947.
1401,CVE-2016-4796,"  void color_cmyk_to_rgb(opj_image_t *image)
 	w = image->comps[0].w;
 	h = image->comps[0].h;
 
	if (
			(image->numcomps < 4)
		 || (image->comps[0].dx != image->comps[1].dx) || (image->comps[0].dx != image->comps[2].dx) || (image->comps[0].dx != image->comps[3].dx)
		 || (image->comps[0].dy != image->comps[1].dy) || (image->comps[0].dy != image->comps[2].dy) || (image->comps[0].dy != image->comps[3].dy)
			) {
		fprintf(stderr,""%s:%d:color_cmyk_to_rgb\n\tCAN NOT CONVERT\n"", __FILE__,__LINE__);
		return;
	}
 
 	max = w * h;
 	",Heap-based buffer overflow in the color_cmyk_to_rgb in common/color.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (crash) via a crafted .j2k file.
1402,CVE-2016-3695," 
 #include <linux/nmi.h>
 #include <linux/delay.h>
 #include <linux/mm.h>
#include <linux/security.h>
 #include <asm/unaligned.h>
 
 #include ""apei-internal.h""
  static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,
 	int rc;
 	u64 base_addr, size;
 
	if (get_securelevel() > 0)
		return -EPERM;

 	 
 	if (flags && (flags &
 		~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))",The einj_error_inject function in drivers/acpi/apei/einj.c in the Linux kernel allows local users to simulate hardware errors and consequently cause a denial of service by leveraging failure to disable APEI error injection through EINJ when securelevel is set.
1403,CVE-2016-3183,"  static void sycc444_to_rgb(opj_image_t *img)
 {
 	int *d0, *d1, *d2, *r, *g, *b;
 	const int *y, *cb, *cr;
	size_t maxw, maxh, max, i;
 	int offset, upb;
 
 	upb = (int)img->comps[0].prec;
 	offset = 1<<(upb - 1); upb = (1<<upb)-1;
 
	maxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;
 	max = maxw * maxh;
 
 	y = img->comps[0].data;
 	cb = img->comps[1].data;
 	cr = img->comps[2].data;
 
	d0 = r = (int*)malloc(sizeof(int) * max);
	d1 = g = (int*)malloc(sizeof(int) * max);
	d2 = b = (int*)malloc(sizeof(int) * max);
 
 	if(r == NULL || g == NULL || b == NULL) goto fails;
 
  static void sycc444_to_rgb(opj_image_t *img)
 	free(img->comps[0].data); img->comps[0].data = d0;
 	free(img->comps[1].data); img->comps[1].data = d1;
 	free(img->comps[2].data); img->comps[2].data = d2;
	img->color_space = OPJ_CLRSPC_SRGB;
 	return;
 
 fails:
	free(r);
	free(g);
	free(b);
 } 
 
 static void sycc422_to_rgb(opj_image_t *img)
 {	
 	int *d0, *d1, *d2, *r, *g, *b;
 	const int *y, *cb, *cr;
	size_t maxw, maxh, max, offx, loopmaxw;
 	int offset, upb;
	size_t i;
 
 	upb = (int)img->comps[0].prec;
 	offset = 1<<(upb - 1); upb = (1<<upb)-1;
 
	maxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;
 	max = maxw * maxh;
 
 	y = img->comps[0].data;
 	cb = img->comps[1].data;
 	cr = img->comps[2].data;
 
	d0 = r = (int*)malloc(sizeof(int) * max);
	d1 = g = (int*)malloc(sizeof(int) * max);
	d2 = b = (int*)malloc(sizeof(int) * max);
 
 	if(r == NULL || g == NULL || b == NULL) goto fails;
 
	 
	offx = img->x0 & 1U;
	loopmaxw = maxw - offx;
	
 	for(i=0U; i < maxh; ++i)
 	{
		size_t j;
		
		if (offx > 0U) {
			sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
			++y; ++r; ++g; ++b;
		}
		
		for(j=0U; j < (loopmaxw & ~(size_t)1U); j += 2U)
 		{
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 			++y; ++r; ++g; ++b;
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 			++y; ++r; ++g; ++b; ++cb; ++cr;
 		}
		if (j < loopmaxw) {
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 			++y; ++r; ++g; ++b; ++cb; ++cr;
 		}
 	}
	
 	free(img->comps[0].data); img->comps[0].data = d0;
 	free(img->comps[1].data); img->comps[1].data = d1;
 	free(img->comps[2].data); img->comps[2].data = d2;
 
	img->comps[1].w = img->comps[2].w = img->comps[0].w;
	img->comps[1].h = img->comps[2].h = img->comps[0].h;
	img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;
	img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;
	img->color_space = OPJ_CLRSPC_SRGB;
 	return;
 
 fails:
	free(r);
	free(g);
	free(b);
 } 
 
 static void sycc420_to_rgb(opj_image_t *img)
 {
 	int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;
 	const int *y, *cb, *cr, *ny;
	size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;
 	int offset, upb;
	size_t i;
 
 	upb = (int)img->comps[0].prec;
 	offset = 1<<(upb - 1); upb = (1<<upb)-1;
 
	maxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;
 	max = maxw * maxh;
 
 	y = img->comps[0].data;
 	cb = img->comps[1].data;
 	cr = img->comps[2].data;
 
	d0 = r = (int*)malloc(sizeof(int) * max);
	d1 = g = (int*)malloc(sizeof(int) * max);
	d2 = b = (int*)malloc(sizeof(int) * max);
	
	if (r == NULL || g == NULL || b == NULL) goto fails;
	
	 
	offx = img->x0 & 1U;
	loopmaxw = maxw - offx;
	 
	offy = img->y0 & 1U;
	loopmaxh = maxh - offy;
	
	if (offy > 0U) {
		size_t j;
		
		for(j=0; j < maxw; ++j)
		{
			sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
			++y; ++r; ++g; ++b;
		}
	}
 
	for(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)
 	{
		size_t j;
		
 		ny = y + maxw;
 		nr = r + maxw; ng = g + maxw; nb = b + maxw;
		
		if (offx > 0U) {
			sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);
			++y; ++r; ++g; ++b;
			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
			++ny; ++nr; ++ng; ++nb;
		}
 
		for(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)
 		{
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 			++y; ++r; ++g; ++b;
  static void sycc420_to_rgb(opj_image_t *img)
 			sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
 			++ny; ++nr; ++ng; ++nb; ++cb; ++cr;
 		}
		if(j < loopmaxw)
 		{
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 			++y; ++r; ++g; ++b;
  static void sycc420_to_rgb(opj_image_t *img)
 		}
 		y += maxw; r += maxw; g += maxw; b += maxw;
 	}
	if(i < loopmaxh)
 	{
		size_t j;
		
		for(j=0U; j < (maxw & ~(size_t)1U); j += 2U)
 		{
 			sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
 
  static void sycc420_to_rgb(opj_image_t *img)
 	free(img->comps[1].data); img->comps[1].data = d1;
 	free(img->comps[2].data); img->comps[2].data = d2;
 
	img->comps[1].w = img->comps[2].w = img->comps[0].w;
	img->comps[1].h = img->comps[2].h = img->comps[0].h;
	img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;
	img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;
	img->color_space = OPJ_CLRSPC_SRGB;
 	return;
 
 fails:
	free(r);
	free(g);
	free(b);
 } 
 
 void color_sycc_to_rgb(opj_image_t *img)
  void color_sycc_to_rgb(opj_image_t *img)
 		fprintf(stderr,""%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n"", __FILE__,__LINE__);
 		return;
   }
 } 
 
 #if defined(OPJ_HAVE_LIBLCMS2) || defined(OPJ_HAVE_LIBLCMS1)",The sycc422_t_rgb function in common/color.c in OpenJPEG before 2.1.1 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted jpeg2000 file.
1404,CVE-2016-3179,"  void processRequest(struct reqelem * req)
 			syslog(LOG_ERR, ""cannot allocate memory"");
 			goto error;
 		}
		memset(newserv, 0, sizeof(struct service));	 
 		if(containsForbiddenChars(p, l)) {
 			syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
 			goto error;",The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (invalid free and daemon crash) via vectors related to error handling.
1405,CVE-2016-2347,"  static uint8_t *extend_raw_data(LHAFileHeader **header,
 	size_t new_raw_len;
 	uint8_t *result;
 
	if (nbytes > LEVEL_3_MAX_HEADER_LEN) {
		return NULL;
	}

 	 
 
 	new_raw_len = RAW_DATA_LEN(header) + nbytes;
  static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)
 
 	header_len = lha_decode_uint32(&RAW_DATA(header, 24));
 
	if (header_len > LEVEL_3_MAX_HEADER_LEN
	 || header_len < RAW_DATA_LEN(header)) {
 		return 0;
 	}
 ",Integer underflow in the decode_level3_header function in lib/lha_file_header.c in Lhasa before 0.3.1 allows remote attackers to execute arbitrary code via a crafted archive.
1406,CVE-2016-1245,"  rtadv_read (struct thread *thread)
    
   rtadv_event (zvrf, RTADV_READ, sock);
 
  len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);
 
   if (len < 0) 
     {","It was discovered that the zebra daemon in Quagga before 1.0.20161017 suffered from a stack-based buffer overflow when processing IPv6 Neighbor Discovery messages. The root cause was relying on BUFSIZ to be compatible with a message size; however, BUFSIZ is system-dependent."
1407,CVE-2015-9004,"  struct perf_event {
 #endif  
 };
 
  
 struct perf_event_context {
 	struct pmu			*pmu;
 	/*
 	 * Protect the states of the events in the list,
 	 * nr_active, and the list:","kernel/events/core.c in the Linux kernel before 3.19 mishandles counter grouping, which allows local users to gain privileges via a crafted application, related to the perf_pmu_register and perf_event_open functions."
1408,CVE-2015-8959,"  static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        if (SeekBlob(image,offset,SEEK_CUR) < 0)
          break;
         w = DIV2(w);
         h = DIV2(h);
       }",coders/dds.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (CPU consumption) via a crafted DDS file.
1409,CVE-2015-8958,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
         sun_info.length || !sun_info.length)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     number_pixels=(MagickSizeType) image->columns*image->rows;
    if ((sun_info.type != RT_ENCODED) && 
        ((number_pixels*sun_info.depth) > (8*sun_info.length)))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     bytes_per_line=sun_info.width*sun_info.depth;
     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
             bytes_per_pixel++;
           if (bytes_per_line == 0)
             bytes_per_line=bytes_per_pixel*image->columns;
          length=image->rows*(bytes_per_line+bytes_per_line % 2);
           if (((sun_info.type == RT_ENCODED) &&
                (length > (bytes_per_line*image->rows))) ||
               ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))",coders/sun.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted SUN file.
1410,CVE-2015-8957,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
         size_t
           one;
 
         image->colors=sun_info.maplength;
         one=1;
         if (sun_info.maptype == RMT_NONE)
           image->colors=one << sun_info.depth;
         if (sun_info.maptype == RMT_EQUAL_RGB)
           image->colors=sun_info.maplength/3;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     switch (sun_info.maptype)
     {
       case RMT_EQUAL_RGB:
       {
         unsigned char
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
          
         sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
           sizeof(*sun_colormap));
         if (sun_colormap == (unsigned char *) NULL)",Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.
1411,CVE-2015-8900,"  static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)
           if (value_expected == MagickFalse)
             continue;
           p=value;
          while ((c != '\n') && (c != '\0') && (c != EOF))
           {
             if ((size_t) (p-value) < (MaxTextExtent-1))
               *p++=c;
  static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)
                     chromaticity[6],
                     white_point[2];
 
                  if (sscanf(value,""%g %g %g %g %g %g %g %g"",&chromaticity[0],
                      &chromaticity[1],&chromaticity[2],&chromaticity[3],
                      &chromaticity[4],&chromaticity[5],&white_point[0],
                      &white_point[1]) == 8)
                    {
                      image->chromaticity.red_primary.x=chromaticity[0];
                      image->chromaticity.red_primary.y=chromaticity[1];
                      image->chromaticity.green_primary.x=chromaticity[2];
                      image->chromaticity.green_primary.y=chromaticity[3];
                      image->chromaticity.blue_primary.x=chromaticity[4];
                      image->chromaticity.blue_primary.y=chromaticity[5];
                      image->chromaticity.white_point.x=white_point[0],
                      image->chromaticity.white_point.y=white_point[1];
                    }
                   break;
                 }
               (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword);
  static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)
                     height,
                     width;
 
                  if (sscanf(value,""%d +X %d"",&height,&width) == 2)
                    {
                      image->columns=(size_t) width;
                      image->rows=(size_t) height;
                    }
                   break;
                 }
               (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword);",The ReadHDRImage function in coders/hdr.c in ImageMagick 6.x and 7.x allows remote attackers to cause a denial of service (infinite loop) via a crafted HDR file.
1412,CVE-2015-8898,"  MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);
   p=images;
   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))
  {
    register Image
      *next;
    
    next=GetNextImageInList(p);
    if (next == (Image *) NULL)
      break;
    if (p->scene >= next->scene)
       {
         register ssize_t
           i;
  MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,
           p->scene=(size_t) i++;
         break;
       }
  }
    ",The WriteImages function in magick/constitute.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image file.
1413,CVE-2015-8897,"  MagickExport Image *SpliceImage(const Image *image,
     splice_geometry;
 
   ssize_t
    columns,
     y;
 
    
   status=MagickTrue;
   progress=0;
  columns=MagickMin(splice_geometry.x,(ssize_t) splice_image->columns);
   image_view=AcquireVirtualCacheView(image,exception);
   splice_view=AcquireAuthenticCacheView(splice_image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
  MagickExport Image *SpliceImage(const Image *image,
 
     if (status == MagickFalse)
       continue;
    p=GetCacheViewVirtualPixels(image_view,0,y,splice_image->columns,1,
      exception);
     q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,
       exception);
     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
       {
         status=MagickFalse;
         continue;
       }
    for (x=0; x < columns; x++)
     {
       register ssize_t
         i;
  MagickExport Image *SpliceImage(const Image *image,
 
     if (status == MagickFalse)
       continue;
    if ((y < 0) || (y >= (ssize_t)splice_image->rows))
       continue;
    p=GetCacheViewVirtualPixels(image_view,0,y-(ssize_t) splice_geometry.height,
      splice_image->columns,1,exception);
     q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,
       exception);
     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
       {
         status=MagickFalse;
         continue;
       }
    for (x=0; x < columns; x++)
     {
       register ssize_t
         i;",The SpliceImage function in MagickCore/transform.c in ImageMagick before 6.9.2-4 allows remote attackers to cause a denial of service (application crash) via a crafted png file.
1414,CVE-2015-8896,"  MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,
       else
         RelinquishMagickResource(MapResource,length);
     }
  if ((memory_info->blob == NULL) &&
      (AcquireMagickResource(DiskResource,length) != MagickFalse))
     {
       int
         file;
  MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,
         Anonymous memory mapping failed, try file-backed memory mapping.
       */
       file=AcquireUniqueFileResource(memory_info->filename);
      if (file == -1)
        RelinquishMagickResource(DiskResource,length);
      else
         {
          if ((lseek(file,length-1,SEEK_SET) < 0) || (write(file,"""",1) != 1))
            RelinquishMagickResource(DiskResource,length);
          else
             {
              if (AcquireMagickResource(MapResource,length) == MagickFalse)
                RelinquishMagickResource(DiskResource,length);
              else
                 {
                  memory_info->blob=MapBlob(file,IOMode,0,length);
                  if (memory_info->blob != NULL)
                    memory_info->type=MapVirtualMemory;
                  else
                    {
                      RelinquishMagickResource(MapResource,length);
                      RelinquishMagickResource(DiskResource,length);
                    }
                 }
             }
           (void) close(file);
  MagickExport MemoryInfo *RelinquishVirtualMemory(MemoryInfo *memory_info)
         memory_info->blob=NULL;
         RelinquishMagickResource(MapResource,memory_info->length);
         if (*memory_info->filename != '\0')
          {
            (void) RelinquishUniqueFileResource(memory_info->filename);
            RelinquishMagickResource(DiskResource,memory_info->length);
          }
         break;
       }
       case UnalignedVirtualMemory:",Integer truncation issue in coders/pict.c in ImageMagick before 7.0.5-0 allows remote attackers to cause a denial of service (application crash) via a crafted .pict file.
1415,CVE-2015-8894,"  static Image *ReadTGAImage(const ImageInfo *image_info,
        
      if (image->colors < tga_info.colormap_index)
        image->colors=tga_info.colormap_index;
       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)",Double free vulnerability in coders/tga.c in ImageMagick 7.0.0 and later allows remote attackers to cause a denial of service (application crash) via a crafted tga file.
1416,CVE-2015-8026,"  int exfat_mount(struct exfat* ef, const char* spec, const char* options)
 		exfat_error(""exFAT file system is not found"");
 		return -EIO;
 	}
	 
	if (ef->sb->sector_bits < 9)
	{
		exfat_close(ef->dev);
		exfat_error(""too small sector size: 2^%hhd"", ef->sb->sector_bits);
		free(ef->sb);
		return -EIO;
	}
	 
	if ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)
	{
		exfat_close(ef->dev);
		exfat_error(""too big cluster size: 2^(%hhd+%hhd)"",
				ef->sb->sector_bits, ef->sb->spc_bits);
		free(ef->sb);
		return -EIO;
	}
 	ef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));
 	if (ef->zero_cluster == NULL)
 	{
  int exfat_mount(struct exfat* ef, const char* spec, const char* options)
 		free(ef->sb);
 		return -EIO;
 	}
 	if (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >
 			exfat_get_size(ef->dev))
 	{",Heap-based buffer overflow in the verify_vbr_checksum function in exfatfsck in exfat-utils before 1.2.1 allows remote attackers to cause a denial of service (infinite loop) or possibly execute arbitrary code via a crafted filesystem.
1417,CVE-2015-7837,"  setup_efi_state(struct boot_params *params, unsigned long params_load_addr,
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
	params->secure_boot = boot_params.secure_boot;
 	ei->efi_loader_signature = current_ei->efi_loader_signature;
 	ei->efi_systab = current_ei->efi_systab;
 	ei->efi_systab_hi = current_ei->efi_systab_hi;","The Linux kernel, as used in Red Hat Enterprise Linux 7, kernel-rt, and Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended securelevel/secureboot restrictions by leveraging improper handling of secure_boot flag across kexec reboot."
1418,CVE-2015-7510,"  enum nss_status _nss_mymachines_getpwnam_r(
         if (!e || e == p)
                 goto not_found;
 
        if (e - p > HOST_NAME_MAX - 1)  
                goto not_found;

         r = parse_uid(e + 1, &uid);
         if (r < 0)
                 goto not_found;
  enum nss_status _nss_mymachines_getgrnam_r(
         if (!e || e == p)
                 goto not_found;
 
        if (e - p > HOST_NAME_MAX - 1)   
                goto not_found;

         r = parse_gid(e + 1, &gid);
         if (r < 0)
                 goto not_found;",Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.
1419,CVE-2015-6817,"  static void start_auth_request(PgSocket *client, const char *username)
 	int res;
 	PktBuf *buf;
 
 	 
 	client->pool = get_pool(client->db, client->db->auth_user);
 	if (!find_server(client)) {","PgBouncer 1.6.x before 1.6.1, when configured with auth_user, allows remote attackers to gain login access as auth_user via an unknown username."
1420,CVE-2015-5224," 
 
 #include ""c.h""
 
extern int xmkstemp(char **tmpname, const char *dir, const char *prefix);
 
static inline FILE *xfmkstemp(char **tmpname, const char *dir, const char *prefix)
 {
 	int fd;
 	FILE *ret;
 
	fd = xmkstemp(tmpname, dir, prefix);
 	if (fd == -1)
 		return NULL;
 ",The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks.
1421,CVE-2015-5221,"  static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
 			break;
 		}
 	}
 	if (!cmpt->sampperx || !cmpt->samppery) {
 		goto error;
 	}
 	if (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {
 		goto error;
 	}
	jas_tvparser_destroy(tvp);
 	return 0;
 
 error:",Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file.
1422,CVE-2015-4645,"  static int read_xattr_entry(struct xattr_list *xattr,
  */
 int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, long long *table_start)
 {
	 
	int res, i, indexes, index_bytes;
	unsigned int ids;
	long long bytes;
 	long long *index, start, end;
 	struct squashfs_xattr_table id_table;
 
  int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, l
 
 	SQUASHFS_INSWAP_XATTR_TABLE(&id_table);
 
	 
	ids = id_table.xattr_ids;
	xattr_table_start = id_table.xattr_table_start;
	index_bytes = SQUASHFS_XATTR_BLOCK_BYTES((long long) ids);
	indexes = SQUASHFS_XATTR_BLOCKS((long long) ids);

	 
	if(index_bytes != (sBlk->bytes_used - (sBlk->xattr_id_table_start + sizeof(id_table)))) {
		ERROR(""read_xattrs_from_disk: Bad xattr_ids count in super block\n"");
		return 0;
	}

	 
	if(table_start != NULL)
 		*table_start = id_table.xattr_table_start;

	 
	if(flag)
 		return id_table.xattr_ids;
 
 	 
 	index = malloc(index_bytes);
 	if(index == NULL)
 		MEM_ERROR();
  int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, l
 	 * Allocate enough space for the uncompressed xattr id table, and
 	 * read and decompress it
 	 */
	bytes = SQUASHFS_XATTR_BYTES((long long) ids);
 	xattr_ids = malloc(bytes);
 	if(xattr_ids == NULL)
 		MEM_ERROR();
  int read_xattrs_from_disk(int fd, struct squashfs_super_block *sBlk, int flag, l
 					bytes & (SQUASHFS_METADATA_SIZE - 1);
 		int length = read_block(fd, index[i], NULL, expected,
 			((unsigned char *) xattr_ids) +
			((long long) i * SQUASHFS_METADATA_SIZE));
 		TRACE(""Read xattr id table block %d, from 0x%llx, length ""
 			""%d\n"", i, index[i], length);
 		if(length == 0) {","Integer overflow in the read_fragment_table_4 function in unsquash-4.c in Squashfs and sasquatch allows remote attackers to cause a denial of service (application crash) via a crafted input, which triggers a stack-based buffer overflow."
1423,CVE-2015-4054,"  static bool handle_client_startup(PgSocket *client, PktHdr *pkt)
 		}
 		break;
 	case 'p':		 
		 
		if (!client->auth_user) {
			disconnect_client(client, true, ""client password pkt before startup packet"");
			return false;
		}

 		 
 		if (cf_auth_type <= AUTH_TRUST) {
 			disconnect_client(client, true, ""unrequested passwd pkt"");",PgBouncer before 1.5.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by sending a password packet before a startup packet.
1424,CVE-2015-3886,"  inf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,
 
       if(ret != GNUTLS_E_SUCCESS)
         inf_gnutls_set_error(&error, ret);
     }

    if(error == NULL)
      if(verify & GNUTLS_CERT_INVALID)
        inf_gnutls_certificate_verification_set_error(&error, verify);
   }
 
   /* Look up the host in our database of pinned certificates if we could not","libinfinity before 0.6.6-1 does not validate expired SSL certificates, which allows remote attackers to have unspecified impact via unknown vectors."
1425,CVE-2015-3315,"  int main(int argc, char** argv)
             unlink(core_basename);
         }
 
 
#if 0
          
  int main(int argc, char** argv)
                 close(src_fd);
             }
         }
#endif
 
         /* We close dumpdir before we start catering for crash storm case.
          * Otherwise, delete_dump_dir's from other concurrent","Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."
1426,CVE-2015-3215,"  tChecksumCheckResult ParaNdis_CheckRxChecksum(
                                             ULONG ulDataOffset)
 {
     tOffloadSettingsFlags f = pContext->Offload.flags;
    tChecksumCheckResult res;
     tTcpIpPacketParsingResult ppr;
     ULONG flagsToCalculate = 0;
     res.value = 0;
 
      
      
  tChecksumCheckResult ParaNdis_CheckRxChecksum(
 
     ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);
 
    if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)
    {
        res.flags.IpOK = FALSE;
        res.flags.IpFailed = TRUE;
        return res;
    }

     if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)
     {
         pContext->extraStatistics.framesRxCSHwOK++;","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options."
1427,CVE-2015-3138,"  wb_id(netdissect_options *ndo,
 	len -= sizeof(*io) * nid;
 	io = (struct id_off *)(id + 1);
 	cp = (char *)(io + nid);
	if (ND_TTEST2(cp, len)) {
 		ND_PRINT((ndo, ""\""""));
 		fn_print(ndo, (u_char *)cp, (u_char *)cp + len);
 		ND_PRINT((ndo, ""\""""));
  wb_prep(netdissect_options *ndo,
 	}
 	n = EXTRACT_32BITS(&prep->pp_n);
 	ps = (const struct pgstate *)(prep + 1);
	while (--n >= 0 && ND_TTEST(*ps)) {
 		const struct id_off *io, *ie;
 		char c = '<';
 
  wb_prep(netdissect_options *ndo,
 		    ipaddr_string(ndo, &ps->page.p_sid),
 		    EXTRACT_32BITS(&ps->page.p_uid)));
 		io = (struct id_off *)(ps + 1);
		for (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {
 			ND_PRINT((ndo, ""%c%s:%u"", c, ipaddr_string(ndo, &io->id),
 			    EXTRACT_32BITS(&io->off)));
 			c = ',';",print-wb.c in tcpdump before 4.7.4 allows remote attackers to cause a denial of service (segmentation fault and process crash).
1428,CVE-2015-2313,"  TEST(Encoding, VoidListAmplification) {
 }
 
 TEST(Encoding, EmptyStructListAmplification) {
  MallocMessageBuilder builder(1024);
  auto listList = builder.initRoot<test::TestAnyPointer>().getAnyPointerField()
      .initAs<List<List<test::TestEmptyStruct>>>(500);

  for (uint i = 0; i < listList.size(); i++) {
    listList.init(i, 1u << 28);
  }
 
   auto segments = builder.getSegmentsForOutput();
  ASSERT_EQ(1, segments.size());
 
   SegmentArrayMessageReader reader(builder.getSegmentsForOutput());
  auto root = reader.getRoot<test::TestAnyPointer>();
  auto listListReader = root.getAnyPointerField().getAs<List<List<TestAllTypes>>>();
  EXPECT_NONFATAL_FAILURE(listListReader[0]);
  EXPECT_NONFATAL_FAILURE(listListReader[10]);

  EXPECT_EQ(segments[0].size() - 1, root.totalSize().wordCount);
 }
 
 TEST(Encoding, Constants) {","Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.2, when an application invokes the totalSize method on an object reader, allows remote peers to cause a denial of service (CPU consumption) via a crafted small message, which triggers a *tight* for loop.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-2312."
1429,CVE-2015-2311,"  struct WireHelpers {
       WirePointer* ref, word* refTarget, SegmentBuilder* segment,
       const void* defaultValue, ByteCount defaultSize)) {
     if (ref->isNull()) {
    useDefault:
       if (defaultSize == 0 * BYTES) {
         return nullptr;
       } else {
  struct WireHelpers {
       }
     } else {
       word* ptr = followFars(ref, refTarget, segment);
      char* cptr = reinterpret_cast<char*>(ptr);
 
       KJ_REQUIRE(ref->kind() == WirePointer::LIST,
           ""Called getText{Field,Element}() but existing pointer is not a list."");
       KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,
           ""Called getText{Field,Element}() but existing list pointer is not byte-sized."");
 
      size_t size = ref->listRef.elementCount() / ELEMENTS;
      KJ_REQUIRE(size > 0 && cptr[size-1] == '\0', ""Text blob missing NUL terminator."") {
        goto useDefault;
      }

      return Text::Builder(cptr, size - 1);
     }
   }
 ",Integer underflow in Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.1 might allow remote peers to cause a denial of service or possibly obtain sensitive information from memory or execute arbitrary code via a crafted message.
1430,CVE-2015-2310,"  struct WireHelpers {
               return result;
             }
 
            KJ_REQUIRE(elementTag->structRef.wordSize() / ELEMENTS *
                       ElementCount64(count) <= wordCount,
                        ""Struct list pointer's elements overran size."") {
               return result;
             }
  struct WireHelpers {
           ElementCount elementCount = tag->inlineCompositeListElementCount();
           auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;
 
          KJ_REQUIRE(wordsPerElement * ElementCount64(elementCount) <= wordCount,
                      ""INLINE_COMPOSITE list's elements overrun its word count."") {
             goto useDefault;
           }
  struct WireHelpers {
       size = tag->inlineCompositeListElementCount();
       wordsPerElement = tag->structRef.wordSize() / ELEMENTS;
 
      KJ_REQUIRE(ElementCount64(size) * wordsPerElement <= wordCount,
                  ""INLINE_COMPOSITE list's elements overrun its word count."") {
         goto useDefault;
       }","Integer overflow in layout.c++ in Sandstorm Cap'n Proto before 0.4.1.1 and 0.5.x before 0.5.1.1 allows remote peers to cause a denial of service or possibly obtain sensitive information from memory via a crafted message, related to pointer validation."
1431,CVE-2014-9940,"  static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
				rdev->ena_pin = NULL;
				return;
 			} else {
 				pin->request_count--;
 			}",The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application.
1432,CVE-2014-9922,"  static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags
 	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
 	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
	s->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;

	rc = -EINVAL;
	if (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""eCryptfs: maximum fs stacking depth exceeded\n"");
		goto out_free;
	}
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);","The eCryptfs subsystem in the Linux kernel before 3.18 allows local users to gain privileges via a large filesystem stack that includes an overlayfs layer, related to fs/ecryptfs/main.c and fs/overlayfs/super.c."
1433,CVE-2014-9914,"  int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 }
 EXPORT_SYMBOL(ip4_datagram_connect);
 
 
 void ip4_datagram_release_cb(struct sock *sk)
 {
 	const struct inet_sock *inet = inet_sk(sk);
 	const struct ip_options_rcu *inet_opt;
 	__be32 daddr = inet->inet_daddr;
	struct dst_entry *dst;
 	struct flowi4 fl4;
 	struct rtable *rt;
 
 	rcu_read_lock();

	dst = __sk_dst_get(sk);
	if (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {
		rcu_read_unlock();
		return;
	}
 	inet_opt = rcu_dereference(inet->inet_opt);
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
 				   inet->inet_saddr, inet->inet_dport,
 				   inet->inet_sport, sk->sk_protocol,
 				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);

	dst = !IS_ERR(rt) ? &rt->dst : NULL;
	sk_dst_set(sk, dst);

 	rcu_read_unlock();
 }
 EXPORT_SYMBOL_GPL(ip4_datagram_release_cb);",Race condition in the ip4_datagram_release_cb function in net/ipv4/datagram.c in the Linux kernel before 3.15.2 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect expectations about locking during multithreaded access to internal data structures for IPv4 UDP sockets.
1434,CVE-2014-9907,"  static const DDSSingleColourLookup*
 if (min > max) \
   min = max; \
 if (max - min < steps) \
  max = MagickMin(min + steps, 255); \
 if (max - min < steps) \
  min = MagickMax(min - steps, 0)
 
 #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)
 
  if (max - min < steps) \
   Forward declarations
 */
 static MagickBooleanType
  ConstructOrdering(const size_t,const DDSVector4 *,const DDSVector3,
    DDSVector4 *,DDSVector4 *,unsigned char *,size_t),
  ReadDDSInfo(Image *,DDSInfo *),
  ReadDXT1(Image *,DDSInfo *,ExceptionInfo *),
  ReadDXT3(Image *,DDSInfo *,ExceptionInfo *),
  ReadDXT5(Image *,DDSInfo *,ExceptionInfo *),
  ReadUncompressedRGB(Image *,DDSInfo *,ExceptionInfo *),
  ReadUncompressedRGBA(Image *,DDSInfo *,ExceptionInfo *),
  SkipDXTMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),
  SkipRGBMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),
  WriteDDSImage(const ImageInfo *,Image *),
  WriteMipmaps(Image *,const size_t,const size_t,const size_t,
    const MagickBooleanType,const MagickBooleanType,ExceptionInfo *);
 
 static void
  RemapIndices(const ssize_t *,const unsigned char *,unsigned char *),
  WriteDDSInfo(Image *,const size_t,const size_t,const size_t),
  WriteFourCC(Image *,const size_t,const MagickBooleanType,
    const MagickBooleanType,ExceptionInfo *),
  WriteImageData(Image *,const size_t,const size_t,const MagickBooleanType,
    const MagickBooleanType,ExceptionInfo *),
  WriteIndices(Image *,const DDSVector3,const DDSVector3, unsigned char *),
  WriteSingleColorFit(Image *,const DDSVector4 *,const ssize_t *),
  WriteUncompressed(Image *,ExceptionInfo *);
 
 static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,
   DDSVector4 *destination)
  static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,
 
 static inline void VectorClamp(DDSVector4 *value)
 {
  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));
  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));
  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));
  value->w = MagickMin(1.0f,MagickMax(0.0f,value->w));
 }
 
 static inline void VectorClamp3(DDSVector3 *value)
 {
  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));
  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));
  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));
 }
 
 static inline void VectorCopy43(const DDSVector4 source,
  static void ComputePrincipleComponent(const float *covariance,
     w.z = (row2.z * v.z) + w.z;
     w.w = (row2.w * v.z) + w.w;
 
    a = 1.0f / MagickMax(w.x,MagickMax(w.y,w.z));
 
     v.x = w.x * a;
     v.y = w.y * a;
  static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,
     for (x = 0; x < (ssize_t) dds_info->width; x += 4)
     {
        
      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),
        MagickMin(4, dds_info->height - y),exception);
 
       if (q == (PixelPacket *) NULL)
         return MagickFalse;
  static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,
     }
   }
 
  return(SkipDXTMipmaps(image,dds_info,8,exception));
 }
 
 static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,
  static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,
     for (x = 0; x < (ssize_t) dds_info->width; x += 4)
     {
        
      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),
                         MagickMin(4, dds_info->height - y),exception);
 
       if (q == (PixelPacket *) NULL)
         return MagickFalse;
  static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,
     }
   }
 
  return(SkipDXTMipmaps(image,dds_info,16,exception));
 }
 
 static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,
  static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,
     for (x = 0; x < (ssize_t) dds_info->width; x += 4)
     {
        
      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),
                         MagickMin(4, dds_info->height - y),exception);
 
       if (q == (PixelPacket *) NULL)
         return MagickFalse;
  static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,
     }
   }
 
  return(SkipDXTMipmaps(image,dds_info,16,exception));
 }
 
 static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,
  static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,
       return MagickFalse;
   }
 
  return(SkipRGBMipmaps(image,dds_info,3,exception));
 }
 
 static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,
  static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,
       return MagickFalse;
   }
 
  return(SkipRGBMipmaps(image,dds_info,4,exception));
 }
 
  
static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
 {
   register ssize_t
     i;
  static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)
       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
     {
      if (EOFBlob(image) != MagickFalse)
        {
          ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
            image->filename);
          return(MagickFalse);
        }
       w = DIV2(dds_info->width);
       h = DIV2(dds_info->height);
 
  static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)
         h = DIV2(h);
       }
     }
  return(MagickTrue);
 }
 
  
static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,
  int pixel_size,ExceptionInfo *exception)
 {
   MagickOffsetType
     offset;
  static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)
       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
     {
      if (EOFBlob(image) != MagickFalse)
        {
          ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
            image->filename);
          return(MagickFalse);
        }
       w = DIV2(dds_info->width);
       h = DIV2(dds_info->height);
 
  static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)
         h = DIV2(h);
       }
     }
  return(MagickTrue);
 }
 
 /*
  static void WriteDDSInfo(Image *image, const size_t pixelFormat,
 
   if (compression == FOURCC_DXT1)
     (void) WriteBlobLSBLong(image,
             (unsigned int) (MagickMax(1,(image->columns+3)/4) * 8));
   else
     (void) WriteBlobLSBLong(image,
             (unsigned int) (MagickMax(1,(image->columns+3)/4) * 16));
 
   (void) WriteBlobLSBLong(image,0x00);
   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);",coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.
1435,CVE-2014-9114,"  static int parse_token(char **name, char **value, char **cp)
 	*value = skip_over_blank(*value + 1);
 
 	if (**value == '""') {
		char *p = end = *value + 1;

		 
		while (*p) {
			if (*p == '\\') {
				p++;
				*end = *p;
			} else {
				*end = *p;
				if (*p == '""')
					break;
			}
			p++;
			end++;
		}

		if (*end != '""') {
 			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
 			*cp = *value;
 			return -BLKID_ERR_CACHE;
 		}
 		(*value)++;
 		*end = '\0';
		end = ++p;
 	} else {
 		end = skip_over_word(*value);
 		if (*end) {",Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.
1436,CVE-2014-8324,"  int net_get(int s, void *arg, int *len)
 	if (!(plen <= *len))
 		printf(""PLEN %d type %d len %d\n"",
 			plen, nh.nh_type, *len);
	assert(plen <= *len && plen > 0);  
 
 	*len = plen;
 	if ((*len) && (net_read_exact(s, arg, *len) == -1))",network.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter.
1437,CVE-2014-8323,"  int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)
 	*cmd++ = htons(S_CMD_PACKET);
 	*cmd++ = *pid;
 	plen = len - 2;
    if (plen < 0)
        return 0;
 
 	last_id = ntohs(*pid);
 	if (last_id > 20000)",buddy-ng.c in Aircrack-ng before 1.2 Beta 3 allows remote attackers to cause a denial of service (segmentation fault) via a response with a crafted length parameter.
1438,CVE-2014-4978,"  void
 rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
 
	 
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
 		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
 		g_warning(""Calling gnome-open failed."");
	g_free(command_line);
 
	g_free(dot_filename);
	g_free(png_filename);
 	g_string_free(str, TRUE);
 }",The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.
1439,CVE-2012-6697,"  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
 		 */
 		case DNS_QUERY_CNAME:
 		case DNS_QUERY_PTR:
		{
			unsigned short lowest_pos = length;
 			o = 0;
 			q = 0;
 			while (q == 0 && i < length && o + 256 < 1023)
  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
 					i = ntohs(ptr);
 
 					 
					if ((i & DN_COMP_BITMASK) != DN_COMP_BITMASK)
 						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
 
 					 
 					i &= ~DN_COMP_BITMASK;
 
 					 
					i -= 12;

					if (i >= lowest_pos)
						return std::make_pair((unsigned char *) NULL, ""Invalid decompression pointer"");
					lowest_pos = i;
 				}
 				else
 				{
  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
 				}
 			}
 			res[o] = 0;
		}
 		break;
 		case DNS_QUERY_AAAA:
 			if (rr.rdlength != sizeof(struct in6_addr))",InspIRCd before 2.0.7 allows remote attackers to cause a denial of service (infinite loop).
1440,CVE-2012-6696,"  DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
 				else i += header.payload[i] + 1;  
 			}
 		}
		if (static_cast<int>(length - i) < 10)
 			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
 
 		 ",inspircd in Debian before 2.0.7 does not properly handle unsigned integers.  NOTE: This vulnerability exists because of an incomplete fix to CVE-2012-1836.
1441,CVE-2010-5329,"  void v4l_printk_ioctl(unsigned int cmd)
 }
 EXPORT_SYMBOL(v4l_printk_ioctl);
 
 static void dbgbuf(unsigned int cmd, struct video_device *vfd,
 					struct v4l2_buffer *p)
 {
  static int check_array_args(unsigned int cmd, void *parg, size_t *array_size,
 	return ret;
 }
 
long
video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
	       v4l2_kioctl func)
 {
 	char	sbuf[128];
 	void    *mbuf = NULL;
  long video_ioctl2(struct file *file,
 	}
 
 	 
	err = func(file, cmd, parg);
 	if (err == -ENOIOCTLCMD)
 		err = -EINVAL;
 
  long video_ioctl2(struct file *file,
 	kfree(mbuf);
 	return err;
 }
EXPORT_SYMBOL(video_usercopy);

long video_ioctl2(struct file *file,
	       unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, __video_do_ioctl);
}
 EXPORT_SYMBOL(video_ioctl2);","The video_usercopy function in drivers/media/video/v4l2-ioctl.c in the Linux kernel before 2.6.39 relies on the count value of a v4l2_ext_controls data structure to determine a kmalloc size, which might allow local users to cause a denial of service (memory consumption) via a large value."
1442,CVE-2010-5328,"  extern struct cred init_cred;
 		[PIDTYPE_PGID] = INIT_PID_LINK(PIDTYPE_PGID),		\
 		[PIDTYPE_SID]  = INIT_PID_LINK(PIDTYPE_SID),		\
 	},								\
	.thread_group	= LIST_HEAD_INIT(tsk.thread_group),		\
 	.dirties = INIT_PROP_LOCAL_SINGLE(dirties),			\
 	INIT_IDS							\
 	INIT_PERF_EVENTS(tsk)						\","include/linux/init_task.h in the Linux kernel before 2.6.35 does not prevent signals with a process group ID of zero from reaching the swapper process, which allows local users to cause a denial of service (system crash) by leveraging access to this process group."
1443,CVE-2007-6761,"  videobuf_vm_open(struct vm_area_struct *vma)
 {
 	struct videobuf_mapping *map = vma->vm_private_data;
 
	dprintk(2,""vm_open %p [count=%u,vma=%08lx-%08lx]\n"",map,
 		map->count,vma->vm_start,vma->vm_end);
 
 	map->count++;
  videobuf_vm_close(struct vm_area_struct *vma)
 	struct videobuf_queue *q = map->q;
 	int i;
 
	dprintk(2,""vm_close %p [count=%u,vma=%08lx-%08lx]\n"",map,
 		map->count,vma->vm_start,vma->vm_end);
 
 	map->count--;
  static int __videobuf_mmap_mapper(struct videobuf_queue *q,
 	}
 
 	 
	map = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);
 	if (NULL == map)
 		return -ENOMEM;
 ","drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321."
1444,CVE-2006-5331,"  void kernel_fp_unavailable_exception(struct pt_regs *regs)
 
 void altivec_unavailable_exception(struct pt_regs *regs)
 {
 	if (user_mode(regs)) {
 		 
 		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
 		return;
 	}

 	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
 			""%lx at %lx\n"", regs->trap, regs->nip);
 	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);","The altivec_unavailable_exception function in arch/powerpc/kernel/traps.c in the Linux kernel before 2.6.19 on 64-bit systems mishandles the case where CONFIG_ALTIVEC is defined and the CPU actually supports Altivec, but the Altivec support was not detected by the kernel, which allows local users to cause a denial of service (panic) by triggering execution of an Altivec instruction."
1445,CVE-2018-1999015,"  static int decode_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)
     return 0;
 }
 
static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
 {
     int i, j, v;
 
     if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
          
         for (i = 0; i < 64; i++) {
             v = get_bits(gb, 8);
  static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
     }
 
     if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
          
         for (i = 0; i < 64; i++) {
             get_bits(gb, 8);
         }
     }
 
     if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
          
         for (i = 0; i < 64; i++) {
             v = get_bits(gb, 8);
  static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
     }
 
     if (get_bits1(gb)) {
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
          
         for (i = 0; i < 64; i++) {
             get_bits(gb, 8);
         }
     }
 
     next_start_code_studio(gb);
    return 0;
 }
 
 static void extension_and_user_data(MpegEncContext *s, GetBitContext *gb, int id)",FFmpeg before commit 5aba5b89d0b1d73164d3b81764828bb8b20ff32a contains an out of array read vulnerability in ASF_F format demuxer that can result in heap memory reading. This attack appear to be exploitable via specially crafted ASF file that has to provided as input. This vulnerability appears to have been fixed in 5aba5b89d0b1d73164d3b81764828bb8b20ff32a and later.
1446,CVE-2018-1999014,"  static int mxf_parse_structural_metadata(MXFContext *mxf)
                 MXFEssenceContainerData *essence_data;
 
                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {
                    av_log(mxf->fc, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");
                     continue;
                 }
                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {",FFmpeg before commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 contains an out of array access vulnerability in MXF format demuxer that can result in DoS. This attack appear to be exploitable via specially crafted MXF file which has to be provided as input. This vulnerability appears to have been fixed in bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 and later.
1447,CVE-2018-1999013,"  static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,
 
         size2 = avio_rb32(pb);
         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
                                        size2, NULL);
         if (ret < 0)
             return ret;
     }",FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later.
1448,CVE-2018-1999012,"  static int read_part_of_packet(AVFormatContext *s, int64_t *pts,
             pes_flags              = avio_rb16(pb);
             pes_header_data_length = avio_r8(pb);
 
            if (avio_feof(pb)) {
                return AVERROR_EOF;
            }

             if (pes_signal != 1 || pes_header_data_length == 0) {
                 pva_log(s, AV_LOG_WARNING, ""expected non empty signaled PES packet, ""
                                           ""trying to recover\n"");",FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later.
1449,CVE-2018-1999011,"  static int parse_video_info(AVIOContext *pb, AVStream *st)
     st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);
     size_bmp = FFMAX(size_asf, size_bmp);
 
    if (size_bmp > BMP_HEADER_SIZE &&
        size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
         int ret;
         st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;
         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +",FFmpeg before commit 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 contains a Buffer Overflow vulnerability in asf_o format demuxer that can result in heap-buffer-overflow that may result in remote code execution. This attack appears to be exploitable via specially crafted ASF file that has to be provided as input to FFmpeg. This vulnerability appears to have been fixed in 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 and later.
1450,CVE-2018-1999010,"  int ff_mms_asf_header_parser(MMSContext *mms)
                 }
             }
         } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {
            if (end - p >= (sizeof(ff_asf_guid) * 3 + 26)) {
                flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
                stream_id = flags & 0x7F;
                 
                 
                 
                if (mms->stream_num < MMS_MAX_STREAMS &&
                        46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {
                    mms->streams = av_fast_realloc(mms->streams,
                                       &mms->nb_streams_allocated,
                                       (mms->stream_num + 1) * sizeof(MMSStream));
                    if (!mms->streams)
                        return AVERROR(ENOMEM);
                    mms->streams[mms->stream_num].id = stream_id;
                    mms->stream_num++;
                } else {
                    av_log(NULL, AV_LOG_ERROR,
                           ""Corrupt stream (too many A/V streams)\n"");
                    return AVERROR_INVALIDDATA;
                }
             }
         } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {
             if (end - p >= 88) {
  int ff_mms_asf_header_parser(MMSContext *mms)
             }
         } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {
             chunksize = 46;  
            if (chunksize > end - p) {
                av_log(NULL, AV_LOG_ERROR,
                    ""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"",
                    chunksize);
                return AVERROR_INVALIDDATA;
            }
         }
         p += chunksize;
     }",FFmpeg before commit cced03dd667a5df6df8fd40d8de0bff477ee02e8 contains multiple out of array access vulnerabilities in the mms protocol that can result in attackers accessing out of bound data. This attack appear to be exploitable via network connectivity. This vulnerability appears to have been fixed in cced03dd667a5df6df8fd40d8de0bff477ee02e8 and later.
1451,CVE-2018-1000880,"  _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off)
 		return (ARCHIVE_EOF);
 	}
 
	if (w->unconsumed) {
		__archive_read_consume(a, w->unconsumed);
		w->unconsumed = 0U;
	}

 	rab = __archive_read_ahead(a, 1U, &nrd);
 	if (nrd < 0) {
 		*bsz = 0U;","libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file. This attack appear to be exploitable via the victim must open a specially crafted WARC file."
1452,CVE-2018-1000879,"  archive_acl_from_text_l(struct archive_acl *acl, const char *text,
 			st = field[n].start + 1;
 			len = field[n].end - field[n].start;
 
			if (len == 0) {
				ret = ARCHIVE_WARN;
				continue;
			}

 			switch (*s) {
 			case 'u':
 				if (len == 1 || (len == 4","libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted archive file."
1453,CVE-2018-1000878,"  struct rar
   struct data_block_offsets *dbo;
   unsigned int cursor;
   unsigned int nodes;
  char filename_must_match;
 
    
   struct huffman_code maincode;
  read_header(struct archive_read *a, struct archive_entry *entry,
     }
     return ret;
   }
  else if (rar->filename_must_match)
  {
    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
      ""Mismatch of file parts split across multi-volume archive"");
    return (ARCHIVE_FATAL);
  }
 
   rar->filename_save = (char*)realloc(rar->filename_save,
                                       filename_size + 1);
  rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)
     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&
       rar->file_flags & FHD_SPLIT_AFTER)
     {
      rar->filename_must_match = 1;
       ret = archive_read_format_rar_read_header(a, a->entry);
       if (ret == (ARCHIVE_EOF))
       {
         rar->has_endarc_header = 1;
         ret = archive_read_format_rar_read_header(a, a->entry);
       }
      rar->filename_must_match = 0;
       if (ret != (ARCHIVE_OK))
         return NULL;
       return rar_read_ahead(a, min, avail);",libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.
1454,CVE-2018-1000877,"  parse_codes(struct archive_read *a)
       new_size = DICTIONARY_MAX_SIZE;
     else
       new_size = rar_fls((unsigned int)rar->unp_size) << 1;
    if (new_size == 0) {
      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                        ""Zero window size is invalid."");
      return (ARCHIVE_FATAL);
    }
     new_window = realloc(rar->lzss.window, new_size);
     if (new_window == NULL) {
       archive_set_error(&a->archive, ENOMEM,","libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted RAR archive."
1455,CVE-2018-1000852,"  static UINT dvcman_receive_channel_data(drdynvcPlugin* drdynvc,
 	if (channel->dvc_data)
 	{
 		 
		if (Stream_GetPosition(channel->dvc_data) + dataSize > Stream_Capacity(channel->dvc_data))
 		{
 			WLog_Print(drdynvc->log, WLOG_ERROR, ""data exceeding declared length!"");
 			Stream_Release(channel->dvc_data);
 			channel->dvc_data = NULL;
 			return ERROR_INVALID_DATA;
 		}
 
		Stream_Copy(data, channel->dvc_data, dataSize);
 
 		if (Stream_GetPosition(channel->dvc_data) >= channel->dvc_data_length)
 		{
  static UINT drdynvc_process_capability_request(drdynvcPlugin* drdynvc, int Sp,
 	if (!drdynvc)
 		return CHANNEL_RC_BAD_INIT_HANDLE;
 
	if (Stream_GetRemainingLength(s) < 3)
		return ERROR_INVALID_DATA;

 	WLog_Print(drdynvc->log, WLOG_TRACE, ""capability_request Sp=%d cbChId=%d"", Sp, cbChId);
 	Stream_Seek(s, 1);  
 	Stream_Read_UINT16(s, drdynvc->version);
  static UINT drdynvc_process_capability_request(drdynvcPlugin* drdynvc, int Sp,
 	 */
 	if ((drdynvc->version == 2) || (drdynvc->version == 3))
 	{
		if (Stream_GetRemainingLength(s) < 8)
			return ERROR_INVALID_DATA;

 		Stream_Read_UINT16(s, drdynvc->PriorityCharge0);
 		Stream_Read_UINT16(s, drdynvc->PriorityCharge1);
 		Stream_Read_UINT16(s, drdynvc->PriorityCharge2);
  static UINT drdynvc_process_capability_request(drdynvcPlugin* drdynvc, int Sp,
 	return status;
 }
 
static UINT32 drdynvc_cblen_to_bytes(int cbLen)
{
	switch (cbLen)
	{
		case 0:
			return 1;

		case 1:
			return 2;

		default:
			return 4;
	}
}

 static UINT32 drdynvc_read_variable_uint(wStream* s, int cbLen)
 {
 	UINT32 val;
  static UINT drdynvc_process_create_request(drdynvcPlugin* drdynvc, int Sp,
 	UINT32 ChannelId;
 	wStream* data_out;
 	UINT channel_status;
	char* name;
	size_t length;
 
 	if (!drdynvc)
 		return CHANNEL_RC_BAD_CHANNEL_HANDLE;
  static UINT drdynvc_process_create_request(drdynvcPlugin* drdynvc, int Sp,
 		drdynvc->state = DRDYNVC_STATE_READY;
 	}
 
	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId))
		return ERROR_INVALID_DATA;

 	ChannelId = drdynvc_read_variable_uint(s, cbChId);
 	pos = Stream_GetPosition(s);
	name = Stream_Pointer(s);
	length = Stream_GetRemainingLength(s);

	if (strnlen(name, length) >= length)
		return ERROR_INVALID_DATA;

 	WLog_Print(drdynvc->log, WLOG_DEBUG, ""process_create_request: ChannelId=%""PRIu32"" ChannelName=%s"",
	           ChannelId, name);
	channel_status = dvcman_create_channel(drdynvc, drdynvc->channel_mgr, ChannelId, name);
 	data_out = Stream_New(NULL, pos + 4);
 
 	if (!data_out)
  static UINT drdynvc_process_data_first(drdynvcPlugin* drdynvc, int Sp,
 	UINT status;
 	UINT32 Length;
 	UINT32 ChannelId;

	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId) + drdynvc_cblen_to_bytes(Sp))
		return ERROR_INVALID_DATA;

 	ChannelId = drdynvc_read_variable_uint(s, cbChId);
 	Length = drdynvc_read_variable_uint(s, Sp);
 	WLog_Print(drdynvc->log, WLOG_DEBUG,
  static UINT drdynvc_process_data(drdynvcPlugin* drdynvc, int Sp, int cbChId,
                                  wStream* s)
 {
 	UINT32 ChannelId;

	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId))
		return ERROR_INVALID_DATA;

 	ChannelId = drdynvc_read_variable_uint(s, cbChId);
 	WLog_Print(drdynvc->log, WLOG_TRACE, ""process_data: Sp=%d cbChId=%d, ChannelId=%""PRIu32"""", Sp,
 	           cbChId,
  static UINT drdynvc_process_close_request(drdynvcPlugin* drdynvc, int Sp,
 	UINT error;
 	UINT32 ChannelId;
 	wStream* data_out;

	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId))
		return ERROR_INVALID_DATA;

 	ChannelId = drdynvc_read_variable_uint(s, cbChId);
 	WLog_Print(drdynvc->log, WLOG_DEBUG, ""process_close_request: Sp=%d cbChId=%d, ChannelId=%""PRIu32"""",
 	           Sp,
  static UINT drdynvc_order_recv(drdynvcPlugin* drdynvc, wStream* s)
 	int Cmd;
 	int Sp;
 	int cbChId;

	if (Stream_GetRemainingLength(s) < 1)
		return ERROR_INVALID_DATA;

 	Stream_Read_UINT8(s, value);
 	Cmd = (value & 0xf0) >> 4;
 	Sp = (value & 0x0c) >> 2;
  static UINT drdynvc_virtual_channel_event_data_received(drdynvcPlugin* drdynvc,
 		return CHANNEL_RC_NO_MEMORY;
 	}
 
	if (!Stream_EnsureRemainingCapacity(data_in, dataLength))
 	{
 		WLog_Print(drdynvc->log, WLOG_ERROR, ""Stream_EnsureRemainingCapacity failed!"");
 		Stream_Free(drdynvc->data_in, TRUE);","FreeRDP FreeRDP 2.0.0-rc3 released version before commit 205c612820dac644d665b5bb1cdf437dc5ca01e3 contains a Other/Unknown vulnerability in channels/drdynvc/client/drdynvc_main.c, drdynvc_process_capability_request that can result in The RDP server can read the client's memory.. This attack appear to be exploitable via RDPClient must connect the rdp server with echo option. This vulnerability appears to have been fixed in after commit 205c612820dac644d665b5bb1cdf437dc5ca01e3."
1456,CVE-2018-1000815,"  bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {
    
    
   bool allow = true;
  if (content_settings_manager_->content_settings()) {
    allow =
        content_settings_manager_->GetSetting(
          ContentSettingsManager::GetOriginOrURL(render_frame()->GetWebFrame()),
          url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL(),
          ""javascript"",
          allow) != CONTENT_SETTING_BLOCK;
   }
   allow = allow || IsWhitelistedForContentSettings();
 ","Brave Software Inc. Brave version version 0.22.810 to 0.24.0 contains a Other/Unknown vulnerability in function ContentSettingsObserver::AllowScript() in content_settings_observer.cc that can result in Websites can run inline JavaScript even if script is blocked, making attackers easier to track users. This attack appear to be exploitable via the victim must visit a specially crafted website. This vulnerability appears to have been fixed in 0.25.2."
1457,CVE-2018-1000524,"  layer_resize(int layer, int x_size, int y_size)
 	struct map_tile*    tilemap;
 	struct map_trigger* trigger;
 	struct map_zone*    zone;
	size_t              tilemap_size;
 
 	int x, y, i;
 
  layer_resize(int layer, int x_size, int y_size)
 
 	 
 	 
	tilemap_size = x_size * y_size * sizeof(struct map_tile);
	if (x_size == 0 || tilemap_size / x_size / sizeof(struct map_tile) != y_size
		|| !(tilemap = malloc(tilemap_size)))
 		return false;
 	for (x = 0; x < x_size; ++x) {
 		for (y = 0; y < y_size; ++y) {","miniSphere version 5.2.9 and earlier contains a Integer Overflow vulnerability in layer_resize() function in map_engine.c that can result in remote denial of service. This attack appear to be exploitable via the victim must load a specially-crafted map which calls SetLayerSize in its entry script. This vulnerability appears to have been fixed in 5.0.3, 5.1.5, 5.2.10 and later."
1458,CVE-2018-1000204,"  sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)
 		num = (rem_sz > scatter_elem_sz_prev) ?
 			scatter_elem_sz_prev : rem_sz;
 
		schp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);
 		if (!schp->pages[k])
 			goto out;
 ","** DISPUTED ** Linux Kernel version 3.18 to 4.16 incorrectly handles an SG_IO ioctl on /dev/sg0 with dxfer_direction=SG_DXFER_FROM_DEV and an empty 6-byte cmdp. This may lead to copying up to 1000 kernel heap pages to the userspace. This has been fixed upstream in https://github.com/torvalds/linux/commit/a45b599ad808c3c982fdcdc12b0b8611c2f92824 already. The problem has limited scope, as users don't usually have permissions to access SCSI devices. On the other hand, e.g. the Nero user manual suggests doing `chmod o+r+w /dev/sg*` to make the devices accessible. NOTE: third parties dispute the relevance of this report, noting that the requirement for an attacker to have both the CAP_SYS_ADMIN and CAP_SYS_RAWIO capabilities makes it *virtually impossible to exploit.*"
1459,CVE-2018-1000127,"  static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas)
     return (p - suffix) + 2;
 }
 
#define IT_REFCOUNT_LIMIT 60000
static inline item* limited_get(char *key, size_t nkey, conn *c) {
    item *it = item_get(key, nkey, c, DO_UPDATE);
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        item_remove(it);
        it = NULL;
    }
    return it;
}

  
 static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {
     char *key;
  static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens,
                 return;
             }
 
            it = limited_get(key, nkey, c);
             if (settings.detail_enabled) {
                 stats_prefix_record_get(key, nkey, NULL != it);
             }",memcached version prior to 1.4.37 contains an Integer Overflow vulnerability in items.c:item_free() that can result in data corruption and deadlocks due to items existing in hash table being reused from free list. This attack appear to be exploitable via network connectivity to the memcached service. This vulnerability appears to have been fixed in 1.4.37 and later.
1460,CVE-2018-1000118,"  bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
 
   if (prefix_length > 0) {
     a += prefix_length;
    std::string switch_name =
        base::ToLowerASCII(base::StringPiece(a, strcspn(a, ""="")));
     auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                   switch_name);
     if (iter != std::end(kBlacklist) && switch_name == *iter) {","Github Electron version Electron 1.8.2-beta.4 and earlier contains a Command Injection vulnerability in Protocol Handler that can result in command execute. This attack appear to be exploitable via the victim opening an electron protocol handler in their browser. This vulnerability appears to have been fixed in Electron 1.8.2-beta.5. This issue is due to an incomplete fix for CVE-2018-1000006, specifically the black list used was not case insensitive allowing an attacker to potentially bypass it."
1461,CVE-2018-1000115,"  static void settings_init(void) {
     settings.use_cas = true;
     settings.access = 0700;
     settings.port = 11211;
    settings.udpport = 0;
      
     settings.inter = NULL;
     settings.maxbytes = 64 * 1024 * 1024;  
  int main (int argc, char **argv) {
         }
     }
 
    if (udp_specified && settings.udpport != 0 && !tcp_specified) {
         settings.port = settings.udpport;
     }
 ","Memcached version 1.5.5 contains an Insufficient Control of Network Message Volume (Network Amplification, CWE-406) vulnerability in the UDP support of the memcached server that can result in denial of service via network flood (traffic amplification of 1:50,000 has been reported by reliable sources). This attack appear to be exploitable via network connectivity to port 11211 UDP. This vulnerability appears to have been fixed in 1.5.6 due to the disabling of the UDP protocol by default."
1462,CVE-2018-1000085,"  static int xar_cleanup_temp_file(cli_ctx *ctx, int fd, char * tmpname)
      value - pointer to long to contain the returned value
    returns - CL_SUCCESS or CL_EFORMAT
  */
static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, size_t * value)
 {
     const xmlChar * numstr;
    ssize_t numval;

     if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
         numstr = xmlTextReaderConstValue(reader);
         if (numstr) {
            numval = atol((const char *)numstr);
            if (numval < 0) {
                 cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *value);
                 return CL_EFORMAT;
             }
            *value = numval;
             return CL_SUCCESS;
         }
     }
  static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** ck
     if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {
         xmlval = xmlTextReaderConstValue(reader);
         if (xmlval) {
            cli_dbgmsg(""cli_scanxar: checksum value is %s.\n"", xmlval);
            if (*hash == XAR_CKSUM_SHA1 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_SHA1 ||
                *hash == XAR_CKSUM_MD5 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_MD5)
                {
                    *cksum = xmlStrdup(xmlval); 
                } 
            else
                {
                    cli_dbgmsg(""cli_scanxar: checksum type is unknown or length is invalid.\n"");
                    *hash = XAR_CKSUM_OTHER;
                    *cksum = NULL;
                }
         } else {
             *cksum = NULL;
             cli_dbgmsg(""cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\n"");           
  static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** ck
      e_hash - pointer to int for returning extracted checksum algorithm.
    returns - CL_FORMAT, CL_SUCCESS, CL_BREAK. CL_BREAK indicates no more <data>/<ea> element.
  */
static int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,
                                    unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)
 {
     const xmlChar *name;
  static int xar_hash_check(int hash, const void * result, const void * expected)
         return 1;
     switch (hash) {
     case XAR_CKSUM_SHA1:
        len = CLI_HASHLEN_SHA1;
         break;
     case XAR_CKSUM_MD5:
        len = CLI_HASHLEN_MD5;
         break;
     case XAR_CKSUM_OTHER:
     case XAR_CKSUM_NONE:
  int cli_scanxar(cli_ctx *ctx)
     int fd = -1;
     struct xar_header hdr;
     fmap_t *map = *ctx->fmap;
    size_t length, offset, size, at;
     int encoding;
     z_stream strm;
     char *toc, *tmpname;
  int cli_scanxar(cli_ctx *ctx)
         goto exit_toc;
     }
 
    if (hdr.toc_length_decompressed != strm.total_out) {
        cli_dbgmsg(""TOC decompress length %"" PRIu64 "" does not match amount decompressed %lu\n"",
                   hdr.toc_length_decompressed, strm.total_out);
        toc[strm.total_out] = '\0';
        hdr.toc_length_decompressed = strm.total_out;
    }

      
      
      
  int cli_scanxar(cli_ctx *ctx)
             goto exit_reader;
         }
 
        cli_dbgmsg(""cli_scanxar: decompress into temp file:\n%s, size %zu,\n""
                   ""from xar heap offset %zu length %zu\n"",
                    tmpname, size, offset, length);
 
 
  int cli_scanxar(cli_ctx *ctx)
 #define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2  
             {
                 struct CLI_LZMA lz;
                unsigned long in_remaining = MIN(length, map->len - at);
                 unsigned long out_size = 0;
                 unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);
                 int lret;

                if (length > in_remaining)
                    length = in_remaining;

                 memset(&lz, 0, sizeof(lz));
                 if (buff == NULL) {
                     cli_dbgmsg(""cli_scanxar: memory request for lzma decompression buffer fails.\n"");
  int cli_scanxar(cli_ctx *ctx)
                 if (blockp == NULL) {
                     char errbuff[128];
                     cli_strerror(errno, errbuff, sizeof(errbuff));
                    cli_dbgmsg(""cli_scanxar: Can't read %i bytes @ %li, errno:%s.\n"",
                               CLI_LZMA_HDR_SIZE, at, errbuff);
                     rc = CL_EREAD;
                     __lzma_wrap_free(NULL, buff);
                     goto exit_tmpfile;
  int cli_scanxar(cli_ctx *ctx)
                         char errbuff[128];
                         cli_strerror(errno, errbuff, sizeof(errbuff));
                         cli_dbgmsg(""cli_scanxar: Can't read %li bytes @ %li, errno: %s.\n"",
                                   lz.avail_in, at, errbuff);
                         rc = CL_EREAD;
                         __lzma_wrap_free(NULL, buff);
                         cli_LzmaShutdown(&lz);
  int cli_scanxar(cli_ctx *ctx)
              
             do_extract_cksum = 0;
             {
                size_t writelen = MIN(map->len - at, length);

                 if (ctx->engine->maxfilesize)
                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);
                     
                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {
                     char errbuff[128];
                     cli_strerror(errno, errbuff, sizeof(errbuff));
                    cli_dbgmsg(""cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\n"",
                               writelen, at, errbuff);
                     rc = CL_EREAD;
                     goto exit_tmpfile;
                 }
                 
                 if (a_hash_ctx != NULL)
                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);
                 
                if (cli_writen(fd, blockp, writelen) < 0) {
                    cli_dbgmsg(""cli_scanxar: cli_writen error %zu bytes @ %li.\n"", writelen, at);
                     rc = CL_EWRITE;
                     goto exit_tmpfile;
                 }
                  
             }          
        }  
 
         if (rc == CL_SUCCESS) {
             if (a_hash_ctx != NULL) {
  int cli_scanxar(cli_ctx *ctx)
     cli_dbgmsg(""cli_scanxar: can't scan xar files, need libxml2.\n"");
 #endif
     if (cksum_fails + extract_errors != 0) {
        cli_dbgmsg(""cli_scanxar: %u checksum errors and %u extraction errors.\n"",
                     cksum_fails, extract_errors);
     }
 ","ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6."
1463,CVE-2018-1000052,"  typename BasicWriter<Char>::CharPtr
       CharPtr p = grow_buffer(fill_size);
       std::uninitialized_fill(p, p + fill_size, fill);
     }
    std::ptrdiff_t offset = get(prepare_int_buffer(
        num_digits, subspec, prefix, prefix_size)) - &buffer_[0];
     if (align == ALIGN_LEFT) {
       CharPtr p = grow_buffer(fill_size);
       std::uninitialized_fill(p, p + fill_size, fill);
     }
    return internal::make_ptr(&buffer_[0], buffer_.size()) + offset;
   }
   unsigned size = prefix_size + num_digits;
   if (width <= size) {","fmtlib version prior to version 4.1.0 (before commit 0555cea5fc0bf890afe0071a558e44625a34ba85) contains a Memory corruption (SIGSEGV), CWE-134 vulnerability in fmt::print() library function that can result in Denial of Service. This attack appear to be exploitable via Specifying an invalid format specifier in the fmt::print() function results in a SIGSEGV (memory corruption, invalid write). This vulnerability appears to have been fixed in after commit 8cf30aa2be256eba07bb1cefb998c52326e846e7."
1464,CVE-2018-1000050," 
  
  
  
 
 
 
  
  
  
 
  
  
  
 
  
  
  
  static int residue_decode(vorb *f, Codebook *book, float *target, int offset, in
    return TRUE;
 }
 
 
 
 static void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode)
 {
    int i,j,pass;
    Residue *r = f->residue_config + rn;
    int rtype = f->residue_types[rn];
    int c = r->classbook;
    int classwords = f->codebooks[c].dimensions;
   unsigned int actual_size = rtype == 2 ? n*2 : n;
   unsigned int limit_r_begin = (r->begin < actual_size ? r->begin : actual_size);
   unsigned int limit_r_end   = (r->end   < actual_size ? r->end   : actual_size);
   int n_read = limit_r_end - limit_r_begin;
    int part_read = n_read / r->part_size;
    int temp_alloc_point = temp_alloc_save(f);
    #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE
  static int start_decoder(vorb *f)
       int i,max_part_read=0;
       for (i=0; i < f->residue_count; ++i) {
          Residue *r = f->residue_config + i;
         unsigned int actual_size = f->blocksize_1 / 2;
         unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size;
         unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size;
         int n_read = limit_r_end - limit_r_begin;
          int part_read = n_read / r->part_size;
          if (part_read > max_part_read)
             max_part_read = part_read;
  static int start_decoder(vorb *f)
       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));
       #endif
 
       

       f->temp_memory_required = classify_mem;
       if (imdct_mem > f->temp_memory_required)
          f->temp_memory_required = imdct_mem;
  int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, in
 #endif  
 
 /* Version history
    1.12    - 2017/11/21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files
    1.11    - 2017/07/23 - fix MinGW compilation 
     1.10    - 2017/03/03 - more robust seeking; fix negative ilog(); clear error in open_memory
     1.09    - 2016/04/04 - back out 'avoid discarding last frame' fix from previous version
     1.08    - 2016/04/02 - fixed multiple warnings; fix setup memory leaks;","Sean Barrett stb_vorbis version 1.12 and earlier contains a Buffer Overflow vulnerability in All vorbis decoding paths. that can result in memory corruption, denial of service, comprised execution of host program. This attack appear to be exploitable via Victim must open a specially crafted Ogg Vorbis file. This vulnerability appears to have been fixed in 1.13."
1465,CVE-2018-20542,"  static void libxsmm_sparse_csr_reader( const char*    i_csr_file_in,
     } else {
        
       if ( l_header_read == 0 ) {
        if (3 == sscanf(l_line, ""%u %u %u"", o_row_count, o_column_count, o_element_count) &&
            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)
        {
            
           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));
           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));","There is a heap-based buffer-overflow at generator_spgemm_csc_reader.c (function libxsmm_sparse_csc_reader) in LIBXSMM 1.10, a different vulnerability than CVE-2018-20541 (which is in a different part of the source code and is seen at a different address)."
1466,CVE-2018-20511,"  static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
                 case SIOCFINDIPDDPRT:
 			spin_lock_bh(&ipddp_route_lock);
 			rp = __ipddp_find_route(&rcp);
			if (rp) {
				memset(&rcp2, 0, sizeof(rcp2));
				rcp2.ip    = rp->ip;
				rcp2.at    = rp->at;
				rcp2.flags = rp->flags;
			}
 			spin_unlock_bh(&ipddp_route_lock);
 
 			if (rp) {",An issue was discovered in the Linux kernel before 4.18.11. The ipddp_ioctl function in drivers/net/appletalk/ipddp.c allows local users to obtain sensitive kernel address information by leveraging CAP_NET_ADMIN to read the ipddp_route dev and next fields via an SIOCFINDIPDDPRT ioctl call.
1467,CVE-2018-20467,"  static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
         bmp_info.x_pixels=ReadBlobLSBLong(image);
         bmp_info.y_pixels=ReadBlobLSBLong(image);
         bmp_info.number_colors=ReadBlobLSBLong(image);
        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         bmp_info.colors_important=ReadBlobLSBLong(image);
         if (image->debug != MagickFalse)
  static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
    offset=(MagickOffsetType) bmp_info.ba_offset;
    if (offset != 0)
      if ((offset < TellBlob(image)) ||
          (SeekBlob(image,offset,SEEK_SET) != offset))
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     *magick='\0';
     count=ReadBlob(image,2,magick);
     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))
       {","In coders/bmp.c in ImageMagick before 7.0.8-16, an input file can result in an infinite loop and hang, with high CPU and memory consumption. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file."
1468,CVE-2018-20461,"  static void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int
 			}
 #endif
 			printline (""bytes"", NULL, 0);
			int minsz = R_MIN (len, size);
			minsz = R_MAX (minsz, 0);
			for (j = 0; j < minsz; j++) {
				ut8 ch = ((j + idx - 1) > minsz)? 0xff: buf[j + idx];
				r_cons_printf (""%02x"", ch);
 			}
 			r_cons_newline ();
			if (op.val != UT64_MAX) {
 				printline (""val"", ""0x%08"" PFMT64x ""\n"", op.val);
			}
			if (op.ptr != UT64_MAX) {
 				printline (""ptr"", ""0x%08"" PFMT64x ""\n"", op.ptr);
			}
			if (op.refptr != -1) {
 				printline (""refptr"", ""%d\n"", op.refptr);
			}
 			printline (""size"", ""%d\n"", size);
 			printline (""sign"", ""%s\n"", r_str_bool (op.sign));
 			printline (""type"", ""%s\n"", r_anal_optype_to_string (op.type));","In radare2 prior to 3.1.1, core_anal_bytes in libr/core/cmd_anal.c allows attackers to cause a denial-of-service (application crash caused by out-of-bounds read) by crafting a binary file."
1469,CVE-2018-20460,"  static bool parseOperands(char* str, ArmOp *op) {
 		while (token[0] == ' ') {
 			token++;
 		}
		if (operand >= MAX_OPERANDS) {
			eprintf (""Too many operands\n"");
			return false;
		}
 		op->operands[operand].type = ARM_NOTYPE;
 		op->operands[operand].reg_type = ARM_UNDEFINED;
 		op->operands[operand].shift = ARM_NO_SHIFT;","In radare2 prior to 3.1.2, the parseOperands function in libr/asm/arch/arm/armass64.c allows attackers to cause a denial-of-service (application crash caused by stack-based buffer overflow) by crafting an input file."
1470,CVE-2018-20459,"  ut32 armass_assemble(const char *str, ut64 off, int thumb) {
 	int i, j;
 	char buf[128];
 	ArmOpcode aop = {.off = off};
	for (i = j = 0; i < sizeof (buf) - 1 && str[j]; i++, j++) {
 		if (str[j] == '#') {
 			i--; continue;
 		}","In radare2 through 3.1.3, the armass_assemble function in libr/asm/arch/arm/armass.c allows attackers to cause a denial-of-service (application crash by out-of-bounds read) by crafting an arm assembly input because a loop uses an incorrect index in armass.c and certain length validation is missing in armass64.c, a related issue to CVE-2018-20457."
1471,CVE-2018-20458," 
 
 
 #include <stdio.h>
 #include <r_types.h>
  static int r_bin_dyldcache_apply_patch (struct r_buf_t* buf, ut32 data, ut64 off
 
 #define NZ_OFFSET(x) if((x) > 0) r_bin_dyldcache_apply_patch (dbuf, (x) - linkedit_offset, (ut64)((size_t)&(x) - (size_t)data))
 
 
static ut64 r_buf_read64le (RBuffer *buf, ut64 off) {
	ut8 data[8] = {0};
	r_buf_read_at (buf, off, data, 8);
	return r_read_le64 (data);
}

static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {
	ut8 *data = malloc (len);
	if (data) {
		r_buf_read_at (buf, addr, data, len);
		data[len-1] = 0;
		return data;
	}
	return NULL;
}

  
 struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib) {
 	ut64 liboff, linkedit_offset;
  struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj
 	*nlib = bin->nlibs;
 	ret = R_NEW0 (struct r_bin_dyldcache_lib_t);
 	if (!ret) {
 		return NULL;
 	}
 	if (bin->hdr.startaddr > bin->size) {
 	    	eprintf (""corrupted dyldcache"");
 		free (ret);
 		return NULL;
 	}

 	if (bin->hdr.startaddr > bin->size || bin->hdr.baseaddroff > bin->size) {
 		eprintf (""corrupted dyldcache"");
 		free (ret);
 		return NULL;
 	}
	int sz = bin->nlibs * sizeof (struct dyld_cache_image_info);
	image_infos = malloc (sz);  
	if (!image_infos) {
		free (ret);
		return NULL;
	}
	r_buf_read_at (bin->b, bin->hdr.startaddr, (ut8*)image_infos, sz);
	dyld_vmbase = r_buf_read64le (bin->b, bin->hdr.baseaddroff);
 	liboff = image_infos[idx].address - dyld_vmbase;
 	if (liboff > bin->size) {
 		eprintf (""Corrupted file\n"");
 		free (ret);
 		return NULL;
 	}
 	ret->offset = liboff;
	int pfo = image_infos[idx].pathFileOffset;
	if (pfo < 0 || pfo > bin->size) {
		eprintf (""corrupted file: pathFileOffset > bin->size (%d)\n"", pfo);
 		free (ret);
 		return NULL;
 	}
	libname = r_buf_read_string (bin->b, pfo, 64);
 	 
 	data = bin->b->buf + liboff;
 	mh = (struct mach_header *)data;
  struct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file) {
 }
 
 struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {
	struct r_bin_dyldcache_obj_t *bin = R_NEW0 (struct r_bin_dyldcache_obj_t);
	if (!bin) {
 		return NULL;
 	}
 	if (!buf) {
 		return r_bin_dyldcache_free (bin);
 	}
	bin->b = r_buf_new ();
	if (!bin->b || !r_buf_set_bytes (bin->b, buf, size)) {
 		return r_bin_dyldcache_free (bin);
 	}
 	if (!r_bin_dyldcache_init (bin)) {","In radare2 prior to 3.1.1, r_bin_dyldcache_extract in libr/bin/format/mach0/dyldcache.c may allow attackers to cause a denial-of-service (application crash caused by out-of-bounds read) by crafting an input file."
1472,CVE-2018-20456,"  static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {
 			if (last_type == TT_SPECIAL) {
 				if (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {
 					if (reg != X86R_UNDEFINED) {
						if (reg_index < 2) {
							op->regs[reg_index] = reg;
							op->scale[reg_index] = temp;
						}
 						++reg_index;
 					} else {
 						op->offset += temp;
						if (reg_index < 2) {
							op->regs[reg_index] = X86R_UNDEFINED;
						}
 					}
 					temp = 1;
 					reg = X86R_UNDEFINED;
 				} else if (str[pos] == '*') {","In radare2 prior to 3.1.1, the parseOperand function inside libr/asm/p/asm_x86_nz.c may allow attackers to cause a denial of service (application crash in libr/util/strbuf.c via a stack-based buffer over-read) by crafting an input file, a related issue to CVE-2018-20455."
1473,CVE-2018-20217,"  kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,
 
         memset(&no_server, 0, sizeof(no_server));
 
         
        princ->pw_expiration = 0;
        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);

         code = validate_as_request(kdc_active_realm, request, *princ,
                                    no_server, kdc_time, status, &e_data);
         if (code) {","A Reachable Assertion issue was discovered in the KDC in MIT Kerberos 5 (aka krb5) before 1.17. If an attacker can obtain a krbtgt ticket using an older encryption type (single-DES, triple-DES, or RC4), the attacker can crash the KDC by making an S4U2Self request."
1474,CVE-2018-20169,"  static int usb_enumerate_device_otg(struct usb_device *udev)
 		 
 		err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
 				le16_to_cpu(udev->config[0].desc.wTotalLength),
				USB_DT_OTG, (void **) &desc, sizeof(*desc));
 		if (err || !(desc->bmAttributes & USB_OTG_HNP))
 			return 0;
 ","An issue was discovered in the Linux kernel before 4.19.9. The USB subsystem mishandles size checks during the reading of an extra descriptor, related to __usb_get_extra_descriptor in drivers/usb/core/usb.c."
1475,CVE-2018-19854,"  static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
  static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_comp rcomp;
 
	strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));
 	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
 		    sizeof(struct crypto_report_comp), &rcomp))
 		goto nla_put_failure;
  static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_acomp racomp;
 
	strncpy(racomp.type, ""acomp"", sizeof(racomp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,
 		    sizeof(struct crypto_report_acomp), &racomp))
  static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	strncpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
  static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_kpp rkpp;
 
	strncpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
 		    sizeof(struct crypto_report_kpp), &rkpp))
  static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
 static int crypto_report_one(struct crypto_alg *alg,
 			     struct crypto_user_alg *ualg, struct sk_buff *skb)
 {
	strncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
	strncpy(ualg->cru_driver_name, alg->cra_driver_name,
 		sizeof(ualg->cru_driver_name));
	strncpy(ualg->cru_module_name, module_name(alg->cra_module),
 		sizeof(ualg->cru_module_name));
 
 	ualg->cru_type = 0;
  static int crypto_report_one(struct crypto_alg *alg,
 	if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
 		struct crypto_report_larval rl;
 
		strncpy(rl.type, ""larval"", sizeof(rl.type));
 		if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
 			    sizeof(struct crypto_report_larval), &rl))
 			goto nla_put_failure;","An issue was discovered in the Linux kernel before 4.19.3. crypto_report_one() and related functions in crypto/crypto_user.c (the crypto user configuration API) do not fully initialize structures that are copied to userspace, potentially leaking sensitive memory to user programs. NOTE: this is a CVE-2013-2547 regression but with easier exploitability because the attacker does not need a capability (however, the system must have the CONFIG_CRYPTO_USER kconfig option)."
1476,CVE-2018-19843,"  static int opmov(RAsm *a, ut8 *data, const Opcode *op) {
 			if (op->operands[1].scale[0] == 0) {
 				return -1;
 			}
			data[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0] % 6];
 			data[l++] = 0x8b;
			data[l++] = (((ut32)op->operands[0].reg) << 3) | 0x5;
 			data[l++] = offset;
 			data[l++] = offset >> 8;
 			data[l++] = offset >> 16;","opmov in libr/asm/p/asm_x86_nz.c in radare2 before 3.1.0 allows attackers to cause a denial of service (buffer over-read) via crafted x86 assembly data, as demonstrated by rasm2."
1477,CVE-2018-19842,"  LookupTable oplookup[] = {
 };
 
 static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {
	if (*begin > strlen (str)) {
		return TT_EOF;
	}
 	 
	while (begin && str[*begin] && isspace ((ut8)str[*begin])) {
 		++(*begin);
 	}
 
 	if (!str[*begin]) {                 
 		*end = *begin;
 		return TT_EOF;
	}
	if (isalpha ((ut8)str[*begin])) {    
 		*end = *begin;
		while (end && str[*end] && isalnum ((ut8)str[*end])) {
 			++(*end);
 		}
 		return TT_WORD;
	}
	if (isdigit ((ut8)str[*begin])) {    
 		*end = *begin;
 		while (end && isalnum ((ut8)str[*end])) {      
 			++(*end);","getToken in libr/asm/p/asm_x86_nz.c in radare2 before 3.1.0 allows attackers to cause a denial of service (stack-based buffer over-read) via crafted x86 assembly data, as demonstrated by rasm2."
1478,CVE-2018-19841,"  int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)
 #endif
 
             if (meta_bc == 4) {
                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))
                     return FALSE;
             }
             else {
                 csum ^= csum >> 16;
 
                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))
                     return FALSE;
             }
 ","The function WavpackVerifySingleBlock in open_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (out-of-bounds read and application crash) via a crafted WavPack Lossless Audio file, as demonstrated by wvunpack."
1479,CVE-2018-19840,"  int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64
     int num_chans = config->num_channels;
     int i;
 
    if (!config->sample_rate) {
        strcpy (wpc->error_message, ""sample rate cannot be zero!"");
        return FALSE;
    }

     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;
 
     if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {",The function WavpackPackInit in pack_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (resource exhaustion caused by an infinite loop) via a crafted wav audio file because WavpackSetConfiguration64 mishandles a sample rate of zero.
1480,CVE-2018-19837,"  namespace Sass {
     if (lex< variable >())
     { return SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)); }
 
     css_error(""Invalid CSS"", "" after "", "": expected expression (e.g. 1px, bold), was "");
 
      ","In LibSass prior to 3.5.5, Sass::Eval::operator()(Sass::Binary_Expression*) inside eval.cpp allows attackers to cause a denial-of-service resulting from stack consumption via a crafted sass file, because of certain incorrect parsing of '%' as a modulo operator in parser.cpp."
1481,CVE-2018-19824,"  static int usb_audio_probe(struct usb_interface *intf,
 
  __error:
 	if (chip) {
		 
		atomic_dec(&chip->active);
 		if (!chip->num_interfaces)
 			snd_card_free(chip->card);
 	}
 	mutex_unlock(&register_mutex);
 	return err;","In the Linux kernel through 4.19.6, a local user could exploit a use-after-free in the ALSA driver by supplying a malicious USB Sound device (with zero interfaces) that is mishandled in usb_audio_probe in sound/usb/card.c."
1482,CVE-2018-19497,"  hfs_cat_traverse(HFS_INFO * hfs,
                 key = (hfs_btree_key_cat *) & node[rec_off];
 
                 keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);
               
                if (keylen >= nodesize - rec_off) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         (""hfs_cat_traverse: length of key %d in index node %d too large (%d vs %""
                        PRIu16 "")"", rec, cur_node, keylen, (nodesize - rec_off));
                     free(node);
                     return 1;
                 }","In The Sleuth Kit (TSK) through 4.6.4, hfs_cat_traverse in tsk/fs/hfs.c does not properly determine when a key length is too large, which allows attackers to cause a denial of service (SEGV on unknown address with READ memory access in a tsk_getu16 call in hfs_dir_open_meta_cb in tsk/fs/hfs_dent.c)."
1483,CVE-2018-19200," 
 
 
 void URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {
	if (uri == NULL) {
		return;
	}
 	memset(uri, 0, sizeof(URI_TYPE(Uri)));
 }
 ",An issue was discovered in uriparser before 0.9.0. UriCommon.c allows attempted operations on NULL input via a uriResetUri* function.
1484,CVE-2018-19198,"  int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,
 
 			 
 			if (firstItem == URI_TRUE) {
				ampersandLen = 1;
 				firstItem = URI_FALSE;
 			} else {
 				write[0] = _UT('&');",An issue was discovered in uriparser before 0.9.0. UriQuery.c allows an out-of-bounds write via a uriComposeQuery* or uriComposeQueryEx* function because the '&' character is mishandled in certain contexts.
1485,CVE-2018-19115,"  size_t extract_content_length(char *buffer, size_t size)
  */
 int extract_status_code(char *buffer, size_t size)
 {
 	char *end = buffer + size;
	unsigned long code;
 
 	 
	while (buffer < end && *buffer != ' ' && *buffer != '\r')
		buffer++;
	buffer++;
	if (buffer + 3 >= end || *buffer == ' ' || buffer[3] != ' ')
		return 0;
	code = strtoul(buffer, &end, 10);
	if (buffer + 3 != end)
		return 0;
 	return code;
 }
 ","keepalived before 2.0.7 has a heap-based buffer overflow when parsing HTTP status codes resulting in DoS or possibly unspecified other impact, because extract_status_code in lib/html.c has no validation of the status code and instead writes an unlimited amount of data to the heap."
1486,CVE-2018-19052,"  PHYSICALPATH_FUNC(mod_alias_physical_handler) {
 					strncmp(uri_ptr, ds->key->ptr, alias_len))) {
 			 
 
			 
			if (uri_ptr[alias_len] == '.') {
				char *s = uri_ptr + alias_len + 1;
				if (*s == '.') ++s;
				if (*s == '/' || *s == '\0') {
					size_t vlen = buffer_string_length(ds->value);
					if (0 != alias_len && ds->key->ptr[alias_len-1] != '/'
					    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {
						con->http_status = 403;
						return HANDLER_FINISHED;
					}
				}
			}

 			buffer_copy_buffer(con->physical.basedir, ds->value);
 			buffer_copy_buffer(srv->tmp_buf, ds->value);
 			buffer_append_string(srv->tmp_buf, uri_ptr + alias_len);","An issue was discovered in mod_alias_physical_handler in mod_alias.c in lighttpd before 1.4.50. There is potential ../ path traversal of a single directory above an alias target, with a specific mod_alias configuration where the matched alias lacks a trailing '/' character, but the alias target filesystem path does have a trailing '/' character."
1487,CVE-2018-19044,"  parse_cmdline(int argc, char **argv)
 			__set_bit(DONT_FORK_BIT, &debug);
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			if (optarg && optarg[0]) {
				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 				if (fd == -1) {
 					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
 					exit(EXIT_FAILURE);","keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd."
1488,CVE-2018-18955,"  static ssize_t map_write(struct file *file, const char __user *buf,
 	if (!new_idmap_permitted(file, ns, cap_setid, &new_map))
 		goto out;
 
 	ret = -EPERM;
 	 
	ret = sort_idmaps(&new_map);
	if (ret < 0)
		goto out;

 	 
 	if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {
 		memcpy(map->extent, new_map.extent,","In the Linux kernel 4.15.x through 4.19.x before 4.19.2, map_write() in kernel/user_namespace.c allows privilege escalation because it mishandles nested user namespaces with more than 5 UID or GID ranges. A user who has CAP_SYS_ADMIN in an affected user namespace can bypass access controls on resources outside the namespace, as demonstrated by reading /etc/shadow. This occurs because an ID transformation takes place properly for the namespaced-to-kernel direction but not for the kernel-to-namespaced direction."
1489,CVE-2018-18928,"  CharString *Formattable::internalGetCharString(UErrorCode &status) {
        
       if (fDecimalQuantity->isZero()) {
         fDecimalStr->append(""0"", -1, status);
      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {
         fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);
       } else {
         fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);",International Components for Unicode (ICU) for C/C++ 63.1 has an integer overflow in number::impl::DecimalQuantity::toScientificString() in i18n/number_decimalquantity.cpp.
1490,CVE-2018-18710,"  static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,
 		return -ENOSYS;
 
 	if (arg != CDSL_CURRENT && arg != CDSL_NONE) {
		if (arg >= cdi->capacity)
 			return -EINVAL;
 	}
 ",An issue was discovered in the Linux kernel through 4.19. An information leak in cdrom_ioctl_select_disc in drivers/cdrom/cdrom.c could be used by local attackers to read kernel memory because a cast from unsigned long to int interferes with bounds checking. This is similar to CVE-2018-10940 and CVE-2018-16658.
1491,CVE-2018-18690,"  xfs_attr_shortform_addname(xfs_da_args_t *args)
 		if (args->flags & ATTR_CREATE)
 			return retval;
 		retval = xfs_attr_shortform_remove(args);
		if (retval)
			return retval;
		 
		args->flags &= ~ATTR_REPLACE;
 	}
 
 	if (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||","In the Linux kernel before 4.17, a local attacker able to set attributes on an xfs filesystem could make this filesystem non-operational until the next mount by triggering an unchecked error condition during an xfs attribute change, because xfs_attr_shortform_addname in fs/xfs/libxfs/xfs_attr.c mishandles ATTR_REPLACE operations with conversion of an attr from short to long form."
1492,CVE-2018-18445,"  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 	u64 umin_val, umax_val;
 	u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;
 
	if (insn_bitness == 32) {
		 
		coerce_reg_to_size(dst_reg, 4);
		coerce_reg_to_size(&src_reg, 4);
	}

 	smin_val = src_reg.smin_value;
 	smax_val = src_reg.smax_value;
 	umin_val = src_reg.umin_value;
  static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
 	if (BPF_CLASS(insn->code) != BPF_ALU64) {
 		 
 		coerce_reg_to_size(dst_reg, 4);
 	}
 
 	__reg_deduce_bounds(dst_reg);","In the Linux kernel 4.14.x, 4.15.x, 4.16.x, 4.17.x, and 4.18.x before 4.18.13, faulty computation of numeric bounds in the BPF verifier permits out-of-bounds memory accesses because adjust_scalar_min_max_vals in kernel/bpf/verifier.c mishandles 32-bit right shifts."
1493,CVE-2018-18397,"  static int userfaultfd_register(struct userfaultfd_ctx *ctx,
 		ret = -EINVAL;
 		if (!vma_can_userfault(cur))
 			goto out_unlock;

		 
		ret = -EPERM;
		if (unlikely(!(cur->vm_flags & VM_MAYWRITE)))
			goto out_unlock;

 		/*
 		 * If this vma contains ending address, and huge pages
 		 * check alignment.
  static int userfaultfd_register(struct userfaultfd_ctx *ctx,
 		BUG_ON(!vma_can_userfault(vma));
 		BUG_ON(vma->vm_userfaultfd_ctx.ctx &&
 		       vma->vm_userfaultfd_ctx.ctx != ctx);
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		/*
 		 * Nothing to do: this vma is already registered into this
  static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,
 		cond_resched();
 
 		BUG_ON(!vma_can_userfault(vma));
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		/*
 		 * Nothing to do: this vma is already registered into this","The userfaultfd implementation in the Linux kernel before 4.19.7 mishandles access control for certain UFFDIO_ ioctl calls, as demonstrated by allowing local users to write data into holes in a tmpfs file (if the user has read-only access to that file, and that file contains holes), related to fs/userfaultfd.c and mm/userfaultfd.c."
1494,CVE-2018-18386,"  static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
	if (!old || (old->c_lflag ^ tty->termios.c_lflag) & (ICANON | EXTPROC)) {
 		bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 		ldata->line_start = ldata->read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
  static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&tty->termios_rwsem);
		if (L_ICANON(tty) && !L_EXTPROC(tty))
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);",drivers/tty/n_tty.c in the Linux kernel before 4.14.11 allows local attackers (who are able to access pseudo terminals) to hang/block further usage of any pseudo terminal devices due to an EXTPROC versus ICANON confusion in TIOCINQ.
1495,CVE-2018-18021,"  static u64 core_reg_offset_from_id(u64 id)
 	return id & ~(KVM_REG_ARCH_MASK | KVM_REG_SIZE_MASK | KVM_REG_ARM_CORE);
 }
 
static int validate_core_offset(const struct kvm_one_reg *reg)
{
	u64 off = core_reg_offset_from_id(reg->id);
	int size;

	switch (off) {
	case KVM_REG_ARM_CORE_REG(regs.regs[0]) ...
	     KVM_REG_ARM_CORE_REG(regs.regs[30]):
	case KVM_REG_ARM_CORE_REG(regs.sp):
	case KVM_REG_ARM_CORE_REG(regs.pc):
	case KVM_REG_ARM_CORE_REG(regs.pstate):
	case KVM_REG_ARM_CORE_REG(sp_el1):
	case KVM_REG_ARM_CORE_REG(elr_el1):
	case KVM_REG_ARM_CORE_REG(spsr[0]) ...
	     KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):
		size = sizeof(__u64);
		break;

	case KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...
	     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):
		size = sizeof(__uint128_t);
		break;

	case KVM_REG_ARM_CORE_REG(fp_regs.fpsr):
	case KVM_REG_ARM_CORE_REG(fp_regs.fpcr):
		size = sizeof(__u32);
		break;

	default:
		return -EINVAL;
	}

	if (KVM_REG_SIZE(reg->id) == size &&
	    IS_ALIGNED(off, size / sizeof(__u32)))
		return 0;

	return -EINVAL;
}

 static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 {
 	/*
  static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)
 		return -ENOENT;
 
	if (validate_core_offset(reg))
		return -EINVAL;

 	if (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))
 		return -EFAULT;
 
  static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)
 		return -ENOENT;
 
	if (validate_core_offset(reg))
		return -EINVAL;

 	if (KVM_REG_SIZE(reg->id) > sizeof(tmp))
 		return -EINVAL;
 ","arch/arm64/kvm/guest.c in KVM in the Linux kernel before 4.18.12 on the arm64 platform mishandles the KVM_SET_ON_REG ioctl. This is exploitable by attackers who can create virtual machines. An attacker can arbitrarily redirect the hypervisor flow of control (with full register control). An attacker can also cause a denial of service (hypervisor panic) via an illegal exception return. This occurs because of insufficient restrictions on userspace access to the core register file, and because PSTATE.M validation does not prevent unintended execution modes."
1496,CVE-2018-17570," 
 # include ""nw_buf.h""
 
 # define NW_BUF_POOL_INIT_SIZE 64
# define NW_BUF_POOL_MAX_SIZE  65535
 # define NW_CACHE_INIT_SIZE    64
# define NW_CACHE_MAX_SIZE     65535
 
 size_t nw_buf_size(nw_buf *buf)
 {
  void nw_buf_free(nw_buf_pool *pool, nw_buf *buf)
 {
     if (pool->free < pool->free_total) {
         pool->free_arr[pool->free++] = buf;
    } else if (pool->free_total < NW_BUF_POOL_MAX_SIZE) {
         uint32_t new_free_total = pool->free_total * 2;
         void *new_arr = realloc(pool->free_arr, new_free_total * sizeof(nw_buf *));
         if (new_arr) {
  void nw_buf_free(nw_buf_pool *pool, nw_buf *buf)
         } else {
             free(buf);
         }
    } else {
        free(buf);
     }
 }
 
  void nw_cache_free(nw_cache *cache, void *obj)
 {
     if (cache->free < cache->free_total) {
         cache->free_arr[cache->free++] = obj;
    } else if (cache->free_total < NW_CACHE_MAX_SIZE) {
         uint32_t new_free_total = cache->free_total * 2;
         void *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));
         if (new_arr) {
  void nw_cache_free(nw_cache *cache, void *obj)
         } else {
             free(obj);
         }
    } else {
        free(obj);
     }
 }
 ",utils/ut_ws_svr.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.
1497,CVE-2018-17569," 
 # include ""nw_buf.h""
 
 # define NW_BUF_POOL_INIT_SIZE 64
# define NW_BUF_POOL_MAX_SIZE  65535
 # define NW_CACHE_INIT_SIZE    64
# define NW_CACHE_MAX_SIZE     65535
 
 size_t nw_buf_size(nw_buf *buf)
 {
  void nw_buf_free(nw_buf_pool *pool, nw_buf *buf)
 {
     if (pool->free < pool->free_total) {
         pool->free_arr[pool->free++] = buf;
    } else if (pool->free_total < NW_BUF_POOL_MAX_SIZE) {
         uint32_t new_free_total = pool->free_total * 2;
         void *new_arr = realloc(pool->free_arr, new_free_total * sizeof(nw_buf *));
         if (new_arr) {
  void nw_buf_free(nw_buf_pool *pool, nw_buf *buf)
         } else {
             free(buf);
         }
    } else {
        free(buf);
     }
 }
 
  void nw_cache_free(nw_cache *cache, void *obj)
 {
     if (cache->free < cache->free_total) {
         cache->free_arr[cache->free++] = obj;
    } else if (cache->free_total < NW_CACHE_MAX_SIZE) {
         uint32_t new_free_total = cache->free_total * 2;
         void *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));
         if (new_arr) {
  void nw_cache_free(nw_cache *cache, void *obj)
         } else {
             free(obj);
         }
    } else {
        free(obj);
     }
 }
 ",network/nw_buf.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.
1498,CVE-2018-17568," 
 # include ""nw_buf.h""
 
 # define NW_BUF_POOL_INIT_SIZE 64
# define NW_BUF_POOL_MAX_SIZE  65535
 # define NW_CACHE_INIT_SIZE    64
# define NW_CACHE_MAX_SIZE     65535
 
 size_t nw_buf_size(nw_buf *buf)
 {
  void nw_buf_free(nw_buf_pool *pool, nw_buf *buf)
 {
     if (pool->free < pool->free_total) {
         pool->free_arr[pool->free++] = buf;
    } else if (pool->free_total < NW_BUF_POOL_MAX_SIZE) {
         uint32_t new_free_total = pool->free_total * 2;
         void *new_arr = realloc(pool->free_arr, new_free_total * sizeof(nw_buf *));
         if (new_arr) {
  void nw_buf_free(nw_buf_pool *pool, nw_buf *buf)
         } else {
             free(buf);
         }
    } else {
        free(buf);
     }
 }
 
  void nw_cache_free(nw_cache *cache, void *obj)
 {
     if (cache->free < cache->free_total) {
         cache->free_arr[cache->free++] = obj;
    } else if (cache->free_total < NW_CACHE_MAX_SIZE) {
         uint32_t new_free_total = cache->free_total * 2;
         void *new_arr = realloc(cache->free_arr, new_free_total * sizeof(void *));
         if (new_arr) {
  void nw_cache_free(nw_cache *cache, void *obj)
         } else {
             free(obj);
         }
    } else {
        free(obj);
     }
 }
 ",utils/ut_rpc.c in ViaBTC Exchange Server before 2018-08-21 has an integer overflow leading to memory corruption.
1499,CVE-2018-17456,"  static struct oidset gitmodules_done = OIDSET_INIT;
 	FUNC(GITMODULES_PARSE, ERROR) \
 	FUNC(GITMODULES_NAME, ERROR) \
 	FUNC(GITMODULES_SYMLINK, ERROR) \
	FUNC(GITMODULES_URL, ERROR) \
 	  \
 	FUNC(BAD_FILEMODE, WARN) \
 	FUNC(EMPTY_NAME, WARN) \
  static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
 				    FSCK_MSG_GITMODULES_NAME,
 				    ""disallowed submodule name: %s"",
 				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
 	free(name);
 
 	return 0;","Git before 2.14.5, 2.15.x before 2.15.3, 2.16.x before 2.16.5, 2.17.x before 2.17.2, 2.18.x before 2.18.1, and 2.19.x before 2.19.1 allows remote code execution during processing of a recursive *git clone* of a superproject if a .gitmodules file has a URL field beginning with a '-' character."
1500,CVE-2018-17294,"  matchCurrentInput(
 		const InString *input, int pos, const widechar *passInstructions, int passIC) {
 	int k;
 	int kk = pos;
	for (k = passIC + 2;
			((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length));
			k++)
 		if (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])
 			return 0;
 	return 1;","The matchCurrentInput function inside lou_translateString.c of Liblouis prior to 3.7 does not check the input string's length, allowing attackers to cause a denial of service (application crash via out-of-bounds read) by crafting an input file with certain translation dictionaries."
1501,CVE-2018-17293,"  static int run(const CommandLineOptions& options)
 	{
 		if(functionType.params().size() == 2)
 		{
			if(!emscriptenInstance)
 			{
 				Log::printf(
 					Log::error,
 					""Module does not declare a default memory object to put arguments in.\n"");
 				return EXIT_FAILURE;
 			}
			else
			{
				std::vector<const char*> argStrings;
				argStrings.push_back(options.filename);
				char** args = options.args;
				while(*args) { argStrings.push_back(*args++); };
 
				wavmAssert(emscriptenInstance);
				Emscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);
			}
 		}
 		else if(functionType.params().size() > 0)
 		{","An issue was discovered in WAVM before 2018-09-16. The run function in Programs/wavm/wavm.cpp does not check whether there is Emscripten memory to store the command-line arguments passed by the input WebAssembly file's main function, which allows attackers to cause a denial of service (application crash by NULL pointer dereference) or possibly have unspecified other impact by crafting certain WebAssembly files."
1502,CVE-2018-17292,"  inline bool loadModule(const char* filename, IR::Module& outModule)
 	if(!loadFile(filename, fileBytes)) { return false; }
 
 	 
	if(fileBytes.size() >= 4 && *(U32*)fileBytes.data() == 0x6d736100)
 	{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }
 	else
 	{","An issue was discovered in WAVM before 2018-09-16. The loadModule function in Include/Inline/CLI.h lacks checking of the file length before a file magic comparison, allowing attackers to cause a Denial of Service (application crash caused by out-of-bounds read) by crafting a file that has fewer than 4 bytes."
1503,CVE-2018-17206,"  decode_bundle(bool load, const struct nx_action_bundle *nab,
                      load ? ""bundle_load"" : ""bundle"", slaves_size,
                      bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves);
         error = OFPERR_OFPBAC_BAD_LEN;
    } else {
        for (i = 0; i < bundle->n_slaves; i++) {
            ofp_port_t ofp_port
                = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));
            ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);
            bundle = ofpacts->header;
        }
     }
 
     ofpact_finish_BUNDLE(ofpacts, &bundle);",An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6. The decode_bundle function inside lib/ofp-actions.c is affected by a buffer over-read issue during BUNDLE action decoding.
1504,CVE-2018-17205,"  ofproto_rule_insert__(struct ofproto *ofproto, struct rule *rule)
     const struct rule_actions *actions = rule_get_actions(rule);
 
      
    ovs_assert(rule->state != RULE_INSERTED);
 
     if (rule->hard_timeout || rule->idle_timeout) {
         ovs_list_insert(&ofproto->expirable, &rule->expirable);","An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6, affecting ofproto_rule_insert__ in ofproto/ofproto.c. During bundle commit, flows that are added in a bundle are applied to ofproto in order. If a flow cannot be added (e.g., the flow action is a go-to for a group id that does not exist), OvS tries to revert back all previous flows that were successfully applied from the same bundle. This is possible since OvS maintains list of old flows that were replaced by flows from the bundle. While reinserting old flows, OvS has an assertion failure due to a check on rule state != RULE_INITIALIZED. This would work for new flows, but for an old flow the rule state is RULE_REMOVED. The assertion failure causes an OvS crash."
1505,CVE-2018-17204,"  parse_group_prop_ntr_selection_method(struct ofpbuf *payload,
                     ""only allowed for select groups"");
         return OFPERR_OFPBPC_BAD_VALUE;
     default:
        return OFPERR_OFPGMFC_BAD_TYPE;
     }
 
     switch (group_cmd) {
  parse_group_prop_ntr_selection_method(struct ofpbuf *payload,
                     ""only allowed for add and delete group modifications"");
         return OFPERR_OFPBPC_BAD_VALUE;
     default:
        return OFPERR_OFPGMFC_BAD_COMMAND;
     }
 
     if (payload->size < sizeof *prop) {","An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6, affecting parse_group_prop_ntr_selection_method in lib/ofp-util.c. When decoding a group mod, it validates the group type and command after the whole group mod has been decoded. The OF1.5 decoder, however, tries to use the type and command earlier, when it might still be invalid. This causes an assertion failure (via OVS_NOT_REACHED). ovs-vswitchd does not enable support for OpenFlow 1.5 by default."
1506,CVE-2018-17182,"  struct mm_struct {
 	struct {
 		struct vm_area_struct *mmap;		 
 		struct rb_root mm_rb;
		u64 vmacache_seqnum;                    
 #ifdef CONFIG_MMU
 		unsigned long (*get_unmapped_area) (struct file *filp,
 				unsigned long addr, unsigned long len,","An issue was discovered in the Linux kernel through 4.18.8. The vmacache_flush_all function in mm/vmacache.c mishandles sequence number overflows. An attacker can trigger a use-after-free (and possibly gain privileges) via certain thread creation, map, unmap, invalidation, and dereference operations."
1507,CVE-2018-17082,"  zend_first_try {
 	if (!parent_req) {
 		php_apache_request_dtor(r TSRMLS_CC);
 		ctx->request_processed = 1;
		apr_brigade_cleanup(brigade);
 		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
 		APR_BRIGADE_INSERT_TAIL(brigade, bucket);
 ","The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a *Transfer-Encoding: chunked* request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c."
1508,CVE-2018-17019,"  void IRC_Analyzer::DeliverStream(int length, const u_char* line, bool orig)
 			{
 			vector<string> parts = SplitWords(params, ' ');
 
			if ( parts.size() < 3 )
 				{
 				Weird(""irc_invalid_names_line"");
 				return;
 				}
 
			 
			parts.erase(parts.begin());

 			string type = parts[0];
 			string channel = parts[1];
 ","In Bro through 2.5.5, there is a DoS in IRC protocol names command parsing in analyzer/protocol/irc/IRC.cc."
1509,CVE-2018-16842,"  static void voutf(struct GlobalConfig *config,
         (void)fwrite(ptr, cut + 1, 1, config->errors);
         fputs(""\n"", config->errors);
         ptr += cut + 1;  
        len -= cut + 1;
       }
       else {
         fputs(ptr, config->errors);",Curl versions 7.14.1 through 7.61.1 are vulnerable to a heap-based buffer over-read in the tool_msgs.c:voutf() function that may result in information exposure and denial of service.
1510,CVE-2018-16840,"  CURLcode Curl_close(struct Curl_easy *data)
        and detach this handle from there. */
     curl_multi_remove_handle(data->multi, data);
 
  if(data->multi_easy) {
      
     curl_multi_cleanup(data->multi_easy);
    data->multi_easy = NULL;
  }
 
   /* Destroy the timeout list that is held in the easy handle. It is
      /normally/ done by curl_multi_remove_handle() but this is ""just in","A heap use-after-free flaw was found in curl versions from 7.59.0 through 7.61.1 in the code related to closing an easy handle. When closing and cleaning up an 'easy' handle in the `Curl_close()` function, the library code first frees a struct (without nulling the pointer) and might then subsequently erroneously write to a struct field within that already freed struct."
1511,CVE-2018-16839,"  CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,
   plen = strlen(passwdp);
 
    
  if((ulen > SIZE_T_MAX/4) || (plen > (SIZE_T_MAX/2 - 2)))
     return CURLE_OUT_OF_MEMORY;
   plainlen = 2 * ulen + plen + 2;
 ",Curl versions 7.33.0 through 7.61.1 are vulnerable to a buffer overrun in the SASL authentication code that may lead to denial of service.
1512,CVE-2018-16790,"  _bson_iter_next_internal (bson_iter_t *iter,     
       memcpy (&l, iter->raw + iter->d1, sizeof (l));
       l = BSON_UINT32_FROM_LE (l);
 
      if (l >= (len - o - 4)) {
          iter->err_off = o;
          goto mark_invalid;
       }","_bson_iter_next_internal in bson-iter.c in libbson 1.12.0, as used in MongoDB mongo-c-driver and other products, has a heap-based buffer over-read via a crafted bson buffer."
1513,CVE-2018-16749,"  static Image *ReadOneJNGImage(MngInfo *mng_info,
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Copying JDAT chunk data to color_blob."");
 
        if ((length != 0) && (color_image != (Image *) NULL))
           {
             (void) WriteBlob(color_image,length,chunk);
             chunk=(unsigned char *) RelinquishMagickMemory(chunk);","In ImageMagick 7.0.7-29 and earlier, a missing NULL check in ReadOneJNGImage in coders/png.c allows an attacker to cause a denial of service (WriteBlob assertion failure and application exit) via a crafted file."
1514,CVE-2018-16658,"  static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,
 	if (!CDROM_CAN(CDC_SELECT_DISC) ||
 	    (arg == CDSL_CURRENT || arg == CDSL_NONE))
 		return cdi->ops->drive_status(cdi, CDSL_CURRENT);
	if (arg >= cdi->capacity)
 		return -EINVAL;
 	return cdrom_slot_status(cdi, arg);
 }",An issue was discovered in the Linux kernel before 4.18.6. An information leak in cdrom_ioctl_drive_status in drivers/cdrom/cdrom.c could be used by local attackers to read kernel memory because a cast from unsigned long to int interferes with bounds checking. This is similar to CVE-2018-10940.
1515,CVE-2018-16645,"  static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
         bmp_info.x_pixels=ReadBlobLSBLong(image);
         bmp_info.y_pixels=ReadBlobLSBLong(image);
         bmp_info.number_colors=ReadBlobLSBLong(image);
        if (bmp_info.number_colors > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
         bmp_info.colors_important=ReadBlobLSBLong(image);
         if (image->debug != MagickFalse)
           {","There is an excessive memory allocation issue in the functions ReadBMPImage of coders/bmp.c and ReadDIBImage of coders/dib.c in ImageMagick 7.0.8-11, which allows remote attackers to cause a denial of service via a crafted image file."
1516,CVE-2018-16644,"  static Image *ReadPICTImage(const ImageInfo *image_info,
               Clipping rectangle.
             */
             length=ReadBlobMSBShort(image);
            if (length > GetBlobSize(image))
              ThrowPICTException(CorruptImageError,
                ""InsufficientImageDataInFile"");
             if (length != 0x000a)
               {
                 for (i=0; i < (ssize_t) (length-2); i++)
  static Image *ReadPICTImage(const ImageInfo *image_info,
             if (pattern != 1)
               ThrowPICTException(CorruptImageError,""UnknownPatternType"");
             length=ReadBlobMSBShort(image);
            if (length > GetBlobSize(image))
              ThrowPICTException(CorruptImageError,
                ""InsufficientImageDataInFile"");
             if (ReadRectangle(image,&frame) == MagickFalse)
               ThrowPICTException(CorruptImageError,""ImproperImageHeader"");
             if (ReadPixmap(image,&pixmap) == MagickFalse)
  static Image *ReadPICTImage(const ImageInfo *image_info,
             (void) ReadBlobMSBLong(image);
             flags=(ssize_t) ReadBlobMSBShort(image);
             length=ReadBlobMSBShort(image);
            if (length > GetBlobSize(image))
              ThrowPICTException(CorruptImageError,
                ""InsufficientImageDataInFile"");
             for (i=0; i <= (ssize_t) length; i++)
               (void) ReadBlobMSBLong(image);
             width=(size_t) (frame.bottom-frame.top);
  static Image *ReadPICTImage(const ImageInfo *image_info,
               Skip polygon or region.
             */
             length=ReadBlobMSBShort(image);
            if (length > GetBlobSize(image))
              ThrowPICTException(CorruptImageError,
                ""InsufficientImageDataInFile"");
             for (i=0; i < (ssize_t) (length-2); i++)
               if (ReadBlobByte(image) == EOF)
                 break;
  static Image *ReadPICTImage(const ImageInfo *image_info,
                   Skip region.
                 */
                 length=ReadBlobMSBShort(image);
                if (length > GetBlobSize(image))
                  ThrowPICTException(CorruptImageError,
                    ""InsufficientImageDataInFile"");
                 for (i=0; i < (ssize_t) (length-2); i++)
                   if (ReadBlobByte(image) == EOF)
                     break;
  static Image *ReadPICTImage(const ImageInfo *image_info,
             */
             type=ReadBlobMSBShort(image);
             length=ReadBlobMSBShort(image);
            if (length > GetBlobSize(image))
              ThrowPICTException(CorruptImageError,
                ""InsufficientImageDataInFile"");
             if (length == 0)
               break;
             (void) ReadBlobMSBLong(image);
  static Image *ReadPICTImage(const ImageInfo *image_info,
             ThrowPICTException(FileOpenError,""UnableToCreateTemporaryFile"");
           }
         length=ReadBlobMSBLong(image);
        if (length > GetBlobSize(image))
          ThrowPICTException(CorruptImageError,
            ""InsufficientImageDataInFile"");
         if (length > 154)
           {
             for (i=0; i < 6; i++)
  static Image *ReadPICTImage(const ImageInfo *image_info,
           Skip reserved.
         */
         length=ReadBlobMSBShort(image);
        if (length > GetBlobSize(image))
          ThrowPICTException(CorruptImageError,
            ""InsufficientImageDataInFile"");
         for (i=0; i < (ssize_t) length; i++)
           if (ReadBlobByte(image) == EOF)
             break;
  static Image *ReadPICTImage(const ImageInfo *image_info,
           Skip reserved.
         */
         length=(size_t) ((code >> 7) & 0xff);
        if (length > GetBlobSize(image))
          ThrowPICTException(CorruptImageError,
            ""InsufficientImageDataInFile"");
         for (i=0; i < (ssize_t) length; i++)
           if (ReadBlobByte(image) == EOF)
             break;","There is a missing check for length in the functions ReadDCMImage of coders/dcm.c and ReadPICTImage of coders/pict.c in ImageMagick 7.0.8-11, which allows remote attackers to cause a denial of service via a crafted image."
1517,CVE-2018-16643,"  static Image *ReadCALSImage(const ImageInfo *image_info,
   if ((unique_file == -1) || (file == (FILE *) NULL))
     ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
   while ((c=ReadBlobByte(image)) != EOF)
    if (fputc(c,file) != c)
      break;
   (void) fclose(file);
   (void) CloseBlob(image);
   image=DestroyImage(image);","The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file."
1518,CVE-2018-16642,"  typedef struct
 } CUTPalHeader;
 
 
static MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,
  ssize_t y,ExceptionInfo *exception)
 {
  int
    bit;
 
  Quantum
    index;

  register Quantum
    *q;

  ssize_t
    x;

  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  if (q == (Quantum *) NULL)
    return(MagickFalse);
  switch (bpp)
    {
     case 1:   
       {
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=0; bit < 8; bit++)
           {
            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)
            {
              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);
              SetPixelIndex(image,index,q);
              if (index < image->colors)
                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
              q+=GetPixelChannels(image);
            }
             p++;
           }
         break;
       }
     case 2:   
       {
        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
         {
            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            q+=GetPixelChannels(image);
            p++;
         }
       if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
            if ((image->columns % 4) > 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);
                 SetPixelIndex(image,index,q);
                if (index < image->colors)
                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
                 q+=GetPixelChannels(image);
                if ((image->columns % 4) > 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,
                       exception);
                     SetPixelIndex(image,index,q);
                    if (index < image->colors)
                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
                        index,q);
                     q+=GetPixelChannels(image);
                   }
               }
             p++;
           }
         break;
       }
 
     case 4:   
       {
         for (x=0; x < ((ssize_t) image->columns-1); x+=2)
          {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             q+=GetPixelChannels(image);
            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
            q+=GetPixelChannels(image);
           }
         if ((image->columns % 2) != 0)
           {
            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);
             SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
             p++;
            q+=GetPixelChannels(image);
           }
         break;
       }
     case 8:  
       {
         for (x=0; x < (ssize_t) image->columns; x++)
          {
            index=ConstrainColormapIndex(image,*p,exception);
            SetPixelIndex(image,index,q);
            if (index < image->colors)
              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);
            p++;
            q+=GetPixelChannels(image);
          }
      }
      break;

    case 24:      
      for (x=0; x < (ssize_t) image->columns; x++)
         {
          SetPixelRed(image,ScaleCharToQuantum(*p++),q);
          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
           q+=GetPixelChannels(image);
         }
      break;
     }
  if (!SyncAuthenticPixels(image,exception))
    return(MagickFalse);
  return(MagickTrue);
 }
 
 /*",The function InsertRow in coders/cut.c in ImageMagick 7.0.7-37 allows remote attackers to cause a denial of service via a crafted image file due to an out-of-bounds write.
1519,CVE-2018-16641,"  static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,
   layers=AcquireStringInfo(profile.quantum);
   if (layers == (StringInfo *) NULL)
     {
      base_image=DestroyImage(base_image);
       clone_info=DestroyImageInfo(clone_info);
       ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
         image->filename);
  static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,
   custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);
   if (custom_stream == (CustomStreamInfo *) NULL)
     {
      base_image=DestroyImage(base_image);
       clone_info=DestroyImageInfo(clone_info);
       layers=DestroyStringInfo(layers);
       ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
  static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,
   blob=CloneBlobInfo((BlobInfo *) NULL);
   if (blob == (BlobInfo *) NULL)
     {
      base_image=DestroyImage(base_image);
       clone_info=DestroyImageInfo(clone_info);
       layers=DestroyStringInfo(layers);
       custom_stream=DestroyCustomStreamInfo(custom_stream);",ImageMagick 7.0.8-6 has a memory leak vulnerability in the TIFFWritePhotoshopLayers function in coders/tiff.c.
1520,CVE-2018-16640,"  static Image *ReadOneJNGImage(MngInfo *mng_info,
         chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));
 
         if (chunk == (unsigned char *) NULL)
          {
            DestroyJNG(NULL,&color_image,&color_image_info,
              &alpha_image,&alpha_image_info);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
 
         for (i=0; i < (ssize_t) length; i++)
         {
  static Image *ReadOneJNGImage(MngInfo *mng_info,
             jng_width=(png_uint_32)mng_get_long(p);
             jng_height=(png_uint_32)mng_get_long(&p[4]);
             if ((jng_width == 0) || (jng_height == 0))
              {
                DestroyJNG(chunk,&color_image,&color_image_info,
                  &alpha_image,&alpha_image_info);
                ThrowReaderException(CorruptImageError,
                  ""NegativeOrZeroImageSize"");
              }
             jng_color_type=p[8];
             jng_image_sample_depth=p[9];
             jng_image_compression_method=p[10];",ImageMagick 7.0.8-5 has a memory leak vulnerability in the function ReadOneJNGImage in coders/png.c.
1521,CVE-2018-16427,"  int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,
 	len = *p & 0x7f;
 	if (*p++ & 0x80) {
 		unsigned int a = 0;
		left--;
 		if (len > 4 || len > left)
 			return SC_ERROR_INVALID_ASN1_OBJECT;
 		left -= len;",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
1522,CVE-2018-16426,"  iasecc_select_file(struct sc_card *card, const struct sc_path *path,
 	sc_log(ctx, ""iasecc_select_file() path:%s"", sc_print_path(path));
 
 	sc_print_cache(card);
	if (path->type != SC_PATH_TYPE_DF_NAME
			&& lpath.len >= 2
			&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {
 		sc_log(ctx, ""EF.ATR(aid:'%s')"", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : """");
 
 		rv = iasecc_select_mf(card, file_out);
 		LOG_TEST_RET(ctx, rv, ""MF selection error"");
 
		memmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);
		lpath.len -=  2;
 	}
 
 	if (lpath.aid.len)	{",Endless recursion when handling responses from an IAS-ECC card in iasecc_select_file in libopensc/card-iasecc.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to hang or crash the opensc library using programs.
1523,CVE-2018-16425,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1524,CVE-2018-16424,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",A double free when handling responses in read_file in tools/egk-tool.c (aka the eGK card tool) in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1525,CVE-2018-16423,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",A double free when handling responses from a smartcard in sc_file_set_sec_attr in libopensc/sc.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1526,CVE-2018-16422,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",A single byte buffer overflow when handling responses from an esteid Card in sc_pkcs15emu_esteid_init in libopensc/pkcs15-esteid.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1527,CVE-2018-16421,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",Several buffer overflows when handling responses from a CAC Card in cac_get_serial_nr_from_CUID in libopensc/card-cac.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1528,CVE-2018-16420,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",Several buffer overflows when handling responses from an ePass 2003 Card in decrypt_response in libopensc/card-epass2003.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1529,CVE-2018-16419,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",Several buffer overflows when handling responses from a Cryptoflex card in read_public_key in tools/cryptoflex-tool.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1530,CVE-2018-16418,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",A buffer overflow when handling string concatenation in util_acl_to_str in tools/util.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1531,CVE-2018-16393,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",Several buffer overflows when handling responses from a Gemsafe V1 Smartcard in gemsafe_get_cert_len in libopensc/pkcs15-gemsafeV1.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1532,CVE-2018-16392,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",Several buffer overflows when handling responses from a TCOS Card in tcos_select_file in libopensc/card-tcos.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1533,CVE-2018-16391,"  static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri
         }
 	if (priv->cac_id_len) {
 		serial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);
		memcpy(serial->value, priv->cac_id, serial->len);
 		SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);
 	}
 	SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
1534,CVE-2018-16323,"  static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
     {
       c=XBMInteger(image,hex_digits);
       if (c < 0)
        {
          data=(unsigned char *) RelinquishMagickMemory(data);
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        }
       *p++=(unsigned char) c;
       if ((padding == 0) || (((i+2) % bytes_per_line) != 0))
         *p++=(unsigned char) (c >> 8);
  static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
     {
       c=XBMInteger(image,hex_digits);
       if (c < 0)
        {
          data=(unsigned char *) RelinquishMagickMemory(data);
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        }
       *p++=(unsigned char) c;
     }
   if (EOFBlob(image) != MagickFalse)","ReadXBMImage in coders/xbm.c in ImageMagick before 7.0.8-9 leaves data uninitialized when processing an XBM file that has a negative pixel value. If the affected code is used as a library loaded into a process that includes sensitive information, that information sometimes can be leaked via the image data."
1535,CVE-2018-16276,"  static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,
 			  loff_t *ppos)
 {
 	struct usb_yurex *dev;
	int len = 0;
 	char in_buffer[20];
 	unsigned long flags;
 
 	dev = file->private_data;
 
 	mutex_lock(&dev->io_mutex);
 	if (!dev->interface) {		 
		mutex_unlock(&dev->io_mutex);
		return -ENODEV;
 	}
 
 	spin_lock_irqsave(&dev->lock, flags);
	len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
 	spin_unlock_irqrestore(&dev->lock, flags);
 	mutex_unlock(&dev->io_mutex);

	return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);
 }
 
 static ssize_t yurex_write(struct file *file, const char __user *user_buffer,",An issue was discovered in yurex_read in drivers/usb/misc/yurex.c in the Linux kernel before 4.17.7. Local attackers could use user access read/writes with incorrect bounds checking in the yurex USB driver to crash the kernel or potentially escalate privileges.
1536,CVE-2018-16253,"  static inline int strlen_P(const char *str) {
     while (pgm_read_byte(str++)) cnt++;
     return cnt;
 }
static inline int memcmp_P(const void *a1, const void *b1, size_t len) {
    const uint8_t* a = (const uint8_t*)(a1);
    uint8_t* b = (uint8_t*)(b1);
    for (size_t i=0; i<len; i++) {
        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);
        if (d) return d;
        a++;
        b++;
    }
    return 0;
}

 #define printf(fmt, ...) do { static const char fstr[] PROGMEM = fmt; char rstr[sizeof(fmt)]; memcpy_P(rstr, fstr, sizeof(rstr)); ets_printf(rstr, ##__VA_ARGS__); } while (0)
 #define strcpy_P(dst, src) do { static const char fstr[] PROGMEM = src; memcpy_P(dst, fstr, sizeof(src)); } while (0)
 ","In sig_verify() in x509.c in axTLS version 2.1.3 and before, the PKCS#1 v1.5 signature verification does not properly verify the ASN.1 metadata. Consequently, a remote attacker can forge signatures when small public exponents are being used, which could lead to impersonation through fake X.509 certificates. This is an even more permissive variant of CVE-2006-4790 and CVE-2014-1568."
1537,CVE-2018-15863,"  ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,
     *pred_rtrn = MATCH_EXACTLY;
     if (expr->expr.op == EXPR_ACTION_DECL) {
         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);
        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||
            !expr->action.args) {
             log_err(info->ctx,
                     ""Illegal modifier predicate \""%s\""; Ignored\n"", pred_txt);
             return false;",Unchecked NULL pointer usage in ResolveStateAndPredicate in xkbcomp/compat.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with a no-op modmask expression.
1538,CVE-2018-15862,"  LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
         return false;
 
     str = xkb_atom_text(ctx, field);
    if (!str)
        return false;
 
     if (istreq(str, ""all"")) {
         *val_rtrn  = MOD_REAL_MASK_ALL;",Unchecked NULL pointer usage in LookupModMask in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file with invalid virtual modifiers.
1539,CVE-2018-15861,"  ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
         *elem_rtrn = NULL;
         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);
         *index_rtrn = NULL;
        return (*field_rtrn != NULL);
     case EXPR_FIELD_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);",Unchecked NULL pointer usage in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file that triggers an xkb_intern_atom failure.
1540,CVE-2018-15859,"  ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,
         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);
         *index_rtrn = NULL;
        return (*elem_rtrn != NULL && *field_rtrn != NULL);
     case EXPR_ARRAY_REF:
         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);
         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);
         *index_rtrn = expr->array_ref.entry;
	if (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)
		return false;
	if (*field_rtrn == NULL)
		return false;
         return true;
     default:
         break;","Unchecked NULL pointer usage when parsing invalid atoms in ExprResolveLhs in xkbcomp/expr.c in xkbcommon before 0.8.2 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because lookup failures are mishandled."
1541,CVE-2018-15858,"  CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)
         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));
         if (!key_aliases)
             return false;
 
        i = 0;
        darray_foreach(alias, info->aliases) {
            if (alias->real != XKB_ATOM_NONE) {
                key_aliases[i].alias = alias->alias;
                key_aliases[i].real = alias->real;
                i++;
            }
         }
     }
 ",Unchecked NULL pointer usage when handling invalid aliases in CopyKeyAliasesToKeymap in xkbcomp/keycodes.c in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file.
1542,CVE-2018-15857,"  ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)
     darray_append(expr->keysym_list.symsNumEntries, numEntries);
     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);
 
    FreeStmt((ParseCommon *) append);
 
     return expr;
 }",An invalid free in ExprAppendMultiKeysymList in xkbcomp/ast-build.c in xkbcommon before 0.8.1 could be used by local attackers to crash xkbcommon keymap parsers or possibly have unspecified other impact by supplying a crafted keymap file.
1543,CVE-2018-15856,"  lex(struct scanner *s, union lvalue *val)
 
      
     if (chr(s, '<')) {
        while (peek(s) != '>' && !eol(s) && !eof(s))
             buf_append(s, next(s));
         if (!chr(s, '>')) {
             scanner_err(s, ""unterminated keysym literal"");",An infinite loop when reaching EOL unexpectedly in compose/parser.c (aka the keymap parser) in xkbcommon before 0.8.1 could be used by local attackers to cause a denial of service during parsing of crafted keymap files.
1544,CVE-2018-15855,"  CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)
          file = (XkbFile *) file->common.next) {
         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||
             file->file_type > LAST_KEYMAP_FILE_TYPE) {
            if (file->file_type == FILE_TYPE_GEOMETRY) {
                log_vrb(ctx, 1,
                        ""Geometry sections are not supported; ignoring\n"");
            } else {
                log_err(ctx, ""Cannot define %s in a keymap file\n"",
                        xkb_file_type_to_string(file->file_type));
            }
             continue;
         }
 ","Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled."
1545,CVE-2018-15854,"  ExprCreateInteger(int ival)
     return expr;
 }
 
ExprDef *
ExprCreateFloat(void)
{
    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);
    return expr;
}

 ExprDef *
 ExprCreateBoolean(bool set)
 {
  static const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {
     [EXPR_TYPE_UNKNOWN] = ""unknown"",
     [EXPR_TYPE_BOOLEAN] = ""boolean"",
     [EXPR_TYPE_INT] = ""int"",
    [EXPR_TYPE_FLOAT] = ""float"",
     [EXPR_TYPE_STRING] = ""string"",
     [EXPR_TYPE_ACTION] = ""action"",
     [EXPR_TYPE_KEYNAME] = ""keyname"",","Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because geometry tokens were desupported incorrectly."
1546,CVE-2018-15853,"  ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,
 
     case EXPR_INVERT:
     case EXPR_NOT:
        ok = ExprResolveBoolean(ctx, expr->unary.child, set_rtrn);
         if (ok)
             *set_rtrn = !*set_rtrn;
         return ok;","Endless recursion exists in xkbcomp/expr.c in xkbcommon and libxkbcommon before 0.8.1, which could be used by local attackers to crash xkbcommon users by supplying a crafted keymap file that triggers boolean negation."
1547,CVE-2018-15836,"  err_t verify_signed_hash(const struct RSA_public_key *k
 	return ""3""""SIG padding does not check out"";
     }
 
     
    (*psig) = s + padlen + 3;

     
    {
        const u_char *p;
        size_t cnt_ffs = 0;

        for (p = s+2; p < s+padlen+2; p++)
            if (*p == 0xFF)
                cnt_ffs ++;

        if (cnt_ffs != padlen)
            return ""4"" ""invalid Padding String"";
    }
 
      
     return NULL;","In verify_signed_hash() in lib/liboswkeys/signatures.c in Openswan before 2.6.50.1, the RSA implementation does not verify the value of padding string during PKCS#1 v1.5 signature verification. Consequently, a remote attacker can forge signatures when small public exponents are being used. IKEv2 signature verification is affected when RAW RSA keys are used."
1548,CVE-2018-15822,"  static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
     int flags = -1, flags_size, ret;
     int64_t cur_offset = avio_tell(pb);
 
    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {
        av_log(s, AV_LOG_WARNING, ""Empty audio Packet\n"");
        return AVERROR(EINVAL);
    }

     if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
         par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
         flags_size = 2;","The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 4.0.2 does not check for an empty audio packet, leading to an assertion failure."
1549,CVE-2018-15594,"  unsigned paravirt_patch_call(void *insnbuf,
 	struct branch *b = insnbuf;
 	unsigned long delta = (unsigned long)target - (addr+5);
 
	if (len < 5) {
#ifdef CONFIG_RETPOLINE
		WARN_ONCE(""Failing to patch indirect CALL in %ps\n"", (void *)addr);
#endif
 		return len;	 
	}
 
 	b->opcode = 0xe8;  
 	b->delta = delta;
  unsigned paravirt_patch_jmp(void *insnbuf, const void *target,
 	struct branch *b = insnbuf;
 	unsigned long delta = (unsigned long)target - (addr+5);
 
	if (len < 5) {
#ifdef CONFIG_RETPOLINE
		WARN_ONCE(""Failing to patch indirect JMP in %ps\n"", (void *)addr);
#endif
 		return len;	 
	}
 
 	b->opcode = 0xe9;	 
 	b->delta = delta;","arch/x86/kernel/paravirt.c in the Linux kernel before 4.18.1 mishandles certain indirect calls, which makes it easier for attackers to conduct Spectre-v2 attacks against paravirtual guests."
1550,CVE-2018-15572,"  static enum spectre_v2_mitigation_cmd __init spectre_v2_parse_cmdline(void)
 	return cmd;
 }
 
 static void __init spectre_v2_select_mitigation(void)
 {
 	enum spectre_v2_mitigation_cmd cmd = spectre_v2_parse_cmdline();
  static void __init spectre_v2_select_mitigation(void)
 	pr_info(""%s\n"", spectre_v2_strings[mode]);
 
 	 
	setup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);
	pr_info(""Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch\n"");
 
 	 
 	if (boot_cpu_has(X86_FEATURE_IBPB)) {","The spectre_v2_select_mitigation function in arch/x86/kernel/cpu/bugs.c in the Linux kernel before 4.18.1 does not always fill RSB upon a context switch, which makes it easier for attackers to conduct userspace-userspace spectreRSB attacks."
1551,CVE-2018-15505,"  PUBLIC int mprParseSocketAddress(cchar *address, char **pip, int *pport, int *ps
 
                  
                 ip = sclone(ip + 1);
                if ((cp = strchr(ip, ']')) != 0) {
                    *cp = '\0';
                }
 
             } else {
                  
  static void validateTime(struct tm *tp, struct tm *defaults)
     }
     if (tp->tm_yday < 0) {
         if (tp->tm_mon <= 11) {
            tp->tm_yday = (leapYear(tp->tm_year + 1900) ?
                leapMonthStart[tp->tm_mon] : normalMonthStart[tp->tm_mon]) + tp->tm_mday - 1;
         } else {
             tp->tm_yday = defaults->tm_yday;
         }","An issue was discovered in Embedthis GoAhead before 4.0.1 and Appweb before 7.0.2. An HTTP POST request with a specially crafted *Host* header field may cause a NULL pointer dereference and thus cause a denial of service, as demonstrated by the lack of a trailing ']' character in an IPv6 address."
1552,CVE-2018-15504,"  static void validateTime(struct tm *tp, struct tm *defaults)
         swapDayMonth(tp);
     }
 
     
    if (tp->tm_sec > 60) {
        tp->tm_sec = -1;
    }
    if (tp->tm_min > 60) {
        tp->tm_sec = -1;
    }
    if (tp->tm_hour > 24) {
        tp->tm_sec = -1;
    }
    if (tp->tm_mday > 31) {
        tp->tm_sec = -1;
    }
    if (tp->tm_mon > 11) {
        tp->tm_sec = -1;
    }
    if (tp->tm_wday > 6) {
        tp->tm_sec = -1;
    }
    if (tp->tm_yday > 366) {
        tp->tm_sec = -1;
    }

#if UNUSED
     if (tp->tm_year != -MAXINT && tp->tm_mon >= 0 && tp->tm_mday >= 0 && tp->tm_hour >= 0) {
          
         return;
     }
#endif
 
      
     if (defaults == NULL) {
         memset(&empty, 0, sizeof(empty));
  static void validateTime(struct tm *tp, struct tm *defaults)
         tp->tm_mday = defaults->tm_mday;
     }
     if (tp->tm_yday < 0) {
        if (tp->tm_mon <= 11) {
         tp->tm_yday = (leapYear(tp->tm_year + 1900) ?
             leapMonthStart[tp->tm_mon] : normalMonthStart[tp->tm_mon]) + tp->tm_mday - 1;
        } else {
            tp->tm_yday = defaults->tm_yday;
        }
     }
     if (tp->tm_hour < 0) {
         tp->tm_hour = defaults->tm_hour;","An issue was discovered in Embedthis GoAhead before 4.0.1 and Appweb before 7.0.2. The server mishandles some HTTP request fields associated with time, which results in a NULL pointer dereference, as demonstrated by If-Modified-Since or If-Unmodified-Since with a month greater than 11."
1553,CVE-2018-15503,"  zend_class_entry swoole_serialize_ce;
 zend_class_entry *swoole_serialize_class_entry_ptr;
 
 #define SWOOLE_SERI_EOF ""EOF""
#define CHECK_STEP if(buffer>unseri_buffer_end){ php_error_docref(NULL TSRMLS_CC, E_ERROR, ""illegal unserialize data""); return NULL;}
 
 static struct _swSeriaG swSeriaG;
char *unseri_buffer_end = NULL;
 
 void swoole_serialize_init(int module_number TSRMLS_DC)
 {
  static CPINLINE void swoole_check_size(seriaString *str, size_t len)
     }
 }
 #ifdef __SSE2__

 void CPINLINE swoole_mini_memcpy(void *dst, const void *src, size_t len)
 {
     register unsigned char *dd = (unsigned char*) dst + len;
     register const unsigned char *ss = (const unsigned char*) src + len;
     switch (len)
     {
         case 68: *((int*) (dd - 68)) = *((int*) (ss - 68));
             
         case 64: *((int*) (dd - 64)) = *((int*) (ss - 64));
             
         case 60: *((int*) (dd - 60)) = *((int*) (ss - 60));
             
         case 56: *((int*) (dd - 56)) = *((int*) (ss - 56));
             
         case 52: *((int*) (dd - 52)) = *((int*) (ss - 52));
             
         case 48: *((int*) (dd - 48)) = *((int*) (ss - 48));
             
         case 44: *((int*) (dd - 44)) = *((int*) (ss - 44));
             
         case 40: *((int*) (dd - 40)) = *((int*) (ss - 40));
             
         case 36: *((int*) (dd - 36)) = *((int*) (ss - 36));
             
         case 32: *((int*) (dd - 32)) = *((int*) (ss - 32));
             
         case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));
             
         case 24: *((int*) (dd - 24)) = *((int*) (ss - 24));
             
         case 20: *((int*) (dd - 20)) = *((int*) (ss - 20));
             
         case 16: *((int*) (dd - 16)) = *((int*) (ss - 16));
             
         case 12: *((int*) (dd - 12)) = *((int*) (ss - 12));
             
         case 8: *((int*) (dd - 8)) = *((int*) (ss - 8));
             
         case 4: *((int*) (dd - 4)) = *((int*) (ss - 4));
             break;
         case 67: *((int*) (dd - 67)) = *((int*) (ss - 67));
             
         case 63: *((int*) (dd - 63)) = *((int*) (ss - 63));
             
         case 59: *((int*) (dd - 59)) = *((int*) (ss - 59));
             
         case 55: *((int*) (dd - 55)) = *((int*) (ss - 55));
             
         case 51: *((int*) (dd - 51)) = *((int*) (ss - 51));
             
         case 47: *((int*) (dd - 47)) = *((int*) (ss - 47));
             
         case 43: *((int*) (dd - 43)) = *((int*) (ss - 43));
             
         case 39: *((int*) (dd - 39)) = *((int*) (ss - 39));
             
         case 35: *((int*) (dd - 35)) = *((int*) (ss - 35));
             
         case 31: *((int*) (dd - 31)) = *((int*) (ss - 31));
             
         case 27: *((int*) (dd - 27)) = *((int*) (ss - 27));
             
         case 23: *((int*) (dd - 23)) = *((int*) (ss - 23));
             
         case 19: *((int*) (dd - 19)) = *((int*) (ss - 19));
             
         case 15: *((int*) (dd - 15)) = *((int*) (ss - 15));
             
         case 11: *((int*) (dd - 11)) = *((int*) (ss - 11));
             
         case 7: *((int*) (dd - 7)) = *((int*) (ss - 7));
             *((int*) (dd - 4)) = *((int*) (ss - 4));
             break;
         case 3: *((short*) (dd - 3)) = *((short*) (ss - 3));
             dd[-1] = ss[-1];
             break;
         case 66: *((int*) (dd - 66)) = *((int*) (ss - 66));
             
         case 62: *((int*) (dd - 62)) = *((int*) (ss - 62));
             
         case 58: *((int*) (dd - 58)) = *((int*) (ss - 58));
             
         case 54: *((int*) (dd - 54)) = *((int*) (ss - 54));
             
         case 50: *((int*) (dd - 50)) = *((int*) (ss - 50));
             
         case 46: *((int*) (dd - 46)) = *((int*) (ss - 46));
             
         case 42: *((int*) (dd - 42)) = *((int*) (ss - 42));
             
         case 38: *((int*) (dd - 38)) = *((int*) (ss - 38));
             
         case 34: *((int*) (dd - 34)) = *((int*) (ss - 34));
             
         case 30: *((int*) (dd - 30)) = *((int*) (ss - 30));
             
         case 26: *((int*) (dd - 26)) = *((int*) (ss - 26));
             
         case 22: *((int*) (dd - 22)) = *((int*) (ss - 22));
             
         case 18: *((int*) (dd - 18)) = *((int*) (ss - 18));
             
         case 14: *((int*) (dd - 14)) = *((int*) (ss - 14));
             
         case 10: *((int*) (dd - 10)) = *((int*) (ss - 10));
             
         case 6: *((int*) (dd - 6)) = *((int*) (ss - 6));
             
         case 2: *((short*) (dd - 2)) = *((short*) (ss - 2));
             break;
         case 65: *((int*) (dd - 65)) = *((int*) (ss - 65));
             
         case 61: *((int*) (dd - 61)) = *((int*) (ss - 61));
             
         case 57: *((int*) (dd - 57)) = *((int*) (ss - 57));
             
         case 53: *((int*) (dd - 53)) = *((int*) (ss - 53));
             
         case 49: *((int*) (dd - 49)) = *((int*) (ss - 49));
             
         case 45: *((int*) (dd - 45)) = *((int*) (ss - 45));
             
         case 41: *((int*) (dd - 41)) = *((int*) (ss - 41));
             
         case 37: *((int*) (dd - 37)) = *((int*) (ss - 37));
             
         case 33: *((int*) (dd - 33)) = *((int*) (ss - 33));
             
         case 29: *((int*) (dd - 29)) = *((int*) (ss - 29));
             
         case 25: *((int*) (dd - 25)) = *((int*) (ss - 25));
             
         case 21: *((int*) (dd - 21)) = *((int*) (ss - 21));
             
         case 17: *((int*) (dd - 17)) = *((int*) (ss - 17));
             
         case 13: *((int*) (dd - 13)) = *((int*) (ss - 13));
             
         case 9: *((int*) (dd - 9)) = *((int*) (ss - 9));
             
         case 5: *((int*) (dd - 5)) = *((int*) (ss - 5));
             
         case 1: dd[-1] = ss[-1];
             break;
         case 0:
  static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE
      
     zend_ulong h, nIndex, max_index = 0;
     uint32_t size = cp_zend_hash_check_size(nNumOfElements);
    CHECK_STEP;
     if (!size)
     {
         return NULL;
  static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE
                     key_len = *((size_t*) buffer);
                     buffer += sizeof (size_t);
                 }
                CHECK_STEP;
                 p->key = zend_string_init((char*) buffer, key_len, 0);
                  
                 h = zend_inline_hash_func((char*) buffer, key_len);
  static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE
                     data_len = *((size_t*) buffer);
                     buffer += sizeof (size_t);
                 }
                CHECK_STEP;
                 p->val.value.str = zend_string_init((char*) buffer, data_len, 0);
                 buffer += data_len;
             }
  static void* swoole_unserialize_arr(void *buffer, zval *zvalue, uint32_t nNumOfE
 
     }
     ht->nNextFreeElement = max_index;
    CHECK_STEP;
 
     return buffer;
 
  static void swoole_serialize_arr(seriaString *buffer, zend_array *zvalue)
 
                 if (GC_IS_RECURSIVE(ht))
                 {
                    ((SBucketType*) (buffer->buffer + p))->data_type = IS_NULL;  
                     php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""the array has cycle ref"");
                 }
                 else
  static CPINLINE void swoole_unserialize_raw(void *buffer, zval *zvalue)
 }
 
 #if 0

  
  static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)
         zend_throw_exception_ex(NULL, 0, ""can not find class %s"", class_name->val TSRMLS_CC);
         return NULL;
     }

     zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));
     Z_STR(user_func) = fname;
     Z_TYPE_INFO(user_func) = IS_STRING_EX;
  static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc
     zval property;
     uint32_t arr_num = 0;
     size_t name_len = *((unsigned short*) buffer);
    CHECK_STEP;
     if (!name_len)
     {
         php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal unserialize data"");
         return NULL;
     }
     buffer += 2;
     zend_string *class_name;
    if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)
     {
         class_name = swoole_string_init(ZEND_STRL(""StdClass""));
    }
    else
     {
         class_name = swoole_string_init((char*) buffer, name_len);
     }
     buffer += name_len;
     zend_class_entry *ce = swoole_try_get_ce(class_name);
     swoole_string_release(class_name);
    CHECK_STEP;
 
     if (!ce)
     {
  static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc
 
     object_init_ex(return_value, ce);
 
    zval *data, *d;
     zend_string *key;
     zend_ulong index;
 
     ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data)
     {
         const char *prop_name, *tmp;
  static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc
                 zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len);
                 zend_update_property(ce, return_value, prop_name, prop_len, data);
             }
             
             
         }
         else
         {
  static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uc
         swoole_string_release(fname);
         zval_ptr_dtor(&ret);
     }
    CHECK_STEP;
     return buffer;
 
 }
  PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value,
 {
     SBucketType type = *(SBucketType*) (buffer);
     zend_uchar real_type = type.data_type;
    unseri_buffer_end = buffer + len;
     buffer += sizeof (SBucketType);
     switch (real_type)
     {
  PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value,
         {
             if (swoole_seria_check_eof(buffer, len) < 0)
             {
                php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""detect the error eof"");
                return SW_FALSE;
             }
             unser_start = buffer - sizeof (SBucketType);
             uint32_t num = 0;
  PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value,
         case IS_UNDEF:
             if (swoole_seria_check_eof(buffer, len) < 0)
             {
                php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""detect the error eof"");
                return SW_FALSE;
             }
             unser_start = buffer - sizeof (SBucketType);
             if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))",The unpack implementation in Swoole version 4.0.4 lacks correct size checks in the deserialization process. An attacker can craft a serialized object to exploit this vulnerability and cause a SEGV.
1554,CVE-2018-15501,"  static int ng_pkt(git_pkt **out, const char *line, size_t len)
 	pkt->ref = NULL;
 	pkt->type = GIT_PKT_NG;
 
	if (len < 3)
		goto out_err;
 	line += 3;  
	len -= 3;
	if (!(ptr = memchr(line, ' ', len)))
 		goto out_err;
 	len = ptr - line;
 
  static int ng_pkt(git_pkt **out, const char *line, size_t len)
 	memcpy(pkt->ref, line, len);
 	pkt->ref[len] = '\0';
 
	if (len < 1)
		goto out_err;
 	line = ptr + 1;
	len -= 1;
	if (!(ptr = memchr(line, '\n', len)))
 		goto out_err;
 	len = ptr - line;
 ","In ng_pkt in transports/smart_pkt.c in libgit2 before 0.26.6 and 0.27.x before 0.27.4, a remote attacker can send a crafted smart-protocol *ng* packet that lacks a '0' byte to trigger an out-of-bounds read that leads to DoS."
1555,CVE-2018-15473," 
 
 
 /*
  * Copyright (c) 2001-2003 Simon Wilkinson. All rights reserved.
  userauth_gssapi(struct ssh *ssh)
 	size_t len;
 	u_char *doid = NULL;
 
 	if ((r = sshpkt_get_u32(ssh, &mechs)) != 0)
 		fatal(""%s: %s"", __func__, ssh_err(r));
 
  userauth_gssapi(struct ssh *ssh)
 		return (0);
 	}
 
	if (!authctxt->valid || authctxt->user == NULL) {
		debug2(""%s: disabled because of invalid user"", __func__);
		free(doid);
		return (0);
	}

 	if (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {
 		if (ctxt != NULL)
 			ssh_gssapi_delete_ctx(&ctxt);","OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c."
1556,CVE-2018-15132,"  PHP_FUNCTION(readlink)
 PHP_FUNCTION(linkinfo)
 {
 	char *link;
	char *dirname;
 	size_t link_len;
 	zend_stat_t sb;
 	int ret;
  PHP_FUNCTION(linkinfo)
 		return;
 	}
 
	dirname = estrndup(link, link_len);
	php_dirname(dirname, link_len);

	if (php_check_open_basedir(dirname)) {
		efree(dirname);
		RETURN_FALSE;
	}

 	ret = VCWD_STAT(link, &sb);
 	if (ret == -1) {
 		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
		efree(dirname);
 		RETURN_LONG(Z_L(-1));
 	}
 
	efree(dirname);
 	RETURN_LONG((zend_long) sb.st_dev);
 }
  ","An issue was discovered in ext/standard/link_win32.c in PHP before 5.6.37, 7.0.x before 7.0.31, 7.1.x before 7.1.20, and 7.2.x before 7.2.8. The linkinfo function on Windows doesn't implement the open_basedir check. This could be abused to find files on paths outside of the allowed directories."
1557,CVE-2018-15120,"  _pango_emoji_iter_next (PangoEmojiIter *iter)
     if (iter->is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type))
     {
       iter->is_emoji = !PANGO_EMOJI_TYPE_IS_EMOJI (current_emoji_type);

       
      if (iter->start == iter->end)
        iter->end = g_utf8_next_char (iter->end);

       return TRUE;
     }
   }","libpango in Pango 1.40.8 through 1.42.3, as used in hexchat and other products, allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted text with invalid Unicode sequences."
1558,CVE-2018-14938,"  void WifiPacket::handle_prism(const u_char *pc, size_t len)
     prism2_pkthdr hdr;
 
      
    if (len>=144){
        hdr.host_time 	= EXTRACT_LE_32BITS(pc+32);
        hdr.mac_time 	= EXTRACT_LE_32BITS(pc+44);
        hdr.channel 	= EXTRACT_LE_32BITS(pc+56);
        hdr.rssi 		= EXTRACT_LE_32BITS(pc+68);
        hdr.sq 		= EXTRACT_LE_32BITS(pc+80);
        hdr.signal  	= EXTRACT_LE_32BITS(pc+92);
        hdr.noise   	= EXTRACT_LE_32BITS(pc+104);
        hdr.rate		= EXTRACT_LE_32BITS(pc+116)/2;
        hdr.istx		= EXTRACT_LE_32BITS(pc+128);
        cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);
        handle_80211(pc+144,len-144);
    }
 }
 
  
  void WifiPacket::handle_prism(const u_char *pc, size_t len)
  
  
 
 
 void WifiPacket::handle_ether(const u_char *ptr, size_t len)
 {
 #if 0
  void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,
         break;
     default:
 #if 0
         
 	 
 	 
         pkt.handle_ip(packet,header->caplen);","An issue was discovered in wifipcap/wifipcap.cpp in TCPFLOW through 1.5.0-alpha. There is an integer overflow in the function handle_prism during caplen processing. If the caplen is less than 144, one can cause an integer overflow in the function handle_80211, which will result in an out-of-bounds read and may allow access to sensitive memory (or a denial of service)."
1559,CVE-2018-14734,"  static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
 		return NULL;
 
 	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);
 	mutex_unlock(&mut);
 	if (mc->id < 0)
 		goto error;
  static ssize_t ucma_process_join(struct ucma_file *file,
 		goto err3;
 	}
 
	mutex_lock(&mut);
	idr_replace(&multicast_idr, mc, mc->id);
	mutex_unlock(&mut);

 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;","drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free)."
1560,CVE-2018-14395,"  static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContex
     uint32_t tag = track->tag;
 
     if (track->mode == MODE_MOV) {
        if (track->timescale > UINT16_MAX || !track->par->channels) {
             if (mov_get_lpcm_flags(track->par->codec_id))
                 tag = AV_RL32(""lpcm"");
             version = 2;",libavformat/movenc.c in FFmpeg before 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.
1561,CVE-2018-14394,"  int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
     else
         samples_in_chunk = 1;
 
    if (samples_in_chunk < 1) {
        av_log(s, AV_LOG_ERROR, ""fatal error, input packet contains no samples\n"");
        return AVERROR_PATCHWELCOME;
    }

      
     if (trk->vos_len == 0 && par->extradata_size > 0 &&
         !TAG_IS_AVCI(trk->tag) &&",libavformat/movenc.c in FFmpeg before 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted Waveform audio file.
1562,CVE-2018-14363,"  int nntp_active_save_cache(struct NntpServer *nserv)
  */
 static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)
 {
  int count = snprintf(dest, destlen, ""%s.hcache"", path);

   
  char *first = strchr(dest, '/');
  char *last = strrchr(dest, '/');
  if (first && last && (last > first))
  {
    memmove(first, last, strlen(last) + 1);
    count -= (last - first);
  }

  return count;
 }
 
 /**",An issue was discovered in NeoMutt before 2018-07-16. newsrc.c does not properly restrict '/' characters that may have unsafe interaction with cache pathnames.
1563,CVE-2018-14361,"  static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,
   fc.last = last;
   fc.restore = restore;
   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));
  if (fc.messages == NULL)
	  return -1;
 #ifdef USE_HCACHE
   fc.hc = hc;
 #endif",An issue was discovered in NeoMutt before 2018-07-16. nntp.c proceeds even if memory allocation fails for messages data.
1564,CVE-2018-14360,"  int nntp_add_group(char *line, void *data)
 {
   struct NntpServer *nserv = data;
   struct NntpData *nntp_data = NULL;
  char group[LONG_STRING] = """";
   char desc[HUGE_STRING] = """";
   char mod;
   anum_t first, last;
 
   if (!nserv || !line)
     return 0;
 
   
  if (sscanf(line, ""%1023s "" ANUM "" "" ANUM "" %c %8191[^\n]"", group, &last, &first, &mod, desc) < 4)
  {
    mutt_debug(4, ""Cannot parse server line: %s\n"", line);
     return 0;
  }
 
   nntp_data = nntp_data_find(nserv, group);
   nntp_data->deleted = false;",An issue was discovered in NeoMutt before 2018-07-16. nntp_add_group in newsrc.c has a stack-based buffer overflow because of incorrect sscanf usage.
1565,CVE-2018-14359,"  enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)
     goto bail;
   }
 
  len = mutt_b64_decode(obuf, idata->buf + 2, sizeof(obuf));
   if (len == -1)
   {
     mutt_debug(1, ""Error decoding base64 response.\n"");",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They have a buffer overflow via base64 data.
1566,CVE-2018-14358,"  static int msg_parse_fetch(struct ImapHeader *h, char *s)
       }
       s++;
       ptmp = tmp;
      while (*s && (*s != '\""') && (ptmp != (tmp + sizeof(tmp) - 1)))
         *ptmp++ = *s++;
       if (*s != '\""')
         return -1;
  static int msg_parse_fetch(struct ImapHeader *h, char *s)
       s += 11;
       SKIPWS(s);
       ptmp = tmp;
      while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))
         *ptmp++ = *s++;
       *ptmp = '\0';
       if (mutt_str_atol(tmp, &h->content_length) < 0)",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/message.c has a stack-based buffer overflow for a FETCH response with a long RFC822.SIZE field.
1567,CVE-2018-14357,"  enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)
 
   mutt_message(_(""Logging in...""));
 
  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);
  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);
 
    ","An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription."
1568,CVE-2018-14356,"  static int fetch_uidl(char *line, void *data)
     endp++;
   memmove(line, endp, strlen(endp) + 1);
 
   
  if (strlen(line) == 0)
    return -1;

   for (i = 0; i < ctx->msgcount; i++)
     if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)
       break;",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c mishandles a zero-length UID.
1569,CVE-2018-14355,"  header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)
     FREE(&mx.mbox);
   }
 
  if (strstr(mbox, ""/../"") || (strcmp(mbox, "".."") == 0) || (strncmp(mbox, ""../"", 3) == 0))
    return NULL;
  size_t len = strlen(mbox);
  if ((len > 3) && (strcmp(mbox + len - 3, ""/.."") == 0))
    return NULL;

   mutt_account_tourl(&idata->conn->account, &url);
   url.path = mbox;
   url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/util.c mishandles *..* directory traversal in a mailbox name.
1570,CVE-2018-14354,"  int imap_subscribe(char *path, bool subscribe)
   char errstr[STRING];
   struct Buffer err, token;
   struct ImapMbox mx;
  size_t len = 0;
 
   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)
   {
  int imap_subscribe(char *path, bool subscribe)
     mutt_buffer_init(&err);
     err.data = errstr;
     err.dsize = sizeof(errstr);
	len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
	imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);
     if (mutt_parse_rc_line(mbox, &token, &err))
       mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr);
     FREE(&token.data);","An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription."
1571,CVE-2018-14353,"  void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_back
   {
     if (strchr(quote, *s))
     {
      if (dlen < 2)
         break;
      dlen -= 2;
       *pt++ = '\\';
       *pt++ = *s;
     }",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap_quote_string in imap/util.c has an integer underflow.
1572,CVE-2018-14352,"  void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_back
   const char *s = src;
 
   *pt++ = '""';
   
  dlen -= 3;
 
   for (; *s && dlen; s++)
   {","An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap_quote_string in imap/util.c does not leave room for quote characters, leading to a stack-based buffer overflow."
1573,CVE-2018-14351,"  static void cmd_parse_status(struct ImapData *idata, char *s)
       idata->status = IMAP_FATAL;
       return;
     }

    if (strlen(idata->buf) < litlen)
    {
      mutt_debug(1, ""Error parsing STATUS mailbox\n"");
      return;
    }

     mailbox = idata->buf;
     s = mailbox + litlen;
     *s = '\0';",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/command.c mishandles a long IMAP status mailbox literal count size.
1574,CVE-2018-14349,"  static int cmd_handle_untagged(struct ImapData *idata)
     mutt_debug(2, ""Handling untagged NO\n"");
 
      
    mutt_error(""%s"", s + 2);
   }
 
   return 0;",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/command.c mishandles a NO response without a message.
1575,CVE-2018-14345,"  namespace SDDM {
         } else {
              
              
            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){
                if(!success)
                    return;
                 qDebug() << ""activating existing seat"";
                 OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());
                 manager.UnlockSession(existingSessionId);","An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp."
1576,CVE-2018-14056,"  CWebSock::EPageReqResult CWebSock::PrintTemplate(const CString& sPageName,
 }
 
 CString CWebSock::GetSkinPath(const CString& sSkinName) {
    const CString sSkin = sSkinName.Replace_n(""/"", ""_"").Replace_n(""."", ""_"");

    CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkin;
 
     if (!CFile::IsDir(sRet)) {
        sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkin;
 
         if (!CFile::IsDir(sRet)) {
            sRet = CString(_SKINDIR_) + ""/"" + sSkin;
         }
     }
 ",ZNC before 1.7.1-rc1 is prone to a path traversal flaw via ../ in a web skin name to access files outside of the intended skins directories.
1577,CVE-2018-14055,"  void CClient::ReadLine(const CString& sData) {
     CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : """");
     CString sLine = sData;
 
    sLine.Replace(""\n"", """");
    sLine.Replace(""\r"", """");
 
     DEBUG(""("" << GetFullName() << "") CLI -> ZNC [""
         << CDebug::Filter(sLine) << ""]"");","ZNC before 1.7.1-rc1 does not properly validate untrusted lines coming from the network, allowing a non-admin user to escalate his privilege and inject rogue values into znc.conf."
1578,CVE-2018-14043,"  static M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)
 	return M_TRUE;
 }
 
 
 static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)
 {
 	M_fs_info_t  *info = NULL;
  static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uin
 
 	if (type != M_FS_TYPE_DIR) {
 		 
		if (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {
 			ret = M_FALSE;
 			goto done;
 		}
  static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 	size_t         offset;
 	M_fs_error_t   res;
 
 	 
 	res = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);
 	if (res != M_FS_ERROR_SUCCESS) {
  static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M
 		}
 		perms = M_fs_info_get_perms(info);
 	}

	 
 	res = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);
 	M_fs_info_destroy(info);
 	if (res != M_FS_ERROR_SUCCESS) {
  M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	 
	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
  M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 		return res;
 	}
 
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
  M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode
 			res = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 		} else {
 			 
			 * want to remove any existing files (especially if the dest is a dir). */
 			if (!(mode & M_FS_FILE_MODE_OVERWRITE)) {
 				M_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 			}
 			res = M_FS_ERROR_GENERIC;
 		}
 	} else {
 		 
		 * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */
 		if (cb) {
 			M_fs_progress_set_result(progress, res);
 			if (!cb(progress)) {
  M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	 
	 * existing to rename because any check we perform may not be true when rename is called. */
 	res = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);
 	if (res != M_FS_ERROR_SUCCESS) {
 		M_free(norm_path_new);
  M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	type = M_fs_info_get_type(info);
 
 	if (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {
  M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 	entries = M_fs_dir_entries_create();
 	 
 	M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));
 	if (type == M_FS_TYPE_DIR) {
  M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 
 			type = M_fs_dir_entry_get_type(entry);
 			 
  M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode
 	}
 
 	 
	 * If we're overwriting then there could be other files in that location (especially if it's a dir). */
 	if (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {
 		M_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);
 	}
  M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	entries = M_fs_dir_entries_create();
 
 	 
 	if (type == M_FS_TYPE_DIR && remove_children) {
  M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	}
 
 	 
  M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress
 	len = M_fs_dir_entries_len(entries);
 	if (cb) {
 		 
		 * new info as necessary. */
 		progress = M_fs_progress_create();
 
 		 ","mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data."
1579,CVE-2018-14017,"  R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64
 		if (!lnattr) {
 			break;
 		}
		if (offset + 8 >= sz) {
			break;
		}
 		lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);
 		offset += 2;
 		lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);",The r_bin_java_annotation_new function in shlr/java/class.c in radare2 2.7.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted .class file because of missing input validation in r_bin_java_line_number_table_attr_new.
1580,CVE-2018-14016,"  static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
 	 
 	if (entry->location.rva + entry->location.data_size > obj->b->length) {
		eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
 		return false;
 	}
 
  static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct m
 
 static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {
 	int i;
	struct minidump_directory entry;
 
 	sdb_num_set (obj->kv, ""mdmp_directory.offset"",
 			obj->hdr->stream_directory_rva, 0);
  static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {
 			""(mdmp_location_descriptor)Location"", 0);
 
 	 
	ut64 rvadir = obj->hdr->stream_directory_rva;
 	for (i = 0; i < (int)obj->hdr->number_of_streams; i++) {
		ut32 delta = i * sizeof (struct minidump_directory);
		int r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));
		if (r) {
			r_bin_mdmp_init_directory_entry (obj, &entry);
		}
 	}
 
 	return true;",The r_bin_mdmp_init_directory_entry function in mdmp.c in radare2 2.7.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted Mini Crash Dump file.
1581,CVE-2018-14015,"  static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,
 					&cu->hdr, debug_str, debug_str_len);
 			if (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {
 				const char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;
				if (name > 1024) {  
					sdb_set (s, ""DW_AT_comp_dir"", name, 0);
				} else {
					eprintf (""Invalid string pointer at %p\n"", name);
				}
 			}
 			cu->dies[cu->length].length++;
 		}",The sdb_set_internal function in sdb.c in radare2 2.7.0 allows remote attackers to cause a denial of service (invalid read and application crash) via a crafted ELF file because of missing input validation in r_bin_dwarf_parse_comp_unit in libr/bin/dwarf.c.
1582,CVE-2018-13785,"  png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)
    {
       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
       size_t row_factor =
         (size_t)png_ptr->width
         * (size_t)png_ptr->channels
         * (png_ptr->bit_depth > 8? 2: 1)
         + 1
         + (png_ptr->interlaced? 6: 0);
       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
         idat_limit = PNG_UINT_31_MAX;
       else
          idat_limit = png_ptr->height * row_factor;
       row_factor = row_factor > 32566? 32566 : row_factor;","In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service."
1583,CVE-2018-13406,"  static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
 		    info->cmap.len || cmap->start < info->cmap.start)
 			return -EINVAL;
 
		entries = kmalloc_array(cmap->len, sizeof(*entries),
					GFP_KERNEL);
 		if (!entries)
 			return -ENOMEM;
 ",An integer overflow in the uvesafb_setcmap function in drivers/video/fbdev/uvesafb.c in the Linux kernel before 4.17.4 could result in local attackers being able to crash the kernel or potentially elevate privileges because kmalloc_array is not used.
1584,CVE-2018-13405,"  void inode_init_owner(struct inode *inode, const struct inode *dir,
 	inode->i_uid = current_fsuid();
 	if (dir && dir->i_mode & S_ISGID) {
 		inode->i_gid = dir->i_gid;

		 
 		if (S_ISDIR(mode))
 			mode |= S_ISGID;
		else if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&
			 !in_group_p(inode->i_gid) &&
			 !capable_wrt_inode_uidgid(dir, CAP_FSETID))
			mode &= ~S_ISGID;
 	} else
 		inode->i_gid = current_fsgid();
 	inode->i_mode = mode;","The inode_init_owner function in fs/inode.c in the Linux kernel through 4.17.4 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID."
1585,CVE-2018-13305,"  static void vc1_put_blocks_clamped(VC1Context *v, int put_signed)
         if ((edges&8) &&                                       \
             s->mb_y == ((s->mb_height >> v->field_mode) - 1))  \
             mquant = -v->altpq;                                \
        if (!mquant || mquant > 31 || mquant < -31) {                          \
             av_log(v->s.avctx, AV_LOG_ERROR,                   \
                    ""Overriding invalid mquant %d\n"", mquant);  \
             mquant = 1;                                        \","In FFmpeg 4.0.1, due to a missing check for negative values of the mquant variable, the vc1_put_blocks_clamped function in libavcodec/vc1_block.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to an information disclosure or a denial of service."
1586,CVE-2018-13304,"  static int er_supported(ERContext *s)
 {
     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
        !s->cur_pic.f                                                  ||
       s->cur_pic.field_picture
     )
         return 0;
     return 1;","In libavcodec in FFmpeg 4.0.1, improper maintenance of the consistency between the context profile field and studio_profile in libavcodec may trigger an assertion failure while converting a crafted AVI file to MPEG4, leading to a denial of service, related to error_resilience.c, h263dec.c, and mpeg4videodec.c."
1587,CVE-2018-13303,"  int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
         return AVERROR(ENOMEM);
     hdr = *phdr;
 
    err = init_get_bits8(&gb, buf, size);
    if (err < 0)
        return AVERROR_INVALIDDATA;
     err = ff_ac3_parse_header(&gb, hdr);
     if (err < 0)
         return AVERROR_INVALIDDATA;","In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service."
1588,CVE-2018-13302,"  static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
                 info->ec3_done = 1;
                 goto concatenate;
             }
        } else {
            if (hdr->substreamid != 0) {
                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
                ret = AVERROR_PATCHWELCOME;
                goto end;
            }
         }
 
          ","In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact."
1589,CVE-2018-13301,"  static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
     return 0;
 }
 
static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
 {
 
    *profile = get_bits(gb, 4);
    *level   = get_bits(gb, 4);
 
      
    if (*profile == 0 && *level == 8) {
        *level = 0;
     }
 
     return 0;
  int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
            int profile, level;
            mpeg4_decode_profile_level(s, gb, &profile, &level);
            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                (level > 0 && level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
            } else if (s->studio_profile) {
                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
                return AVERROR_PATCHWELCOME;
             }
            s->avctx->profile = profile;
            s->avctx->level   = level;
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
  int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;","In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service."
1590,CVE-2018-13300,"  static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)
 
             if (hdr->substreamid == info->num_ind_sub + 1) {
                  
                avpriv_request_sample(mov->fc, ""Multiple independent substreams"");
                 ret = AVERROR_PATCHWELCOME;
                 goto end;
             } else if (hdr->substreamid < info->num_ind_sub ||","In FFmpeg 4.0.1, an improper argument (AVCodecParameters) passed to the avpriv_request_sample function in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array read while converting a crafted AVI file to MPEG4, leading to a denial of service and possibly an information disclosure."
1591,CVE-2018-13095,"  typedef enum xfs_dinode_fmt {
 		XFS_DFORK_DSIZE(dip, mp) : \
 		XFS_DFORK_ASIZE(dip, mp))
 
#define XFS_DFORK_MAXEXT(dip, mp, w) \
	(XFS_DFORK_SIZE(dip, mp, w) / sizeof(struct xfs_bmbt_rec))

  ","An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork."
1592,CVE-2018-13094,"  xfs_attr_shortform_to_leaf(
 	ASSERT(blkno == 0);
 	error = xfs_attr3_leaf_create(args, blkno, &bp);
 	if (error) {
		 
		if (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))
 			goto out;
 		xfs_idata_realloc(dp, size, XFS_ATTR_FORK);	 
 		memcpy(ifp->if_u1.if_data, tmpbuffer, size);	 ",An issue was discovered in fs/xfs/libxfs/xfs_attr_leaf.c in the Linux kernel through 4.17.3. An OOPS may occur for a corrupted xfs image after xfs_da_shrink_inode() is called with a NULL bp.
1593,CVE-2018-13093,"  xfs_reinit_inode(
 	return error;
 }
 
 
static int
xfs_iget_check_free_state(
	struct xfs_inode	*ip,
	int			flags)
{
	if (flags & XFS_IGET_CREATE) {
		 
		if (VFS_I(ip)->i_mode != 0) {
			xfs_warn(ip->i_mount,
""Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)"",
				ip->i_ino, VFS_I(ip)->i_mode);
			return -EFSCORRUPTED;
		}

		if (ip->i_d.di_nblocks != 0) {
			xfs_warn(ip->i_mount,
""Corruption detected! Free inode 0x%llx has blocks allocated!"",
				ip->i_ino);
			return -EFSCORRUPTED;
		}
		return 0;
	}

	 
	if (VFS_I(ip)->i_mode == 0)
		return -ENOENT;

	return 0;
}

  
  xfs_iget_cache_hit(
 	}
 
 	 
	error = xfs_iget_check_free_state(ip, flags);
	if (error)
 		goto out_error;
 
 	 
	error = xfs_iget_check_free_state(ip, flags);
	if (error)
 		goto out_destroy;
 
 	/*
 	 * Preload the radix tree so we can insert safely under the",An issue was discovered in fs/xfs/xfs_icache.c in the Linux kernel through 4.17.3. There is a NULL pointer dereference and panic in lookup_slow() on a NULL inode->i_ops pointer when doing pathwalks on a corrupted xfs image. This occurs because of a lack of proper validation that cached inodes are free during allocation.
1594,CVE-2018-13006,"  GF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(char *
 		char __ptype[5];\
 		strcpy(__ptype, gf_4cc_to_str(__parent->type) );\
 		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] extra box %s found in %s, deleting\n"", gf_4cc_to_str(__abox->type), __ptype)); \
		gf_isom_box_del(__abox);\
 		return GF_OK;\
 	}
 ",An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.
1595,CVE-2018-12904,"  static int handle_vmon(struct kvm_vcpu *vcpu)
 		return 1;
 	}
 
	 
	if (vmx_get_cpl(vcpu)) {
		kvm_queue_exception(vcpu, UD_VECTOR);
		return 1;
	}

 	if (vmx->nested.vmxon) {
 		nested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);
 		return kvm_skip_emulated_instruction(vcpu);
  static int handle_vmon(struct kvm_vcpu *vcpu)
  */
 static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)
 {
	if (vmx_get_cpl(vcpu)) {
		kvm_queue_exception(vcpu, UD_VECTOR);
		return 0;
	}

 	if (!to_vmx(vcpu)->nested.vmxon) {
 		kvm_queue_exception(vcpu, UD_VECTOR);
 		return 0;
  static int handle_vmread(struct kvm_vcpu *vcpu)
 		if (get_vmx_mem_address(vcpu, exit_qualification,
 				vmx_instruction_info, true, &gva))
 			return 1;
		 
 		kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,
 			     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);
 	}
  static int handle_vmptrst(struct kvm_vcpu *vcpu)
 	if (get_vmx_mem_address(vcpu, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
	 
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(vcpu)->nested.current_vmptr,
 				 sizeof(u64), &e)) {","In arch/x86/kvm/vmx.c in the Linux kernel before 4.17.2, when nested virtualization is used, local attackers could cause L1 KVM guests to VMEXIT, potentially allowing privilege escalations and denial of service attacks due to lack of checking of CPL."
1596,CVE-2018-12896,"  struct k_itimer {
 	clockid_t		it_clock;
 	timer_t			it_id;
 	int			it_active;
	s64			it_overrun;
	s64			it_overrun_last;
 	int			it_requeue_pending;
 	int			it_sigev_notify;
 	ktime_t			it_interval;","An issue was discovered in the Linux kernel through 4.17.3. An Integer Overflow in kernel/time/posix-timers.c in the POSIX timer code is caused by the way the overrun accounting works. Depending on interval and expiry time values, the overrun can be larger than INT_MAX, but the accounting is int based. This basically makes the accounting values, which are visible to user space via timer_getoverrun(2) and siginfo::si_overrun, random. For example, a local user can cause a denial of service (signed integer overflow) via crafted mmap, futex, timer_create, and timer_settime system calls."
1597,CVE-2018-12713,"  gimp_write_and_read_file (Gimp     *gimp,
   GimpImage           *image;
   GimpImage           *loaded_image;
   GimpPlugInProcedure *proc;
  gchar               *filename = NULL;
  gint                 file_handle;
   GFile               *file;
 
    
  gimp_write_and_read_file (Gimp     *gimp,
                          use_gimp_2_8_features);
 
    
  file_handle = g_file_open_tmp (""gimp-test-XXXXXX.xcf"", &filename, NULL);
  g_assert (file_handle != -1);
  close (file_handle);
   file = g_file_new_for_path (filename);
   g_free (filename);
 ","GIMP through 2.10.2 makes g_get_tmp_dir calls to establish temporary filenames, which may result in a filename that already exists, as demonstrated by the gimp_write_and_read_file function in app/tests/test-xcf.c. This might be leveraged by attackers to overwrite files or read file content that was intended to be private."
1598,CVE-2018-12684,"  send_ssi_file(struct mg_connection *conn,
 					 
 					buf[len] = 0;
 
					if ((len > 12) && !memcmp(buf + 5, ""include"", 7)) {
 						do_ssi_include(conn, path, buf + 12, include_level + 1);
 #if !defined(NO_POPEN)
					} else if ((len > 9) && !memcmp(buf + 5, ""exec"", 4)) {
 						do_ssi_exec(conn, buf + 9);
 #endif  
 					} else {",Out-of-bounds Read in the send_ssi_file function in civetweb.c in CivetWeb through 1.10 allows attackers to cause a Denial of Service or Information Disclosure via a crafted SSI file.
1599,CVE-2018-12633,"  static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,
 	if (!buf)
 		return -ENOMEM;
 
	*((struct vbg_ioctl_hdr *)buf) = hdr;
	if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr),
			   hdr.size_in - sizeof(hdr))) {
 		ret = -EFAULT;
 		goto out;
 	}","An issue was discovered in the Linux kernel through 4.17.2. vbg_misc_device_ioctl() in drivers/virt/vboxguest/vboxguest_linux.c reads the same user data twice with copy_from_user. The header part of the user data is double-fetched, and a malicious user thread can tamper with the critical variables (hdr.size_in and hdr.size_out) in the header between the two fetches because of a race condition, leading to severe kernel errors, such as buffer over-accesses. This bug can cause a local denial of service and information leakage."
1600,CVE-2018-12615,"  switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {
 			if (ngroups <= NGROUPS_MAX) {
 				setgroupsCalled = true;
 				gidset.reset(new gid_t[ngroups]);
				for (int i = 0; i < ngroups; i++) {
					gidset[i] = groups[i];
				}
 				if (setgroups(ngroups, gidset.get()) == -1) {
 					int e = errno;
 					fprintf(stderr, ""ERROR: setgroups(%d, ...) failed: %s (errno=%d)\n"",","An issue was discovered in switchGroup() in agent/ExecHelper/ExecHelperMain.cpp in Phusion Passenger before 5.3.2. The set of groups (gidset) is not set correctly, leaving it up to randomness (i.e., uninitialized memory) which supplementary groups are actually being set while lowering privileges."
1601,CVE-2018-12584,"  ConnectionBase::preparseNewBytes(int bytesRead)
                   mBufferSize = size;
                   
                   DebugLog (<< ""Extra bytes after message: "" << overHang);
                   
                   
                   bytesRead = overHang;
                }
  ConnectionBase::preparseNewBytes(int bytesRead)
          }
 
          mBufferPos += bytesRead;
         if (mBufferPos >= contentLength)
          {
            int overHang = mBufferPos - (int)contentLength;
            char *overHangStart = mBuffer + contentLength;

             mMessage->addBuffer(mBuffer);
             mMessage->setBody(mBuffer, (UInt32)contentLength);
            mConnState = NewMessage;
            mBuffer = 0;

            if (overHang > 0)
            {
                 
                size_t size = overHang * 3 / 2;
                if (size < ConnectionBase::ChunkSize)
                {
                    size = ConnectionBase::ChunkSize;
                }
                char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);
                memcpy(newBuffer, overHangStart, overHang);
                mBuffer = newBuffer;
                mBufferPos = 0;
                mBufferSize = size;

                DebugLog(<< ""Extra bytes after message: "" << overHang);
                 

                bytesRead = overHang;
            }

              
              
             CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();
  ConnectionBase::preparseNewBytes(int bytesRead)
                mTransport->pushRxMsgUp(mMessage);
                mMessage = 0;
             }
            
            if (overHang > 0) 
            {
               goto start;
            }
          }
          else if (mBufferPos == mBufferSize)
          {
             
            assert(contentLength >= mBufferSize);
             size_t newSize = resipMin(mBufferSize*3/2, contentLength);
             char* newBuffer = 0;
             try",The ConnectionBase::preparseNewBytes function in resip/stack/ConnectionBase.cxx in reSIProcate through 1.10.2 allows remote attackers to cause a denial of service (buffer overflow) or possibly execute arbitrary code when TLS communication is enabled.
1602,CVE-2018-12460,"  av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
              
            if (c->mpeg4_studio_profile)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;
             else {
                 c->idct_put              = ff_simple_idct_put_int16_10bit;","libavcodec in FFmpeg 4.0 may trigger a NULL pointer dereference if the studio profile is incorrectly detected while converting a crafted AVI file to MPEG4, leading to a denial of service, related to idctdsp.c and mpegvideo.c."
1603,CVE-2018-12459,"  int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
      
     align_get_bits(gb);
 
     
     
     
    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
        s->avctx->bits_per_raw_sample = 0;

     if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
         skip_bits(gb, 24);
         if (get_bits(gb, 8) == 0xF0)","An inconsistent bits-per-sample value in the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service."
1604,CVE-2018-12458,"  void ff_set_mpeg4_time(MpegEncContext *s)
 
 static void mpeg4_encode_gop_header(MpegEncContext *s)
 {
    int64_t hours, minutes, seconds;
     int64_t time;
 
     put_bits(&s->pb, 16, 0);","An improper integer type in the mpeg4_encode_gop_header function in libavcodec/mpeg4videoenc.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service."
1605,CVE-2018-12453,"  NULL
      
     if (c->argc >= 4) {
         robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
         s = o->ptr;
         grpname = c->argv[3]->ptr;
 ",Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.
1606,CVE-2018-12436,"  static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)
     if (err == 0)
         err = mp_read_unsigned_bin(k, (byte*)buf, size);
 
      
     if (err == MP_OKAY) {
         if (mp_cmp(k, order) != MP_LT) {
             err = mp_mod(k, order, k);
         }
     }
 
     
    if (err == MP_OKAY) {
        if (mp_iszero(k) == MP_YES)
          err = MP_ZERO_E;
    }

     ForceZero(buf, ECC_MAXSIZE);
 #ifdef WOLFSSL_SMALL_STACK
     XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);
  int wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,
 
         
        if ((err = wc_ecc_init_ex(&pubkey, key->heap, INVALID_DEVID)) == MP_OKAY) {
           mp_int b;

           if (err == MP_OKAY) {
               err = mp_init(&b);
           }

        #ifdef WOLFSSL_CUSTOM_CURVES
             
           if (err == MP_OKAY && key->idx == ECC_CUSTOM_IDX) {
                err = wc_ecc_set_custom_curve(&pubkey, key->dp);
            }
        #endif
 
           if (err == MP_OKAY) {
                
               do {
                   if (++loop_check > 64) {
                        err = RNG_FAILURE_E;
                        break;
                   }

                   err = wc_ecc_gen_k(rng, key->dp->size, &b, curve->order);
               }
               while (err == MP_ZERO_E);
               loop_check = 0;
           }

            for (; err == MP_OKAY;) {
                if (++loop_check > 64) {
                     err = RNG_FAILURE_E;
                     break;
                }
                err = wc_ecc_make_key_ex(rng, key->dp->size, &pubkey,
                                                                   key->dp->id);
                if (err != MP_OKAY) break;
 
                 
  int wc_ecc_sign_hash_ex(const byte* in, word32 inlen, WC_RNG* rng,
                    mp_forcezero(&pubkey.k);
                }
                else {
                    

                    
                   err = mp_mulmod(&pubkey.k, &b, curve->order, &pubkey.k);
                   if (err != MP_OKAY) break;

                    
                    err = mp_invmod(&pubkey.k, curve->order, &pubkey.k);
                    if (err != MP_OKAY) break;
 
                    
                    err = mp_mulmod(&key->k, r, curve->order, s);
                    if (err != MP_OKAY) break;
 
                    
                   err = mp_mulmod(&pubkey.k, s, curve->order, s);
                   if (err != MP_OKAY) break;

                    
                   err = mp_mulmod(&pubkey.k, e, curve->order, e);
                   if (err != MP_OKAY) break;

                    
                    err = mp_add(e, s, s);
                    if (err != MP_OKAY) break;
 
                    
                   err = mp_mulmod(s, &b, curve->order, s);
                    if (err != MP_OKAY) break;
 
                     
                   err = mp_mod(s, curve->order, s);
                   if (err != MP_OKAY) break;
 
                    if (mp_iszero(s) == MP_NO)
                        break;
                 }
            }
            wc_ecc_free(&pubkey);
           mp_clear(&b);
           mp_free(&b);
        }
    }
 ","wolfcrypt/src/ecc.c in wolfSSL before 3.15.1.patch allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host."
1607,CVE-2018-12326,"  static long long mstime(void) {
 }
 
 static void cliRefreshPrompt(void) {
     if (config.eval_ldb) return;

    sds prompt = sdsempty();
    if (config.hostsocket != NULL) {
        prompt = sdscatfmt(prompt,""redis %s"",config.hostsocket);
    } else {
        char addr[256];
        anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);
        prompt = sdscatlen(prompt,addr,strlen(addr));
    }

      
     if (config.dbnum != 0)
        prompt = sdscatfmt(prompt,""[%i]"",config.dbnum);

     
    prompt = sdscatlen(prompt,""> "",2);
    snprintf(config.prompt,sizeof(config.prompt),""%s"",prompt);
    sdsfree(prompt);
 }
 
 /* Return the name of the dotfile for the specified 'dotfilename'.","Buffer overflow in redis-cli of Redis before 4.0.10 and 5.x before 5.0 RC3 allows an attacker to achieve code execution and escalate to higher privileges via a crafted command line. NOTE: It is unclear whether there are any common situations in which redis-cli is used with, for example, a -h (aka hostname) argument from an untrusted source."
1608,CVE-2018-12322,"  static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int le
 		op->cycles = 2;
 		op->failcycles = 3;
 		op->type = R_ANAL_OP_TYPE_CJMP;
		if (len > 1) {
			if (data[1] <= 127) {
				op->jump = addr + data[1] + op->size;
			} else {
				op->jump = addr - (256 - data[1]) + op->size;
			}
		} else {
			op->jump = addr;
		}
 		op->fail = addr + op->size;
 		 
 		 ",There is a heap out of bounds read in radare2 2.6.0 in _6502_op() in libr/anal/p/anal_6502.c via a crafted iNES ROM binary file.
1609,CVE-2018-12321,"  static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data,
 
 	if (op_byte == 0xaa) {
 		 
		if (pos + 8 + 8 > len) {
 			return op->size;
 		}
		const int min_val = (ut32)(UINT (data, pos + 4));
		const int max_val = (ut32)(UINT (data, pos + 8));
 
 		ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;
 		op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);",There is a heap out of bounds read in radare2 2.6.0 in java_switch_op() in libr/anal/p/anal_java.c via a crafted Java binary file.
1610,CVE-2018-12320,"  R_API void r_anal_bb_free(RAnalBlock *bb) {
 		bb->failbb->prev = NULL;
 		bb->failbb = NULL;
 	}
	if (bb->next) {
		 
		bb->next->prev = NULL;
	}
	R_FREE (bb);  
 }
 
 R_API RList *r_anal_bb_list_new() {",There is a use after free in radare2 2.6.0 in r_anal_bb_free() in libr/anal/bb.c via a crafted Java binary file.
1611,CVE-2018-12249,"  mrb_class_path(mrb_state *mrb, struct RClass *c)
 MRB_API struct RClass*
 mrb_class_real(struct RClass* cl)
 {
  if (cl == 0) return NULL;
   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {
     cl = cl->super;
    if (cl == 0) return NULL;
   }
   return cl;
 }",An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class_real because *class BasicObject* is not properly supported in class.c.
1612,CVE-2018-12248,"  fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
 {
   struct mrb_context *c = fiber_check(mrb, self);
   struct mrb_context *old_c = mrb->c;
  enum mrb_fiber_state status;
   mrb_value value;
 
   fiber_check_cfunc(mrb, c);
  status = c->status;
  if (resume && status == MRB_FIBER_TRANSFERRED) {
     mrb_raise(mrb, E_FIBER_ERROR, ""resuming transferred fiber"");
   }
  if (status == MRB_FIBER_RUNNING || status == MRB_FIBER_RESUMED) {
     mrb_raise(mrb, E_FIBER_ERROR, ""double resume (fib)"");
   }
  if (status == MRB_FIBER_TERMINATED) {
     mrb_raise(mrb, E_FIBER_ERROR, ""resuming dead fiber"");
   }
  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
   c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);
  fiber_switch_context(mrb, c);
  if (status == MRB_FIBER_CREATED) {
     mrb_value *b, *e;
 
    mrb_stack_extend(mrb, len+2);  
     b = c->stack+1;
     e = b + len;
     while (b<e) {
  fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mr
   else {
     value = fiber_result(mrb, a, len);
   }
 
   if (vmexec) {
     c->vmexec = TRUE;",An issue was discovered in mruby 1.4.1. There is a heap-based buffer over-read associated with OP_ENTER because mrbgems/mruby-fiber/src/fiber.c does not extend the stack in cases of many arguments to fiber.
1613,CVE-2018-12247,"  mrb_obj_clone(mrb_state *mrb, mrb_value self)
   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);
   clone = mrb_obj_value(p);
   init_copy(mrb, clone, self);
  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;
 
   return clone;
 }","An issue was discovered in mruby 1.4.1. There is a NULL pointer dereference in mrb_class, related to certain .clone usage, because mrb_obj_clone in kernel.c copies flags other than the MRB_FLAG_IS_FROZEN flag (e.g., the embedded flag)."
1614,CVE-2018-12232,"  static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)
 	if (!err && (iattr->ia_valid & ATTR_UID)) {
 		struct socket *sock = SOCKET_I(d_inode(dentry));
 
		if (sock->sk)
			sock->sk->sk_uid = iattr->ia_uid;
		else
			err = -ENOENT;
 	}
 
 	return err;
  EXPORT_SYMBOL(sock_alloc);
  *	an inode not a file.
  */
 
static void __sock_release(struct socket *sock, struct inode *inode)
 {
 	if (sock->ops) {
 		struct module *owner = sock->ops->owner;
 
		if (inode)
			inode_lock(inode);
 		sock->ops->release(sock);
		if (inode)
			inode_unlock(inode);
 		sock->ops = NULL;
 		module_put(owner);
 	}
  void sock_release(struct socket *sock)
 	}
 	sock->file = NULL;
 }

void sock_release(struct socket *sock)
{
	__sock_release(sock, NULL);
}
 EXPORT_SYMBOL(sock_release);
 
 void __sock_tx_timestamp(__u16 tsflags, __u8 *tx_flags)
  static int sock_mmap(struct file *file, struct vm_area_struct *vma)
 
 static int sock_close(struct inode *inode, struct file *filp)
 {
	__sock_release(SOCKET_I(inode), inode);
 	return 0;
 }
 ","In net/socket.c in the Linux kernel through 4.17.1, there is a race condition between fchownat and close in cases where they target the same socket file descriptor, related to the sock_close and sockfs_setattr functions. fchownat does not increment the file descriptor reference count, which allows close to set the socket to NULL during fchownat's execution, leading to a NULL pointer dereference and system crash."
1615,CVE-2018-11743,"  static void
 init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)
 {
   switch (mrb_type(obj)) {
    case MRB_TT_ICLASS:
      copy_class(mrb, dest, obj);
      return;
     case MRB_TT_CLASS:
     case MRB_TT_MODULE:
       copy_class(mrb, dest, obj);","The init_copy function in kernel.c in mruby 1.4.1 makes initialize_copy calls for TT_ICLASS objects, which allows attackers to cause a denial of service (mrb_hash_keys uninitialized pointer and application crash) or possibly have unspecified other impact."
1616,CVE-2018-11596,"  size_t jsvGetString(const JsVar *v, char *str, size_t len) {
      * want to pad the entire buffer with zeros */
     len--;
     int l = 0;
    while (s[l] && l<len) {
       str[l] = s[l];
       l++;
     }",Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because a check for '0' is made for the wrong array element in jsvar.c.
1617,CVE-2018-11593,"  void jslFunctionCharAsString(unsigned char ch, char *str, size_t len) {
 }
 
 void jslTokenAsString(int token, char *str, size_t len) {
  assert(len>28);  
    
   if (token>32 && token<128) {
     assert(len>=4);
  void jslTokenAsString(int token, char *str, size_t len) {
     return;
   }
 

   switch (token) {
  case LEX_EOF : strcpy(str, ""EOF""); return;
  case LEX_ID : strcpy(str, ""ID""); return;
  case LEX_INT : strcpy(str, ""INT""); return;
  case LEX_FLOAT : strcpy(str, ""FLOAT""); return;
  case LEX_STR : strcpy(str, ""STRING""); return;
  case LEX_UNFINISHED_STR : strcpy(str, ""UNFINISHED STRING""); return;
  case LEX_TEMPLATE_LITERAL : strcpy(str, ""TEMPLATE LITERAL""); return;
  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, ""UNFINISHED TEMPLATE LITERAL""); return;
  case LEX_REGEX : strcpy(str, ""REGEX""); return;
  case LEX_UNFINISHED_REGEX : strcpy(str, ""UNFINISHED REGEX""); return;
  case LEX_UNFINISHED_COMMENT : strcpy(str, ""UNFINISHED COMMENT""); return;
   }
   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {
     const char tokenNames[] =
  void jslTokenAsString(int token, char *str, size_t len) {
       n--;  
     }
     assert(n==0);
    strcpy(str, &tokenNames[p]);
     return;
   }
 
   espruino_snprintf(str, len, ""?[%d]"", token);
 }
 ",Espruino before 1.99 allows attackers to cause a denial of service (application crash) and potential Information Disclosure with a user crafted input file via a Buffer Overflow during syntax parsing because strncpy is misused in jslex.c.
1618,CVE-2018-11508,"  int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
 {
 	struct compat_timex tx32;
 
	memset(txc, 0, sizeof(struct timex));
 	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
 		return -EFAULT;
 ",The compat_get_timex function in kernel/compat.c in the Linux kernel before 4.16.9 allows local users to obtain sensitive information from kernel memory via adjtimex.
1619,CVE-2018-11506,"  int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
 	struct scsi_device *SDev;
 	struct scsi_sense_hdr sshdr;
 	int result, err = 0, retries = 0;
	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;
 
 	SDev = cd->device;
 
	if (cgc->sense)
		senseptr = sense_buffer;

       retry:
 	if (!scsi_block_when_processing_errors(SDev)) {
 		err = -ENODEV;
 		goto out;
 	}
 
 	result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
			      cgc->buffer, cgc->buflen, senseptr, &sshdr,
 			      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);
 
	if (cgc->sense)
		memcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));

 	 
 	if (driver_byte(result) != 0) {
 		switch (sshdr.sense_key) {","The sr_do_ioctl function in drivers/scsi/sr_ioctl.c in the Linux kernel through 4.16.12 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact because sense buffers have different sizes at the CDROM layer and the SCSI layer, as demonstrated by a CDROMREADMODE2 ioctl call."
1620,CVE-2018-11384,"  static int (*first_nibble_decode[])(RAnal*,RAnalOp*,ut16) = {
 static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!data || len < 2) {
 		return 0;
	}
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = R_ANAL_OP_TYPE_UNK;",The sh_op() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.
1621,CVE-2018-11383,"  INST_HANDLER (cpi) {  
 INST_HANDLER (cpse) {	 
 	int r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);
 	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	RAnalOp next_op = {0};
 
 	 
 	 ",The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c.
1622,CVE-2018-11382,"  INST_HANDLER (lds) {	 
 }
 
 INST_HANDLER (sts) {	 
	if (len < 4) {
		return;
	}
 	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
 	int k = (buf[3] << 8) | buf[2];
 	op->ptr = k;",The _inst__sts() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
1623,CVE-2018-11381,"  static int string_scan_range(RList *list, RBinFile *bf, int min,
 		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
 		return -1;
 	}
	int len = to - from;
	ut8 *buf = calloc (len, 1);
 	if (!buf || !min) {
 		return -1;
 	}
	r_buf_read_at (bf->buf, from, buf, len);
 	 
 	while (needle < to) {
 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
  static int string_scan_range(RList *list, RBinFile *bf, int min,
 		}
 		if (type == R_STRING_TYPE_DETECT) {
 			char *w = (char *)buf + needle + rc - from;
			if ((to - needle) > 5 + rc) {
				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
 				if (is_wide32) {
 					str_type = R_STRING_TYPE_WIDE32;
 				} else {",The string_scan_range() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
1624,CVE-2018-11380,"  struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {
 			bprintf (""mach0-get-symbols: error\n"");
 			break;
 		}
		if (parse_import_stub(bin, &symbols[j], i)) {
 			symbols[j++].last = 0;
		}
 	}
 
 #if 1
  static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, in
 
 	for (i = 0; i < bin->nsects; i++) {
 		if ((bin->sects[i].flags & SECTION_TYPE) == stype) {
			for (j = 0, sym = -1; bin->sects[i].reserved1 + j < bin->nindirectsyms; j++) {
				int indidx = bin->sects[i].reserved1 + j;
				if (indidx < 0 || indidx >= bin->nindirectsyms) {
					break;
				}
				if (idx == bin->indirectsyms[indidx]) {
 					sym = j;
 					break;
 				}
			}
 			reloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;
 			reloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;
 			return true;
  struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {
 	int i, j, idx, stridx;
 	const char *symstr;
 
	if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {
 		return NULL;
	}
 	if (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {
 		return NULL;
 	}",The parse_import_ptr() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted Mach-O file.
1625,CVE-2018-11379,"  static bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {
 
 static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {
 	const int nb10sz = 16;
	 
	 
 }
 
 static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {
  static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_direc
 			res->file_name[sizeof (res->file_name) - 1] = 0;
 			rsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);
 		} else if (strncmp ((const char*) dbg_data, ""NB10"", 4) == 0) {
			if (dbg_data_len < 20) {
				eprintf (""Truncated NB10 entry, not enough data to parse\n"");
				return 0;
			}
			SCV_NB10_HEADER nb10_hdr = {{0}};
 			init_cv_nb10_header (&nb10_hdr);
 			get_nb10 (dbg_data, &nb10_hdr);
 			snprintf (res->guidstr, sizeof (res->guidstr),
 				""%x%x"", nb10_hdr.timestamp, nb10_hdr.age);
			res->file_name[0] = 0;
			if (nb10_hdr.file_name) {
				strncpy (res->file_name, (const char*)
						nb10_hdr.file_name, sizeof (res->file_name) - 1);
			}
 			res->file_name[sizeof (res->file_name) - 1] = 0;
 			nb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);
 		} else {",The get_debug_info() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted PE file.
1626,CVE-2018-11378,"  int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {
 			}
 			op->len += n;
 			snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d "", opdef->txt, count);
			char *txt = op->txt;
			int txtLen = strlen (op->txt);
			int txtLeft = R_ASM_BUFSIZE - txtLen;
			txt += txtLen;
			for (i = 0; i < count && txtLen + 10 < R_ASM_BUFSIZE; i++) {
				snprintf (txt, txtLeft, ""%d "", table[i]);
				txtLen = strlen (txt);
				txt += txtLen;
				txtLeft -= txtLen;
 			}
			snprintf (txt, txtLeft - 1, ""%d"", def);
 			free (table);
 			break;
		beach:
 			free (table);
 			goto err;
 		}",The wasm_dis() function in libr/asm/arch/wasm/wasm.c in or possibly have unspecified other impact via a crafted WASM file.
1627,CVE-2018-11377,"  INST_HANDLER (sbrx) {	 
 			 
 	int b = buf[0] & 0x7;
 	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op = {0};
 
 	 
 	 ",The avr_op_analyze() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
1628,CVE-2018-11376,"  static void process_constructors (RBinFile *bf, RList *ret, int bits) {
 			}
 			(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);
 			if (bits == 32) {
				for (i = 0; (i + 3) < sec->size; i += 4) {
 					ut32 addr32 = r_read_le32 (buf + i);
 					if (addr32) {
 						RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);
 						r_list_append (ret, ba);
 					}
 				}
 			} else {
				for (i = 0; (i + 7) < sec->size; i += 8) {
 					ut64 addr64 = r_read_le64 (buf + i);
 					if (addr64) {
 						RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);",The r_read_le32() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.
1629,CVE-2018-11375,"  INST_HANDLER (ldi) {	 
 }
 
 INST_HANDLER (lds) {	 
	if (len < 4) {
		return;
	}
 	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
 	int k = (buf[3] << 8) | buf[2];
 	op->ptr = k;",The _inst__lds() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
1630,CVE-2018-11363,"  static int jpeg_size(unsigned char* data, unsigned int data_size,
                     return 0;
                 }
                 i+=2;
                if (i + 1 < data_size)
                    block_length = data[i] * 256 + data[i+1];
             }
         }
     }",jpeg_size in pdfgen.c in PDFGen before 2018-04-09 has a heap-based buffer over-read.
1631,CVE-2018-11232,"  static void *etm_setup_aux(int event_cpu, void **pages,
 	if (!sink_ops(sink)->alloc_buffer)
 		goto err;
 
	cpu = cpumask_first(mask);
 	 
 	event_data->snk_config =
 			sink_ops(sink)->alloc_buffer(sink, cpu, pages,",The etm_setup_aux function in drivers/hwtracing/coresight/coresight-etm-perf.c in the Linux kernel before 4.10.2 allows attackers to cause a denial of service (panic) because a parameter is incorrectly used as a local variable.
1632,CVE-2018-11219,"  static int b_unpack (lua_State *L) {
   const char *fmt = luaL_checkstring(L, 1);
   size_t ld;
   const char *data = luaL_checklstring(L, 2, &ld);
  size_t pos = luaL_optinteger(L, 3, 1);
  luaL_argcheck(L, pos > 0, 3, ""offset must be 1 or greater"");
  pos--;  
   int n = 0;   
   defaultoptions(&h);
   while (*fmt) {
     int opt = *fmt++;
     size_t size = optsize(L, opt, &fmt);
     pos += gettoalign(pos, &h, opt, size);
    luaL_argcheck(L, size <= ld && pos <= ld - size,
                   2, ""data string too short"");
      
     luaL_checkstack(L, 2, ""too many results"");
     switch (opt) {","An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking."
1633,CVE-2018-11218,"  void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {
 #endif
 
     mp_encode_array(L,buf,len);
    luaL_checkstack(L, 1, ""in function mp_encode_lua_table_as_array"");
     for (j = 1; j <= len; j++) {
         lua_pushnumber(L,j);
         lua_gettable(L,-2);
  void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
    luaL_checkstack(L, 3, ""in function mp_encode_lua_table_as_map"");
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1);  
  int mp_pack(lua_State *L) {
     for(i = 1; i <= nargs; i++) {
          
        luaL_checkstack(L, 1, ""in function mp_check"");
         lua_pushvalue(L, i);
 
         mp_encode_lua_type(L,buf,0);
  void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
     int index = 1;
 
     lua_newtable(L);
    luaL_checkstack(L, 1, ""in function mp_decode_to_lua_array"");
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
  int mp_unpack_full(lua_State *L, int limit, int offset) {
          * subtract the entire buffer size from the unprocessed size
          * to get our next start offset */
         int offset = len - c.left;

        luaL_checkstack(L, 1, ""in function mp_unpack_full"");

          
         lua_pushinteger(L, c.left == 0 ? -1 : offset);
         /* Results are returned with the arg elements still","Memory Corruption was discovered in the cmsgpack library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2 because of stack-based buffer overflows."
1634,CVE-2018-10940,"  static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,
 	if (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)
 		return media_changed(cdi, 1);
 
	if (arg >= cdi->capacity)
 		return -EINVAL;
 
 	info = kmalloc(sizeof(*info), GFP_KERNEL);",The cdrom_ioctl_media_changed function in drivers/cdrom/cdrom.c in the Linux kernel before 4.16.6 allows local attackers to use a incorrect bounds check in the CDROM driver CDROM_MEDIA_CHANGED ioctl to read out kernel memory.
1635,CVE-2018-10916,"  int   MirrorJob::Do()
 	    }
 	    continue;
 	 }
	 bool use_rmdir = (file->TypeIs(file->DIRECTORY)
			   && recursion_mode==RECURSION_NEVER);
 	 if(script)
 	 {
	    ArgV args(use_rmdir?""rmdir"":""rm"");
	    if(file->TypeIs(file->DIRECTORY) && !use_rmdir)
	       args.Append(""-r"");
 	    args.Append(target_session->GetFileURL(file->name));
 	    xstring_ca cmd(args.CombineQuoted());
 	    fprintf(script,""%s\n"",cmd.get());
 	 }
 	 if(!script_only)
 	 {
	    ArgV *args=new ArgV(use_rmdir?""rmdir"":""rm"");
	    args->Append(dir_file(""."",file->name));
 	    args->seek(1);
 	    rmJob *j=new rmJob(target_session->Clone(),args);
 	    args->CombineTo(j->cmdline);
 	    JobStarted(j);
 	    if(file->TypeIs(file->DIRECTORY))
 	    {
 	       if(recursion_mode==RECURSION_NEVER)
 		  j->Rmdir();
 	       else
 		  j->Recurse();
 	    }
  int   MirrorJob::Do()
 	 if(!script_only)
 	 {
 	    ArgV *a=new ArgV(""chmod"");
	    a->Append(dir_file(""."",file->name));
 	    a->seek(1);
 	    ChmodJob *cj=new ChmodJob(target_session->Clone(),
 				 file->mode&~mode_mask,a);
  int   MirrorJob::Do()
 	 if(!script_only)
 	 {
 	    ArgV *args=new ArgV(""rm"");
	    args->Append(dir_file(""."",file->name));
 	    args->seek(1);
 	    rmJob *j=new rmJob(source_session->Clone(),args);
 	    args->CombineTo(j->cmdline);","It has been discovered that lftp up to and including version 4.8.3 does not properly sanitize remote file names, leading to a loss of integrity on the local system when reverse mirroring is used. A remote attacker may trick a user to use reverse mirroring on an attacker controlled FTP server, resulting in the removal of all files in the current working directory of the victim's system."
1636,CVE-2018-10888,"  int git_delta_apply(
 			 
 			size_t off = 0, len = 0;
 
#define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }
			if (cmd & 0x01) ADD_DELTA(off, 0UL);
			if (cmd & 0x02) ADD_DELTA(off, 8UL);
			if (cmd & 0x04) ADD_DELTA(off, 16UL);
			if (cmd & 0x08) ADD_DELTA(off, 24UL);

			if (cmd & 0x10) ADD_DELTA(len, 0UL);
			if (cmd & 0x20) ADD_DELTA(len, 8UL);
			if (cmd & 0x40) ADD_DELTA(len, 16UL);
 			if (!len)       len = 0x10000;
#undef ADD_DELTA
 
 			if (base_len < off + len || res_sz < len)
 				goto fail;","A flaw was found in libgit2 before version 0.27.3. A missing check in git_delta_apply function in delta.c file, may lead to an out-of-bound read while reading a binary delta file. An attacker may use this flaw to cause a Denial of Service."
1637,CVE-2018-10887,"  int git_delta_apply(
 		unsigned char cmd = *delta++;
 		if (cmd & 0x80) {
 			 
			size_t off = 0, len = 0, end;
 
 #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }
 			if (cmd & 0x01) ADD_DELTA(off, 0UL);
  int git_delta_apply(
 			if (!len)       len = 0x10000;
 #undef ADD_DELTA
 
			if (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||
			    base_len < end || res_sz < len)
 				goto fail;

 			memcpy(res_dp, base + off, len);
 			res_dp += len;
 			res_sz -= len;","A flaw was found in libgit2 before version 0.27.3. It has been discovered that an unexpected sign extension in git_delta_apply function in delta.c file may lead to an integer overflow which in turn leads to an out of bound read, allowing to read before the base object. An attacker may use this flaw to leak memory addresses or cause a Denial of Service."
1638,CVE-2018-10717,"  static int DecodeGifImg(struct ngiflib_img * i) {
 			act_code = GetGifWord(i, &context);
 			casspecial = (u8)act_code;
 			old_code = act_code;
			if(npix > 0) WritePixel(i, &context, casspecial);
			npix--;
 		} else {
 			read_byt = act_code;
 			if(act_code >= free) {	 
  static int DecodeGifImg(struct ngiflib_img * i) {
 			 
 			casspecial = (u8)act_code;	 
 			*(--stackp) = casspecial;	 
			if(npix >= (stack_top - stackp)) {
				WritePixels(i, &context, stackp, stack_top - stackp);	 
			} else if(npix > 0) {	 
				WritePixels(i, &context, stackp, npix);
			}
 			npix -= (stack_top - stackp);
 			stackp = stack_top;
  ","The DecodeGifImg function in ngiflib.c in MiniUPnP ngiflib 0.4 does not consider the bounds of the pixels data structure, which allows remote attackers to cause a denial of service (WritePixels heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted GIF file, a different vulnerability than CVE-2018-10677."
1639,CVE-2018-10677,"  static int DecodeGifImg(struct ngiflib_img * i) {
 	i->width = GetWord(i->parent);	 
 	i->height = GetWord(i->parent);	 
 
	if((i->width > i->parent->width) || (i->height > i->parent->height)) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
		return -1;
	}
	if((i->posX + i->width) > i->parent->width) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
		i->posX = i->parent->width - i->width;
	}
	if((i->posY + i->height) > i->parent->height) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
		i->posY = i->parent->height - i->height;
	}
 	context.Xtogo = i->width;
 	context.curY = i->posY;
 #ifdef NGIFLIB_INDEXED_ONLY","The DecodeGifImg function in ngiflib.c in MiniUPnP ngiflib 0.4 lacks certain checks against width and height, which allows remote attackers to cause a denial of service (WritePixels heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted GIF file."
1640,CVE-2018-10675,"  static long do_get_mempolicy(int *policy, nodemask_t *nmask,
 		*policy |= (pol->flags & MPOL_MODE_FLAGS);
 	}
 
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {",The do_get_mempolicy function in mm/mempolicy.c in the Linux kernel before 4.12.9 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted system calls.
1641,CVE-2018-10540,"  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
         else {           
 
             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);
            char *buff;

            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",","An issue was discovered in WavPack 5.1.0 and earlier for W64 input. Out-of-bounds writes can occur because ParseWave64HeaderConfig in wave64.c does not validate the sizes of unknown chunks before attempting memory allocation, related to a lack of integer-overflow protection within a bytes_to_copy calculation and subsequent malloc call, leading to insufficient memory allocation."
1642,CVE-2018-10537,"  extern int debug_logging_mode;
 
 int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
    int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0, format_chunk = 0;
     int64_t total_samples = 0, infilesize;
     RiffChunkHeader riff_chunk_header;
     ChunkHeader chunk_header;
  int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
         else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {      
             int supported = TRUE, format;                         
 
            if (format_chunk++) {
                error_line (""%s is not a valid .WAV file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

             if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||
                 !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||
                 bcount != chunk_header.ckSize) {",An issue was discovered in WavPack 5.1.0 and earlier. The W64 parser component contains a vulnerability that allows writing to memory because ParseWave64HeaderConfig in wave64.c does not reject multiple format chunks.
1643,CVE-2018-10529,"  void CLASS identify()
       tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;
   }
 #endif

   memset(gpsdata, 0, sizeof gpsdata);
   memset(cblack, 0, sizeof cblack);
   memset(white, 0, sizeof white);",An issue was discovered in LibRaw 0.18.9. There is an out-of-bounds read affecting the X3F property table list implementation in libraw_x3f.cpp and libraw_cxx.cpp.
1644,CVE-2018-10528,"  const char *LibRaw::strprogress(enum LibRaw_progress p)
 
 void x3f_clear(void *p) { x3f_delete((x3f_t *)p); }
 
void utf2char(utf16_t *str, char *buffer, unsigned bufsz)
 {
 if(bufsz<1) return;
 buffer[bufsz-1] = 0;
   char *b = buffer;
 
  while (*str != 0x00 && --bufsz>0)
   {
     char *chr = (char *)str;
     *b++ = *chr;
     str++;
   }
   *b = 0;
 }
 
 static void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)
  void LibRaw::parse_x3f()
       for (i = 0; i < PL->num_properties; i++)
       {
         char name[100], value[100];
        utf2char(P[i].name, name,sizeof(name));
        utf2char(P[i].value, value,sizeof(value));
         if (!strcmp(name, ""ISO""))
           imgdata.other.iso_speed = atoi(value);
         if (!strcmp(name, ""CAMMANUF""))",An issue was discovered in LibRaw 0.18.9. There is a stack-based buffer overflow in the utf2char function in libraw_cxx.cpp.
1645,CVE-2018-10360," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.143 2018/06/09 16:00:06 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,
 
 				cname = (unsigned char *)
 				    &nbuf[doff + prpsoffsets(i)];
				for (cp = cname; cp < nbuf + size && *cp
				    && isprint(*cp); cp++)
 					continue;
 				/*
 				 * Linux apparently appends a space at the end",The do_core_note function in readelf.c in libmagic.a in file 5.33 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted ELF file.
1646,CVE-2018-10199,"  mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)
   mrb_bool failed = TRUE;
 
   mrb_get_args(mrb, ""o"", &orig);
  fptr_orig = io_get_open_fptr(mrb, orig);
   fptr_copy = (struct mrb_io *)DATA_PTR(copy);
   if (fptr_copy != NULL) {
     fptr_finalize(mrb, fptr_copy, FALSE);
     mrb_free(mrb, fptr_copy);
   }
   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);
 
   DATA_TYPE(copy) = &mrb_io_type;
   DATA_PTR(copy) = fptr_copy;","In versions of mruby up to and including 1.4.0, a use-after-free vulnerability exists in src/io.c::File#initilialize_copy(). An attacker that can cause Ruby code to be run can possibly use this to execute arbitrary code."
1647,CVE-2018-10191,"  mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)
       mrb_value *regs_a = regs + a;
       struct REnv *e = uvenv(mrb, c);
 
      if (e && b < MRB_ENV_STACK_LEN(e)) {
        *regs_a = e->stack[b];
       }
       else {
        *regs_a = mrb_nil_value();
       }
       NEXT;
     }","In versions of mruby up to and including 1.4.0, an integer overflow exists in src/vm.c::mrb_vm_exec() when handling OP_GETUPVAR in the presence of deep scope nesting, resulting in a use-after-free. An attacker that can cause Ruby code to be run can use this to possibly execute arbitrary code."
1648,CVE-2018-10124,"  static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
 		return ret;
 	}
 
	 
	if (pid == INT_MIN)
		return -ESRCH;

 	read_lock(&tasklist_lock);
 	if (pid != -1) {
 		ret = __kill_pgrp_info(sig, info,","The kill_something_info function in kernel/signal.c in the Linux kernel before 4.13, when an unspecified architecture and compiler is used, might allow local users to cause a denial of service via an INT_MIN argument."
1649,CVE-2018-10087,"  long kernel_wait4(pid_t upid, int __user *stat_addr, int options,
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
	 
	if (upid == INT_MIN)
		return -ESRCH;

 	if (upid == -1)
 		type = PIDTYPE_MAX;
 	else if (upid < 0) {","The kernel_wait4 function in kernel/exit.c in the Linux kernel before 4.13, when an unspecified architecture and compiler is used, might allow local users to cause a denial of service by triggering an attempted use of the -INT_MIN value."
1650,CVE-2018-10074,"  static int hi3660_stub_clk_probe(struct platform_device *pdev)
 		return PTR_ERR(stub_clk_chan.mbox);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res)
		return -EINVAL;
 	freq_reg = devm_ioremap(dev, res->start, resource_size(res));
 	if (!freq_reg)
 		return -ENOMEM;",The hi3660_stub_clk_probe function in drivers/clk/hisilicon/clk-hi3660-stub.c in the Linux kernel before 4.16 allows local users to cause a denial of service (NULL pointer dereference) by triggering a failure of resource retrieval.
1651,CVE-2018-10021,"  int sas_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)
 static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)
 {
 	struct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);
	struct domain_device *dev = cmd_to_domain_dev(cmd);
 	struct sas_task *task = TO_SAS_TASK(cmd);
 
 	 
 	sas_end_task(cmd, task);
 
	if (dev_is_sata(dev)) {
		 
		list_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);
		return;
	}

 	 
 	scsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);
 }
 
 static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)
 {
 	struct scsi_cmnd *cmd, *n;
 
 	list_for_each_entry_safe(cmd, n, error_q, eh_entry) {
 		if (cmd->device->sdev_target == my_cmd->device->sdev_target &&
 		    cmd->device->lun == my_cmd->device->lun)
			sas_eh_finish_cmd(cmd);
 	}
 }
 
  static void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *
 		case TASK_IS_DONE:
 			SAS_DPRINTK(""%s: task 0x%p is done\n"", __func__,
 				    task);
			sas_eh_finish_cmd(cmd);
 			continue;
 		case TASK_IS_ABORTED:
 			SAS_DPRINTK(""%s: task 0x%p is aborted\n"",
 				    __func__, task);
			sas_eh_finish_cmd(cmd);
 			continue;
 		case TASK_IS_AT_LU:
 			SAS_DPRINTK(""task 0x%p is at LU: lu recover\n"", task);
  static void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *
 					    ""recovered\n"",
 					    SAS_ADDR(task->dev),
 					    cmd->device->lun);
				sas_eh_finish_cmd(cmd);
 				sas_scsi_clear_queue_lu(work_q, cmd);
 				goto Again;
 			}",** DISPUTED ** drivers/scsi/libsas/sas_scsi_host.c in the Linux kernel before 4.16 allows local users to cause a denial of service (ata qc leak) by triggering certain failure conditions. NOTE: a third party disputes the relevance of this report because the failure can only occur for physically proximate attackers who unplug SAS Host Bus Adapter cables.
1652,CVE-2018-10017,"  std::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMod
 			if(GetType() == MOD_TYPE_IT)
 			{
 				 
				pChn = playState.Chn;
				for(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)
 				{
 					if((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))
 					{",soundlib/Snd_fx.cpp in OpenMPT before 1.27.07.00 and libopenmpt before 0.3.8 allows remote attackers to cause a denial of service (out-of-bounds read) via an IT or MO3 file with many nested pattern loops.
1653,CVE-2018-9989,"  static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
      *
      * opaque psk_identity_hint<0..2^16-1>;
      */
    if( (*p) > end - 2 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                    ""(psk_identity_hint length)"" ) );
        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
    }
     len = (*p)[0] << 8 | (*p)[1];
     *p += 2;
 ","ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_psk_hint() that could cause a crash on invalid input."
1654,CVE-2018-9988,"  static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
          

        if( p > end - 2 )
        {
            MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
        }
         sig_len = ( p[0] << 8 ) | p[1];
         p += 2;
 ","ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input."
1655,CVE-2018-9336,"  static BOOL
 GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
 {
     size_t size, len;
     WCHAR *data = NULL;
     DWORD bytes, read;
 
  GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
     {
         MsgToEventLog(M_SYSERR, TEXT(""PeekNamedPipeAsync failed""));
         ReturnLastError(pipe, L""PeekNamedPipeAsync"");
        goto err;
     }
 
     size = bytes / sizeof(*data);
     if (size == 0)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malformed startup data: 1 byte received""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     data = malloc(bytes);
     if (data == NULL)
     {
         MsgToEventLog(M_SYSERR, TEXT(""malloc failed""));
         ReturnLastError(pipe, L""malloc"");
        goto err;
     }
 
     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);
     if (bytes != read)
     {
         MsgToEventLog(M_SYSERR, TEXT(""ReadPipeAsync failed""));
         ReturnLastError(pipe, L""ReadPipeAsync"");
        goto err;
     }
 
     if (data[size - 1] != 0)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data is not NULL terminated""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     sud->directory = data;
  GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at working directory""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     sud->options = sud->directory + len;
  GetStartupData(HANDLE pipe, STARTUP_DATA *sud)
     {
         MsgToEventLog(M_ERR, TEXT(""Startup data ends at command line options""));
         ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event);
        goto err;
     }
 
     sud->std_input = sud->options + len;
    return TRUE;
 
err:
    sud->directory = NULL;		 
     free(data);
    return FALSE;
 }
 
 ",openvpnserv.exe (aka the interactive service helper) in OpenVPN 2.4.x before 2.4.6 allows a local attacker to cause a double-free of memory by sending a malformed request to the interactive service. This could cause a denial-of-service through memory corruption or possibly have unspecified other impact including privilege escalation.
1656,CVE-2018-9275,"  check_user_token (const char *authfile,
 		{
 		  if(verbose)
 		      D (debug_file, ""Match user/token as %s/%s"", username, otp_id);

		  fclose(opwfile);
 		  return AUTH_FOUND;
 		}
 	    }","In check_user_token in util.c in the Yubico PAM module (aka pam_yubico) 2.18 through 2.25, successful logins can leak file descriptors to the auth mapping file, which can lead to information disclosure (serial number of a device) and/or DoS (reaching the maximum number of file descriptors)."
1657,CVE-2018-8970," 
 
  
  int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,
 {
 	char *copy;
 
	if (name != NULL && namelen == 0)
		namelen = strlen(name);
 	/*
 	 * Refuse names with embedded NUL bytes.
 	 * XXX: Do we need to push an error onto the error stack?","The int_x509_param_set_hosts function in lib/libcrypto/x509/x509_vpm.c in LibreSSL 2.7.0 before 2.7.1 does not support a certain special case of a zero name length, which causes silent omission of hostname verification, and consequently allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate. NOTE: the LibreSSL documentation indicates that this special case is supported, but the BoringSSL documentation does not."
1658,CVE-2018-8828,"  int tmx_check_pretran(sip_msg_t *msg)
 	if(likely(vbr!=NULL)) {
 		svbranch = vbr->value;
 		trim(&svbranch);
		dsize += svbranch.len + 1;
 	}
 	if(dsize<256) dsize = 256;
 ","A Buffer Overflow issue was discovered in Kamailio before 4.4.7, 5.0.x before 5.0.6, and 5.1.x before 5.1.2. A specially crafted REGISTER message with a malformed branch or From tag triggers an off-by-one heap-based buffer overflow in the tmx_check_pretran function in modules/tmx/tmx_pretran.c."
1659,CVE-2018-8789,"  static const char* const NTLM_NEGOTIATE_STRINGS[] =
 	""NTLMSSP_NEGOTIATE_UNICODE""
 };
 
static void ntlm_print_negotiate_flags(UINT32 flags)
 {
 	int i;
 	const char* str;
  void ntlm_print_negotiate_flags(UINT32 flags)
 	}
 }
 
static int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
 {
 	if (Stream_GetRemainingLength(s) < 12)
 		return -1;
  int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
 	return 1;
 }
 
static void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)
 {
 	Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));
 	Stream_Write_UINT32(s, header->MessageType);
 }
 
static void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)
 {
 	CopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));
 	header->MessageType = MessageType;
 }
 
static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 {
 	if (Stream_GetRemainingLength(s) < 8)
 		return -1;
  int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 	return 1;
 }
 
static void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 {
 	if (fields->MaxLen < 1)
 		fields->MaxLen = fields->Len;
  void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 	Stream_Write_UINT32(s, fields->BufferOffset);  
 }
 
static int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 {
 	if (fields->Len > 0)
 	{
		const UINT64 offset = (UINT64)fields->BufferOffset + (UINT64)fields->Len;

		if (offset > Stream_Length(s))
 			return -1;
 
 		fields->Buffer = (PBYTE) malloc(fields->Len);
  int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 	return 1;
 }
 
static void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 {
 	if (fields->Len > 0)
 	{
  void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)
 	}
 }
 
static void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)
 {
 	if (fields)
 	{
  void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)
 	}
 }
 
static void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)
 {
 	WLog_DBG(TAG, ""%s (Len: %""PRIu16"" MaxLen: %""PRIu16"" BufferOffset: %""PRIu32"")"",
 	         name, fields->Len, fields->MaxLen, fields->BufferOffset);",FreeRDP prior to version 2.0.0-rc4 contains several Out-Of-Bounds Reads in the NTLM Authentication module that results in a Denial of Service (segfault).
1660,CVE-2018-8788,"  struct _NSC_CONTEXT
 	 
 	const BYTE* palette;
 
	BOOL (*decode)(NSC_CONTEXT* context);
	BOOL (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,
 	               UINT32 rowstride);
 
 	NSC_CONTEXT_PRIV* priv;",FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
1661,CVE-2018-8787,"  static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,
 {
 	UINT32 SrcSize = length;
 	rdpGdi* gdi = context->gdi;
	UINT32 size = DstWidth * DstHeight;
 	bitmap->compressed = FALSE;
 	bitmap->format = gdi->dstFormat;

	if ((GetBytesPerPixel(bitmap->format) == 0) ||
	    (DstWidth == 0) || (DstHeight == 0) || (DstWidth > UINT32_MAX / DstHeight) ||
	    (size > (UINT32_MAX / GetBytesPerPixel(bitmap->format))))
		return FALSE;

	size *= GetBytesPerPixel(bitmap->format);
	bitmap->length = size;
 	bitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);
 
 	if (!bitmap->data)",FreeRDP prior to version 2.0.0-rc4 contains an Integer Overflow that leads to a Heap-Based Buffer Overflow in function gdi_Bitmap_Decompress() and results in a memory corruption and probably even a remote code execution.
1662,CVE-2018-8786,"  BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)
 
 	if (bitmapUpdate->number > bitmapUpdate->count)
 	{
		UINT32 count = bitmapUpdate->number * 2;
		BITMAP_DATA* newdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,
		                       sizeof(BITMAP_DATA) * count);
 
 		if (!newdata)
 			goto fail;",FreeRDP prior to version 2.0.0-rc4 contains an Integer Truncation that leads to a Heap-Based Buffer Overflow in function update_read_bitmap_update() and results in a memory corruption and probably even a remote code execution.
1663,CVE-2018-8785," 
 
 #define ZGFX_SEGMENTED_MAXSIZE			65535
 
 typedef struct _ZGFX_CONTEXT ZGFX_CONTEXT;
 
 #ifdef __cplusplus
 extern ""C"" {
 #endif
 
FREERDP_API int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize,
                                BYTE** ppDstData, UINT32* pDstSize, UINT32 flags);
FREERDP_API int zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize,
                              BYTE** ppDstData, UINT32* pDstSize, UINT32* pFlags);
FREERDP_API int zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst,
                                        const BYTE* pUncompressed, UINT32 uncompressedSize, UINT32* pFlags);
 
 FREERDP_API void zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush);
 
  FREERDP_API void zgfx_context_free(ZGFX_CONTEXT* zgfx);
 #endif
 
 #endif  
",FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress() that results in a memory corruption and probably even a remote code execution.
1664,CVE-2018-8784,"  static INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)
 	_zgfx->cBitsCurrent -= _nbits;
 	_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;
 	_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);
	return TRUE;
 }
 
 static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)
  static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t
 	UINT32 count;
 	UINT32 distance;
 	BYTE* pbSegment;
	size_t cbSegment;
 
	if (!zgfx || !stream)
		return FALSE;

	cbSegment = segmentSize - 1;

	if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||
	    (segmentSize > UINT32_MAX))
 		return FALSE;
 
 	Stream_Read_UINT8(stream, flags);  
  static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t
 	if (!(flags & PACKET_COMPRESSED))
 	{
 		zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);

		if (cbSegment > sizeof(zgfx->OutputBuffer))
			return FALSE;

 		CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);
 		zgfx->OutputCount = cbSegment;
 		return TRUE;
  static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t
 					if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)
 						zgfx->HistoryIndex = 0;
 
					if (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))
						return FALSE;

 					zgfx->OutputBuffer[zgfx->OutputCount++] = c;
 				}
 				else
  static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t
 							count += zgfx->bits;
 						}
 
						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
							return FALSE;

 						zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
 						zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);
 						zgfx->OutputCount += count;
  static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t
 						zgfx->cBitsRemaining -= zgfx->cBitsCurrent;
 						zgfx->cBitsCurrent = 0;
 						zgfx->BitsCurrent = 0;

						if (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)
							return FALSE;

 						CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);
 						zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);
 						zgfx->pbInputCurrent += count;",FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress_segment() that results in a memory corruption and probably even a remote code execution.
1665,CVE-2018-8099,"  static size_t index_entry_size(size_t path_len, size_t varint_len, uint32_t flag
 	}
 }
 
static int read_entry(
 	git_index_entry **out,
	size_t *out_size,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
  static size_t read_entry(
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
		return -1;
 
 	 
 	memcpy(&source, buffer, sizeof(struct entry_short));
  static size_t read_entry(
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
				return -1;
 
 			path_length = path_end - path_ptr;
 		}
  static size_t read_entry(
 		entry.path = tmp_path;
 	}
 
	if (entry_size == 0)
		return -1;

 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
		return -1;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
		return -1;
 	}
 
 	git__free(tmp_path);
	*out_size = entry_size;
	return 0;
 }
 
 static int read_header(struct index_header *dest, const void *buffer)
  static int parse_index(git_index *index, const char *buffer, size_t buffer_size)
 	 
 	for (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {
 		git_index_entry *entry = NULL;
		size_t entry_size;
 
		if ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {
 			error = index_error_invalid(""invalid entry"");
 			goto done;
 		}","Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file."
1666,CVE-2018-8098,"  static int read_entry(
 		entry_size = index_entry_size(path_length, 0, entry.flags);
 		entry.path = (char *)path_ptr;
 	} else {
		size_t varint_len, last_len, prefix_len, suffix_len, path_len;
		uintmax_t strip_len;

		strip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);
		last_len = strlen(last);

		if (varint_len == 0 || last_len < strip_len)
 			return index_error_invalid(""incorrect prefix length"");
 
		prefix_len = last_len - strip_len;
		suffix_len = strlen(path_ptr + varint_len);

 		GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);
 		GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);
 		tmp_path = git__malloc(path_len);",Integer overflow in the index.c:read_entry() function while decompressing a compressed prefix length in libgit2 before v0.26.2 allows an attacker to cause a denial of service (out-of-bounds read) via a crafted repository index file.
1667,CVE-2018-8087,"  static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)
 	if (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {
 		u32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);
 
		if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {
			kfree(hwname);
 			return -EINVAL;
		}
 		param.regd = hwsim_world_regdom_custom[idx];
 	}
 ",Memory leak in the hwsim_new_radio_nl function in drivers/net/wireless/mac80211_hwsim.c in the Linux kernel through 4.15.9 allows local users to cause a denial of service (memory consumption) by triggering an out-of-array error case.
1668,CVE-2018-8050,"  int af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes)
 	    return -3;			 
 	}
 
	 
	if(af->image_pagesize <= 0 || af->image_pagesize > 16*1024*1024)
	    return -1;


 	 ",The af_get_page() function in lib/afflib_pages.cpp in AFFLIB (aka AFFLIBv3) through 3.7.16 allows remote attackers to cause a denial of service (segmentation fault) via a corrupt AFF image that triggers an unexpected pagesize value.
1669,CVE-2018-8043,"  static int unimac_mdio_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!r)
		return -EINVAL;
 
 	/* Just ioremap, as this MDIO block is usually integrated into an
 	 * Ethernet MAC controller register range","The unimac_mdio_probe function in drivers/net/phy/mdio-bcm-unimac.c in the Linux kernel through 4.15.8 does not validate certain resource availability, which allows local users to cause a denial of service (NULL pointer dereference)."
1670,CVE-2018-7999,"  GR2_API void gr_engine_version(int *nMajor, int *nMinor, int *nBugFix);
 enum gr_face_options {
      
     gr_face_default = 0,
     
     gr_face_dumbRendering = 1,
      
     gr_face_preloadGlyphs = 2,","In libgraphite2 in graphite2 1.3.11, a NULL pointer dereference vulnerability was found in Segment.cpp during a dumbRendering operation, which may allow attackers to cause a denial of service or possibly have unspecified other impact via a crafted .ttf file."
1671,CVE-2018-7757,"  int sas_smp_get_phy_events(struct sas_phy *phy)
 	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 
  out:
	kfree(req);
 	kfree(resp);
 	return res;
 ","Memory leak in the sas_smp_get_phy_events function in drivers/scsi/libsas/sas_expander.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (memory consumption) via many read accesses to files in the /sys/class/sas_phy directory, as demonstrated by the /sys/class/sas_phy/phy-1:0:12/invalid_dword_count file."
1672,CVE-2018-7752,"  void gf_fm_request_call(u32 type, u32 param, int *value);
 
  
 
#define ARRAY_LENGTH(a) (sizeof(a) / sizeof((a)[0]))
 
 #ifdef __cplusplus
 }","GPAC through 0.7.1 has a Buffer Overflow in the gf_media_avc_read_sps function in media_tools/av_parsers.c, a different vulnerability than CVE-2018-1000100."
1673,CVE-2018-7648,"  int main(int argc, char *argv[])
         fread(frame_codestream, sample->sample_size - 8, 1,
               file);  
 
        int num = snprintf(outfilename, sizeof(outfilename), ""%s_%05d.j2k"", argv[2], snum);
        if (num >= sizeof(outfilename)) {
            fprintf(stderr, ""maximum length of output prefix exceeded\n"");
            return 1;
        }

         outfile = fopen(outfilename, ""wb"");
         if (!outfile) {
             fprintf(stderr, ""failed to open %s for writing\n"", outfilename);","An issue was discovered in mj2/opj_mj2_extract.c in OpenJPEG 2.3.0. The output prefix was not checked for length, which could overflow a buffer, when providing a prefix with 50 or more characters on the command line."
1674,CVE-2018-7584,"  php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper,
 								tmp_line, response_code);
 				}
 			}
			if (tmp_line_len >= 1 && tmp_line[tmp_line_len - 1] == '\n') {
 				--tmp_line_len;
				if (tmp_line_len >= 1 &&tmp_line[tmp_line_len - 1] == '\r') {
 					--tmp_line_len;
 				}
 			}","In PHP through 5.6.33, 7.0.x before 7.0.28, 7.1.x through 7.1.14, and 7.2.x through 7.2.2, there is a stack-based buffer under-read while parsing an HTTP response in the php_stream_url_wrap_http_ex function in ext/standard/http_fopen_wrapper.c. This subsequently results in copying a large string."
1675,CVE-2018-7492,"  static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,
 	long i;
 	int ret;
 
	if (rs->rs_bound_addr == 0 || !rs->rs_transport) {
 		ret = -ENOTCONN;  
 		goto out;
 	}","A NULL pointer dereference was found in the net/rds/rdma.c __rds_rdma_map() function in the Linux kernel before 4.14.7 allowing local attackers to cause a system panic and a denial-of-service, related to RDS_GET_MR and RDS_GET_MR_FOR_DEST."
1676,CVE-2018-7480,"  int blkcg_init_queue(struct request_queue *q)
 	if (preloaded)
 		radix_tree_preload_end();
 
	if (IS_ERR(blkg))
 		return PTR_ERR(blkg);
 
 	q->root_blkg = blkg;
 	q->root_rl.blkg = blkg;",The blkcg_init_queue function in block/blk-cgroup.c in the Linux kernel before 4.11 allows local users to cause a denial of service (double free) or possibly have unspecified other impact by triggering a creation failure.
1677,CVE-2018-7254,"  typedef struct
 
 #define CAFChannelDescriptionFormat ""LLLLL""
 
static const char TMH_full [] = { 1,2,3,13,9,10,5,6,12,14,15,16,17,9,4,18,7,8,19,20,21,0 };
static const char TMH_std [] = { 1,2,3,11,8,9,5,6,10,12,13,14,15,7,4,16,0 };
 
 static struct {
     uint32_t mChannelLayoutTag;      
  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
             }
         }
         else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;
 
            if (caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout) || caf_chunk_header.mChunkSize > 1024) {
                error_line (""this .CAF file has an invalid 'chan' chunk!"");
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                 bcount != caf_chunk_header.mChunkSize) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     free (caf_channel_layout);
  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
         }
         else {           
 
            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);
 
             if (debug_logging_mode)
                 error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",","The ParseCaffHeaderConfig function of the cli/caff.c file of WavPack 5.1.0 allows a remote attacker to cause a denial-of-service (global buffer over-read), or possibly trigger a buffer overflow or incorrect memory allocation, via a maliciously crafted CAF file."
1678,CVE-2018-7253,"  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
                 error_line (""dsdiff file version = 0x%08x"", version);
         }
         else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) {
            char *prop_chunk;

            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize);

            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);
 
             if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||
                 bcount != dff_chunk_header.ckDataSize) {",The ParseDsdiffHeaderConfig function of the cli/dsdiff.c file of WavPack 5.1.0 allows a remote attacker to cause a denial-of-service (heap-based buffer over-read) or possibly overwrite the heap via a maliciously crafted DSDIFF file.
1679,CVE-2018-7247,"  SARRAY    *safiles, *sathumbs, *saviews, *sahtml, *salink;
         return ERROR_INT(""safiles not made"", procName, 1);
 
          
    snprintf(charbuf, sizeof(charbuf), ""%s/%s.html"", dirout, rootname);
     mainname = stringNew(charbuf);
    snprintf(charbuf, sizeof(charbuf), ""%s/%s-links.html"", dirout, rootname);
     linkname = stringNew(charbuf);
     linknameshort = stringJoin(rootname, ""-links.html"");
 
  SARRAY    *safiles, *sathumbs, *saviews, *sahtml, *salink;
         pixGetDimensions(pix, &w, NULL, &d);
         factor = (l_float32)thumbwidth / (l_float32)w;
         pixthumb = pixScale(pix, factor, factor);
        snprintf(charbuf, sizeof(charbuf), ""%s_thumb_%03d"", rootname, index);
         sarrayAddString(sathumbs, charbuf, L_COPY);
         outname = genPathname(dirout, charbuf);
         WriteFormattedPix(outname, pixthumb);","An issue was discovered in pixHtmlViewer in prog/htmlviewer.c in Leptonica before 1.75.3. Unsanitized input (rootname) can overflow a buffer, leading potentially to arbitrary code execution or possibly unspecified other impact."
1680,CVE-2018-6927,"  static int futex_requeue(u32 __user *uaddr1, unsigned int flags,
 	struct futex_q *this, *next;
 	DEFINE_WAKE_Q(wake_q);
 
	if (nr_wake < 0 || nr_requeue < 0)
		return -EINVAL;

 	/*
 	 * When PI not supported: return -ENOSYS if requeue_pi is true,
 	 * consequently the compiler knows requeue_pi is always false past",The futex_requeue function in kernel/futex.c in the Linux kernel before 4.14.15 might allow attackers to cause a denial of service (integer overflow) or possibly have unspecified other impact by triggering a negative wake or requeue value.
1681,CVE-2018-6794,"  static void DetectFlow(ThreadVars *tv,
                        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,
                        Packet *p)
 {
    if (p->flags & PKT_NOPACKET_INSPECTION) {
          
  static void DetectFlow(ThreadVars *tv,
             flags = FlowGetDisruptionFlags(p->flow, flags);
             DeStateUpdateInspectTransactionId(p->flow, flags, true);
         }
        SCLogDebug(""p->pcap %""PRIu64"": no detection on packet, ""
                ""PKT_NOPACKET_INSPECTION is set"", p->pcap_cnt);
         return;
     }
 ","Suricata before 4.0.4 is prone to an HTTP detection bypass vulnerability in detect.c and stream-tcp.c. If a malicious server breaks a normal TCP flow and sends data before the 3-way handshake is complete, then the data sent by the malicious server will be accepted by web clients such as a web browser or Linux CLI utilities, but ignored by Suricata IDS signatures. This mostly affects IDS signatures for the HTTP protocol and TCP stream content; signatures for TCP packets will inspect such network traffic as usual."
1682,CVE-2018-6767,"  typedef struct {
 
 #pragma pack(pop)
 
#define CS64ChunkFormat ""4D""
 #define DS64ChunkFormat ""DDDL""
 
 #define WAVPACK_NO_ERROR    0
  int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
 
         if (!strncmp (chunk_header.ckID, ""ds64"", 4)) {
             if (chunk_header.ckSize < sizeof (DS64Chunk) ||
                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||
                bcount != sizeof (DS64Chunk)) {
                     error_line (""%s is not a valid .WAV file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     return WAVPACK_SOFT_ERROR;
             }
  int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
 
 int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)
 {
    int do_rf64 = 0, write_junk = 1, table_length = 0;
     ChunkHeader ds64hdr, datahdr, fmthdr;
     RiffChunkHeader riffhdr;
     DS64Chunk ds64_chunk;
    CS64Chunk cs64_chunk;
     JunkChunk junkchunk;
     WaveHeader wavhdr;
     uint32_t bcount;
  int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,
     strncpy (riffhdr.formType, ""WAVE"", sizeof (riffhdr.formType));
     total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);
     if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);
    total_riff_bytes += table_length * sizeof (CS64Chunk);
     if (write_junk) total_riff_bytes += sizeof (junkchunk);
     strncpy (fmthdr.ckID, ""fmt "", sizeof (fmthdr.ckID));
     strncpy (datahdr.ckID, ""data"", sizeof (datahdr.ckID));
  int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,
 
     if (do_rf64) {
         strncpy (ds64hdr.ckID, ""ds64"", sizeof (ds64hdr.ckID));
        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));
         CLEAR (ds64_chunk);
         ds64_chunk.riffSize64 = total_riff_bytes;
         ds64_chunk.dataSize64 = total_data_bytes;
         ds64_chunk.sampleCount64 = total_samples;
        ds64_chunk.tableLength = table_length;
         riffhdr.ckSize = (uint32_t) -1;
         datahdr.ckSize = (uint32_t) -1;
         WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);
  int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,
         datahdr.ckSize = (uint32_t) total_data_bytes;
     }
 
     

    if (table_length) {
        strncpy (cs64_chunk.ckID, ""dmmy"", sizeof (cs64_chunk.ckID));
        cs64_chunk.chunkSize64 = 12345678;
        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);
    }

      
 
     WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);
  int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,
 
     if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||
         (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||
        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {
            error_line (""can't write .WAV data, disk probably full!"");
            return FALSE;
    }

     

    while (table_length--)
        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {
            error_line (""can't write .WAV data, disk probably full!"");
            return FALSE;
        }


    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||
         !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||
         !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||
         !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {",A stack-based buffer over-read in the ParseRiffHeaderConfig function of cli/riff.c file of WavPack 5.1.0 allows a remote attacker to cause a denial-of-service attack or possibly have unspecified other impact via a maliciously crafted RF64 file.
1683,CVE-2018-6758,"  void uwsgi_write_pidfile_explicit(char *pidfile_name, pid_t pid) {
 }
 
 char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {
	if (dir_len > PATH_MAX)
	{
		uwsgi_log(""invalid path size: %d (max %d)\n"", dir_len, PATH_MAX);
		return NULL;
	}
	char *src = uwsgi_concat2n(dir, dir_len, """", 0);
 	char *dst = ptr;
 	if (!dst)
 		dst = uwsgi_malloc(PATH_MAX + 1);
 	if (!realpath(src, dst)) {
 		uwsgi_error_realpath(src);
 		if (!ptr)
 			free(dst);
		free(src);
 		return NULL;
 	}
	free(src);
 	return dst;
 }
 ",The uwsgi_expand_path function in core/utils.c in Unbit uWSGI through 2.0.15 has a stack-based buffer overflow via a large directory length.
1684,CVE-2018-6651,"  UNCURL_EXPORT int32_t uncurl_ws_accept(struct uncurl_conn *ucc, char **origins,
 	e = uncurl_get_header_str(ucc, ""Origin"", &origin);
 	if (e != UNCURL_OK) return e;
 
	 
 	bool origin_ok = false;
	for (int32_t x = 0; x < n_origins; x++) {
		char *match = strstr(origin, origins[x]);
		if (match && !strcmp(match, origins[x])) {origin_ok = true; break;}
	}
 
 	if (!origin_ok) return UNCURL_WS_ERR_ORIGIN;
 ","In the uncurl_ws_accept function in uncurl.c in uncurl before 0.07, as used in Parsec before 140-3, insufficient Origin header validation (accepting an arbitrary substring match) for WebSocket API requests allows remote attackers to bypass intended access restrictions. In Parsec, this means full control over the victim's computer."
1685,CVE-2018-6560," 
 
 typedef struct FlatpakProxyClient FlatpakProxyClient;
 
#define FIND_AUTH_END_CONTINUE -1
#define FIND_AUTH_END_ABORT -2

#define AUTH_LINE_SENTINEL ""\r\n""
#define AUTH_BEGIN ""BEGIN""
 
 typedef enum {
   EXPECTED_REPLY_NONE,
  struct FlatpakProxyClient
   FlatpakProxy *proxy;
 
   gboolean      authenticated;
  GByteArray   *auth_buffer;
 
   ProxySide     client_side;
   ProxySide     bus_side;
  flatpak_proxy_client_finalize (GObject *object)
   client->proxy->clients = g_list_remove (client->proxy->clients, client);
   g_clear_object (&client->proxy);
 
  g_byte_array_free (client->auth_buffer, TRUE);
   g_hash_table_destroy (client->rewrite_reply);
   g_hash_table_destroy (client->get_owner_reply);
   g_hash_table_destroy (client->unique_id_policy);
  flatpak_proxy_client_init (FlatpakProxyClient *client)
   init_side (client, &client->client_side);
   init_side (client, &client->bus_side);
 
  client->auth_buffer = g_byte_array_new ();
   client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
   client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);
   client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  got_buffer_from_side (ProxySide *side, Buffer *buffer)
     got_buffer_from_bus (client, side, buffer);
 }
 
#define _DBUS_ISASCII(c) ((c) != '\0' && (((c) & ~0x7f) == 0))

static gboolean
auth_line_is_valid (guint8 *line, guint8 *line_end)
{
  guint8 *p;

  for (p = line; p < line_end; p++)
    {
      if (!_DBUS_ISASCII(*p))
        return FALSE;

       
      if (*p < ' ')
        return FALSE;
    }

   
  if (line[0] < 'A' || line[0] > 'Z')
    return FALSE;

  return TRUE;
}

static gboolean
auth_line_is_begin (guint8 *line)
{
  guint8 next_char;

  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))
    return FALSE;

   
  next_char = line[strlen (AUTH_BEGIN)];
  return (next_char == 0 ||
          next_char == ' ' ||
          next_char == '\t');
}

 static gssize
 find_auth_end (FlatpakProxyClient *client, Buffer *buffer)
 {
  goffset offset = 0;
  gsize original_size = client->auth_buffer->len;

   
  g_byte_array_append (client->auth_buffer, buffer->data, buffer->pos);
 
  while (TRUE)
     {
      guint8 *line_start = client->auth_buffer->data + offset;
      gsize remaining_data = client->auth_buffer->len - offset;
      guint8 *line_end;

      line_end = memmem (line_start, remaining_data,
                         AUTH_LINE_SENTINEL, strlen (AUTH_LINE_SENTINEL));
      if (line_end)  
         {
          offset = (line_end + strlen (AUTH_LINE_SENTINEL) - line_start);
 
          if (!auth_line_is_valid (line_start, line_end))
            return FIND_AUTH_END_ABORT;
 
          *line_end = 0;
          if (auth_line_is_begin (line_start))
            return offset - original_size;
 
           
        }
      else
        {
           
          g_byte_array_remove_range (client->auth_buffer, 0, offset);
 
           
          if (client->auth_buffer->len >= 16*1024)
            return FIND_AUTH_END_ABORT;
 
          return FIND_AUTH_END_CONTINUE;
         }
     }
 }
 
 static gboolean
  side_in_cb (GSocket *socket, GIOCondition condition, gpointer user_data)
                       if (extra_data > 0)
                         side->extra_input_data = g_bytes_new (buffer->data + buffer->size, extra_data);
                     }
                  else if (auth_end == FIND_AUTH_END_ABORT)
                    {
                      buffer_unref (buffer);
                      if (client->proxy->log_messages)
                        g_print (""Invalid AUTH line, aborting\n"");
                      side_closed (side);
                      break;
                    }
                 }
 
               got_buffer_from_side (side, buffer);","In dbus-proxy/flatpak-proxy.c in Flatpak before 0.8.9, and 0.9.x and 0.10.x before 0.10.3, crafted D-Bus messages to the host can be used to break out of the sandbox, because whitespace handling in the proxy is not identical to whitespace handling in the daemon."
1686,CVE-2018-6412,"  int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
 		unsigned char __user *ured;
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
		unsigned int index, count, i;
 
 		if (get_user(index, &c->index) ||
 		    __get_user(count, &c->count) ||
  int sbusfb_ioctl_helper(unsigned long cmd, unsigned long arg,
 		unsigned char __user *ugreen;
 		unsigned char __user *ublue;
 		struct fb_cmap *cmap = &info->cmap;
		unsigned int index, count, i;
 		u8 red, green, blue;
 
 		if (get_user(index, &c->index) ||","In the function sbusfb_ioctl_helper() in drivers/video/fbdev/sbuslib.c in the Linux kernel through 4.15, an integer signedness error allows arbitrary information leakage for the FBIOPUTCMAP_SPARC and FBIOGETCMAP_SPARC commands."
1687,CVE-2018-6347,"  ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {
     VLOG(4) << ""Parsing downstream trailers streamId="" << streamId;
   }
 
  if (sessionClosing_ != ClosingState::CLOSED && streamId > lastStreamID_) {
     lastStreamID_ = streamId;
   }
 
  size_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue&  ,
 size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,
                                     StreamID stream,
                                     const HTTPHeaders& trailers) {
  VLOG(4) << ""generating TRAILERS for stream="" << stream;
   std::vector<compress::Header> allHeaders;
   CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);
 ",An issue in the Proxygen handling of HTTP2 parsing of headers/trailers can lead to a denial-of-service attack. This affects Proxygen prior to v2018.12.31.00.
1688,CVE-2018-6346,"  folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(
     isReq = transportDirection_ == TransportDirection::DOWNSTREAM;
   }
 
   
  if (priority && (curHeader_.stream == priority->streamDependency)) {
    streamError(
        folly::to<string>(""Circular dependency for txn="", curHeader_.stream),
        ErrorCode::PROTOCOL_ERROR,
        curHeader_.type == http2::FrameType::HEADERS);
    return ErrorCode::NO_ERROR;
  }

   decodeInfo_.init(isReq, parsingDownstreamTrailers_);
   if (priority) {
     decodeInfo_.msg->setHTTP2Priority(
         std::make_tuple(priority->streamDependency,
                         priority->exclusive,
                         priority->weight));
   }

   headerCodec_.decodeStreaming(
       headerCursor, curHeaderBlock_.chainLength(), this);
   msg = std::move(decodeInfo_.msg);",A potential denial-of-service issue in the Proxygen handling of invalid HTTP2 priority settings (specifically a circular dependency). This affects Proxygen prior to v2018.12.31.00.
1689,CVE-2018-6343,"  void HTTPSession::onCertificateRequest(uint16_t requestId,
   DestructorGuard dg(this);
   VLOG(4) << ""CERTIFICATE_REQUEST on"" << *this << "", requestId="" << requestId;
 
  if (!secondAuthManager_) {
    return;
  }

   std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;
   auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
   if (fizzBase) {
  void HTTPSession::onCertificate(uint16_t certId,
   DestructorGuard dg(this);
   VLOG(4) << ""CERTIFICATE on"" << *this << "", certId="" << certId;
 
  if (!secondAuthManager_) {
    return;
  }

   bool isValid = false;
   auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
   if (fizzBase) {",Proxygen fails to validate that a secondary auth manager is set before dereferencing it. That can cause a denial of service issue when parsing a Certificate/CertificateRequest HTTP2 Frame over a fizz (TLS 1.3) transport. This issue affects Proxygen releases starting from v2018.10.29.00 until the fix in v2018.11.19.00.
1690,CVE-2018-6340,"  static Array HHVM_METHOD(Memcache, getextendedstats,
 
   for (int server_id = 0; server_id < server_count; server_id++) {
     memcached_stat_st *stat;
     LMCD_SERVER_POSITION_INSTANCE_TYPE instance =
       memcached_server_instance_by_position(&data->m_memcache, server_id);
     const char *hostname = LMCD_SERVER_HOSTNAME(instance);
  static Array HHVM_METHOD(Memcache, getextendedstats,
       continue;
     }
 
    auto const port_str = folly::to<std::string>(port);
    auto const key_len = strlen(hostname) + 1 + port_str.length();
    auto key = String(key_len, ReserveString);
    key += hostname;
    key += "":"";
    key += port_str;
    return_val.set(key, server_stats);
   }
 
   free(stats);",The Memcache::getextendedstats function can be used to trigger an out-of-bounds read. Exploiting this issue requires control over memcached server hostnames and/or ports. This affects all supported versions of HHVM (3.30 and 3.27.4 and below).
1691,CVE-2018-6337,"  void readRandomDevice(void* data, size_t size) {
 
 class BufferedRandomDevice {
  public:
  static once_flag flag;
   static constexpr size_t kDefaultBufferSize = 128;
 
   explicit BufferedRandomDevice(size_t bufferSize = kDefaultBufferSize);
  class BufferedRandomDevice {
   unsigned char* ptr_;
 };
 
once_flag BufferedRandomDevice::flag;
struct RandomTag {};

 BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)
   : bufferSize_(bufferSize),
     buffer_(new unsigned char[bufferSize]),
     ptr_(buffer_.get() + bufferSize) {   
  call_once(flag, [this]() {
    detail::AtFork::registerHandler(
        this,
          []() { return true; },
          []() {},
         
        []() {
          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;
          auto& t = Single::get();
           
           
           
          t.ptr_ = t.buffer_.get() + t.bufferSize_;
        });
  });
 }
 
 void BufferedRandomDevice::getSlow(unsigned char* data, size_t size) {
  void BufferedRandomDevice::getSlow(unsigned char* data, size_t size) {
   ptr_ += size;
 }
 
 }  
 
 void Random::secureRandom(void* data, size_t size) {",folly::secureRandom will re-use a buffer between parent and child processes when fork() is called. That will result in multiple forked children producing repeat (or similar) results. This affects HHVM 3.26 prior to 3.26.3 and the folly library between v2017.12.11.00 and v2018.08.09.00.
1692,CVE-2018-6334," 
 */
 
 #include ""hphp/runtime/server/upload.h""

 #include ""hphp/runtime/base/program-functions.h""
#include ""hphp/runtime/base/request-event-handler.h""
 #include ""hphp/runtime/base/request-local.h""
#include ""hphp/runtime/base/runtime-option.h""
#include ""hphp/runtime/base/string-util.h""
 #include ""hphp/runtime/base/zend-printf.h""
 #include ""hphp/runtime/ext/apc/ext_apc.h""

 #include ""hphp/util/logger.h""
 #include ""hphp/util/text-util.h""

 #include <folly/FileUtil.h>
 
 using std::set;
  void rfc1867PostHandler(Transport* transport,
   std::string array_index, abuf;
   char *lbuf=nullptr;
   int total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0;
  int max_file_size=0, skip_upload=0, anonindex=0;
   std::set<std::string> &uploaded_files = s_rfc1867_data->rfc1867UploadedFiles;
   multipart_buffer *mbuff;
   int fd=-1;
  void rfc1867PostHandler(Transport* transport,
       }
 
       if (!param) {
         param = (char*)malloc(MAX_SIZE_ANONNAME);
         snprintf(param, MAX_SIZE_ANONNAME, ""%u"", anonindex++);
       }
 
        
  void rfc1867PostHandler(Transport* transport,
         s = tmp;
       }
 
        
       if (is_arr_upload) {
         snprintf(lbuf, llen, ""%s[name][%s]"",
  void rfc1867PostHandler(Transport* transport,
         }
       }
 
        
       if (is_arr_upload) {
         snprintf(lbuf, llen, ""%s[type][%s]"",
  void rfc1867PostHandler(Transport* transport,
 
       Variant tempFileName(temp_filename);
 
        
       if (is_arr_upload) {
         snprintf(lbuf, llen, ""%s[tmp_name][%s]"",
  void rfc1867PostHandler(Transport* transport,
       }
       safe_php_register_variable(lbuf, error_type, files, 0);
 
        
       if (is_arr_upload) {
         snprintf(lbuf, llen, ""%s[size][%s]"",","Multipart-file uploads call variables to be improperly registered in the global scope. In cases where variables are not declared explicitly before being used this can lead to unexpected behavior. This affects all supported versions of HHVM prior to the patch (3.25.1, 3.24.5, and 3.21.9 and below)."
1693,CVE-2018-6197,"  formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
 	rows = form->rows ? form->rows : 1;
 	col = COLPOS(l, a->start.pos);
 	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
	    if (l == NULL)
		break;
 	    if (rows > 1) {
 		pos = columnPos(l, col);
 		a = retrieveAnchor(buf->formitem, l->linenumber, pos);",w3m through 0.5.3 is prone to a NULL pointer dereference flaw in formUpdateBuffer in form.c.
1694,CVE-2018-6196,"  feed_table_block_tag(struct table *tbl,
 	if (mode->indent_level < MAX_INDENT_LEVEL)
 	    tbl->indent -= INDENT_INCR;
     }
    if (tbl->indent < 0)
	tbl->indent = 0;
     offset = tbl->indent;
     if (cmd == HTML_DT) {
 	if (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)
 	    offset -= INDENT_INCR;
	if (offset < 0)
	    offset = 0;
     }
     if (tbl->indent > 0) {
 	check_minimum0(tbl, 0);",w3m through 0.5.3 is prone to an infinite recursion flaw in HTMLlineproc0 because the feed_table_block_tag function in table.c does not prevent a negative indent value.
1695,CVE-2018-5873,"  static void *__ns_get_path(struct path *path, struct ns_common *ns)
 		return ERR_PTR(-ENOMEM);
 	}
 	d_instantiate(dentry, inode);
	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_fsdata = (void *)ns->ops;
 	d = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);
 	if (d) {","An issue was discovered in the __ns_get_path function in fs/nsfs.c in the Linux kernel before 4.11. Due to a race condition when accessing files, a Use After Free condition can occur. This also affects all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05."
1696,CVE-2018-5816,"  void CLASS identify()
 #endif
 	switch (tiff_bps = i*8 / (width * height)) {
 	case  8: load_raw = &CLASS eight_bit_load_raw;  break;
	case 10: load_raw = &CLASS nokia_load_raw; break;
#ifdef LIBRAW_LIBRARY_BUILD
        case 0:  throw LIBRAW_EXCEPTION_IO_CORRUPT; break;
#endif
 	}
 	raw_height = height + (top_margin = i / (width * tiff_bps/8) - height);
 	mask[0][3] = 1;",An integer overflow error within the *identify()* function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.12 can be exploited to trigger a division by zero via specially crafted NOKIARAW file (Note: This vulnerability is caused due to an incomplete fix of CVE-2018-5804).
1697,CVE-2018-5815,"  void CLASS parse_qt (int end)
   while (ftell(ifp)+7 < end) {
     save = ftell(ifp);
     if ((size = get4()) < 8) return;
    if ((int)size < 0) return;  
    if (save + size < save) return;  
     fread (tag, 4, 1, ifp);
     if (!memcmp(tag,""moov"",4) ||
 	!memcmp(tag,""udta"",4) ||",An integer overflow error within the *parse_qt()* function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.12 can be exploited to trigger an infinite loop via a specially crafted Apple QuickTime file.
1698,CVE-2018-5813,"  void CLASS parse_minolta(int base)
     return;
   order = fgetc(ifp) * 0x101;
   offset = base + get4() + 8;
#ifdef LIBRAW_LIBRARY_BUILD
  if(offset>ifp->size()-8)  
    offset = ifp->size()-8;
#endif

   while ((save = ftell(ifp)) < offset)
   {
     for (tag = i = 0; i < 4; i++)
       tag = tag << 8 | fgetc(ifp);
     len = get4();
    if(len < 0)
      return;  
     switch (tag)
     {
     case 0x505244:  ",An error within the *parse_minolta()* function (dcraw/dcraw.c) in LibRaw versions prior to 0.18.11 can be exploited to trigger an infinite loop via a specially crafted file.
1699,CVE-2018-5812,"  static float fMAX(float a, float b)
 	3 G R G R G R	3 B G B G B G	3 R G R G R G	3 G B G B G B
  */
 
#define RAWINDEX(row, col) ((row)*raw_width + (col))
 #define RAW(row,col) \
 	raw_image[(row)*raw_width+(col)]
  
  void CLASS pentax_load_raw()
 
 void CLASS nikon_coolscan_load_raw()
 {
  if(!image)
    throw LIBRAW_EXCEPTION_IO_CORRUPT;

  int bypp = tiff_bps <= 8 ? 1 : 2;
  int bufsize = width * 3 * bypp;

  if (tiff_bps <= 8)
    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);
   else
     gamma_curve(1.0/imgdata.params.coolscan_nef_gamma,0.,1,65535);
   fseek (ifp, data_offset, SEEK_SET);
  void CLASS rollei_thumb()
 void CLASS rollei_load_raw()
 {
   uchar pixel[10];
  unsigned iten = 0, isix, i, buffer = 0, todo[16];
#ifdef LIBRAW_LIBRARY_BUILD
  if(raw_width > 32767 || raw_height > 32767)
    throw LIBRAW_EXCEPTION_IO_BADFILE;
#endif
  unsigned maxpixel = raw_width*(raw_height+7);
 
   isix = raw_width * raw_height * 5 / 8;
   while (fread (pixel, 1, 10, ifp) == 10) {
  void CLASS rollei_load_raw()
       todo[i]   = isix++;
       todo[i+1] = buffer >> (14-i)*5;
     }
    for (i = 0; i < 16; i += 2)
      if(todo[i] < maxpixel)
        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);
      else
        derror();
   }
   maximum = 0x3ff;
 }
  void CLASS sony_arw2_load_raw()
 void CLASS samsung_load_raw()
 {
   int row, col, c, i, dir, op[4], len[4];
#ifdef LIBRAW_LIBRARY_BUILD
  if(raw_width> 32768 || raw_height > 32768)   
    throw LIBRAW_EXCEPTION_IO_BADFILE;
#endif
  unsigned maxpixels = raw_width*(raw_height+7);
 
   order = 0x4949;
   for (row=0; row < raw_height; row++) {
  void CLASS samsung_load_raw()
 	case 2: len[c]--;		break;
 	case 1: len[c]++;
       }
      for (c = 0; c < 16; c += 2)
      {
        i = len[((c & 1) << 1) | (c >> 3)];
	unsigned idest = RAWINDEX(row, col + c);
	unsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);
	if(idest < maxpixels && isrc < maxpixels)  
  	RAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + 			                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);
	else
  	  derror();
        if (c == 14)
          c = -1;
       }
     }
   }
  void CLASS parse_exif (int base)
        if (((make[0] == '\0') && (!strncmp(model, ""ov5647"",6))) ||
            ((!strncmp(make, ""RaspberryPi"",11)) && (!strncmp(model, ""RP_OV5647"",9))) ||
            ((!strncmp(make, ""RaspberryPi"",11)) && (!strncmp(model, ""RP_imx219"",9)))) {
        char mn_text[512];
        char *pos;
        char ccms[512];
        ushort l;
        float num;

	fgets(mn_text, MIN(len,511), ifp);
        mn_text[511] = 0;

        pos = strstr(mn_text, ""gain_r="");
        if (pos)
          cam_mul[0] = atof(pos + 7);
        pos = strstr(mn_text, ""gain_b="");
        if (pos)
          cam_mul[2] = atof(pos + 7);
        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))
          cam_mul[1] = cam_mul[3] = 1.0f;
        else
          cam_mul[0] = cam_mul[2] = 0.0f;

        pos = strstr(mn_text, ""ccm="");
        if(pos)
        {
         pos +=4;
         char *pos2 = strstr(pos, "" "");
         if(pos2)
         {
           l = pos2 - pos;
           memcpy(ccms, pos, l);
           ccms[l] = '\0';
#if defined WIN32 || defined(__MINGW32__)
            
          pos = strtok(ccms, "","");
#else
          char *last=0;
          pos = strtok_r(ccms, "","",&last);
#endif
          if(pos)
          {
            for (l = 0; l < 4; l++)
            {
              num = 0.0;
              for (c = 0; c < 3; c++)
              {
                imgdata.color.ccm[l][c] = (float)atoi(pos);
                num += imgdata.color.ccm[l][c];
#if defined WIN32 || defined(__MINGW32__)
                pos = strtok(NULL, "","");
#else
                pos = strtok_r(NULL, "","",&last);
#endif
                if(!pos) goto end;  
              }
              if (num > 0.01)
                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;
            }
          }
        }
        }
      end:;
      }
      else
 #endif
         parse_makernote (base, 0);
        break;
  float CLASS find_green (int bps, int bite, int off0, int off1)
   UINT64 bitbuf=0;
   int vbits, col, i, c;
   ushort img[2][2064];
  double sum[] = {0, 0};
  if(width > 2064) return 0.f;  
 
   FORC(2) {
     fseek (ifp, c ? off1:off0, SEEK_SET);
  float CLASS find_green (int bps, int bite, int off0, int off1)
 #ifdef LIBRAW_LIBRARY_BUILD
 static void remove_trailing_spaces(char *string, size_t len)
 {
  if (len < 1)
    return;  
  string[len - 1] = 0;
  if (len < 3)
    return;  
  len = strnlen(string, len - 1);
  for (int i = len - 1; i >= 0; i--)
   {
    if (isspace((unsigned char)string[i]))
      string[i] = 0;
     else
       break;
   }",An error within the *nikon_coolscan_load_raw()* function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.9 can be exploited to trigger a NULL pointer dereference.
1700,CVE-2018-5730,"  kadm5_create_principal_3(void *server_handle,
         return KADM5_BAD_MASK;
     if((mask & ~ALL_PRINC_MASK))
         return KADM5_BAD_MASK;
    if (mask & KADM5_TL_DATA) {
        for (tl_data_tail = entry->tl_data; tl_data_tail != NULL;
             tl_data_tail = tl_data_tail->tl_data_next) {
            if (tl_data_tail->tl_data_type < 256)
                return KADM5_BAD_TL_TYPE;
        }
    }
 
     /*
      * Check to see if the principal exists","MIT krb5 1.6 or later allows an authenticated kadmin with permission to add principals to an LDAP Kerberos database to circumvent a DN containership check by supplying both a *linkdn* and *containerdn* database argument, or by supplying a DN string which is a left extension of a container DN string but is not hierarchically within the container DN."
1701,CVE-2018-5344,"  static int lo_open(struct block_device *bdev, fmode_t mode)
 	return err;
 }
 
static void __lo_release(struct loop_device *lo)
 {
 	int err;
 
 	if (atomic_dec_return(&lo->lo_refcnt))
  static void lo_release(struct gendisk *disk, fmode_t mode)
 	mutex_unlock(&lo->lo_ctl_mutex);
 }
 
static void lo_release(struct gendisk *disk, fmode_t mode)
{
	mutex_lock(&loop_index_mutex);
	__lo_release(disk->private_data);
	mutex_unlock(&loop_index_mutex);
}

 static const struct block_device_operations lo_fops = {
 	.owner =	THIS_MODULE,
 	.open =		lo_open,","In the Linux kernel through 4.14.13, drivers/block/loop.c mishandles lo_release serialization, which allows attackers to cause a denial of service (__lock_acquire use-after-free) or possibly have unspecified other impact."
1702,CVE-2018-5333,"  int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,
 err:
 	if (page)
 		put_page(page);
	rm->atomic.op_active = 0;
 	kfree(rm->atomic.op_notifier);
 
 	return ret;","In the Linux kernel through 4.14.13, the rds_cmsg_atomic function in net/rds/rdma.c mishandles cases where page pinning fails or an invalid address is supplied, leading to an rds_atomic_free_op NULL pointer dereference."
1703,CVE-2018-5332,"  int rds_rdma_extra_size(struct rds_rdma_args *args)
 
 	local_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;
 
	if (args->nr_local == 0)
		return -EINVAL;

 	 
 	for (i = 0; i < args->nr_local; i++) {
 		if (copy_from_user(&vec, &local_vec[i],","In the Linux kernel through 4.14.13, the rds_message_alloc_sgs() function does not validate a value that is used during DMA page allocation, leading to a heap-based out-of-bounds write (related to the rds_rdma_extra_size function in net/rds/rdma.c)."
1704,CVE-2018-1281,"  class ZMQVan : public Van {
     CHECK(receiver_ != NULL)
         << ""create receiver socket failed: "" << zmq_strerror(errno);
     int local = GetEnv(""DMLC_LOCAL"", 0);
    std::string hostname = node.hostname.empty() ? ""*"" : node.hostname;
    std::string addr = local ? ""ipc:///tmp/"" : ""tcp://"" + hostname + "":"";
     int port = node.port;
     unsigned seed = static_cast<unsigned>(time(NULL)+port);
     for (int i = 0; i < max_retry+1; ++i) {","The clustered setup of Apache MXNet allows users to specify which IP address and port the scheduler will listen on via the DMLC_PS_ROOT_URI and DMLC_PS_ROOT_PORT env variables. In versions older than 1.0.0, however, the MXNet framework will listen on 0.0.0.0 rather than user specified DMLC_PS_ROOT_URI once a scheduler node is initialized. This exposes the instance running MXNet to any attackers reachable via the interface they didn't expect to be listening on. For example: If a user wants to run a clustered setup locally, they may specify to run on 127.0.0.1. But since MXNet will listen on 0.0.0.0, it makes the port accessible on all network interfaces."
1705,CVE-2018-1129,"  int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)
   const ceph_msg_header& header = m->get_header();
   const ceph_msg_footer& footer = m->get_footer();
 
  if (!HAVE_FEATURE(features, CEPHX_V2)) {
     

     
     
     
    struct {
      __u8 v;
      __le64 magic;
      __le32 len;
      __le32 header_crc;
      __le32 front_crc;
      __le32 middle_crc;
      __le32 data_crc;
    } __attribute__ ((packed)) sigblock = {
      1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),
      mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),
      mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)
     };

    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];

    try {
      const CryptoKey::in_slice_t in {
	sizeof(sigblock),
	reinterpret_cast<const unsigned char*>(&sigblock)
      };
      const CryptoKey::out_slice_t out {
	sizeof(exp_buf),
	reinterpret_cast<unsigned char*>(&exp_buf)
      };
      key.encrypt(cct, in, out);
    } catch (std::exception& e) {
      lderr(cct) << __func__ << "" failed to encrypt signature block"" << dendl;
      return -1;
    }

    *psig = *reinterpret_cast<__le64*>(exp_buf);
  } else {
     
    struct {
      __le32 header_crc;
      __le32 front_crc;
      __le32 front_len;
      __le32 middle_crc;
      __le32 middle_len;
      __le32 data_crc;
      __le32 data_len;
      __le32 seq_lower_word;
    } __attribute__ ((packed)) sigblock = {
      mswab<uint32_t>(header.crc),
      mswab<uint32_t>(footer.front_crc),
      mswab<uint32_t>(header.front_len),
      mswab<uint32_t>(footer.middle_crc),
      mswab<uint32_t>(header.middle_len),
      mswab<uint32_t>(footer.data_crc),
      mswab<uint32_t>(header.data_len),
      mswab<uint32_t>(header.seq)
     };
 
    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];

    try {
      const CryptoKey::in_slice_t in {
	sizeof(sigblock),
	reinterpret_cast<const unsigned char*>(&sigblock)
      };
      const CryptoKey::out_slice_t out {
	sizeof(exp_buf),
	reinterpret_cast<unsigned char*>(&exp_buf)
      };
      key.encrypt(cct, in, out);
    } catch (std::exception& e) {
      lderr(cct) << __func__ << "" failed to encrypt signature block"" << dendl;
      return -1;
    }
 
    struct enc {
      __le64 a, b, c, d;
    } *penc = reinterpret_cast<enc*>(exp_buf);
    *psig = penc->a ^ penc->b ^ penc->c ^ penc->d;
  }
 
   ldout(cct, 10) << __func__ << "" seq "" << m->get_seq()
 		 << "" front_crc_ = "" << footer.front_crc","A flaw was found in the way signature calculation was handled by cephx authentication protocol. An attacker having access to ceph cluster network who is able to alter the message payload was able to bypass signature checks done by cephx protocol. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable."
1706,CVE-2018-1128,"  struct AuthAuthorizer {
   explicit AuthAuthorizer(__u32 p) : protocol(p) {}
   virtual ~AuthAuthorizer() {}
   virtual bool verify_reply(bufferlist::iterator& reply) = 0;
  virtual bool add_challenge(CephContext *cct, bufferlist& challenge) = 0;
};

struct AuthAuthorizerChallenge {
  virtual ~AuthAuthorizerChallenge() {}
 };
 
 ","It was found that cephx authentication protocol did not verify ceph clients correctly and was vulnerable to replay attack. Any attacker having access to ceph cluster network who is able to sniff packets on network can use this vulnerability to authenticate with ceph service and perform actions allowed by ceph service. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable."
1707,CVE-2018-1091,"  static void flush_tmregs_to_thread(struct task_struct *tsk)
 	 * in the appropriate thread structures from live.
 	 */
 
	if ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))
 		return;
 
 	if (MSR_TM_SUSPENDED(mfmsr())) {","In the flush_tmregs_to_thread function in arch/powerpc/kernel/ptrace.c in the Linux kernel before 4.13.5, a guest kernel crash can be triggered from unprivileged userspace during a core dump on a POWER host due to a missing processor feature check and an erroneous use of transactional memory (TM) instructions in the core dump path, leading to a denial of service."
1708,CVE-2018-1068,"  static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,
 		if (match_kern)
 			match_kern->match_size = ret;
 
		if (WARN_ON(type == EBT_COMPAT_TARGET && size_left))
			return -EINVAL;

 		match32 = (struct compat_ebt_entry_mwt *) buf;
 	}
 
  static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,
 	 *
 	 * offsets are relative to beginning of struct ebt_entry (i.e., 0).
 	 */
	for (i = 0; i < 4 ; ++i) {
		if (offsets[i] >= *total)
			return -EINVAL;
		if (i == 0)
			continue;
		if (offsets[i-1] > offsets[i])
			return -EINVAL;
	}

 	for (i = 0, j = 1 ; j < 4 ; j++, i++) {
 		struct compat_ebt_entry_mwt *match32;
 		unsigned int size;",A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.
1709,CVE-2018-1066,"  void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,
 	 
 	flags = NTLMSSP_NEGOTIATE_56 |	NTLMSSP_REQUEST_TARGET |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);
 
  int build_ntlmssp_auth_blob(unsigned char **pbuffer,
 	flags = NTLMSSP_NEGOTIATE_56 |
 		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
 		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
 		flags |= NTLMSSP_NEGOTIATE_SIGN;
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
 
 	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
 	sec_blob->NegotiateFlags = cpu_to_le32(flags);","The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery."
1710,CVE-2018-1065,"  unsigned int arpt_do_table(struct sk_buff *skb,
 			}
 			if (table_base + v
 			    != arpt_next_entry(e)) {
				if (unlikely(stackidx >= private->stacksize)) {
					verdict = NF_DROP;
					break;
				}
 				jumpstack[stackidx++] = e;
 			}
 ","The netfilter subsystem in the Linux kernel through 4.15.7 mishandles the case of a rule blob that contains a jump but lacks a user-defined chain, which allows local users to cause a denial of service (NULL pointer dereference) by leveraging the CAP_NET_RAW or CAP_NET_ADMIN capability, related to arpt_do_table in net/ipv4/netfilter/arp_tables.c, ipt_do_table in net/ipv4/netfilter/ip_tables.c, and ip6t_do_table in net/ipv6/netfilter/ip6_tables.c."
1711,CVE-2018-0500,"  CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)
   if(!scratch || data->set.crlf) {
     oldscratch = scratch;
 
    scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE);
     if(!newscratch) {
       failf(data, ""Failed to alloc scratch buffer!"");
 
       return CURLE_OUT_OF_MEMORY;
     }
   }
  DEBUGASSERT(UPLOAD_BUFSIZE >= nread);
 
    
   eob_sent = smtp->eob;","Curl_smtp_escape_eob in lib/smtp.c in curl 7.54.1 to and including curl 7.60.0 has a heap-based buffer overflow that might be exploitable by an attacker who can control the data that curl transmits over SMTP with certain settings (i.e., use of a nonstandard --limit-rate argument or CURLOPT_BUFFERSIZE value)."
1712,CVE-2018-0429,"  void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY
 
   decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);
 
  if (split_flag && size >= MIN_BLOCK_SIZE){
     int new_size = size/2;
     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);
     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);",Stack-based buffer overflow in the Cisco Thor decoder before commit 18de8f9f0762c3a542b1122589edb8af859d9813 allows local users to cause a denial of service (segmentation fault) and execute arbitrary code via a crafted non-conformant Thor bitstream.
1713,CVE-2017-1000494," 
  
 
  ParseNameValue(const char * buffer, int bufsize,
                struct NameValueParserData * data)
 {
 	struct xmlparser parser;
	memset(data, 0, sizeof(struct NameValueParserData));
 	 
 	parser.xmlstart = buffer;
 	parser.xmlsize = bufsize;",Uninitialized stack variable vulnerability in NameValueParserEndElt (upnpreplyparse.c) in miniupnpd < 2.0 allows an attacker to cause Denial of Service (Segmentation fault and Memory Corruption) or possibly have unspecified other impact
1714,CVE-2017-1000471,"  PUBLIC bool cgiHandler(Webs *wp)
     if (strchr(wp->query, '=') == NULL) {
         query = sclone(wp->query);
         websDecodeUrl(query, query, strlen(query));
        for (cp = stok(query, "" "", &tok); cp != NULL && argp != NULL; ) {
             *(argp+n) = cp;
             trace(5, ""ARG[%d] %s"", n, argp[n-1]);
             n++;",EmbedThis GoAhead Webserver version 4.0.0 is vulnerable to a NULL pointer dereference in the CGI handler resulting in memory corruption or denial of service.
1715,CVE-2017-1000470,"  static void parseHeaders(Webs *wp)
         } else if (strcmp(key, ""content-length"") == 0) {
             wp->rxLen = atoi(value);
             if (smatch(wp->method, ""PUT"")) {
                if (wp->rxLen > ME_GOAHEAD_LIMIT_PUT || wp->rxLen < 0) {
                     websError(wp, HTTP_CODE_REQUEST_TOO_LARGE | WEBS_CLOSE, ""Too big"");
                     return;
                 }
             } else {
                if (wp->rxLen > ME_GOAHEAD_LIMIT_POST || wp->rxLen < 0) {
                     websError(wp, HTTP_CODE_REQUEST_TOO_LARGE | WEBS_CLOSE, ""Too big"");
                     return;
                 }",EmbedThis GoAhead Webserver versions 4.0.0 and earlier is vulnerable to an integer overflow in the HTTP listener resulting in denial of service.
1716,CVE-2017-1000458,"  int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)
 		case '\n':
 			if ( last_char == '\r' )
 				{
				 
				 
				 
				 
				 
				if ( offset == 0 )
					{
					last_char = c;
					break;
					}
 				--offset;  
 				EMIT_LINE
 				}",Bro before Bro v2.5.2 is vulnerable to an out of bounds write in the ContentLine analyzer allowing remote attackers to cause a denial of service (crash) and possibly other exploitation.
1717,CVE-2017-1000414," 
  
 
  
  
  
  unsigned CjfifDecode::DecodeMarker()
 			 
 			m_anSofHorzSampFact_Hi[nCompIdent] = (anSofSampFact[nCompIdent] & 0xF0) >> 4;	 
 			m_anSofVertSampFact_Vi[nCompIdent] = (anSofSampFact[nCompIdent] & 0x0F);		 
			if (!ValidateValue(m_anSofHorzSampFact_Hi[nCompIdent],1,4,_T(""Horizontal Sampling Factor <Hi>""),true,1)) return DECMARK_ERR;
			if (!ValidateValue(m_anSofVertSampFact_Vi[nCompIdent],1,4,_T(""Vertical Sampling Factor <Vi>""),true,1)) return DECMARK_ERR;
 
 		}
 
",ImpulseAdventure JPEGsnoop version 1.7.5 is vulnerable to a division by zero in the JFIF decode handling resulting denial of service.
1718,CVE-2017-18344,"  static struct pid *good_sigevent(sigevent_t * event)
 {
 	struct task_struct *rtn = current->group_leader;
 
	switch (event->sigev_notify) {
	case SIGEV_SIGNAL | SIGEV_THREAD_ID:
		rtn = find_task_by_vpid(event->sigev_notify_thread_id);
		if (!rtn || !same_thread_group(rtn, current))
			return NULL;
		 
	case SIGEV_SIGNAL:
	case SIGEV_THREAD:
		if (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)
			return NULL;
		 
	case SIGEV_NONE:
		return task_pid(rtn);
	default:
 		return NULL;
	}
 }
 
 static struct k_itimer * alloc_posix_timer(void)
  void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)
 	struct timespec64 ts64;
 	bool sig_none;
 
	sig_none = timr->it_sigev_notify == SIGEV_NONE;
 	iv = timr->it_interval;
 
 	 
  int common_timer_set(struct k_itimer *timr, int flags,
 
 	timr->it_interval = timespec64_to_ktime(new_setting->it_interval);
 	expires = timespec64_to_ktime(new_setting->it_value);
	sigev_none = timr->it_sigev_notify == SIGEV_NONE;
 
 	kc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);
 	timr->it_active = !sigev_none;","The timer_create syscall implementation in kernel/time/posix-timers.c in the Linux kernel before 4.14.8 doesn't properly validate the sigevent->sigev_notify field, which leads to out-of-bounds access in the show_timer function (called when /proc/$PID/timers is read). This allows userspace applications to read arbitrary kernel memory (on a kernel built with CONFIG_POSIX_TIMERS and CONFIG_CHECKPOINT_RESTORE)."
1719,CVE-2017-18270,"  struct key {
 #define KEY_FLAG_BUILTIN	8	 
 #define KEY_FLAG_ROOT_CAN_INVAL	9	 
 #define KEY_FLAG_KEEP		10	 
#define KEY_FLAG_UID_KEYRING	11	 
 
 	 
 #define KEY_ALLOC_BUILT_IN		0x0004	 
 #define KEY_ALLOC_BYPASS_RESTRICTION	0x0008	 
#define KEY_ALLOC_UID_KEYRING		0x0010	 
 
 extern void key_revoke(struct key *key);
 extern void key_invalidate(struct key *key);","In the Linux kernel before 4.13.5, a local user could create keyrings for other users via keyctl commands, setting unwanted defaults or causing a denial of service."
1720,CVE-2017-18261,"  DECLARE_PER_CPU(const struct arch_timer_erratum_workaround *,
 	u64 _val;							\
 	if (needs_unstable_timer_counter_workaround()) {		\
 		const struct arch_timer_erratum_workaround *wa;		\
		preempt_disable_notrace();				\
 		wa = __this_cpu_read(timer_unstable_counter_workaround); \
 		if (wa && wa->read_##reg)				\
 			_val = wa->read_##reg();			\
 		else							\
 			_val = read_sysreg(reg);			\
		preempt_enable_notrace();				\
 	} else {							\
 		_val = read_sysreg(reg);				\
 	}								\","The arch_timer_reg_read_stable macro in arch/arm64/include/asm/arch_timer.h in the Linux kernel before 4.13 allows local users to cause a denial of service (infinite recursion) by writing to a file under /sys/kernel/debug in certain circumstances, as demonstrated by a scenario involving debugfs, ftrace, PREEMPT_TRACER, and FUNCTION_GRAPH_TRACER."
1721,CVE-2017-18257,"  static int __get_data_block(struct inode *inode, sector_t iblock,
 	if (!err) {
 		map_bh(bh, inode->i_sb, map.m_pblk);
 		bh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;
		bh->b_size = (u64)map.m_len << inode->i_blkbits;
 	}
 	return err;
 }",The __get_data_block function in fs/f2fs/data.c in the Linux kernel before 4.11 allows local users to cause a denial of service (integer overflow and loop) via crafted use of the open and fallocate system calls with an FS_IOC_FIEMAP ioctl.
1722,CVE-2017-18255,"  int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,
 				void __user *buffer, size_t *lenp,
 				loff_t *ppos)
 {
	int ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
 
 	if (ret || !write)
 		return ret;","The perf_cpu_time_max_percent_handler function in kernel/events/core.c in the Linux kernel before 4.11 allows local users to cause a denial of service (integer overflow) or possibly have unspecified other impact via a large value, as demonstrated by an incorrect sample-rate calculation."
1723,CVE-2017-18249,"  static void __remove_nid_from_list(struct f2fs_sb_info *sbi,
 static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)
 {
 	struct f2fs_nm_info *nm_i = NM_I(sbi);
	struct free_nid *i, *e;
 	struct nat_entry *ne;
	int err = -EINVAL;
	bool ret = false;
 
 	 
 	if (unlikely(nid == 0))
 		return false;
 
 	i = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);
 	i->nid = nid;
 	i->state = NID_NEW;
 
	if (radix_tree_preload(GFP_NOFS))
		goto err;
 
 	spin_lock(&nm_i->nid_list_lock);

	if (build) {
		 
		ne = __lookup_nat_cache(nm_i, nid);
		if (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||
				nat_get_blkaddr(ne) != NULL_ADDR))
			goto err_out;

		e = __lookup_free_nid_list(nm_i, nid);
		if (e) {
			if (e->state == NID_NEW)
				ret = true;
			goto err_out;
		}
	}
	ret = true;
 	err = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);
err_out:
 	spin_unlock(&nm_i->nid_list_lock);
 	radix_tree_preload_end();
err:
	if (err)
 		kmem_cache_free(free_nid_slab, i);
	return ret;
 }
 
 static void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)","The add_free_nid function in fs/f2fs/node.c in the Linux kernel before 4.12 does not properly track an allocated nid, which allows local users to cause a denial of service (race condition) or possibly have unspecified other impact via concurrent threads."
1724,CVE-2017-18241,"  int create_flush_cmd_control(struct f2fs_sb_info *sbi)
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
	if (!test_opt(sbi, FLUSH_MERGE))
		return err;

 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
  int build_segment_manager(struct f2fs_sb_info *sbi)
 
 	INIT_LIST_HEAD(&sm_info->sit_entry_set);
 
	if (!f2fs_readonly(sbi->sb)) {
 		err = create_flush_cmd_control(sbi);
 		if (err)
 			return err;",fs/f2fs/segment.c in the Linux kernel before 4.13 allows local users to cause a denial of service (NULL pointer dereference and panic) by using a noflush_merge option that triggers a NULL value for a flush_cmd_control data structure.
1725,CVE-2017-18232,"  int sas_discover_sata(struct domain_device *dev)
 	if (res)
 		return res;
 
 	return 0;
 }
 ","The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code."
1726,CVE-2017-18224,"  static int ocfs2_symlink_get_block(struct inode *inode, sector_t iblock,
 	return err;
 }
 
static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,
		    struct buffer_head *bh_result, int create)
{
	int ret = 0;
	struct ocfs2_inode_info *oi = OCFS2_I(inode);

	down_read(&oi->ip_alloc_sem);
	ret = ocfs2_get_block(inode, iblock, bh_result, create);
	up_read(&oi->ip_alloc_sem);

	return ret;
}

 int ocfs2_get_block(struct inode *inode, sector_t iblock,
 		    struct buffer_head *bh_result, int create)
 {
  static void ocfs2_dio_free_write_ctx(struct inode *inode,
  * called like this: dio->get_blocks(dio->inode, fs_startblk,
  * 					fs_count, map_bh, dio->rw == WRITE);
  */
static int ocfs2_dio_wr_get_block(struct inode *inode, sector_t iblock,
 			       struct buffer_head *bh_result, int create)
 {
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
  static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,
 	 * while file size will be changed.
 	 */
 	if (pos + total_len <= i_size_read(inode)) {
 
		 
		ret = ocfs2_lock_get_block(inode, iblock, bh_result, create);
 		if (buffer_mapped(bh_result) &&
 		    !buffer_new(bh_result) &&
 		    ret == 0)
  static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)
 		return 0;
 
 	if (iov_iter_rw(iter) == READ)
		get_block = ocfs2_lock_get_block;
 	else
		get_block = ocfs2_dio_wr_get_block;
 
 	return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,
 				    iter, get_block,","In the Linux kernel before 4.15, fs/ocfs2/aops.c omits use of a semaphore and consequently has a race condition for access to the extent tree during read operations in DIRECT mode, which allows local users to cause a denial of service (BUG) by modifying a certain e_cpos field."
1727,CVE-2017-18222,"  static void hns_gmac_get_strings(u32 stringset, u8 *data)
 
 static int hns_gmac_get_sset_count(int stringset)
 {
	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
 		return ARRAY_SIZE(g_gmac_stats_string);
 
 	return 0;","In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings."
1728,CVE-2017-18221,"  static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)
 {
 	int i;
 	int nr = pagevec_count(pvec);
	int delta_munlocked = -nr;
 	struct pagevec pvec_putback;
 	int pgrescued = 0;
 
  static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)
 				continue;
 			else
 				__munlock_isolation_failed(page);
		} else {
			delta_munlocked++;
 		}
 
 		/*
  static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)
 		pagevec_add(&pvec_putback, pvec->pages[i]);
 		pvec->pages[i] = NULL;
 	}
 	__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);
 	spin_unlock_irq(zone_lru_lock(zone));
 ",The __munlock_pagevec function in mm/mlock.c in the Linux kernel before 4.11.4 allows local users to cause a denial of service (NR_MLOCK accounting corruption) via crafted use of mlockall and munlockall system calls.
1729,CVE-2017-18218,"  static void fill_tso_desc(struct hnae_ring *ring, void *priv,
 			     mtu);
 }
 
netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
				struct sk_buff *skb,
				struct hns_nic_ring_data *ring_data)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 	struct hnae_ring *ring = ring_data->ring;
  int hns_nic_net_xmit_hw(struct net_device *ndev,
 	dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping);
 	netdev_tx_sent_queue(dev_queue, skb->len);
 
	netif_trans_update(ndev);
	ndev->stats.tx_bytes += skb->len;
	ndev->stats.tx_packets++;

 	wmb();  
 	assert(skb->queue_mapping < priv->ae_handle->q_num);
 	hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num);
  static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);

	return hns_nic_net_xmit_hw(ndev, skb,
				   &tx_ring_data(priv, skb->queue_mapping));
 }
 
 static void hns_nic_drop_rx_fetch(struct hns_nic_ring_data *ring_data,","In drivers/net/ethernet/hisilicon/hns/hns_enet.c in the Linux kernel before 4.13, local users can cause a denial of service (use-after-free and BUG) or possibly have unspecified other impact by leveraging differences in skb handling between hns_nic_net_xmit_hw and hns_nic_net_xmit."
1730,CVE-2017-18216,"  char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {
 		""panic"",	 
 };
 
static inline void o2nm_lock_subsystem(void);
static inline void o2nm_unlock_subsystem(void);

 struct o2nm_node *o2nm_get_node_by_num(u8 node_num)
 {
 	struct o2nm_node *node = NULL;
  static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
 {
 	 
	if (node->nd_item.ci_parent)
		return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
	else
		return NULL;
 }
 
 enum {
  static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 				   size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	int ret = 0;
  static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL;  
 
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

 	write_lock(&cluster->cl_nodes_lock);
 	if (cluster->cl_nodes[tmp])
 		ret = -EEXIST;
  static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
 		set_bit(tmp, cluster->cl_nodes_bitmap);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

 	if (ret)
 		return ret;
 
  static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 					    size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
 	int ret, i;
 	struct rb_node **p, *parent;
 	unsigned int octets[4];
  static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
 	}
 
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

 	ret = 0;
 	write_lock(&cluster->cl_nodes_lock);
 	if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
  static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
 		rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
 	}
 	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

 	if (ret)
 		return ret;
 
  static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 				     size_t count)
 {
 	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
 	unsigned long tmp;
 	char *p = (char *)page;
 	ssize_t ret;
  static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
 		return -EINVAL;  
 
	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		ret = -EINVAL;
		goto out;
	}

 	 
 	if (tmp && tmp == cluster->cl_has_local &&
	    cluster->cl_local_node != node->nd_num) {
		ret = -EBUSY;
		goto out;
	}
 
 	 
 	if (tmp && !cluster->cl_has_local) {
 		ret = o2net_start_listening(node);
 		if (ret)
			goto out;
 	}
 
 	if (!tmp && cluster->cl_has_local &&
  static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,
 		cluster->cl_local_node = node->nd_num;
 	}
 
	ret = count;

out:
	o2nm_unlock_subsystem();
	return ret;
 }
 
 CONFIGFS_ATTR(o2nm_node_, num);
  static struct o2nm_cluster_group o2nm_cluster_group = {
 	},
 };
 
static inline void o2nm_lock_subsystem(void)
{
	mutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);
}

static inline void o2nm_unlock_subsystem(void)
{
	mutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);
}

 int o2nm_depend_item(struct config_item *item)
 {
 	return configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);","In fs/ocfs2/cluster/nodemanager.c in the Linux kernel before 4.15, local users can cause a denial of service (NULL pointer dereference and BUG) because a required mutex is not used."
1731,CVE-2017-18208,"  static long madvise_willneed(struct vm_area_struct *vma,
 {
 	struct file *file = vma->vm_file;
 
	*prev = vma;
 #ifdef CONFIG_SWAP
 	if (!file) {
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file->f_mapping)) {
 		force_shm_swapin_readahead(vma, start, end,
 					file->f_mapping);
 		return 0;
  static long madvise_willneed(struct vm_area_struct *vma,
 		return 0;
 	}
 
 	start = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 	if (end > vma->vm_end)
 		end = vma->vm_end;",The madvise_willneed function in mm/madvise.c in the Linux kernel before 4.14.4 allows local users to cause a denial of service (infinite loop) by triggering use of MADVISE_WILLNEED for a DAX mapping.
1732,CVE-2017-18204,"  int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)
 	}
 	size_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;
 	if (size_change) {
		 
		inode_dio_wait(inode);

 		status = ocfs2_rw_lock(inode, 1);
 		if (status < 0) {
 			mlog_errno(status);
  int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)
 		if (status)
 			goto bail_unlock;
 
 		if (i_size_read(inode) >= attr->ia_size) {
 			if (ocfs2_should_order_data(inode)) {
 				status = ocfs2_begin_ordered_truncate(inode,",The ocfs2_setattr function in fs/ocfs2/file.c in the Linux kernel before 4.14.2 allows local users to cause a denial of service (deadlock) via DIO requests.
1733,CVE-2017-18203,"  struct mapped_device *dm_get_from_kobject(struct kobject *kobj)
 
 	md = container_of(kobj, struct mapped_device, kobj_holder.kobj);
 
	spin_lock(&_minor_lock);
	if (test_bit(DMF_FREEING, &md->flags) || dm_deleting_md(md)) {
		md = NULL;
		goto out;
	}
 	dm_get(md);
out:
	spin_unlock(&_minor_lock);

 	return md;
 }
 ",The dm_get_from_kobject function in drivers/md/dm.c in the Linux kernel before 4.14.3 allow local users to cause a denial of service (BUG) by leveraging a race condition with __dm_destroy during creation and removal of DM devices.
1734,CVE-2017-18202,"  static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 	 */
 	set_bit(MMF_UNSTABLE, &mm->flags);
 
 	for (vma = mm->mmap ; vma; vma = vma->vm_next) {
 		if (!can_madv_dontneed_vma(vma))
 			continue;
  static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)
 		 * we do not want to block exit_mmap by keeping mm ref
 		 * count elevated without a good reason.
 		 */
		if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {
			tlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);
 			unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,
 					 NULL);
			tlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);
		}
 	}
 	pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"",
 			task_pid_nr(tsk), tsk->comm,
 			K(get_mm_counter(mm, MM_ANONPAGES)),","The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window."
1735,CVE-2017-18200,"  void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);
 bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);
 void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);
 void stop_discard_thread(struct f2fs_sb_info *sbi);
void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);
 void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);
 void release_discard_addrs(struct f2fs_sb_info *sbi);
 int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);","The f2fs implementation in the Linux kernel before 4.14 mishandles reference counts associated with f2fs_wait_discard_bios calls, which allows local users to cause a denial of service (BUG), as demonstrated by fstrim."
1736,CVE-2017-18193,"  static void __drop_largest_extent(struct inode *inode,
 }
 
  
static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)
 {
 	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
 	struct extent_tree *et;
  bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)
 	return false;
 }
 
bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)
{
	bool ret =  __f2fs_init_extent_tree(inode, i_ext);

	if (!F2FS_I(inode)->extent_tree)
		set_inode_flag(inode, FI_NO_EXTENT);

	return ret;
}

 static bool f2fs_lookup_extent_tree(struct inode *inode, pgoff_t pgofs,
 							struct extent_info *ei)
 {","fs/f2fs/extent_cache.c in the Linux kernel before 4.13 mishandles extent trees, which allows local users to cause a denial of service (BUG) via an application with multiple threads."
1737,CVE-2017-18190,"  valid_host(cupsd_client_t *con)		 
 
     return (!_cups_strcasecmp(con->clientname, ""localhost"") ||
 	    !_cups_strcasecmp(con->clientname, ""localhost."") ||
             !strcmp(con->clientname, ""127.0.0.1"") ||
 	    !strcmp(con->clientname, ""[::1]""));
   }",A localhost.localdomain whitelist entry in valid_host() in scheduler/client.c in CUPS before 2.2.2 allows remote attackers to execute arbitrary IPP commands by sending POST requests to the CUPS daemon in conjunction with DNS rebinding. The localhost.localdomain name is often resolved via a DNS server (neither the OS nor the web browser is responsible for ensuring that localhost.localdomain is 127.0.0.1).
1738,CVE-2017-18187,"  static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned cha
      
    if( end - *p < 2 )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad client key exchange message"" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
  static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned cha
     n = ( (*p)[0] << 8 ) | (*p)[1];
     *p += 2;
 
    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad client key exchange message"" ) );
         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );","In ARM mbed TLS before 2.7.0, there is a bounds-check bypass through an integer overflow in PSK identity parsing in the ssl_parse_client_psk_identity() function in library/ssl_srv.c."
1739,CVE-2017-18184,"  compute_O_value(std::string const& user_password,
 
     char upass[key_bytes];
     pad_or_truncate_password_V4(user_password, upass);
    std::string k1(reinterpret_cast<char*>(O_key), OU_key_bytes_V4);
    pad_short_parameter(k1, data.getLengthBytes());
     iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,
 		O_key, data.getLengthBytes(),
                 (data.getR() >= 3) ? 20 : 1, false);
  compute_U_value_R2(std::string const& user_password,
     std::string k1 = QPDF::compute_encryption_key(user_password, data);
     char udata[key_bytes];
     pad_or_truncate_password_V4("""", udata);
    pad_short_parameter(k1, data.getLengthBytes());
     iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,
 		QUtil::unsigned_char_pointer(k1),
                 data.getLengthBytes(), 1, false);
  compute_U_value_R3(std::string const& user_password,
                                 data.getId1().length());
     MD5::Digest digest;
     md5.digest(digest);
    pad_short_parameter(k1, data.getLengthBytes());
     iterate_rc4(digest, sizeof(MD5::Digest),
 		QUtil::unsigned_char_pointer(k1),
                 data.getLengthBytes(), 20, false);
  check_owner_password_V4(std::string& user_password,
     compute_O_rc4_key(user_password, owner_password, data, key);
     unsigned char O_data[key_bytes];
     memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);
    std::string k1(reinterpret_cast<char*>(key), OU_key_bytes_V4);
    pad_short_parameter(k1, data.getLengthBytes());
    iterate_rc4(O_data, key_bytes, QUtil::unsigned_char_pointer(k1),
                data.getLengthBytes(),
                 (data.getR() >= 3) ? 20 : 1, true);
     std::string new_user_password =
         std::string(reinterpret_cast<char*>(O_data), key_bytes);
  QPDF::initializeEncryption()
 
     if (V < 5)
     {
         
         pad_short_parameter(O, key_bytes);
         pad_short_parameter(U, key_bytes);
         if (! ((O.length() == key_bytes) && (U.length() == key_bytes)))
  QPDF::initializeEncryption()
         UE = encryption_dict.getKey(""/UE"").getStringValue();
         Perms = encryption_dict.getKey(""/Perms"").getStringValue();
 
         
         pad_short_parameter(O, OU_key_bytes_V5);
         pad_short_parameter(U, OU_key_bytes_V5);
         pad_short_parameter(OE, OUE_key_bytes_V5);
         pad_short_parameter(UE, OUE_key_bytes_V5);
         pad_short_parameter(Perms, Perms_key_bytes_V5);
     }
 
     int Length = 40;",An issue was discovered in QPDF before 7.0.0. There is a stack-based out-of-bounds read in the function iterate_rc4 in QPDF_encryption.cc.
1740,CVE-2017-18183,"  QPDFWriter::enqueueObject(QPDFObjectHandle object)
 		 
 		 
 		int stream_id = this->object_to_object_stream[og];
                 
                 
                obj_renumber[og] = 0;
 		enqueueObject(this->pdf.getObjectByID(stream_id, 0));
 	    }
 	    else
  QPDFWriter::enqueueObject(QPDFObjectHandle object)
 		}
 	    }
 	}
        else if (obj_renumber[og] == 0)
        {
             
             
            QTC::TC(""qpdf"", ""QPDFWriter ignore self-referential object stream"");
        }
     }
     else if (object.isArray())
     {",An issue was discovered in QPDF before 7.0.0. There is an infinite loop in the QPDFWriter::enqueueObject() function in libqpdf/QPDFWriter.cc.
1741,CVE-2017-18174,"  static int amd_gpio_remove(struct platform_device *pdev)
 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
 
 	return 0;
 }","In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free."
1742,CVE-2017-18120,"  read_gif(Gif_Reader *grr, int read_flags,
   Gif_DeleteArray(gfc.suffix);
   Gif_DeleteArray(gfc.length);
   gfc.gfi = 0;
  last_name = 0;
 
   if (gfs)
     gfs->errors = gfc.errors[1];","A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421."
1743,CVE-2017-18079,"  static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
	spin_lock_irq(&i8042_lock);
 	port->exists = true;
	spin_unlock_irq(&i8042_lock);

 	return 0;
 }
 
  static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
	spin_lock_irq(&i8042_lock);
 	port->exists = false;
	port->serio = NULL;
	spin_unlock_irq(&i8042_lock);
 
 	 
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
 }
 
 /*
  static irqreturn_t i8042_interrupt(int irq, void *dev_id)
 
 	spin_unlock_irqrestore(&i8042_lock, flags);
 
	if (likely(serio && !filtered))
 		serio_interrupt(serio, data, dfl);
 
  out:",drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.
1744,CVE-2017-18075,"  static void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)
 	crypto_free_aead(ctx->child);
 }
 
static void pcrypt_free(struct aead_instance *inst)
{
	struct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);

	crypto_drop_aead(&ctx->spawn);
	kfree(inst);
}

 static int pcrypt_init_instance(struct crypto_instance *inst,
 				struct crypto_alg *alg)
 {
  static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,
 	inst->alg.encrypt = pcrypt_aead_encrypt;
 	inst->alg.decrypt = pcrypt_aead_decrypt;
 
	inst->free = pcrypt_free;

 	err = aead_register_instance(tmpl, inst);
 	if (err)
 		goto out_drop_aead;
  static int pcrypt_create(struct crypto_template *tmpl, struct rtattr **tb)
 	return -EINVAL;
 }
 
 static int pcrypt_cpumask_change_notify(struct notifier_block *self,
 					unsigned long val, void *data)
 {
  static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
 static struct crypto_template pcrypt_tmpl = {
 	.name = ""pcrypt"",
 	.create = pcrypt_create,
 	.module = THIS_MODULE,
 };
 ","crypto/pcrypt.c in the Linux kernel before 4.14.13 mishandles freeing instances, allowing a local user able to access the AF_ALG-based AEAD interface (CONFIG_CRYPTO_USER_API_AEAD) and pcrypt (CONFIG_CRYPTO_PCRYPT) to cause a denial of service (kfree of an incorrect pointer) or possibly have unspecified other impact by executing a crafted sequence of system calls."
1745,CVE-2017-18017,"  tcpmss_mangle_packet(struct sk_buff *skb,
 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph->doff * 4;
 
	if (len < tcp_hdrlen || tcp_hdrlen < sizeof(struct tcphdr))
 		return -1;
 
 	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
  tcpmss_mangle_packet(struct sk_buff *skb,
 	if (len > tcp_hdrlen)
 		return 0;
 
	 
	if (tcp_hdrlen >= 15 * 4)
		return 0;

 	 ","The tcpmss_mangle_packet function in net/netfilter/xt_TCPMSS.c in the Linux kernel before 4.11, and 4.9.x before 4.9.36, allows remote attackers to cause a denial of service (use-after-free and memory corruption) or possibly have unspecified other impact by leveraging the presence of xt_TCPMSS in an iptables action."
1746,CVE-2017-16910,"  void CLASS xtrans_interpolate(int passes)
 #endif
 
 #ifdef LIBRAW_LIBRARY_BUILD
  if(width < TS || height < TS)
	  throw LIBRAW_EXCEPTION_IO_CORRUPT;  
  
   for (row = 0; row < 6; row++)
 	  for (col = 0; col < 6; col++)
  void CLASS xtrans_interpolate(int passes)
   if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16
     || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])
 	  throw LIBRAW_EXCEPTION_IO_CORRUPT;

  
 for(int i = 0; i < 3; i++)
  for(int j = 0; j < 3; j++)
   for(int k = 0; k < 2; k++)
    for(int l = 0; l < 8; l++)
     allhex[i][j][k][l]=32700;
 #endif
   cielab(0, 0);
   ndir = 4 << (passes > 1);
  void CLASS xtrans_interpolate(int passes)
   drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));
   homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));
 
  int minv=0,maxv=0,minh=0,maxh=0;
    
   for (row = 0; row < 3; row++)
     for (col = 0; col < 3; col++)
  void CLASS xtrans_interpolate(int passes)
           {
             v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];
             h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];
	    minv=MIN(v,minv);
	    maxv=MAX(v,maxv);
	    minh=MIN(v,minh);
   	    maxh=MAX(v,maxh);
             allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;
             allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;
           }
       }
 
#ifdef LIBRAW_LIBRARY_BUILD
    
  for(int i = 0; i < 3; i++)
    for(int j = 0; j < 3; j++)
      for(int k = 0; k < 2; k++)
        for(int l = 0; l < 8; l++)
	  if(allhex[i][j][k][l]>maxh+maxv*width+1 || allhex[i][j][k][l]<minh+minv*width-1)
	  throw LIBRAW_EXCEPTION_IO_CORRUPT;
  int retrycount = 0;
#endif
    
   for (row = 2; row < height - 2; row++)
     for (min = ~(max = 0), col = 2; col < width - 2; col++)
  void CLASS xtrans_interpolate(int passes)
         break;
       case 2:
         if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)
	{
           row--;
#ifdef LIBRAW_LIBRARY_BUILD
	  if(retrycount++ > width*height)
	  	throw LIBRAW_EXCEPTION_IO_CORRUPT;
#endif
	}
       }
     }
 ",An error within the *LibRaw::xtrans_interpolate()* function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.6 can be exploited to cause an invalid read memory access and subsequently a Denial of Service condition.
1747,CVE-2017-16909,"  void CLASS panasonic_load_raw()
   int row, col, i, j, sh = 0, pred[2], nonz[2];
 
   pana_bits(0);
  for (row = 0; row < raw_height; row++)
   {
 #ifdef LIBRAW_LIBRARY_BUILD
     checkCancel();
  void CLASS panasonic_load_raw()
       }
       else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
         pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)
         derror();
     }
   }
  void CLASS parse_fuji(int offset)
   entries = get4();
   if (entries > 255)
     return;
#ifdef LIBRAW_LIBRARY_BUILD
  imgdata.process_warnings |=  LIBRAW_WARN_PARSEFUJI_PROCESSED; 
#endif
   while (entries--)
   {
     tag = get2();
  void CLASS identify()
     if (raw_color)
       adobe_coeff(""Apple"", ""Quicktake"");
 
#ifdef LIBRAW_LIBRARY_BUILD
   
  if(fuji_width && !dng_version && !(imgdata.process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ))
     fuji_width = 0;
#endif
   if (fuji_width)
   {
     fuji_width = width >> !fuji_layout;",An error related to the *LibRaw::panasonic_load_raw()* function (dcraw_common.cpp) in LibRaw versions prior to 0.18.6 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash via a specially crafted TIFF image.
1748,CVE-2017-15365,"  Event_job_data::execute(THD *thd, bool drop)
       bool save_tx_read_only= thd->tx_read_only;
       thd->tx_read_only= false;
 
       
      const enum_sql_command sql_command_save= thd->lex->sql_command;
      const bool sql_command_set= WSREP(thd);

      if (sql_command_set)
         thd->lex->sql_command = SQLCOM_DROP_EVENT;
 
       ret= Events::drop_event(thd, dbname, name, FALSE);
 
      if (sql_command_set)
      {
        WSREP_TO_ISOLATION_END;
        thd->lex->sql_command = sql_command_save;
      }
 
       thd->tx_read_only= save_tx_read_only;
       thd->security_ctx->master_access= saved_master_access;
     }",sql/event_data_objects.cc in MariaDB before 10.1.30 and 10.2.x before 10.2.10 and Percona XtraDB Cluster before 5.6.37-26.21-3 and 5.7.x before 5.7.19-29.22-3 allows remote authenticated users with SQL access to bypass intended access restrictions and replicate data definition language (DDL) statements to cluster nodes by leveraging incorrect ordering of DDL replication and ACL checking.
1749,CVE-2017-15129,"  struct net *get_net_ns_by_id(struct net *net, int id)
 	spin_lock_bh(&net->nsid_lock);
 	peer = idr_find(&net->netns_ids, id);
 	if (peer)
		peer = maybe_get_net(peer);
 	spin_unlock_bh(&net->nsid_lock);
 	rcu_read_unlock();
 ","A use-after-free vulnerability was found in network namespaces code affecting the Linux kernel before 4.14.11. The function get_net_ns_by_id() in net/core/net_namespace.c does not check for the net::count value after it has found a peer network in netns_ids idr, which could lead to double free and memory corruption. This vulnerability could allow an unprivileged local user to induce kernel memory corruption on the system, leading to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is thought to be unlikely."
1750,CVE-2017-15128,"  int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
 			    unsigned long src_addr,
 			    struct page **pagep)
 {
	struct address_space *mapping;
	pgoff_t idx;
	unsigned long size;
 	int vm_shared = dst_vma->vm_flags & VM_SHARED;
 	struct hstate *h = hstate_vma(dst_vma);
 	pte_t _dst_pte;
  int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
 	__SetPageUptodate(page);
 	set_page_huge_active(page);
 
	mapping = dst_vma->vm_file->f_mapping;
	idx = vma_hugecache_offset(h, dst_vma, dst_addr);

 	 
 	if (vm_shared) {
		size = i_size_read(mapping->host) >> huge_page_shift(h);
		ret = -EFAULT;
		if (idx >= size)
			goto out_release_nounlock;
 
		 
 		ret = huge_add_to_page_cache(page, mapping, idx);
 		if (ret)
 			goto out_release_nounlock;
  int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
 	ptl = huge_pte_lockptr(h, dst_mm, dst_pte);
 	spin_lock(ptl);
 
	 
	size = i_size_read(mapping->host) >> huge_page_shift(h);
	ret = -EFAULT;
	if (idx >= size)
		goto out_release_unlock;

 	ret = -EEXIST;
 	if (!huge_pte_none(huge_ptep_get(dst_pte)))
 		goto out_release_unlock;",A flaw was found in the hugetlb_mcopy_atomic_pte function in mm/hugetlb.c in the Linux kernel before 4.13.12. A lack of size check could cause a denial of service (BUG).
1751,CVE-2017-15127,"  int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,
 	return ret;
 out_release_unlock:
 	spin_unlock(ptl);
 	if (vm_shared)
 		unlock_page(page);
out_release_nounlock:
 	put_page(page);
 	goto out;
 }",A flaw was found in the hugetlb_mcopy_atomic_pte function in mm/hugetlb.c in the Linux kernel before 4.13. A superfluous implicit page unlock for VM_SHARED hugetlbfs mapping could trigger a local denial of service (BUG).
1752,CVE-2017-15126,"  static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
 			break;
 		if (ACCESS_ONCE(ctx->released) ||
 		    fatal_signal_pending(current)) {
			 
 			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
 			if (ewq->msg.event == UFFD_EVENT_FORK) {
 				struct userfaultfd_ctx *new;
  static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,
 					(unsigned long)
 					uwq->msg.arg.reserved.reserved1;
 				list_move(&uwq->wq.entry, &fork_event);
				 
				userfaultfd_ctx_get(fork_nctx);
 				spin_unlock(&ctx->event_wqh.lock);
 				ret = 0;
 				break;
  static ssize_t userfaultfd_ctx_read(struct userfaultfd_ctx *ctx, int no_wait,
 
 	if (!ret && msg->event == UFFD_EVENT_FORK) {
 		ret = resolve_userfault_fork(ctx, fork_nctx, msg);
		spin_lock(&ctx->event_wqh.lock);
		if (!list_empty(&fork_event)) {
			 
			userfaultfd_ctx_put(fork_nctx);

			uwq = list_first_entry(&fork_event,
					       typeof(*uwq),
					       wq.entry);
			 
			list_del(&uwq->wq.entry);
			__add_wait_queue(&ctx->event_wqh, &uwq->wq);
 
			 
			if (likely(!ret))
 				userfaultfd_event_complete(ctx, uwq);
		} else {
			 
			if (ret)
				userfaultfd_ctx_put(fork_nctx);
 		}
		spin_unlock(&ctx->event_wqh.lock);
 	}
 
 	return ret;",A use-after-free flaw was found in fs/userfaultfd.c in the Linux kernel before 4.13.6. The issue is related to the handling of fork failure when dealing with event messages. Failure to fork correctly can lead to a situation where a fork event will be removed from an already freed list of events with userfaultfd_ctx_put().
1753,CVE-2017-9732,"  gstd_accept(int fd, char **display_creds, char **export_name, char **mech)
 	    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,
 	    NULL, NULL);
 
	gss_release_buffer(&min, &in);

 	if (out.length && write_packet(fd, &out)) {
 		gss_release_buffer(&min, &out);
 		return NULL;
 	}
	gss_release_buffer(&min, &out);
 
 	GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context"");
 
  read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 				return -2;
 
 			LOG(LOG_ERR, (""%s"", strerror(errno)));
			goto bail;
 		}
 
 		if (ret == 0) {		 
  read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 			 * a protocol error.
 			 */
 			LOG(LOG_INFO, (""EOF reading packet len""));
			goto bail;
 		}
 
 		len_buf_pos += ret;
  read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 	 */
 	if (len > GSTD_MAXPACKETCONTENTS + 512) {
 		LOG(LOG_ERR, (""ridiculous length, %ld"", len));
		goto bail;
 	}
 
 	if (!tmpbuf) {
 		if ((tmpbuf = malloc(len)) == NULL) {
 			LOG(LOG_CRIT, (""malloc failure, %ld bytes"", len));
			goto bail;
 		}
 	}
 
 	ret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);
 	if (ret == -1) {

 		if (errno == EINTR || errno == EAGAIN)
 			return -2;
 
 		LOG(LOG_ERR, (""%s"", strerror(errno)));
		goto bail;
 	}
 
 	if (ret == 0) {
 		LOG(LOG_ERR, (""EOF while reading packet (len=%d)"", len));
		goto bail;
 	}
 
 	tmpbuf_pos += ret;
  read_packet(int fd, gss_buffer_t buf, int timeout, int first)
 	}
 
 	return -2;

bail:
	free(tmpbuf);
	tmpbuf = NULL;

	return -1;
 }
 
 static int","The read_packet function in knc (Kerberised NetCat) before 1.11-1 is vulnerable to denial of service (memory exhaustion) that can be exploited remotely without authentication, possibly affecting another services running on the targeted host."
1754,CVE-2017-7500,"  rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)
     }
 
      
    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
	struct stat dsb;
	 
	if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
	    uid_t fuid;
	     
	    if (sb.st_uid == 0 ||
			(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
			 sb.st_uid == fuid)) {
		sb = dsb;  
	    }
	}
     }
 
      ","It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege."
1755,CVE-2017-2616,"  create_watching_parent (void)
             }
           else
             status = WEXITSTATUS (status);

	   
	  child = (pid_t) -1;
         }
       else if (caught_signal)
         status = caught_signal + 128;
  create_watching_parent (void)
   else
     status = 1;
 
  if (caught_signal && child != (pid_t)-1)
     {
       fprintf (stderr, _(""\nSession terminated, killing shell...""));
       kill (child, SIGTERM);
  create_watching_parent (void)
 
   if (caught_signal)
     {
      if (child != (pid_t)-1)
	{
	  sleep (2);
	  kill (child, SIGKILL);
	  fprintf (stderr, _("" ...killed.\n""));
	}
 
       /* Let's terminate itself with the received signal.
        *",A race condition was found in util-linux before 2.32.1 in the way su handled the management of child processes. A local authenticated attacker could use this flaw to kill other processes with root privileges under specific conditions.
1756,CVE-2016-10544," 
 #include ""HTTPSocket.h""
 #include <openssl/sha.h>
 
static const int INFLATE_LESS_THAN_ROUGHLY = 16777216;

 namespace uWS {
 
 char *Hub::inflate(char *data, size_t &length) {
  char *Hub::inflate(char *data, size_t &length) {
         if (!inflationStream.avail_in) {
             break;
         }

         dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);
    } while (err == Z_BUF_ERROR && dynamicInflationBuffer.length() <= INFLATE_LESS_THAN_ROUGHLY);
 
     inflateReset(&inflationStream);
 
    if ((err != Z_BUF_ERROR && err != Z_OK) || dynamicInflationBuffer.length() > INFLATE_LESS_THAN_ROUGHLY) {
         length = 0;
         return nullptr;
     }","uws is a WebSocket server library. By sending a 256mb websocket message to a uws server instance with permessage-deflate enabled, there is a possibility used compression will shrink said 256mb down to less than 16mb of websocket payload which passes the length check of 16mb payload. This data will then inflate up to 256mb and crash the node process by exceeding V8's maximum string size. This affects uws >=0.10.0 <=0.10.8."
1757,CVE-2016-9586," 
 #  define mp_uintmax_t unsigned long
 #endif
 
#define BUFFSIZE 326  
 #define MAX_PARAMETERS 128  
 
 #ifdef __AMIGA__
  static int dprintf_formatf(
         *fptr = 0;
 
         if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
            
           len = curl_msnprintf(fptr, left, ""%ld"", width);
           fptr += len;
           left -= len;
         }
         if(prec >= 0) {
           
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = maxprec-1;
            
           len = curl_msnprintf(fptr, left, "".%ld"", prec);
           fptr += len;
  static int dprintf_formatf(
          
         (sprintf)(work, formatbuf, p->data.dnum);
#ifdef CURLDEBUG
        assert(strlen(work) <= sizeof(work));
#endif
         for(fptr=work; *fptr; fptr++)
           OUTCHAR(*fptr);
       }","curl before version 7.52.0 is vulnerable to a buffer overflow when doing a large floating point output in libcurl's implementation of the printf() functions. If there are any application that accepts a format string from the outside without necessary input filtering, it could allow remote attacks."
1758,CVE-2016-9583," 
 #define	JAS_CAST(t, e) \
 	((t) (e))
 
 
 
#define JAS_UINTFAST32_NUMBITS (8 * sizeof(uint_fast32_t))

 #ifdef __cplusplus
 extern ""C"" {
 #endif",An out-of-bounds heap read vulnerability was found in the jpc_pi_nextpcrl() function of jasper before 2.0.6 when processing crafted input.
1759,CVE-2016-7035,"  crm_client_disconnect_all(qb_ipcs_service_t *service)
 crm_client_t *
 crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
 {
     static gid_t gid_cluster = 0;
 
     crm_client_t *client = NULL;
  crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
     }
 
     if (gid_cluster == 0) {
         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {
             static bool have_error = FALSE;
             if(have_error == FALSE) {
  crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)
         }
     }
 
    if (uid_client != 0) {
         crm_trace(""Giving access to group %u"", gid_cluster);
         
        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
     }
 
     crm_client_init();","An authorization flaw was found in Pacemaker before 1.1.16, where it did not properly guard its IPC interface. An attacker with an unprivileged account on a Pacemaker node could use this flaw to, for example, force the Local Resource Manager daemon to execute a script as root and thereby gain root access on the machine."
1760,CVE-2015-9016," 
 
 #include ""blk.h""
 #include ""blk-mq.h""
#include ""blk-mq-tag.h""
 
  
 enum {
  static void flush_end_io(struct request *flush_rq, int error)
 	struct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);
 
 	if (q->mq_ops) {
		struct blk_mq_hw_ctx *hctx;

		 
 		spin_lock_irqsave(&fq->mq_flush_lock, flags);
		hctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);
		blk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);
 		flush_rq->tag = -1;
 	}
 
  static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)
 
 	 
 	if (q->mq_ops) {
		struct blk_mq_hw_ctx *hctx;

 		flush_rq->mq_ctx = first_rq->mq_ctx;
 		flush_rq->tag = first_rq->tag;
		fq->orig_rq = first_rq;

		hctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);
		blk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);
 	}
 
 	flush_rq->cmd_type = REQ_TYPE_FS;","In blk_mq_tag_to_rq in blk-mq.c in the upstream kernel, there is a possible use after free due to a race condition when a request has been previously freed by blk_mq_complete_request. This could lead to local escalation of privilege. Product: Android. Versions: Android kernel. Android ID: A-63083046."
1761,CVE-2019-1010319,"  int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
     int format_chunk = 0;
     uint32_t bcount;
 
    CLEAR (WaveHeader);
     infilesize = DoGetFileSize (infile);
     memcpy (&filehdr, fourcc, 4);
 ","WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseWave64HeaderConfig (wave64.c:211). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/33a0025d1d63ccd05d9dbaa6923d52b1446a62fe."
1762,CVE-2019-1010317,"  static struct {
 
 int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
            desc_chunk = 1;
 
             if (debug_logging_mode) {
                 char formatstr [5];
  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {      
             uint32_t mEditCount;
 
            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;","WavPack 5.1.0 and earlier is affected by: CWE-457: Use of Uninitialized Variable. The impact is: Unexpected control flow, crashes, and segfaults. The component is: ParseCaffHeaderConfig (caff.c:486). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/f68a9555b548306c5b1ee45199ccdc4a16a6101b."
1763,CVE-2019-1010315,"  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
 
             if (!strncmp (prop_chunk, ""SND "", 4)) {
                 char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                uint16_t numChannels = 0, chansSpecified, chanMask = 0;
                 uint32_t sampleRate;
 
                 while (eptr - cptr >= sizeof (dff_chunk_header)) {
  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
 
                             chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;
 
                            if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {
                                 error_line (""%s is not a valid .DFF file!"", infilename);
                                 free (prop_chunk);
                                 return WAVPACK_SOFT_ERROR;
  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
             free (prop_chunk);
         }
         else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {

            if (!config->num_channels) {
                error_line (""%s is not a valid .DFF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

             total_samples = dff_chunk_header.ckDataSize / config->num_channels;
             break;
         }",WavPack 5.1 and earlier is affected by: CWE 369: Divide by Zero. The impact is: Divide by zero can lead to sudden crash of a software/service that tries to parse a .wav file. The component is: ParseDsdiffHeaderConfig (dsdiff.c:282). The attack vector is: Maliciously crafted .wav file. The fixed version is: After commit https://github.com/dbry/WavPack/commit/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc.
1764,CVE-2019-1010298,"  TEE_Result syscall_asymm_operate(unsigned long state,
 	if (res != TEE_SUCCESS)
 		return res;
 
	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(utc, usr_params, num_params, params);
  TEE_Result syscall_asymm_verify(unsigned long state,
 	if (res != TEE_SUCCESS)
 		return res;
 
	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(utc, usr_params, num_params, params);",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Code execution in the context of TEE core (kernel). The component is: optee_os. The fixed version is: 3.4.0 and later.
1765,CVE-2019-1010297,"  TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,
 	if (key_size > type_props->max_size)
 		return TEE_ERROR_NOT_SUPPORTED;
 
	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,
  TEE_Result syscall_cryp_derive_key(unsigned long state,
 	if (res != TEE_SUCCESS)
 		return res;
 
	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(utc, usr_params, param_count, params);",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Execution of code in TEE core (kernel) context. The component is: optee_os. The fixed version is: 3.4.0 and later.
1766,CVE-2019-1010296," 
  */
 
 #include <assert.h>
#include <compiler.h>
 #include <crypto/crypto.h>
 #include <kernel/tee_ta_manager.h>
 #include <mm/tee_mmu.h>
  TEE_Result syscall_cryp_obj_populate(unsigned long obj,
 	if (!type_props)
 		return TEE_ERROR_NOT_IMPLEMENTED;
 
	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), attr_count, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	attrs = malloc(alloc_size);
 	if (!attrs)
 		return TEE_ERROR_OUT_OF_MEMORY;

 	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,
 			    attrs);
 	if (res != TEE_SUCCESS)",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Code execution in context of TEE core (kernel). The component is: optee_os. The fixed version is: 3.4.0 and later.
1767,CVE-2019-1010295,"  TEE_Result syscall_get_property_name_to_index(unsigned long prop_set,
 	return res;
 }
 
static TEE_Result utee_param_to_param(struct user_ta_ctx *utc,
				      struct tee_ta_param *p,
				      struct utee_params *up)
 {
 	size_t n;
 	uint32_t types = up->types;
  static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)
 	for (n = 0; n < TEE_NUM_PARAMS; n++) {
 		uintptr_t a = up->vals[n * 2];
 		size_t b = up->vals[n * 2 + 1];
		uint32_t flags = TEE_MEMORY_ACCESS_READ |
				 TEE_MEMORY_ACCESS_ANY_OWNER;
 
 		switch (TEE_PARAM_TYPE_GET(types, n)) {
 		case TEE_PARAM_TYPE_MEMREF_OUTPUT:
 		case TEE_PARAM_TYPE_MEMREF_INOUT:
			flags |= TEE_MEMORY_ACCESS_WRITE;
			 
		case TEE_PARAM_TYPE_MEMREF_INPUT:
 			p->u[n].mem.mobj = &mobj_virt;
 			p->u[n].mem.offs = a;
 			p->u[n].mem.size = b;
			if (tee_mmu_check_access_rights(utc, flags, a, b))
				return TEE_ERROR_ACCESS_DENIED;
 			break;
 		case TEE_PARAM_TYPE_VALUE_INPUT:
 		case TEE_PARAM_TYPE_VALUE_INOUT:
  static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)
 			break;
 		}
 	}

	return TEE_SUCCESS;
 }
 
 static TEE_Result alloc_temp_sec_mem(size_t size, struct mobj **mobj,
  static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess,
 			(uaddr_t)callee_params, sizeof(struct utee_params));
 		if (res != TEE_SUCCESS)
 			return res;
		res = utee_param_to_param(utc, param, callee_params);
		if (res != TEE_SUCCESS)
			return res;
 	}
 
 	if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) {",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Buffer Overflow. The impact is: Memory corruption and disclosure of memory content. The component is: optee_os. The fixed version is: 3.4.0 and later.
1768,CVE-2019-1010294,"  static struct mobj *alloc_ta_mem(size_t size)
 #else
 	struct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);
 
	if (mobj) {
		size_t granularity = BIT(tee_mm_sec_ddr.shift);

		 
		memset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity));
	}
 	return mobj;
 #endif
 }",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Rounding error. The impact is: Potentially leaking code and/or data from previous Trusted Application. The component is: optee_os. The fixed version is: 3.4.0 and later.
1769,CVE-2019-1010293,"  TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
 				       size_t len)
 {
 	uaddr_t a;
	uaddr_t end_addr = 0;
 	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
 			       CORE_MMU_USER_PARAM_SIZE);
 
	if (ADD_OVERFLOW(uaddr, len, &end_addr))
 		return TEE_ERROR_ACCESS_DENIED;
 
 	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
  TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
 	   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
 		return TEE_ERROR_ACCESS_DENIED;
 
	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
 		uint32_t attr;
 		TEE_Result res;
 ",Linaro/OP-TEE OP-TEE 3.3.0 and earlier is affected by: Boundary crossing. The impact is: Memory corruption of the TEE itself. The component is: optee_os. The fixed version is: 3.4.0 and later.
1770,CVE-2019-1010292,"  static TEE_Result set_tmem_param(const struct optee_msg_param_tmem *tmem,
 static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,
 				 struct param_mem *mem)
 {
	size_t req_size = 0;
 	uint64_t shm_ref = READ_ONCE(rmem->shm_ref);
 
 	mem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);
  static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,
 	mem->offs = READ_ONCE(rmem->offs);
 	mem->size = READ_ONCE(rmem->size);
 
	 
	if (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||
	    mem->mobj->size < req_size)
		return TEE_ERROR_SECURITY;

 	return TEE_SUCCESS;
 }
 ",Linaro/OP-TEE OP-TEE Prior to version v3.4.0 is affected by: Boundary checks. The impact is: This could lead to corruption of any memory which the TA can access. The component is: optee_os. The fixed version is: v3.4.0.
1771,CVE-2019-1010279,"  static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,
 
     if (pflow != NULL) {
          
        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL &&
            (p->flags & PKT_STREAM_EST))
        {
             StreamReassembleRawUpdateProgress(pflow->protoctx, p,
                     det_ctx->raw_stream_progress);
 ",Open Information Security Foundation Suricata prior to version 4.1.3 is affected by: Denial of Service - TCP/HTTP detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed sequence of network packets. The component is: detect.c (https://github.com/OISF/suricata/pull/3625/commits/d8634daf74c882356659addb65fb142b738a186b). The attack vector is: An attacker can trigger the vulnerability by a specifically crafted network TCP session. The fixed version is: 4.1.3.
1772,CVE-2019-1010251,"  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
     SCEnter();
 
     uint8_t *orig_pkt = pkt;
    uint8_t nh = IPV6_GET_NH(p);  
     uint16_t hdrextlen = 0;
    uint16_t plen = len;
     char dstopts = 0;
     char exthdr_fh_done = 0;
     int hh = 0;
     int rh = 0;
     int eh = 0;
     int ah = 0;
 
     while(1)
     {
        if (nh == IPPROTO_NONE) {
            if (plen > 0) {
                 
                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);
            }
             SCReturn;
         }
 
         if (plen < 2) {  
            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
             SCReturn;
         }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                 SCLogDebug(""hdrextlen %""PRIu8, hdrextlen);
 
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                 IPV6_SET_L4PROTO(p,nh);
                 hdrextlen =  (*(pkt+1) + 1) << 3;
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                 if (optslen > plen) {
                      
                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                      
                     nh = *pkt;
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                     }
 
                     if (offset + 1 >= optslen) {
                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                         break;
                     }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
 
                      
                     if ((offset + 1 + ip6_optlen) > optslen) {
                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                         break;
                     }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                         ra->ip6ra_len  = ip6_optlen;
 
                         if (ip6_optlen < sizeof(ra->ip6ra_value)) {
                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                             break;
                         }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                         jumbo->ip6j_len  = ip6_optlen;
 
                         if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {
                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                             break;
                         }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                         hao->ip6hao_len  = ip6_optlen;
 
                         if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {
                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                             break;
                         }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                 uint16_t prev_hdrextlen = hdrextlen;
                 hdrextlen = sizeof(IPV6FragHdr);
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                 IPV6_SET_L4PROTO(p,nh);
                 hdrextlen = sizeof(IPV6EspHdr);
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
                 SCLogDebug(""hdrextlen %""PRIu8, hdrextlen);
 
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
  DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt
             case IPPROTO_SHIM6:
                 hdrextlen = 8 + (*(pkt+1) * 8);   
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
                 nh = *pkt;","Open Information Security Foundation Suricata prior to version 4.1.2 is affected by: Denial of Service - DNS detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed network packet. The component is: app-layer-detect-proto.c, decode.c, decode-teredo.c and decode-ipv6.c (https://github.com/OISF/suricata/pull/3590/commits/11f3659f64a4e42e90cb3c09fcef66894205aefe, https://github.com/OISF/suricata/pull/3590/commits/8357ef3f8ffc7d99ef6571350724160de356158b). The attack vector is: An attacker can trigger the vulnerability by sending a specifically crafted network request. The fixed version is: 4.1.2."
1773,CVE-2019-1010239,"  static cJSON *get_object_item(const cJSON * const object, const char * const nam
     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
  static cJSON *get_object_item(const cJSON * const object, const char * const nam
         }
     }
 
    if ((current_element == NULL) || (current_element->string == NULL)) {
        return NULL;
    }

     return current_element;
 }
 ","DaveGamble/cJSON cJSON 1.7.8 is affected by: Improper Check for Unusual or Exceptional Conditions. The impact is: Null dereference, so attack can cause denial of service. The component is: cJSON_GetObjectItemCaseSensitive() function. The attack vector is: crafted json file. The fixed version is: 1.7.9 and later."
1774,CVE-2019-1010208,"  NTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Ex
 			UNICODE_STRING FullFileName;
 			IO_STATUS_BLOCK IoStatus;
 			LARGE_INTEGER offset;
			size_t devicePathLen = 0;
 
 			if (!ValidateIOBufferSize (Irp, sizeof (GetSystemDriveConfigurationRequest), ValidateInputOutput))
 				break;
 
			 
			if (	!NT_SUCCESS (RtlUnalignedStringCchLengthW (request->DevicePath, TC_MAX_PATH, &devicePathLen))
				||	(devicePathLen < 28)  
				||	(devicePathLen > 30)  
				||	(memcmp (request->DevicePath, L""\\Device\\Harddisk"", 16 * sizeof (WCHAR)))
				||	(memcmp (&request->DevicePath[devicePathLen - 11], L""\\Partition0"", 11 * sizeof (WCHAR)))
				)
			{
				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
				Irp->IoStatus.Information = 0;
				break;
			}

 			EnsureNullTerminatedString (request->DevicePath, sizeof (request->DevicePath));
 			RtlInitUnicodeString (&FullFileName, request->DevicePath);
 
  NTSTATUS ProcessMainDeviceControlIrp (PDEVICE_OBJECT DeviceObject, PEXTENSION Ex
 
 			if (NT_SUCCESS (ntStatus))
 			{
				byte *readBuffer = TCalloc (TC_MAX_VOLUME_SECTOR_SIZE);
				if (!readBuffer)
 				{
					Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
					Irp->IoStatus.Information = 0;
				}
				else
				{
					 
					offset.QuadPart = 0;	 
 
					ntStatus = ZwReadFile (NtFileHandle,
						NULL,
						NULL,
						NULL,
						&IoStatus,
						readBuffer,
						TC_MAX_VOLUME_SECTOR_SIZE,
						&offset,
						NULL);
 
					if (NT_SUCCESS (ntStatus))
 					{
						 
						if (IoStatus.Information >= TC_SECTOR_SIZE_BIOS)
 						{
							size_t i;

							 
							request->DriveIsDynamic = FALSE;

							if (readBuffer[510] == 0x55 && readBuffer[511] == 0xaa)
 							{
								int i;
								for (i = 0; i < 4; ++i)
								{
									if (readBuffer[446 + i * 16 + 4] == PARTITION_LDM)
									{
										request->DriveIsDynamic = TRUE;
										break;
									}
								}
 							}
 
							request->BootLoaderVersion = 0;
							request->Configuration = 0;
							request->UserConfiguration = 0;
							request->CustomUserMessage[0] = 0;
 
							 
							for (i = 0; i < sizeof (readBuffer) - strlen (TC_APP_NAME); ++i)
 							{
								if (memcmp (readBuffer + i, TC_APP_NAME, strlen (TC_APP_NAME)) == 0)
								{
									request->BootLoaderVersion = BE16 (*(uint16 *) (readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET));
									request->Configuration = readBuffer[TC_BOOT_SECTOR_CONFIG_OFFSET];

									if (request->BootLoaderVersion != 0 && request->BootLoaderVersion <= VERSION_NUM)
									{
										request->UserConfiguration = readBuffer[TC_BOOT_SECTOR_USER_CONFIG_OFFSET];
										memcpy (request->CustomUserMessage, readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET, TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH);
									}
									break;
								}
 							}

							Irp->IoStatus.Status = STATUS_SUCCESS;
							Irp->IoStatus.Information = sizeof (*request);
						}
						else
						{
							Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
							Irp->IoStatus.Information = 0;
 						}
 					}
					else
					{
						Irp->IoStatus.Status = ntStatus;
						Irp->IoStatus.Information = 0;
					}
 
					TCfree (readBuffer);
 				}
 
 				ZwClose (NtFileHandle);","IDRIX, Truecrypt Veracrypt, Truecrypt Prior to 1.23-Hotfix-1 (Veracrypt), all versions (Truecrypt) is affected by: Buffer Overflow. The impact is: Minor information disclosure of kernel stack. The component is: Veracrypt NT Driver (veracrypt.sys). The attack vector is: Locally executed code, IOCTL request to driver. The fixed version is: 1.23-Hotfix-1."
1775,CVE-2019-1010065,"  hfs_cat_traverse(HFS_INFO * hfs,
                 size_t rec_off;
                 hfs_btree_key_cat *key;
                 uint8_t retval;
                int keylen;
 
                  
                 rec_off =
  hfs_cat_traverse(HFS_INFO * hfs,
                 size_t rec_off;
                 hfs_btree_key_cat *key;
                 uint8_t retval;
                int keylen;
 
                  
                 rec_off =","The Sleuth Kit 4.6.0 and earlier is affected by: Integer Overflow. The impact is: Opening crafted disk image triggers crash in tsk/fs/hfs_dent.c:237. The component is: Overflow in fls tool used on HFS image. Bug is in tsk/fs/hfs.c file in function hfs_cat_traverse() in lines: 952, 1062. The attack vector is: Victim must open a crafted HFS filesystem image."
1776,CVE-2019-1000020,"  parse_rockridge(struct archive_read *a, struct file_info *file,
     const unsigned char *p, const unsigned char *end)
 {
 	struct iso9660 *iso9660;
	int entry_seen = 0;
 
 	iso9660 = (struct iso9660 *)(a->format->data);
 
  parse_rockridge(struct archive_read *a, struct file_info *file,
 		}
 
 		p += p[2];
		entry_seen = 1;
	}

	if (entry_seen)
		return (ARCHIVE_OK);
	else {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
				  ""Tried to parse Rockridge extensions, but none found"");
		return (ARCHIVE_WARN);
 	}
 }
 
 static int","libarchive version commit 5a98dcf8a86364b3c2c469c85b93647dfb139961 onwards (version v2.8.0 onwards) contains a CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in ISO9660 parser, archive_read_support_format_iso9660.c, read_CE()/parse_rockridge() that can result in DoS by infinite loop. This attack appears to be exploitable via the victim opening a specially crafted ISO9660 file."
1777,CVE-2019-1000019,"  get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,
 	if (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {
 		 
 
		*buff = __archive_read_ahead(a, minimum, &bytes_avail);
 		if (bytes_avail <= 0) {
 			archive_set_error(&a->archive,
 			    ARCHIVE_ERRNO_FILE_FORMAT,","libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service). This attack appears to be exploitable via the victim opening a specially crafted 7zip file."
1778,CVE-2019-17547,"  static MagickBooleanType TraceBezier(MVGInfo *mvg_info,
         quantum=(size_t) alpha;
     }
   }
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);
   coefficients=(double *) AcquireQuantumMemory(number_coordinates,
     sizeof(*coefficients));
   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*
  static MagickBooleanType TraceBezier(MVGInfo *mvg_info,
       coefficients=(double *) RelinquishMagickMemory(coefficients);
       return(MagickFalse);
     }
  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
    ","In ImageMagick before 7.0.8-62, TraceBezier in MagickCore/draw.c has a use-after-free."
1779,CVE-2019-17546,"  gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 	fromskew = (w < imagewidth ? imagewidth - w : 0);
 	for (row = 0; row < h; row += nrow)
 	{
		uint32 temp;
 		rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
 		nrow = (row + rowstoread > h ? h - row : rowstoread);
 		nrowsub = nrow;
 		if ((nrowsub%subsamplingver)!=0)
 			nrowsub+=subsamplingver-nrowsub%subsamplingver;
		temp = (row + img->row_offset)%rowsperstrip + nrowsub;
		if( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )
		{
			TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""Integer overflow in gtStripContig"");
			return 0;
		}
 		if (_TIFFReadEncodedStripAndAllocBuffer(tif,
 		    TIFFComputeStrip(tif,row+img->row_offset, 0),
 		    (void**)(&buf),
                     maxstripsize,
		    temp * scanline)==(tmsize_t)(-1)
 		    && (buf == NULL || img->stoponerr))
 		{
 			ret = 0;
  gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 	fromskew = (w < imagewidth ? imagewidth - w : 0);
 	for (row = 0; row < h; row += nrow)
 	{
                uint32 temp;
 		rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;
 		nrow = (row + rowstoread > h ? h - row : rowstoread);
 		offset_row = row + img->row_offset;
                temp = (row + img->row_offset)%rowsperstrip + nrow;
                if( scanline > 0 && temp > (size_t)(TIFF_TMSIZE_T_MAX / scanline) )
                {
                        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""Integer overflow in gtStripSeparate"");
                        return 0;
                }
                 if( buf == NULL )
                 {
                     if (_TIFFReadEncodedStripAndAllocBuffer(
                             tif, TIFFComputeStrip(tif, offset_row, 0),
                             (void**) &buf, bufsize,
                            temp * scanline)==(tmsize_t)(-1)
                         && (buf == NULL || img->stoponerr))
                     {
                             ret = 0;
  gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
                     }
                 }
 		else if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),
		    p0, temp * scanline)==(tmsize_t)(-1)
 		    && img->stoponerr)
 		{
 			ret = 0;
 			break;
 		}
 		if (colorchannels > 1 
                     && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),
                                            p1, temp * scanline) == (tmsize_t)(-1)
 		    && img->stoponerr)
 		{
 			ret = 0;
 			break;
 		}
 		if (colorchannels > 1 
                     && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),
                                            p2, temp * scanline) == (tmsize_t)(-1)
 		    && img->stoponerr)
 		{
 			ret = 0;
  gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)
 		if (alpha)
 		{
 			if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels),
			    pa, temp * scanline)==(tmsize_t)(-1)
 			    && img->stoponerr)
 			{
 				ret = 0;","tif_getimage.c in LibTIFF through 4.0.10, as used in GDAL through 3.0.1 and other products, has an integer overflow that potentially causes a heap-based buffer overflow via a crafted RGBA image, related to a *Negative-size-param* condition."
1780,CVE-2019-17545,"  static void* OGRExpatRealloc( void *ptr, size_t size )
     if( CanAlloc(size) )
         return realloc(ptr, size);
 
     return nullptr;
 }
 ",GDAL through 3.0.1 has a poolDestroy double free in OGRExpatRealloc in ogr/ogr_expat.cpp when the 10MB threshold is exceeded.
1781,CVE-2019-17544,"  namespace acommon {
       }
       res.append(':');
     }
    if (!res.empty() && res.back() == ':') res.pop_back();
   }
 
   struct ListAddHelper : public AddableContainer ",libaspell.a in GNU Aspell before 0.60.8 has a stack-based buffer over-read in acommon::unescape in common/getdata.cpp via an isolated  character.
1782,CVE-2019-17542,"  static av_cold int vqa_decode_init(AVCodecContext *avctx)
     }
     s->width = AV_RL16(&s->avctx->extradata[6]);
     s->height = AV_RL16(&s->avctx->extradata[8]);
    if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {
         s->width= s->height= 0;
         return ret;
     }",FFmpeg before 4.2 has a heap-based buffer overflow in vqa_decode_chunk because of an out-of-array access in vqa_decode_init in libavcodec/vqavideo.c.
1783,CVE-2019-17539,"  FF_ENABLE_DEPRECATION_WARNINGS
 
     return ret;
 free_and_end:
    if (avctx->codec && avctx->codec->close &&
         (codec_init_ok ||
          (avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))
         avctx->codec->close(avctx);","In FFmpeg before 4.2, avcodec_open2 in libavcodec/utils.c allows a NULL pointer dereference and possibly unspecified other impact when there is no valid close function pointer."
1784,CVE-2019-17534,"  vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif )
 {
 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
 	GifFileType *file = gif->file;
 
	ColorMapObject *map;
 	GifByteType *extension;
 
 	if( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {
  vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif )
 
 	 
	map = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap;
 	if( !gif->has_colour &&
 		map ) {
 		int i;","vips_foreign_load_gif_scan_image in foreign/gifload.c in libvips before 8.8.2 tries to access a color map before a DGifGetImageDesc call, leading to a use-after-free."
1785,CVE-2019-17533,"  Mat_VarReadNextInfo4(mat_t *mat)
     if ( tmp != readresult ) {
         Mat_VarFree(matvar);
         return NULL;
    } else {
        matvar->name[tmp - 1] = '\0';
     }
 
     matvar->internal->datapos = ftell((FILE*)mat->fp);","Mat_VarReadNextInfo4 in mat4.c in MATIO 1.5.17 omits a certain '0' character, leading to a heap-based buffer over-read in strdup_vprintf when uninitialized memory is accessed."
1786,CVE-2019-17351,"  static void balloon_process(struct work_struct *work)
 				state = reserve_additional_memory();
 		}
 
		if (credit < 0) {
			long n_pages;

			n_pages = min(-credit, si_mem_available());
			state = decrease_reservation(n_pages, GFP_BALLOON);
			if (state == BP_DONE && n_pages != -credit &&
			    n_pages < totalreserve_pages)
				state = BP_EAGAIN;
		}
 
 		state = update_schedule(state);
 
  static int add_ballooned_pages(int nr_pages)
 		}
 	}
 
	if (si_mem_available() < nr_pages)
		return -ENOMEM;

 	st = decrease_reservation(nr_pages, GFP_USER);
 	if (st != BP_DONE)
 		return -ENOMEM;
  static int __init balloon_init(void)
 	balloon_stats.schedule_delay = 1;
 	balloon_stats.max_schedule_delay = 32;
 	balloon_stats.retry_count = 1;
	balloon_stats.max_retry_count = 4;
 
 #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG
 	set_online_page_callback(&xen_online_page);","An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7."
1787,CVE-2019-17178," 
 LPSTR tr_esc_str(LPCSTR arg, bool format)
 {
 	LPSTR tmp = NULL;
	LPSTR tmp2 = NULL;
 	size_t cs = 0, x, ds, len;
 	size_t s;
 
  LPSTR tr_esc_str(LPCSTR arg, bool format)
 	ds = s + 1;
 
 	if (s)
	{
		tmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));
		if (!tmp2)
			free(tmp);
		tmp = tmp2;
	}
 
 	if (NULL == tmp)
 	{
  LPSTR tr_esc_str(LPCSTR arg, bool format)
 			case '<':
 				len = format ? 13 : 4;
 				ds += len - 1;
				tmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));
				if (!tmp2)
					free(tmp);
				tmp = tmp2;
 
 				if (NULL == tmp)
 				{
  LPSTR tr_esc_str(LPCSTR arg, bool format)
 			case '>':
 				len = format ? 14 : 4;
 				ds += len - 1;
				tmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));
				if (!tmp2)
					free(tmp);
				tmp = tmp2;
 
 				if (NULL == tmp)
 				{
  LPSTR tr_esc_str(LPCSTR arg, bool format)
 
 			case '\'':
 				ds += 5;
				tmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));
				if (!tmp2)
					free(tmp);
				tmp = tmp2;
 
 				if (NULL == tmp)
 				{
  LPSTR tr_esc_str(LPCSTR arg, bool format)
 
 			case '""':
 				ds += 5;
				tmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));
				if (!tmp2)
					free(tmp);
				tmp = tmp2;
 
 				if (NULL == tmp)
 				{
  LPSTR tr_esc_str(LPCSTR arg, bool format)
 
 			case '&':
 				ds += 4;
				tmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));
				if (!tmp2)
					free(tmp);
				tmp = tmp2;
 
 				if (NULL == tmp)
 				{","HuffmanTree_makeFromFrequencies in lodepng.c in LodePNG through 2019-09-28, as used in WinPR in FreeRDP and other products, has a memory leak because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value."
1788,CVE-2019-17113,"  LIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)
 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
 
 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_instrument_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
 
 LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)","In libopenmpt before 0.3.19 and 0.4.x before 0.4.9, ModPlug_InstrumentName and ModPlug_SampleName in libopenmpt_modplug.c do not restrict the lengths of libmodplug output-buffer strings in the C API, leading to a buffer overflow."
1789,CVE-2019-16995,"  int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 
 	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);
 	if (res)
		goto err_add_port;
 
 	res = register_netdevice(hsr_dev);
 	if (res)
  int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 fail:
 	hsr_for_each_port(hsr, port)
 		hsr_del_port(port);
err_add_port:
	hsr_del_node(&hsr->self_node_db);
 
 	return res;
 }","In the Linux kernel before 5.0.3, a memory leak exits in hsr_dev_finalize() in net/hsr/hsr_device.c if hsr_add_port fails to add a port, which may cause denial of service, aka CID-6caabe7f197d."
1790,CVE-2019-16994,"  static int __net_init sit_init_net(struct net *net)
 
 err_reg_dev:
 	ipip6_dev_free(sitn->fb_tunnel_dev);
	free_netdev(sitn->fb_tunnel_dev);
 err_alloc_dev:
 	return err;
 }","In the Linux kernel before 5.0, a memory leak exists in sit_init_net() in net/ipv6/sit.c when register_netdev() fails to register sitn->fb_tunnel_dev, which may cause denial of service, aka CID-07f12b26e21a."
1791,CVE-2019-16930,"  boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(
     }
 
      
    try {
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss << pt.get();
 
        SaplingOutgoingPlaintext ret;
        ss >> ret;
 
        assert(ss.size() == 0);
 
        return ret;
    } catch (const boost::thread_interrupted&) {
        throw;
    } catch (...) {
        return boost::none;
    }
 }
 
 boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(
  boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(
     }
 
      
     SaplingNotePlaintext ret;
    try {
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss << pt.get();
        ss >> ret;
        assert(ss.size() == 0);
    } catch (const boost::thread_interrupted&) {
        throw;
    } catch (...) {
        return boost::none;
    }
 
     uint256 pk_d;
     if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {
  boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(
     }
 
      
     SaplingNotePlaintext ret;
    try {
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss << pt.get();
        ss >> ret;
        assert(ss.size() == 0);
    } catch (const boost::thread_interrupted&) {
        throw;
    } catch (...) {
        return boost::none;
    }
 
     uint256 cmu_expected;
     if (!librustzcash_sapling_compute_cm(
  boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt(
         return boost::none;
     }
 
     return ret;
 }
 ","Zcashd in Zcash before 2.0.7-3 allows discovery of the IP address of a full node that owns a shielded address, related to mishandling of exceptions during deserialization of note plaintexts. This affects anyone who has disclosed their zaddr to a third party."
1792,CVE-2019-16921,"  static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,
 {
 	int ret = 0;
 	struct hns_roce_ucontext *context;
	struct hns_roce_ib_alloc_ucontext_resp resp = {};
 	struct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);
 
 	resp.qp_tab_size = hr_dev->caps.num_qps;","In the Linux kernel before 4.17, hns_roce_alloc_ucontext in drivers/infiniband/hw/hns/hns_roce_main.c does not initialize the resp data structure, which might allow attackers to obtain sensitive information from kernel stack memory, aka CID-df7e40425813."
1793,CVE-2019-16718,"  static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek
 				cmd = sc + 1;
 				continue;
 			}
			char op0 = 0;
 			if (*p) {
 				 
 				if (p[0] == '@') {
  static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek
 				if (p[1] == '@' || (p[1] && p[2] == '@')) {
 					char *q = strchr (p + 1, '""');
 					if (q) {
						op0 = *q;
 						*q = 0;
 					}
 					haveQuote = q != NULL;
  static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon, bool *tmpseek
 					cmd = p + 1;
 				} else {
 					if (*p == '""') {
						cmd = p;
 					} else {
						*p = op0;
 						cmd = p;
 					}
 				}","In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables."
1794,CVE-2019-16714," 
 /*
 * Copyright (c) 2006, 2019 Oracle and/or its affiliates. All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
  void rds6_inc_info_copy(struct rds_incoming *inc,
 
 	minfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);
 	minfo6.len = be32_to_cpu(inc->i_hdr.h_len);
	minfo6.tos = inc->i_conn->c_tos;
 
 	if (flip) {
 		minfo6.laddr = *daddr;
  void rds6_inc_info_copy(struct rds_incoming *inc,
 		minfo6.fport = inc->i_hdr.h_dport;
 	}
 
	minfo6.flags = 0;

 	rds_info_copy(iter, &minfo6, sizeof(minfo6));
 }
 #endif","In the Linux kernel before 5.2.14, rds6_inc_info_copy in net/rds/recv.c allows attackers to obtain sensitive information from kernel stack memory because tos and flags fields are not initialized."
1795,CVE-2019-16163,"  parse_char_class(Node** np, PToken* tok, UChar** src, UChar* end, ScanEnv* env)
   env->parse_depth++;
   if (env->parse_depth > ParseDepthLimit)
     return ONIGERR_PARSE_DEPTH_LIMIT_OVER;

   prev_cc = (CClassNode* )NULL;
   r = fetch_token_in_cc(tok, src, end, env);
   if (r == TK_CHAR && tok->u.c == '^' && tok->escaped == 0) {
  static int
 parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,
           ScanEnv* env, int group_head)
 {
  int r, len, group;
   Node* qn;
   Node** tp;
  unsigned int parse_depth;
 
  group = 0;
   *np = NULL;
   if (tok->type == (enum TokenSyms )term)
     goto end_of_token;
 
  parse_depth = env->parse_depth;

   switch (tok->type) {
   case TK_ALT:
   case TK_EOT:
  parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,
       if (is_invalid_quantifier_target(*tp))
         return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;
 
      parse_depth++;
      if (parse_depth > ParseDepthLimit)
        return ONIGERR_PARSE_DEPTH_LIMIT_OVER;

       qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,
                                r == TK_INTERVAL);
       CHECK_NULL_RETURN_MEMERR(qn);",Oniguruma before 6.9.3 allows Stack Exhaustion in regcomp.c because of recursion in regparse.c.
1796,CVE-2019-16161,"  fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
 
 	  if (c == 'R' || c == '0') {
 	    PINC;    
	    if (!PPEEK_IS(')')) {
	      r = ONIGERR_INVALID_GROUP_NAME;
	      onig_scan_env_set_error_string(env, r, p - 1, p + 1);
	      return r;
	    }
 	    PINC;    
 	    name_end = name = p;
 	    gnum = 0;",Onigmo through 6.2.0 has a NULL pointer dereference in onig_error_code_to_str because of fetch_token in regparse.c.
1797,CVE-2019-16058," 
 #include <openssl/crypto.h>
 #include <libp11.h>
 #include <regex.h>
#include <stdlib.h>
 
  
 #ifndef HAVE_EVP_MD_CTX_NEW
  static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)
 {
 	int ok = 0;
 	unsigned char challenge[30];
	unsigned char *signature = NULL;
	unsigned int siglen;
 	const EVP_MD *md = EVP_sha1();
 	EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();
 	EVP_PKEY *privkey = PKCS11_get_private_key(authkey);
 	EVP_PKEY *pubkey = PKCS11_get_public_key(authkey);
 
	if (NULL == privkey)
		goto err;
	siglen = EVP_PKEY_size(privkey);
	if (siglen <= 0)
		goto err;
	signature = malloc(siglen);
	if (NULL == signature)
		goto err;

 	/* Verify a SHA-1 hash of random data, signed by the key.
 	 *
 	 * Note that this will not work keys that aren't eligible for signing.
  static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)
 	ok = 1;
 
 err:
	free(signature);
 	if (NULL != pubkey)
 		EVP_PKEY_free(pubkey);
 	if (NULL != privkey)","An issue was discovered in the pam_p11 component 0.2.0 and 0.3.0 for OpenSC. If a smart card creates a signature with a length longer than 256 bytes, this triggers a buffer overflow. This may be the case for RSA keys with 4096 bits depending on the signature scheme."
1798,CVE-2019-15946,"  static int asn1_decode_entry(sc_context_t *ctx,struct sc_asn1_entry *entry,
 
 			 
 			if ((entry->flags & SC_ASN1_UNSIGNED)
					&& objlen > 1 && obj[0] == 0x00) {
 				objlen--;
 				obj++;
 			}",OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Octet string in asn1_decode_entry in libopensc/asn1.c.
1799,CVE-2019-15945,"  static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
 {
 	const u8 *in = inbuf;
 	u8 *out = (u8 *) outbuf;
 	int i, count = 0;
	int zero_bits;
	size_t octets_left;
 
 	if (outlen < octets_left)
 		return SC_ERROR_BUFFER_TOO_SMALL;
 	if (inlen < 1)
 		return SC_ERROR_INVALID_ASN1_OBJECT;

	zero_bits = *in & 0x07;
	octets_left = inlen - 1;
	in++;
	memset(outbuf, 0, outlen);

 	while (octets_left) {
 		 
 		 ",OpenSC before 0.20.0-rc1 has an out-of-bounds access of an ASN.1 Bitstring in decode_bit_string in libopensc/asn1.c.
1800,CVE-2019-15924,"  static int __init fm10k_init_module(void)
 	 
 	fm10k_workqueue = alloc_workqueue(""%s"", WQ_MEM_RECLAIM, 0,
 					  fm10k_driver_name);
	if (!fm10k_workqueue)
		return -ENOMEM;
 
 	fm10k_dbg_init();
 ",An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure.
1801,CVE-2019-15923,"  static void pcd_init_units(void)
 		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
 						   1, BLK_MQ_F_SHOULD_MERGE);
 		if (IS_ERR(disk->queue)) {
			put_disk(disk);
 			disk->queue = NULL;
 			continue;
 		}
  static int pcd_detect(void)
 
 	printk(""%s: No CD-ROM drive found\n"", name);
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (!cd->disk)
			continue;
 		blk_cleanup_queue(cd->disk->queue);
 		cd->disk->queue = NULL;
 		blk_mq_free_tag_set(&cd->tag_set);
  static int __init pcd_init(void)
 	pcd_probe_capabilities();
 
 	if (register_blkdev(major, name)) {
		for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
			if (!cd->disk)
				continue;

			blk_cleanup_queue(cd->disk->queue);
			blk_mq_free_tag_set(&cd->tag_set);
 			put_disk(cd->disk);
		}
 		return -EBUSY;
 	}
 
  static void __exit pcd_exit(void)
 	int unit;
 
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
		if (!cd->disk)
			continue;

 		if (cd->present) {
 			del_gendisk(cd->disk);
 			pi_release(cd->pi);",An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.
1802,CVE-2019-15922,"  static int pf_detect(void)
 
 	printk(""%s: No ATAPI disk detected\n"", name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		if (!pf->disk)
			continue;
 		blk_cleanup_queue(pf->disk->queue);
 		pf->disk->queue = NULL;
 		blk_mq_free_tag_set(&pf->tag_set);
  static int __init pf_init(void)
 	pf_busy = 0;
 
 	if (register_blkdev(major, name)) {
		for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
			if (!pf->disk)
				continue;
			blk_cleanup_queue(pf->disk->queue);
			blk_mq_free_tag_set(&pf->tag_set);
 			put_disk(pf->disk);
		}
 		return -EBUSY;
 	}
 
  static void __exit pf_exit(void)
 	int unit;
 	unregister_blkdev(major, name);
 	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		if (!pf->disk)
			continue;

 		if (pf->present)
 			del_gendisk(pf->disk);
 ",An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a pf data structure if alloc_disk fails in drivers/block/paride/pf.c.
1803,CVE-2019-15921,"  int genl_register_family(struct genl_family *family)
 			       start, end + 1, GFP_KERNEL);
 	if (family->id < 0) {
 		err = family->id;
		goto errout_free;
 	}
 
 	err = genl_validate_assign_mc_groups(family);
  int genl_register_family(struct genl_family *family)
 
 errout_remove:
 	idr_remove(&genl_fam_idr, family->id);
errout_free:
 	kfree(family->attrbuf);
 errout_locked:
 	genl_unlock_all();",An issue was discovered in the Linux kernel before 5.0.6. There is a memory leak issue when idr_alloc() fails in genl_register_family() in net/netlink/genetlink.c.
1804,CVE-2019-15920,"  SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,
 	rqst.rq_nvec = 1;
 
 	rc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);
 	rsp = (struct smb2_read_rsp *)rsp_iov.iov_base;
 
 	if (rc) {
  SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,
 				    io_parms->tcon->tid, ses->Suid,
 				    io_parms->offset, io_parms->length);
 
	cifs_small_buf_release(req);

 	*nbytes = le32_to_cpu(rsp->DataLength);
 	if ((*nbytes > CIFS_MAX_MSGSIZE) ||
 	    (*nbytes > io_parms->length)) {","An issue was discovered in the Linux kernel before 5.0.10. SMB2_read in fs/cifs/smb2pdu.c has a use-after-free. NOTE: this was not fixed correctly in 5.0.10; see the 5.0.11 ChangeLog, which documents a memory leak."
1805,CVE-2019-15919,"  SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,
 
 	rc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,
 			    &resp_buftype, flags, &rsp_iov);
 	rsp = (struct smb2_write_rsp *)rsp_iov.iov_base;
 
 	if (rc) {
  SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,
 				     io_parms->offset, *nbytes);
 	}
 
	cifs_small_buf_release(req);
 	free_rsp_buf(resp_buftype, rsp);
 	return rc;
 }",An issue was discovered in the Linux kernel before 5.0.10. SMB2_write in fs/cifs/smb2pdu.c has a use-after-free.
1806,CVE-2019-15918,"  SMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)
 		} else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) {
 			 
 			ses->server->ops = &smb21_operations;
			ses->server->vals = &smb21_values;
		} else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) {
 			ses->server->ops = &smb311_operations;
			ses->server->vals = &smb311_values;
		}
 	} else if (le16_to_cpu(rsp->DialectRevision) !=
 				ses->server->vals->protocol_id) {
 		 ",An issue was discovered in the Linux kernel before 5.0.10. SMB2_negotiate in fs/cifs/smb2pdu.c has an out-of-bounds read because data structures are incompletely updated after a change from smb30 to smb21.
1807,CVE-2019-15917,"  static int hci_uart_set_proto(struct hci_uart *hu, int id)
 		return -EPROTONOSUPPORT;
 
 	hu->proto = p;
 
 	err = hci_uart_register_dev(hu);
 	if (err) {
 		return err;
 	}
 
	set_bit(HCI_UART_PROTO_READY, &hu->flags);
 	return 0;
 }
 ",An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c.
1808,CVE-2019-15903,"  static enum XML_Error initializeEncoding(XML_Parser parser);
 static enum XML_Error doProlog(XML_Parser parser, const ENCODING *enc,
                                const char *s, const char *end, int tok,
                                const char *next, const char **nextPtr,
                               XML_Bool haveMore, XML_Bool allowClosingDoctype);
 static enum XML_Error processInternalEntity(XML_Parser parser, ENTITY *entity,
                                             XML_Bool betweenDecl);
 static enum XML_Error doContent(XML_Parser parser, int startTagLevel,
  externalParEntProcessor(XML_Parser parser, const char *s, const char *end,
 
   parser->m_processor = prologProcessor;
   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
 }
 
 static enum XML_Error PTRCALL
  prologProcessor(XML_Parser parser, const char *s, const char *end,
   const char *next = s;
   int tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
 }
 
 static enum XML_Error
 doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,
         int tok, const char *next, const char **nextPtr, XML_Bool haveMore,
         XML_Bool allowClosingDoctype) {
 #ifdef XML_DTD
   static const XML_Char externalSubsetName[] = {ASCII_HASH, '\0'};
 #endif  
  doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,
       }
       break;
     case XML_ROLE_DOCTYPE_CLOSE:
      if (allowClosingDoctype != XML_TRUE) {
         
        return XML_ERROR_INVALID_TOKEN;
      }

       if (parser->m_doctypeName) {
         parser->m_startDoctypeDeclHandler(
             parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,
  processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {
     int tok
         = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
                      tok, next, &next, XML_FALSE, XML_FALSE);
   } else
 #endif  
     result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,
  internalEntityProcessor(XML_Parser parser, const char *s, const char *end,
     int tok
         = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
                      tok, next, &next, XML_FALSE, XML_TRUE);
   } else
 #endif  
     result = doContent(parser, openEntity->startTagLevel,
  internalEntityProcessor(XML_Parser parser, const char *s, const char *end,
     parser->m_processor = prologProcessor;
     tok = XmlPrologTok(parser->m_encoding, s, end, &next);
     return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
   } else
 #endif  
   {","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read."
1809,CVE-2019-15785,"  typedef struct fontview {
     struct lookup_subtable *cur_subtable;
     struct qg_data *qg;
     GPid pid_webfontserver;
    bool script_unsaved;  
 } FontView;
 
 typedef struct findsel {",FontForge 20190813 through 20190820 has a buffer overflow in PrefsUI_LoadPrefs in prefs.c.
1810,CVE-2019-15538,"  xfs_setattr_nonsize(
 
 out_cancel:
 	xfs_trans_cancel(tp);
	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 out_dqrele:
 	xfs_qm_dqrele(udqp);
 	xfs_qm_dqrele(gdqp);","An issue was discovered in xfs_setattr_nonsize in fs/xfs/xfs_iops.c in the Linux kernel through 5.2.9. XFS partially wedges when a chgrp fails on account of being out of disk quota. xfs_setattr_nonsize is failing to unlock the ILOCK after the xfs_qm_vop_chown_reserve call fails. This is primarily a local DoS attack vector, but it might result as well in remote DoS if the XFS filesystem is exported for instance via NFS."
1811,CVE-2019-15296,"  void faad_resetbits(bitfile *ld, int bits)
     int words = bits >> 5;
     int remainder = bits & 0x1F;
 
    if (ld->buffer_size < words * 4)
        ld->bytes_left = 0;
    else
        ld->bytes_left = ld->buffer_size - words*4;
 
     if (ld->bytes_left >= 4)
     {","An issue was discovered in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The faad_resetbits function in libfaad/bits.c is affected by a buffer overflow vulnerability. The number of bits to be read is determined by ld->buffer_size - words*4, cast to uint32. If ld->buffer_size - words*4 is negative, a buffer overflow is later performed via getdword_n(&ld->start[words], ld->bytes_left)."
1812,CVE-2019-15166," 
 #include ""addrtoname.h""
 #include ""gmpls.h""
 
static const char tstr[] = "" [|LMP]"";

 /*
  * LMP common header
  *
  lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,
     } bw;
 
     while (total_subobj_len > 0 && hexdump == FALSE ) {
	ND_TCHECK_16BITS(obj_tptr + offset);
 	subobj_type = EXTRACT_8BITS(obj_tptr + offset);
 	subobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);
 	ND_PRINT((ndo, ""\n\t    Subobject, Type: %s (%u), Length: %u"",
  lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,
 	}
 	switch(subobj_type) {
 	case INT_SWITCHING_TYPE_SUBOBJ:
	    ND_TCHECK_8BITS(obj_tptr + offset + 2);
 	    ND_PRINT((ndo, ""\n\t      Switching Type: %s (%u)"",
 		tok2str(gmpls_switch_cap_values,
 			""Unknown"",
 			EXTRACT_8BITS(obj_tptr + offset + 2)),
 			EXTRACT_8BITS(obj_tptr + offset + 2)));
	    ND_TCHECK_8BITS(obj_tptr + offset + 3);
 	    ND_PRINT((ndo, ""\n\t      Encoding Type: %s (%u)"",
 		tok2str(gmpls_encoding_values,
 			""Unknown"",
  lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,
 	    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);
 	    ND_PRINT((ndo, ""\n\t      Min Reservable Bandwidth: %.3f Mbps"",
                 bw.f*8/1000000));
	    ND_TCHECK_32BITS(obj_tptr + offset + 8);
 	    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);
 	    ND_PRINT((ndo, ""\n\t      Max Reservable Bandwidth: %.3f Mbps"",
                 bw.f*8/1000000));
 	    break;
 	case WAVELENGTH_SUBOBJ:
	    ND_TCHECK_32BITS(obj_tptr + offset + 4);
 	    ND_PRINT((ndo, ""\n\t      Wavelength: %u"",
 		EXTRACT_32BITS(obj_tptr+offset+4)));
 	    break;
  lmp_print(netdissect_options *ndo,
     }
     return;
 trunc:
    ND_PRINT((ndo, ""%s"", tstr));
 }
 /*
  * Local Variables:",lmp_print_data_link_subobjs() in print-lmp.c in tcpdump before 4.9.3 lacks certain bounds checks.
1813,CVE-2019-15165,"  struct option_header {
  * Section Header Block.
  */
 #define BT_SHB			0x0A0D0D0A
#define BT_SHB_INSANE_MAX       1024U*1024U*1U   
 struct section_header_block {
 	bpf_u_int32	byte_order_magic;
 	u_short		major_version;
  pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
 	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
             (total_length > BT_SHB_INSANE_MAX)) {
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
		    ""Section Header Block in pcapng dump file has invalid length %"" PRIsize "" < _%u_ < %u (BT_SHB_INSANE_MAX)"",
		    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
		    total_length,
		    BT_SHB_INSANE_MAX);
 
 		*err = 1;
 		return (NULL);",sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.
1814,CVE-2019-15164,"  static int rpcapd_recv(SOCKET sock, char *buffer, size_t toread, uint32 *plen, c
 static int rpcapd_discard(SOCKET sock, uint32 len);
 static void session_close(struct session *);
 
static int is_url(const char *source);

 int
 daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,
     int nullAuthAllowed)
  daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,
 	source[nread] = '\0';
 	plen -= nread;
 
	 
	 
	if (is_url(source))
	{
		pcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, ""Source string refers to a remote device"");
		goto error;
	}
 
 	 
 	 
  static void session_close(struct session *session)
 		session->fp = NULL;
 	}
 }

 
 
 
 
 
static int
is_url(const char *source)
{
	char *colonp;

	 
	colonp = strchr(source, ':');
	if (colonp == NULL)
	{
		 
		return (0);
	}

	 
	if (strncmp(colonp + 1, ""//"", 2) != 0)
	{
		 
		return (0);
	}

	 
	return (1);
}",rpcapd/daemon.c in libpcap before 1.9.1 allows SSRF because a URL may be provided as a capture source.
1815,CVE-2019-15163,"  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
	char *crypt_password;
 
 	 
 	if ((user = getpwnam(username)) == NULL)
  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	user_password = user->pw_passwd;
 #endif
 
	crypt_password = crypt(password, user_password);
	if (crypt_password == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}
	if (strcmp(user_password, crypt_password) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;",rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.
1816,CVE-2019-15162,"  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	 * stop trying to log in with a given user name and move on
 	 * to another user name.
 	 */
	DWORD error;
 	HANDLE Token;
	char errmsgbuf[PCAP_ERRBUF_SIZE];	 

 	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
 	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		error = GetLastError();
		if (error != ERROR_LOGON_FAILURE)
		{
			 
			 
			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
			    PCAP_ERRBUF_SIZE, error, ""LogonUser() failed"");
			rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
		}			    
 		return -1;
 	}
 
 	 
 	 
 	if (ImpersonateLoggedOnUser(Token) == 0)
 	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
 		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
 		CloseHandle(Token);
 		return -1;
 	}
  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	 * only password database or some other authentication mechanism,
 	 * behind its API.
 	 */
	int error;
 	struct passwd *user;
 	char *user_password;
 #ifdef HAVE_GETSPNAM
  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	 
 	if ((user = getpwnam(username)) == NULL)
 	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		return -1;
 	}
 
 #ifdef HAVE_GETSPNAM
 	 
 	if ((usersp = getspnam(username)) == NULL)
 	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		return -1;
 	}
 	user_password = usersp->sp_pwdp;
  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 	user_password = user->pw_passwd;
 #endif
 
	 
	 
	 
	 
	 
	errno = 0;
 	crypt_password = crypt(password, user_password);
 	if (crypt_password == NULL)
 	{
		error = errno;
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		if (error == 0)
		{
			 
			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed"");
		}
		else
		{
			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed: %s"",
			    strerror(error));
		}
 		return -1;
 	}
 	if (strcmp(user_password, crypt_password) != 0)
 	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		return -1;
 	}
 
 	if (setuid(user->pw_uid))
 	{
		error = errno;
 		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    error, ""setuid"");
		rpcapd_log(LOGPRIO_ERROR, ""setuid() failed: %s"",
		    strerror(error));
 		return -1;
 	}
 
  ","rpcapd/daemon.c in libpcap before 1.9.1 on non-Windows platforms provides details about why authentication failed, which might make it easier for attackers to enumerate valid usernames."
1817,CVE-2019-15161,"  daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 	pcap_if_t *d;				 
 	struct pcap_addr *address;		 
 	struct rpcap_findalldevs_if *findalldevs_if; 
	uint32 replylen;			 
 	uint16 nif = 0;				 
 
 	 
  daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 		return 0;
 	}
 
	 
	 
	replylen = 0;
 	for (d = alldevs; d != NULL; d = d->next)
 	{
 		nif++;
 
 		if (d->description)
			replylen += strlen(d->description);
 		if (d->name)
			replylen += strlen(d->name);
 
		replylen += sizeof(struct rpcap_findalldevs_if);
 
 		for (address = d->addresses; address != NULL; address = address->next)
 		{
  daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 #ifdef AF_INET6
 			case AF_INET6:
 #endif
				replylen += (sizeof(struct rpcap_sockaddr) * 4);
 				break;
 
 			default:
  daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)
 		goto error;
 
 	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
	    RPCAP_MSG_FINDALLIF_REPLY, nif, replylen);
 
 	 
 	for (d = alldevs; d != NULL; d = d->next)",rpcapd/daemon.c in libpcap before 1.9.1 mishandles certain length values because of reuse of a variable. This may open up an attack vector involving extra data at the end of a request.
1818,CVE-2019-15148," 
  * 
  *  @brief GPMF Parser library
  *
 *  @version 1.2.2
  * 
  *  (C) Copyright 2017 GoPro Inc (http: 
  *	
  GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size)  
 {
 	if (ms)
 	{
		uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
 		if (nestsize == 0 && ms->nest_level == 0)
 			nestsize = ms->buffer_size_longs;
 ",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.
1819,CVE-2019-15141,"  RestoreMSCWarning
     if (image->colorspace == LabColorspace)
       DecodeLabImage(image,&image->exception);
     DestroyTIFFInfo(&tiff_info);
 DisableMSCWarning(4127)
     if (0 && (image_info->verbose != MagickFalse))
 RestoreMSCWarning
       TIFFPrintDirectory(tiff,stdout,MagickFalse);
    if (TIFFWriteDirectory(tiff) == 0)
      {
        status=MagickFalse;
        break;
      }
     image=SyncNextImageInList(image);
     if (image == (Image *) NULL)
       break;
  RestoreMSCWarning
       break;
   } while (image_info->adjoin != MagickFalse);
   TIFFClose(tiff);
  return(status);
 }
 #endif","WriteTIFFImage in coders/tiff.c in ImageMagick 7.0.8-43 Q16 allows attackers to cause a denial-of-service (application crash resulting from a heap-based buffer over-read) via a crafted TIFF image file, related to TIFFRewriteDirectory, TIFFWriteDirectory, TIFFWriteDirectorySec, and TIFFWriteDirectoryTagColormap in tif_dirwrite.c of LibTIFF. NOTE: this occurs because of an incomplete fix for CVE-2019-11597."
1820,CVE-2019-15140,"  static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,
      Object parser loop.
     */
     ldblk=ReadBlobLSBLong(image);
    if(EOFBlob(image)) break;
     if ((ldblk > 9999) || (ldblk < 0))
       break;
     HDR.Type[3]=ldblk % 10; ldblk /= 10;   
  static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
     }
 
   filepos = TellBlob(image);
  while(filepos < GetBlobSize(image) && !EOFBlob(image))  
   {
     Frames = 1;
    if(filepos > GetBlobSize(image) || filepos < 0)
       break;
     if(SeekBlob(image,filepos,SEEK_SET) != filepos) break;
      
  static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if(EOFBlob(image)) break;
     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
     if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) >= GetBlobSize(image))
       goto MATLAB_KO;
     filepos += (MagickOffsetType) MATLAB_HDR.ObjectSize + 4 + 4;
 
  RestoreMSCWarning
           {
             if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
            ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
             goto ExitLoop;
           }
         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))",coders/mat.c in ImageMagick 7.0.8-43 Q16 allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact by crafting a Matlab image file that is mishandled in ReadImage in MagickCore/constitute.c.
1821,CVE-2019-15139,"  static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
     ThrowReaderException(CorruptImageError,""FileFormatVersionMismatch"");
   if (header.header_size < sz_XWDheader)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if ((MagickSizeType) header.xoffset >= GetBlobSize(image))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   switch (header.visual_class)
   {
     case StaticGray:
  static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
     case PseudoColor:
     {
       if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||
          (header.colormap_entries == 0))
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       break;
     }
  static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
     default:
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   }
   if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   length=(size_t) (header.header_size-sz_XWDheader);
  static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
       XWDColor
         color;
 
      length=(size_t) header.ncolors;
      if (length > ((~0UL)/sizeof(*colors)))
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));
       if (colors == (XColor *) NULL)
         {
           ximage=(XImage *) RelinquishMagickMemory(ximage);
  ModuleExport size_t RegisterXWDImage(void)
   entry->encoder=(EncodeImageHandler *) WriteXWDImage;
 #endif
   entry->magick=(IsImageFormatHandler *) IsXWD;
  entry->flags|=CoderDecoderSeekableStreamFlag;
   entry->flags^=CoderAdjoinFlag;
   (void) RegisterMagickInfo(entry);
   return(MagickImageCoderSignature);","The XWD image (X Window System window dumping file) parsing component in ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (application crash resulting from an out-of-bounds Read) in ReadXWDImage in coders/xwd.c by crafting a corrupted XWD image file, a different vulnerability than CVE-2019-11472."
1822,CVE-2019-15090,"  qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 {
 	va_list va;
 	struct va_format vaf;
 
 	va_start(va, fmt);
 
  qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_err(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
		       func, line, qedi->host_no, &vaf);
 	else
		pr_err(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);
 
 	va_end(va);
 }
  qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 {
 	va_list va;
 	struct va_format vaf;
 
 	va_start(va, fmt);
 
  qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_warn(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
			func, line, qedi->host_no, &vaf);
 	else
		pr_warn(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);
 
 ret:
 	va_end(va);
  qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 {
 	va_list va;
 	struct va_format vaf;
 
 	va_start(va, fmt);
 
  qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), func, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);
 
 ret:
 	va_end(va);
  qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 {
 	va_list va;
 	struct va_format vaf;
 
 	va_start(va, fmt);
 
  qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_info(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
			func, line, qedi->host_no, &vaf);
 	else
		pr_info(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);
 
 ret:
 	va_end(va);","An issue was discovered in drivers/scsi/qedi/qedi_dbg.c in the Linux kernel before 5.1.12. In the qedi_dbg_* family of functions, there is an out-of-bounds read."
1823,CVE-2019-15026,"  static inline void get_conn_text(const conn *c, const int af,
     addr_text[0] = '\0';
     const char *protoname = ""?"";
     unsigned short port = 0;
    size_t pathlen = 0;
 
     switch (af) {
         case AF_INET:
  static inline void get_conn_text(const conn *c, const int af,
             break;
 
         case AF_UNIX:
             
             
             
             
             
             
             
             
             
             
             
             
             
            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);
            if (MAXPATHLEN <= pathlen) {
                pathlen = MAXPATHLEN - 1;
            }
             strncpy(addr_text,
                     ((struct sockaddr_un *)sock_addr)->sun_path,
                    pathlen);
            addr_text[pathlen] = '\0';
             protoname = ""unix"";
             break;
     }","memcached 1.5.16, when UNIX sockets are used, has a stack-based buffer over-read in conn_to_str in memcached.c."
1824,CVE-2019-14982,"  namespace Exiv2 {
         }
     }
 
    long WebPImage::getHeaderOffset(byte* data, long data_size, byte* header, long header_size)
    {
        if (data_size < header_size) { return -1; }
         long pos = -1;
         for (long i=0; i < data_size - header_size; i++) {
             if (memcmp(header, &data[i], header_size) == 0) {","In Exiv2 before v0.27.2, there is an integer overflow vulnerability in the WebPImage::getHeaderOffset function in webpimage.cpp. It can lead to a buffer overflow vulnerability and a crash."
1825,CVE-2019-14981,"  MagickExport Image *MeanShiftImage(const Image *image,const size_t width,
               }
           }
         }
        gamma=PerceptibleReciprocal(count);
         mean_location.x=gamma*sum_location.x;
         mean_location.y=gamma*sum_location.y;
         mean_pixel.red=gamma*sum_pixel.red;","In ImageMagick 7.x before 7.0.8-41 and 6.x before 6.9.10-41, there is a divide-by-zero vulnerability in the MeanShiftImage function. It allows an attacker to cause a denial of service by sending a crafted file."
1826,CVE-2019-14980,"  MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;","In ImageMagick 7.x before 7.0.8-42 and 6.x before 6.9.10-42, there is a use after free vulnerability in the UnmapBlob function that allows an attacker to cause a denial of service by sending a crafted file."
1827,CVE-2019-14934,"  static void write_version(
      
     if ((c = strstr(fname, "".pdf"")))
       *c = '\0';
    new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);
     snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,
              ""%s/%s-version-%d.pdf"", dirname, fname, xref->version);
 
  static pdf_t *init_pdf(FILE *fp, const char *name)
 }
 
 
void *safe_calloc(size_t size) {
  void *addr;

  if (!size)
  {
    ERR(""Invalid allocation size.\n"");
    exit(EXIT_FAILURE);
  }
  if (!(addr = calloc(1, size)))
  {
      ERR(""Failed to allocate requested number of bytes, out of memory?\n"");
      exit(EXIT_FAILURE);
  }
  return addr;
}


 int main(int argc, char **argv)
 {
     int         i, n_valid, do_write, do_scrub;
  int main(int argc, char **argv)
         if ((c = strrchr(name, '.')))
           *c = '\0';
 
        dname = safe_calloc(strlen(name) + 16);
         sprintf(dname, ""%s-versions"", name);
         if (!(dir = opendir(dname)))
           mkdir(dname, S_IRWXU);","An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write."
1828,CVE-2019-14816,"  static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,
 		}
 
 		vs_ie = (struct ieee_types_header *)vendor_ie;
		if (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >
			IEEE_MAX_IE_SIZE)
			return -EINVAL;
 		memcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),
 		       vs_ie, vs_ie->len + 2);
 		le16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);","There is heap-based buffer overflow in kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code."
1829,CVE-2019-14814,"  static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,
 		}
 
 		vs_ie = (struct ieee_types_header *)vendor_ie;
		if (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >
			IEEE_MAX_IE_SIZE)
			return -EINVAL;
 		memcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),
 		       vs_ie, vs_ie->len + 2);
 		le16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);","There is heap-based buffer overflow in Linux kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code."
1830,CVE-2019-14763,"  static void dwc3_ep_inc_deq(struct dwc3_ep *dep)
 	dwc3_ep_inc_trb(&dep->trb_dequeue);
 }
 
void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,
		struct dwc3_request *req, int status)
 {
 	struct dwc3			*dwc = dep->dwc;
 
  void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
 
 	if (req->trb)
 		usb_gadget_unmap_request_by_dev(dwc->sysdev,
				&req->request, req->direction);
 
 	req->trb = NULL;
 	trace_dwc3_gadget_giveback(req);
 
	if (dep->number > 1)
		pm_runtime_put(dwc->dev);
}

 
void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
		int status)
{
	struct dwc3			*dwc = dep->dwc;

	dwc3_gadget_del_and_unmap_request(dep, req, status);

 	spin_unlock(&dwc->lock);
 	usb_gadget_giveback_request(&dep->endpoint, &req->request);
 	spin_lock(&dwc->lock);
 }
 
 /**
  static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)
 		if (req->trb)
 			memset(req->trb, 0, sizeof(struct dwc3_trb));
 		dep->queued_requests--;
		dwc3_gadget_del_and_unmap_request(dep, req, ret);
 		return ret;
 	}
 ","In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid."
1831,CVE-2019-14495," 
 
 #define RETURN(xxx) { param->res = xxx; goto CLEANRET; }
 
#define LINESIZE 65536
 
 extern FILE *writable;
 FILE * confopen();
  void * adminchild(struct clientparam* param) {
  char *sb;
  char *req = NULL;
  struct printparam pp;
 unsigned contentlen = 0;
  int isform = 0;
 
  pp.inbuf = 0;
  void * adminchild(struct clientparam* param) {
 	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
 		sb = buf + 15;
 		while(isspace(*sb))sb++;
		sscanf(sb, ""%u"", &contentlen);
		if(contentlen > LINESIZE*1024) contentlen = 0;
 	}
 	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
 		sb = buf + 13;
  void * adminchild(struct clientparam* param) {
 				break;
 			}
 				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
 				while(fgets(buf, 256, fp)){
 					printstr(&pp, buf);
 				}
  void * adminchild(struct clientparam* param) {
 		}
 	case 'U':
 		{
			unsigned l=0;
 			int error = 0;
 
			if(!writable || !contentlen || fseek(writable, 0, 0)){
 				error = 1;
 			}
			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
 				if(i > (contentlen - l)) i = (contentlen - l);
 				if(!l){
					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
 				}
 				if(!error){
					buf[i] = 0;
 					decodeurl((unsigned char *)buf, 1);
 					fprintf(writable, ""%s"", l? buf : buf + 9);
 				}
 				l += i;
 			}
 			if(writable && !error){
 				fflush(writable);",webadmin.c in 3proxy before 0.8.13 has an out-of-bounds write in the admin interface.
1832,CVE-2019-14463,"  int modbus_reply(modbus_t *ctx, const uint8_t *req,
         break;
     case MODBUS_FC_WRITE_MULTIPLE_COILS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
        int nb_bits = req[offset + 5];
         int mapping_address = address - mb_mapping->start_bits;
 
        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {
              
  int modbus_reply(modbus_t *ctx, const uint8_t *req,
         break;
     case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
        int nb_bytes = req[offset + 5];
         int mapping_address = address - mb_mapping->start_registers;
 
        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {
             rsp_length = response_exception(
                 ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                 ""Illegal number of values %d in write_registers (max %d)\n"",","An issue was discovered in libmodbus before 3.0.7 and 3.1.x before 3.1.5. There is an out-of-bounds read for the MODBUS_FC_WRITE_MULTIPLE_REGISTERS case, aka VD-1301."
1833,CVE-2019-14452,"  void ImportEPUB::ExtractContainer()
 
              
             if (!qfile_name.isEmpty()) {

	         
                 
                 
                 
	        qfile_name = qfile_name.replace(""../"","""");
                cp437_file_name = cp437_file_name.replace(""../"","""");

                  
                  
                 QDir dir(m_ExtractedFolderPath);","Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction."
1834,CVE-2019-14323,"  static void ssdp_recv(int sd)
 	ssize_t len;
 	struct sockaddr sa;
 	socklen_t salen;
	char buf[MAX_PKT_SIZE + 1];
 
 	memset(buf, 0, sizeof(buf));
	len = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);
 	if (len > 0) {
 		if (sa.sa_family != AF_INET)
 			return;
 ","SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c."
1835,CVE-2019-14284,"  static void setup_format_params(int track)
 	raw_cmd->kernel_data = floppy_track_buffer;
 	raw_cmd->length = 4 * F_SECT_PER_TRACK;
 
	if (!F_SECT_PER_TRACK)
		return;

 	 
 	head_shift = (F_SECT_PER_TRACK + 5) / 6;
 
  static int set_geometry(unsigned int cmd, struct floppy_struct *g,
 	 
 	if (g->sect <= 0 ||
 	    g->head <= 0 ||
	     
	    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||
 	    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||
 	     
 	    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)","In the Linux kernel before 5.2.3, drivers/block/floppy.c allows a denial of service by setup_format_params division-by-zero. Two consecutive ioctls can trigger the bug: the first one should set the drive geometry with .sect and .rate values that make F_SECT_PER_TRACK be zero. Next, the floppy format operation should be called. It can be triggered by an unprivileged local user even when a floppy disk has not been inserted. NOTE: QEMU creates the floppy device by default."
1836,CVE-2019-14283,"  static int set_geometry(unsigned int cmd, struct floppy_struct *g,
 	int cnt;
 
 	 
	if ((int)g->sect <= 0 ||
	    (int)g->head <= 0 ||
	     
	    (int)(g->sect * g->head) <= 0 ||
 	     
 	    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||
 	    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||","In the Linux kernel before 5.2.3, set_geometry in drivers/block/floppy.c does not validate the sect and head fields, as demonstrated by an integer overflow and out-of-bounds read. It can be triggered by an unprivileged local user when a floppy disk has been inserted. NOTE: QEMU creates the floppy device by default."
1837,CVE-2019-13615,"  EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSe
     ReadIndex = SizeIdx - 1;
     memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);
     UpperLevel = UpperLevel_original;
  } while ( MaxDataSize >= ReadSize );
 
   return NULL;
 }","libebml before 1.3.6, as used in the MKV module in VideoLAN VLC Media Player binaries before 3.0.3, has a heap-based buffer over-read in EbmlElement::FindNextElement."
1838,CVE-2019-13568,"  namespace cimg_library_suffixed {
 
       CImg<ucharT> buffer;
       if (buf_size<cimg_iobuffer) {
 
        buffer.assign(buf_size,1,1,1,0);
         cimg::fread(buffer._data,buf_size,nfile);
       } else buffer.assign(dx_bytes + align_bytes);
       unsigned char *ptrs = buffer;",CImg through 2.6.7 has a heap-based buffer overflow in _load_bmp in CImg.h because of erroneous memory allocation for a malformed BMP image.
1839,CVE-2019-13454,"  MagickExport void OptimizeImageTransparency(const Image *image,
 %    o exception: return any errors or warnings in this structure.
 %
 */
MagickExport void RemoveDuplicateLayers(Image **images,ExceptionInfo *exception)
 {
   RectangleInfo
     bounds;
 
  register Image
    *image,
    *next;

   assert((*images) != (const Image *) NULL);
   assert((*images)->signature == MagickCoreSignature);
   if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      (*images)->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
  image=GetFirstImageInList(*images);
  for ( ; (next=GetNextImageInList(image)) != (Image *) NULL; image=next)
   {
    if ((image->columns != next->columns) || (image->rows != next->rows) ||
        (image->page.x != next->page.x) || (image->page.y != next->page.y))
       continue;
    bounds=CompareImageBounds(image,next,CompareAnyLayer,exception);
    if (bounds.x < 0)
      {
         
        size_t
          time;

        time=1000*image->delay*PerceptibleReciprocal(image->ticks_per_second);
        time+=1000*next->delay*PerceptibleReciprocal(next->ticks_per_second);
        next->ticks_per_second=100L;
        next->delay=time*image->ticks_per_second/1000;
        next->iterations=image->iterations;
        *images=image;
        (void) DeleteImageFromList(images);
      }
   }
  *images=GetFirstImageInList(*images);
 }
 
 /*",ImageMagick 7.0.8-54 Q16 allows Division by Zero in RemoveDuplicateLayers in MagickCore/layer.c.
1840,CVE-2019-13391,"  MagickExport MagickBooleanType AnnotateImage(Image *image,
     {
       annotate_info=DestroyDrawInfo(annotate_info);
       annotate=DestroyDrawInfo(annotate);
      text=DestroyString(text);
       return(MagickFalse);
     }
   p=text;
  MagickExport MagickBooleanType AnnotateImage(Image *image,
       annotate_info=DestroyDrawInfo(annotate_info);
       annotate=DestroyDrawInfo(annotate);
       textlist=(char **) RelinquishMagickMemory(textlist);
      text=DestroyString(text);
       return(MagickFalse);
     }
   if (IsGrayColorspace(image->colorspace) != MagickFalse)
  MagickExport MagickBooleanType AnnotateImage(Image *image,
   annotate_info=DestroyDrawInfo(annotate_info);
   annotate=DestroyDrawInfo(annotate);
   textlist=(char **) RelinquishMagickMemory(textlist);
  text=DestroyString(text);
   return(status);
 }
 ","In ImageMagick 7.0.8-50 Q16, ComplexImages in MagickCore/fourier.c has a heap-based buffer over-read because of incorrect calls to GetCacheViewVirtualPixels."
1841,CVE-2019-13311,"  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             clut_image=RemoveFirstImageFromList(images);
             if (clut_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
           }
         if (LocaleCompare(""compare"",option+1) == 0)
           {
             double
               distortion;
 
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             reconstruct_image=RemoveFirstImageFromList(images);
             if (reconstruct_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             composite_image=RemoveFirstImageFromList(images);
             if (composite_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             hald_image=RemoveFirstImageFromList(images);
             if (hald_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             phase_image=RemoveFirstImageFromList(images);
             if (phase_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                magnitude_image=DestroyImage(magnitude_image);
                 status=MagickFalse;
                 break;
               }
             fourier_image=InverseFourierTransformImage(magnitude_image,
               phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);
            magnitude_image=DestroyImage(magnitude_image);
            phase_image=DestroyImage(phase_image);
             if (fourier_image == (Image *) NULL)
               break;
             if (*images != (Image *) NULL)",ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of a wand/mogrify.c error.
1842,CVE-2019-13310,"  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
               channel,metric,&distortion,exception);
             if (difference_image == (Image *) NULL)
               break;
            reconstruct_image=DestroyImage(reconstruct_image);
            image=DestroyImage(image);
             if (*images != (Image *) NULL)
               *images=DestroyImageList(*images);
             *images=difference_image;
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
                    q=GetImageFromList(*images,index-1);
                    if (q == (Image *) NULL)
                      {
                       p=DestroyImage(p);
                        (void) ThrowMagickException(exception,GetMagickModule(),
                          OptionError,""NoSuchImage"",""`%s'"",argv[i+1]);
                        status=MagickFalse;",ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of an error in MagickWand/mogrify.c.
1843,CVE-2019-13308,"  static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,
        
      next_pixel=MagickFalse;
      displacement=1;
       index=(IndexPacket) ((size_t) GetPixelIndex(indexes+x) & 0xff);
       p++;
       k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);
       if (k >= MaxHashTable)
         k-=MaxHashTable;
      if (k < 0)
        continue;
       if (hash_code[k] > 0)
         {
           if ((hash_prefix[k] == waiting_code) &&",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow in MagickCore/fourier.c in ComplexImage.
1844,CVE-2019-13307,"  static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)
 
   size_t
     columns,
    rows;
 
  rows=MagickMax(GetImageListLength(images),
    (size_t) GetMagickResourceLimit(ThreadResource));
  pixels=(MagickPixelPacket **) AcquireQuantumMemory(rows,sizeof(*pixels));
   if (pixels == (MagickPixelPacket **) NULL)
     return((MagickPixelPacket **) NULL);
   columns=images->columns;
   for (next=images; next != (Image *) NULL; next=next->next)
     columns=MagickMax(next->columns,columns);
  for (i=0; i < (ssize_t) rows; i++)
   {
     pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,
       sizeof(**pixels));",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling rows.
1845,CVE-2019-13306,"  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image)
             extent=(size_t) count;
             (void) strncpy((char *) q,buffer,extent);
             q+=extent;
            if ((q-pixels+extent+2) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image)
             extent=(size_t) count;
             (void) strncpy((char *) q,buffer,extent);
             q+=extent;
            if ((q-pixels+extent+2) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of off-by-one errors.
1846,CVE-2019-13305,"  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image)
                 count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,""%u "",
                   ScaleQuantumToLong(index));
             extent=(size_t) count;
            if ((q-pixels+extent+1) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
            (void) strncpy((char *) q,buffer,extent);
            q+=extent;
             p++;
           }
           *q++='\n';
  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image)
                   ScaleQuantumToLong(GetPixelGreen(p)),
                   ScaleQuantumToLong(GetPixelBlue(p)));
             extent=(size_t) count;
            if ((q-pixels+extent+1) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
            (void) strncpy((char *) q,buffer,extent);
            q+=extent;
             p++;
           }
           *q++='\n';",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of a misplaced strncpy and an off-by-one error.
1847,CVE-2019-13304,"  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
           {
             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?
               '0' : '1');
             if ((q-pixels+1) >= (ssize_t) sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
            *q++=' ';
             p+=GetPixelChannels(image);
           }
           *q++='\n';",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of a misplaced assignment.
1848,CVE-2019-13303,"  MagickExport MagickBooleanType CompositeImage(Image *image,
               q+=GetPixelChannels(image);
               continue;
             }
          for (i=0; i < (ssize_t) GetPixelChannels(source_image); i++)
           {
            PixelChannel channel = GetPixelChannelChannel(source_image,i);
            PixelTrait source_traits = GetPixelChannelTraits(source_image,
               channel);
            PixelTrait traits = GetPixelChannelTraits(image,channel);
            if (source_traits == UndefinedPixelTrait)
               continue;
            if (traits != UndefinedPixelTrait)
               SetPixelChannel(image,channel,p[i],q);
            else
              if (channel == AlphaPixelChannel)
                SetPixelChannel(image,channel,OpaqueAlpha,q);
           }
           p+=GetPixelChannels(source_image);
           q+=GetPixelChannels(image);",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read in MagickCore/composite.c in CompositeImage.
1849,CVE-2019-13302,"  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
   MagickOffsetType
     progress;
 
  size_t
    number_channels;

   ssize_t
     y;
 
  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
     }
   Cr_image=complex_images;
   Ci_image=complex_images->next;
  number_channels=MagickMin(MagickMin(MagickMin(
    Ar_image->number_channels,Ai_image->number_channels),MagickMin(
    Br_image->number_channels,Bi_image->number_channels)),MagickMin(
    Cr_image->number_channels,Ci_image->number_channels));
   Ar_view=AcquireVirtualCacheView(Ar_image,exception);
   Ai_view=AcquireVirtualCacheView(Ai_image,exception);
   Br_view=AcquireVirtualCacheView(Br_image,exception);
  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
       register ssize_t
         i;
 
      for (i=0; i < (ssize_t) number_channels; i++)
       {
         switch (op)
         {",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read in MagickCore/fourier.c in ComplexImages.
1850,CVE-2019-13301,"  MagickExport MagickBooleanType AnnotateImage(Image *image,
       number_lines++;
   textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));
   if (textlist == (char **) NULL)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      annotate=DestroyDrawInfo(annotate);
      return(MagickFalse);
    }
   p=text;
   for (i=0; i < number_lines; i++)
   {
  MagickExport MagickBooleanType AnnotateImage(Image *image,
       (void) ParseGeometry(annotate_info->geometry,&geometry_info);
     }
   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    {
      annotate_info=DestroyDrawInfo(annotate_info);
      annotate=DestroyDrawInfo(annotate);
      textlist=(char **) RelinquishMagickMemory(textlist);
      return(MagickFalse);
    }
   if (IsGrayColorspace(image->colorspace) != MagickFalse)
     (void) SetImageColorspace(image,sRGBColorspace,exception);
   status=MagickTrue;",ImageMagick 7.0.8-50 Q16 has memory leaks in AcquireMagickMemory because of an AnnotateImage error.
1851,CVE-2019-13300,"  static MagickPixelPacket **DestroyPixelThreadSet(MagickPixelPacket **pixels)
   return(pixels);
 }
 
static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)
 {
  const Image
    *next;

   MagickPixelPacket
     **pixels;
 
  static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)
     j;
 
   size_t
    columns,
     number_threads;
 
   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
  static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)
   if (pixels == (MagickPixelPacket **) NULL)
     return((MagickPixelPacket **) NULL);
   (void) memset(pixels,0,number_threads*sizeof(*pixels));
  columns=images->columns;
  for (next=images; next != (Image *) NULL; next=next->next)
    columns=MagickMax(next->columns,columns);
   for (i=0; i < (ssize_t) number_threads; i++)
   {
    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,
       sizeof(**pixels));
     if (pixels[i] == (MagickPixelPacket *) NULL)
       return(DestroyPixelThreadSet(pixels));
    for (j=0; j < (ssize_t) columns; j++)
      GetMagickPixelPacket(images,&pixels[i][j]);
   }
   return(pixels);
 }",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling columns.
1852,CVE-2019-13299,"  static inline PixelTrait GetPixelCbTraits(const Image *magick_restrict image)
 static inline Quantum GetPixelChannel(const Image *magick_restrict image,
   const PixelChannel channel,const Quantum *magick_restrict pixel)
 {
  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)
     return((Quantum) 0);
   return(pixel[image->channel_map[channel].offset]);
 }",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/pixel-accessor.h in GetPixelChannel.
1853,CVE-2019-13298,"  MagickExport Image *EnhanceImage(const Image *image,ExceptionInfo *exception)
           pixel.black=((aggregate.black+total_weight/2.0)/total_weight);
           pixel.alpha=((aggregate.alpha+total_weight/2.0)/total_weight);
         }
      SetPixelViaPixelInfo(enhance_image,&pixel,q);
       p+=GetPixelChannels(image);
       q+=GetPixelChannels(enhance_image);
     }",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/pixel-accessor.h in SetPixelViaPixelInfo because of a MagickCore/enhance.c error.
1854,CVE-2019-13297,"  MagickExport Image *AdaptiveThresholdImage(const Image *image,
   threshold_image=CloneImage(image,0,0,MagickTrue,exception);
   if (threshold_image == (Image *) NULL)
     return((Image *) NULL);
  if ((width == 0) || (height == 0))
     return(threshold_image);
   if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)
     {",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a height of zero is mishandled.
1855,CVE-2019-13296,"  WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,
           reconstruct_image=RemoveFirstImageFromList(&_images);
            
           if (reconstruct_image == (Image *) NULL)
            { 
              image=DestroyImage(image);
              break;
            }
           metric=UndefinedErrorMetric;
           option=GetImageOption(_image_info,""metric"");
           if (option != (const char *) NULL)",ImageMagick 7.0.8-50 Q16 has direct memory leaks in AcquireMagickMemory because of an error in CLIListOperatorImages in MagickWand/operation.c for a NULL value.
1856,CVE-2019-13295,"  MagickExport Image *AdaptiveThresholdImage(const Image *image,
   threshold_image=CloneImage(image,0,0,MagickTrue,exception);
   if (threshold_image == (Image *) NULL)
     return((Image *) NULL);
  if (width == 0)
    return(threshold_image);
   status=SetImageStorageClass(threshold_image,DirectClass,exception);
   if (status == MagickFalse)
     {",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a width of zero is mishandled.
1857,CVE-2019-13272,"  void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
  */
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
	__ptrace_link(child, new_parent, current_cred());
 }
 
 /**","In the Linux kernel before 5.1.17, ptrace_link in kernel/ptrace.c mishandles the recording of the credentials of a process that wants to create a ptrace relationship, which allows local users to obtain root access by leveraging certain scenarios with a parent-child process relationship, where a parent drops privileges and calls execve (potentially allowing control by an attacker). One contributing factor is an object lifetime issue (which can also cause a panic). Another contributing factor is incorrect marking of a ptrace relationship as privileged, which is exploitable through (for example) Polkit's pkexec helper with PTRACE_TRACEME. NOTE: SELinux deny_ptrace might be a usable workaround in some environments."
1858,CVE-2019-13233,"  static int get_reg_offset_16(struct insn *insn, struct pt_regs *regs,
 }
 
  
static bool get_desc(struct desc_struct *out, unsigned short sel)
 {
 	struct desc_ptr gdt_desc = {0, 0};
 	unsigned long desc_base;
 
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
 	if ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {
		bool success = false;
 		struct ldt_struct *ldt;
 
 		 
 		sel >>= 3;
 
 		mutex_lock(&current->active_mm->context.lock);
 		ldt = current->active_mm->context.ldt;
		if (ldt && sel < ldt->nr_entries) {
			*out = ldt->entries[sel];
			success = true;
		}
 
 		mutex_unlock(&current->active_mm->context.lock);
 
		return success;
 	}
 #endif
 	native_store_gdt(&gdt_desc);
  static struct desc_struct *get_desc(unsigned short sel)
 	desc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);
 
 	if (desc_base > gdt_desc.size)
		return false;
 
	*out = *(struct desc_struct *)(gdt_desc.address + desc_base);
	return true;
 }
 
  
 unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
 {
	struct desc_struct desc;
 	short sel;
 
 	sel = get_segment_selector(regs, seg_reg_idx);
  unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
 	if (!sel)
 		return -1L;
 
	if (!get_desc(&desc, sel))
 		return -1L;
 
	return get_desc_base(&desc);
 }
 
  
 static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 {
	struct desc_struct desc;
 	unsigned long limit;
 	short sel;
 
  static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
 	if (!sel)
 		return 0;
 
	if (!get_desc(&desc, sel))
 		return 0;
 
 	 
	limit = get_desc_limit(&desc);
	if (desc.g)
 		limit = (limit << 12) + 0xfff;
 
 	return limit;
  static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)
  */
 int insn_get_code_seg_params(struct pt_regs *regs)
 {
	struct desc_struct desc;
 	short sel;
 
 	if (v8086_mode(regs))
  int insn_get_code_seg_params(struct pt_regs *regs)
 	if (sel < 0)
 		return sel;
 
	if (!get_desc(&desc, sel))
 		return -EINVAL;
 
 	 
	if (!(desc.type & BIT(3)))
 		return -EINVAL;
 
	switch ((desc.l << 1) | desc.d) {
 	case 0: /*
 		 * Legacy mode. CS.L=0, CS.D=0. Address and operand size are
 		 * both 16-bit.","In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation."
1859,CVE-2019-13229,"  bool DDeviceDiskInfoPrivate::openDataStream(int index)
 
         if (currentMode == DDiskInfo::Read) {
             const QString &executer = Helper::getPartcloneExecuter(part);
            process->start(QStringLiteral(""%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log"").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);
         } else {
            process->start(QStringLiteral(""partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log"").arg(part.filePath()).arg(Global::bufferSize));
         }
 
         break;","deepin-clone before 1.1.3 uses a fixed path /tmp/partclone.log in the Helper::getPartitionSizeInfo() function to write a log file as root, and follows symlinks there. An unprivileged user can prepare a symlink attack there to create or overwrite files in arbitrary file system locations. The content is not attacker controlled."
1860,CVE-2019-13225,"  compile_length_bag_node(BagNode* node, regex_t* reg)
         len += tlen;
       }
 
      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;

       if (IS_NOT_NULL(Else)) {
         tlen = compile_length_tree(Else, reg);
         if (tlen < 0) return tlen;
         len += tlen;
  compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
 
   case BAG_IF_ELSE:
     {
      int cond_len, then_len, else_len, jump_len;
       Node* cond = NODE_BAG_BODY(node);
       Node* Then = node->te.Then;
       Node* Else = node->te.Else;
  compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
       else
         then_len = 0;
 
      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;
 
       r = add_op(reg, OP_PUSH);
       if (r != 0) return r;
  compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
       }
 
       if (IS_NOT_NULL(Else)) {
        else_len = compile_length_tree(Else, reg);
        if (else_len < 0) return else_len;
      }
      else
        else_len = 0;
 
      r = add_op(reg, OP_JUMP);
      if (r != 0) return r;
      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;

      r = add_op(reg, OP_ATOMIC_END);
      if (r != 0) return r;

      if (IS_NOT_NULL(Else)) {
         r = compile_tree(Else, reg, env);
       }
     }","A NULL Pointer Dereference in match_at() in regexec.c in Oniguruma 6.9.2 allows attackers to potentially cause denial of service by providing a crafted regular expression. Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust."
1861,CVE-2019-13224," 
 
 #include ""regint.h""
 
#if 0
 static void
 conv_ext0be32(const UChar* s, const UChar* end, UChar* conv)
 {
  conv_encoding(OnigEncoding from, OnigEncoding to, const UChar* s, const UChar* e
 
   return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
 }
#endif
 
 extern int
 onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
  onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,
   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;
 
   if (ci->pattern_enc != ci->target_enc) {
    return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION;
   }
   else {
     cpat     = (UChar* )pattern;","A use-after-free in onig_new_deluxe() in regext.c in Oniguruma 6.9.2 allows attackers to potentially cause information disclosure, denial of service, or possibly code execution by providing a crafted regular expression. The attacker provides a pair of a regex pattern and a string, with a multi-byte encoding that gets handled by onig_new_deluxe(). Oniguruma issues often affect Ruby, as well as common optional libraries for PHP and Rust."
1862,CVE-2019-13223," 
  
  
  
 
  
  
  
  static int lookup1_values(int entries, int dim)
    int r = (int) floor(exp((float) log((float) entries) / dim));
    if ((int) floor(pow((float) r+1, dim)) <= entries)    
       ++r;                                               
   if (pow((float) r+1, dim) <= entries)
      return -1;
   if ((int) floor(pow((float) r, dim)) > entries)
      return -1;
    return r;
 }
 
  static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y
    ady -= abs(base) * adx;
    if (x1 > n) x1 = n;
    if (x < x1) {
      LINE_OP(output[x], inverse_db_table[y&255]);
       for (++x; x < x1; ++x) {
          err += ady;
          if (err >= adx) {
             err -= adx;
             y += sy;
          } else
             y += base;
         LINE_OP(output[x], inverse_db_table[y&255]);
       }
    }
 }
  static float *get_window(vorb *f, int len)
    len <<= 1;
    if (len == f->blocksize_0) return f->window[0];
    if (len == f->blocksize_1) return f->window[1];
    return NULL;
 }
 
  static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
    if (f->previous_length) {
       int i,j, n = f->previous_length;
       float *w = get_window(f, n);
      if (w == NULL) return 0;
       for (i=0; i < f->channels; ++i) {
          for (j=0; j < n; ++j)
             f->channel_buffers[i][left+j] =
  static int start_decoder(vorb *f)
          while (current_entry < c->entries) {
             int limit = c->entries - current_entry;
             int n = get_bits(f, ilog(limit));
            if (current_length >= 32) return error(f, VORBIS_invalid_setup);
             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
             memset(lengths + current_entry, current_length, n);
             current_entry += n;
  static int start_decoder(vorb *f)
          c->value_bits = get_bits(f, 4)+1;
          c->sequence_p = get_bits(f,1);
          if (c->lookup_type == 1) {
            int values = lookup1_values(c->entries, c->dimensions);
            if (values < 0) return error(f, VORBIS_invalid_setup);
            c->lookup_values = (uint32) values;
          } else {
             c->lookup_values = c->entries * c->dimensions;
          }
  static int start_decoder(vorb *f)
             p[j].id = j;
          }
          qsort(p, g->values, sizeof(p[0]), point_compare);
         for (j=0; j < g->values-1; ++j)
            if (p[j].x == p[j+1].x)
               return error(f, VORBIS_invalid_setup);
          for (j=0; j < g->values; ++j)
             g->sorted_order[j] = (uint8) p[j].id;
           
  static int start_decoder(vorb *f)
          max_submaps = m->submaps;
       if (get_bits(f,1)) {
          m->coupling_steps = get_bits(f,8)+1;
         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);
          for (k=0; k < m->coupling_steps; ++k) {
             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
             m->chan[k].angle = get_bits(f, ilog(f->channels-1));
  int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, in
 #endif  
 
 /* Version history
    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13223, -13223
                           found with Mayhem by ForAllSecure
    1.16    - 2019-03-04 - fix warnings
    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found
    1.14    - 2018-02-11 - delete bogus dealloca usage
    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)
     1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files
     1.11    - 2017-07-23 - fix MinGW compilation 
     1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory",A reachable assertion in the lookup1_values function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service by opening a crafted Ogg Vorbis file.
1863,CVE-2019-13137,"  static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
         {
           (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
             ""InvalidGeometry"",""`%s'"",option);
          geometry=DestroyString(geometry);
           image=DestroyImage(image);
           return((Image *) NULL);
         }",ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadPSImage in coders/ps.c.
1864,CVE-2019-13136,"  static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,
     }
     case SEEK_CUR:
     {
      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||
          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))
        {
          errno=EOVERFLOW;
          return(-1);
        }
       if ((profile->offset+offset) < 0)
         return(-1);
       profile->offset+=offset;",ImageMagick before 7.0.8-50 has an integer overflow vulnerability in the function TIFFSeekCustomStream in coders/tiff.c.
1865,CVE-2019-13135,"  static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)
   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
     sizeof(*BImgBuff));   
   if(BImgBuff==NULL) goto NoMemory;
  (void) memset(BImgBuff,0,(size_t) ldblk*sizeof(*BImgBuff));
 
   offset=SeekBlob(image,6  ,SEEK_SET);
   if (offset < 0)",ImageMagick before 7.0.8-50 has a *use of uninitialized value* vulnerability in the function ReadCUTImage in coders/cut.c.
1866,CVE-2019-13134,"  static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             status=MagickFalse;
            break;
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),",ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadVIFFImage in coders/viff.c.
1867,CVE-2019-13045,"  static void destroy_server_connect(SERVER_CONNECT_REC *conn)
 
 	g_free_not_null(ircconn->usermode);
 	g_free_not_null(ircconn->alternate_nick);
	g_free_not_null(ircconn->sasl_username);
	g_free_not_null(ircconn->sasl_password);
 }
 
 void irc_core_init(void)","Irssi before 1.0.8, 1.1.x before 1.1.3, and 1.2.x before 1.2.1, when SASL is enabled, has a use after free when sending SASL login to the server."
1868,CVE-2019-12984,"  static int nfc_genl_deactivate_target(struct sk_buff *skb,
 	u32 device_idx, target_idx;
 	int rc;
 
	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
	    !info->attrs[NFC_ATTR_TARGET_INDEX])
 		return -EINVAL;
 
 	device_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);","A NULL pointer dereference vulnerability in the function nfc_genl_deactivate_target() in net/nfc/netlink.c in the Linux kernel before 5.1.13 can be triggered by a malicious user-mode program that omits certain NFC attributes, leading to denial of service."
1869,CVE-2019-12982,"  decompileCAST(int n, SWF_ACTION *actions, int maxn)
 int
 decompileAction(int n, SWF_ACTION *actions, int maxn)
 {
 
 #ifdef DEBUG
 	fprintf(stderr,""%d:\tACTION[%3.3d]: %s\n"",
 	        actions[n].SWF_ACTIONRECORD.Offset, n, 
 	        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));
 #endif
 
	switch(OpCode(actions, n, maxn))
 	{
 	case SWFACTION_END:
 		return 0;",Ming (aka libming) 0.4.8 has a heap buffer overflow and underflow in the decompileCAST function in util/decompile.c in libutil.a. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted SWF file.
1870,CVE-2019-12981,"  SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)
 			return;		
 		idx = getFillIdx(shape, fill);
 	}
	else if (idx >= 255 && shape->useVersion == SWF_SHAPE1)
	{
		SWF_error(""Too many fills for SWFShape V1.\n"" 
			  ""Use a higher SWFShape version\n"");
	}
 				
 	record = addStyleRecord(shape);
 	record.record.stateChange->leftFill = idx;",Ming (aka libming) 0.4.8 has an *fill overflow* vulnerability in the function SWFShape_setLeftFillStyle in blocks/shape.c.
1871,CVE-2019-12980,"  SWFInput_readSBits(SWFInput input, int number)
 {
 	int num = SWFInput_readBits(input, number);
 
	if(number && num & (1<<(number-1)))
 		return num - (1<<number);
 	else
 		return num;","In Ming (aka libming) 0.4.8, there is an integer overflow (caused by an out-of-range left shift) in the SWFInput_readSBits function in blocks/input.c. Remote attackers could leverage this vulnerability to cause a denial-of-service via a crafted swf file."
1872,CVE-2019-12973,"  static OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride,
 static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
 
    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
  static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = c1;
                written++;
             }
         } else {
             c = getc(IN);
  static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                     }
                     c1 = (OPJ_UINT8)c1_int;
                     *pix = c1;
                    written++;
                 }
                 if ((OPJ_UINT32)c & 1U) {  
                     c = getc(IN);
  static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
             }
         }
     } 

    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }

     return OPJ_TRUE;
 }
 ","In OpenJPEG 2.3.1, there is excessive iteration in the opj_t1_encode_cblks function of openjp2/t1.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file. This issue is similar to CVE-2018-6616."
1873,CVE-2019-12951,"  static const char *scanto(const char *p, struct mg_str *s) {
 MG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {
   uint8_t header;
   size_t len = 0, len_len = 0;
  const char *p, *end, *eop = &io->buf[io->len];
   unsigned char lc = 0;
   int cmd;
 
  MG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {
    
   len = len_len = 0;
   p = io->buf + 1;
  while (p < eop) {
     lc = *((const unsigned char *) p++);
     len += (lc & 0x7f) << 7 * len_len;
     len_len++;
  MG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {
   }
 
   end = p + len;
  if (lc & 0x80 || end > eop) return MG_MQTT_ERROR_INCOMPLETE_MSG;
 
   mm->cmd = cmd;
   mm->qos = MG_MQTT_GET_QOS(header);
  MG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {
     case MG_MQTT_CMD_PUBREL:
     case MG_MQTT_CMD_PUBCOMP:
     case MG_MQTT_CMD_SUBACK:
      if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;
       mm->message_id = getu16(p);
      p += 2;
       break;
     case MG_MQTT_CMD_PUBLISH: {
       p = scanto(p, &mm->topic);",An issue was discovered in Mongoose before 6.15. The parse_mqtt() function in mg_mqtt.c has a critical heap-based buffer overflow.
1874,CVE-2019-12904," 
 #include ""./cipher-internal.h""
 
 
 
#ifdef HAVE_GCC_ATTRIBUTE_ALIGNED
# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))
#else
# define ATTR_ALIGNED_64
#endif


 #ifdef GCM_USE_INTEL_PCLMUL
 extern void _gcry_ghash_setup_intel_pclmul (gcry_cipher_hd_t c);
 
  ghash_armv7_neon (gcry_cipher_hd_t c, byte *result, const byte *buf,
 
 
 #ifdef GCM_USE_TABLES
static struct
{
  volatile u32 counter_head;
  u32 cacheline_align[64 / 4 - 1];
  u16 R[256];
  volatile u32 counter_tail;
} gcm_table ATTR_ALIGNED_64 =
  {
    0,
    { 0, },
    {
      0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,
      0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,
      0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,
      0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,
      0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,
      0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,
      0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,
      0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,
      0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,
      0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,
      0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,
      0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,
      0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,
      0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,
      0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,
      0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,
      0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,
      0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,
      0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,
      0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,
      0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,
      0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,
      0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,
      0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,
      0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,
      0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,
      0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,
      0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,
      0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,
      0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,
      0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,
      0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,
    },
    0
  };

#define gcmR gcm_table.R
 
 static inline
 void prefetch_table(const void *tab, size_t len)
 {
   const volatile byte *vtab = tab;
   size_t i;
 
  for (i = 0; len - i >= 8 * 32; i += 8 * 32)
     {
       (void)vtab[i + 0 * 32];
       (void)vtab[i + 1 * 32];
  void prefetch_table(const void *tab, size_t len)
       (void)vtab[i + 6 * 32];
       (void)vtab[i + 7 * 32];
     }
  for (; i < len; i += 32)
    {
      (void)vtab[i];
    }
 
   (void)vtab[len - 1];
 }
 
 static inline void
 do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
   
  gcm_table.counter_head++;
  gcm_table.counter_tail++;

   
   prefetch_table(gcmM, gcmM_size);
  prefetch_table(&gcm_table, sizeof(gcm_table));
 }
 
 #ifdef GCM_TABLES_USE_U64","In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)"
1875,CVE-2019-12819,"  int __mdiobus_register(struct mii_bus *bus, struct module *owner)
 	err = device_register(&bus->dev);
 	if (err) {
 		pr_err(""mii_bus %s failed to register\n"", bus->id);
 		return -EINVAL;
 	}
 ","An issue was discovered in the Linux kernel before 5.0. The function __mdiobus_register() in drivers/net/phy/mdio_bus.c calls put_device(), which will trigger a fixed_mdio_bus_init use-after-free. This will cause a denial of service."
1876,CVE-2019-12818,"  int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
		if (!service_name_tlv) {
			err = -ENOMEM;
			goto error_tlv;
		}
 		size += service_name_tlv_length;
 	}
 
  int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);
  int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += rw_tlv_length;
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);","An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c."
1877,CVE-2019-12816,"  class CModules : public std::vector<CModule*>, private CCoreTranslationMixin {
   private:
     static ModHandle OpenModule(const CString& sModule, const CString& sModPath,
                                 CModInfo& Info, CString& sRetMsg);
    static bool ValidateModuleName(const CString& sModule, CString& sRetMsg);
 
   protected:
     CUser* m_pUser;",Modules.cpp in ZNC before 1.7.4-rc1 allows remote authenticated non-admin users to escalate privileges and execute arbitrary code by loading a module with a crafted name.
1878,CVE-2019-12730,"  static int aa_read_header(AVFormatContext *s)
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
    int ret;
 
      
     avio_skip(pb, 4);  
  static int aa_read_header(AVFormatContext *s)
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) {  
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);

            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
            if (ret != 4)
                return AVERROR_INVALIDDATA;

             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]);  
             }",aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.
1879,CVE-2019-12589," 
 #define RUN_LIB_FILE	""/run/firejail/mnt/libfiles""
 #define RUN_DNS_ETC	""/run/firejail/mnt/dns-etc""
 
#define RUN_SECCOMP_DIR	""/run/firejail/mnt/seccomp""
#define RUN_SECCOMP_LIST	""/run/firejail/mnt/seccomp/seccomp.list""	 
#define RUN_SECCOMP_PROTOCOL	""/run/firejail/mnt/seccomp/seccomp.protocol""	 
#define RUN_SECCOMP_CFG	""/run/firejail/mnt/seccomp/seccomp""			 
#define RUN_SECCOMP_32		""/run/firejail/mnt/seccomp/seccomp.32""		 
#define RUN_SECCOMP_MDWX	""/run/firejail/mnt/seccomp/seccomp.mdwx""		 
#define RUN_SECCOMP_BLOCK_SECONDARY	""/run/firejail/mnt/seccomp/seccomp.block_secondary""	 
#define RUN_SECCOMP_POSTEXEC	""/run/firejail/mnt/seccomp/seccomp.postexec""		 
 #define PATH_SECCOMP_DEFAULT (LIBDIR ""/firejail/seccomp"")			 
 #define PATH_SECCOMP_DEFAULT_DEBUG (LIBDIR ""/firejail/seccomp.debug"")	 
 #define PATH_SECCOMP_32 (LIBDIR ""/firejail/seccomp.32"")			 
 
 #define RUN_ASOUNDRC_FILE	""/run/firejail/mnt/.asoundrc""
 #define RUN_HOSTNAME_FILE	""/run/firejail/mnt/hostname""
 #define RUN_HOSTS_FILE	""/run/firejail/mnt/hosts""
 #define RUN_MACHINEID	""/run/firejail/mnt/machine-id""
 #define RUN_LDPRELOAD_FILE	""/run/firejail/mnt/ld.so.preload""
 #define RUN_UTMP_FILE		""/run/firejail/mnt/utmp""","In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker."
1880,CVE-2019-12439,"  main (int    argc,
       char **argv)
 {
   mode_t old_umask;
  const char *base_path = NULL;
   int clone_flags;
   char *old_cwd = NULL;
   pid_t pid;
  main (int    argc,
     die_with_error (""Can't open /proc"");
 
    
   * Because we use pivot_root, it won't appear to be mounted from
   * the perspective of the sandboxed process, so we can use anywhere
   * that is sure to exist, that is sure to not be a symlink controlled
   * by someone malicious, and that we won't immediately need to
   * access ourselves. */
  base_path = ""/tmp"";
 
   __debug__ ((""creating new namespace\n""));
 
  main (int    argc,
    
   * dir if the user requested to bind mount something over / (or
   * over /tmp, now that we use that for base_path). */
 
   if (mkdir (""newroot"", 0755))
     die_with_error (""Creating newroot failed"");","bubblewrap.c in Bubblewrap before 0.3.3 misuses temporary directories in /tmp as a mount point. In some particular configurations (related to XDG_RUNTIME_DIR), a local attacker may abuse this flaw to prevent other users from executing bubblewrap or potentially execute code."
1881,CVE-2019-12210," 
  
 
  
  char *secure_getenv(const char *name) {
 #endif
 
 static void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {
  struct stat st;
  FILE *file = NULL;
  int fd = -1;
   int i;

   memset(cfg, 0, sizeof(cfg_t));
   cfg->debug_file = stderr;
 
  static void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {
         cfg->debug_file = (FILE *)-1;
       }
       else {
        fd = open(filename, O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY);
        if (fd >= 0 && (fstat(fd, &st) == 0) && S_ISREG(st.st_mode)) {
          file = fdopen(fd, ""a"");
          if(file != NULL) {
            cfg->debug_file = file;
            cfg->is_custom_debug_file = 1;
            file = NULL;
            fd = -1;
           }
         }
       }
  static void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {
     D(cfg->debug_file, ""appid=%s"", cfg->appid ? cfg->appid : ""(null)"");
     D(cfg->debug_file, ""prompt=%s"", cfg->prompt ? cfg->prompt : ""(null)"");
   }

  if (fd != -1)
    close(fd);

  if (file != NULL)
    fclose(file);
 }
 
 #ifdef DBG
  int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
     DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);
 
      
    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
     if (authpending_file_descriptor < 0) {
       DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
           cfg->authpending_file, strerror(errno));
  int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
   }
   DBG(""done. [%s]"", pam_strerror(pamh, retval));
 
  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

   return retval;
 }
 ","In Yubico pam-u2f 1.0.7, when configured with debug and a custom debug log file is set using debug_file, that file descriptor is not closed when a new process is spawned. This leads to the file descriptor being inherited into the child process; the child process can then read from and write to it. This can leak sensitive information and also, if written to, be used to fill the disk or plant misinformation."
1882,CVE-2019-12111,"  static const char * getPCPOpCodeStr(uint8_t opcode)
  * buffers are same */
 static void copyIPv6IfDifferent(void * dest, const void * src)
 {
	if(dest != src && src != NULL) {
 		memcpy(dest, src, sizeof(struct in6_addr));
 	}
 }",A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in copyIPv6IfDifferent in pcpserver.c.
1883,CVE-2019-12110,"  upnp_redirect(const char * rhost, unsigned short eport,
 		                 ""%hu->%s:%hu %s"", eport, iaddr, iport, protocol);
 		return -3;
 	}

	if (desc == NULL)
		desc = """";	 

 	/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)
 	 * - 2.2.20.PortMappingDescription :
 	 *  Overwriting Previous / Existing Port Mappings:",An AddPortMapping Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in upnpredirect.c.
1884,CVE-2019-12109,"  GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
	if (!int_port || !ext_port || !protocol)
	{
		ClearNameValueList(&data);
		SoapError(h, 402, ""Invalid Args"");
		return;
	}

 	rport = (unsigned short)atoi(rem_port);
 	iport = (unsigned short)atoi(int_port);
 	 ",A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for rem_port.
1885,CVE-2019-12107,"  static void upnp_event_prepare(struct upnp_event_notify * obj)
 		l = 0;
 	}
 	obj->buffersize = 1024;
	for (;;) {
		obj->buffer = malloc(obj->buffersize);
		if(!obj->buffer) {
			syslog(LOG_ERR, ""%s: malloc returned NULL"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
 		}
		obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,
		                       obj->path, obj->addrstr, obj->portstr, l+2,
		                       obj->sub->uuid, obj->sub->seq,
		                       l, xml);
		if (obj->tosend < 0) {
			syslog(LOG_ERR, ""%s: snprintf() failed"", ""upnp_event_prepare"");
			if(xml) {
				free(xml);
			}
			obj->state = EError;
			return;
		} else if (obj->tosend < obj->buffersize) {
			break;  
		}
		 
		free(obj->buffer);
		obj->buffersize = obj->tosend + 1;	 
 	}
 	if(xml) {
 		free(xml);
 		xml = NULL;",The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value.
1886,CVE-2019-12106,"  updateDevice(const struct header * headers, time_t t)
 				if(!tmp)	 
 				{
 					syslog(LOG_ERR, ""updateDevice() : memory allocation error"");
					*pp = p->next;	 
 					free(p);
 					return 0;
 				}",The updateDevice function in minissdpd.c in MiniUPnP MiniSSDPd 1.4 and 1.5 allows a remote attacker to crash the process due to a Use After Free vulnerability.
1887,CVE-2019-12098,"  krb5_init_creds_step(krb5_context context,
 				       &ctx->req_buffer,
 				       NULL,
 				       NULL);
	    if (ret == 0 && ctx->pk_init_ctx) {
		PA_DATA *pa_pkinit_kx;
		int idx = 0;

		pa_pkinit_kx =
		    krb5_find_padata(rep.kdc_rep.padata->val,
				     rep.kdc_rep.padata->len,
				     KRB5_PADATA_PKINIT_KX,
				     &idx);

		ret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,
					  ctx->fast_state.reply_key,
					  &ctx->cred.session,
					  pa_pkinit_kx);
		if (ret)
		    krb5_set_error_message(context, ret,
					   N_(""Failed to confirm PA-PKINIT-KX"", """"));
		else if (pa_pkinit_kx != NULL)
		    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;
	    }
 	    if (ret == 0)
 		ret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);
 ","In the client side of Heimdal before 7.6.0, failure to verify anonymous PKINIT PA-PKINIT-KX key exchange permits a man-in-the-middle attack. This issue is in krb5_init_creds_step in lib/krb5/init_creds_pw.c."
1888,CVE-2019-11929,"  String string_number_format(double d, int dec,
   d = php_math_round(d, dec);
 
    
   
   String tmpstr(63, ReserveString);
   tmpbuf = tmpstr.mutableData();
   tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d);
   
   
   
   if (tmplen < 0) return empty_string();
  if (tmplen < 64 && (tmpbuf == nullptr || !isdigit((int)tmpbuf[0]))) {
     tmpstr.setSize(tmplen);
     return tmpstr;
   }","Insufficient boundary checks when formatting numbers in number_format allows read/write access to out-of-bounds memory, potentially leading to remote code execution. This issue affects HHVM versions prior to 3.30.10, all versions between 4.0.0 and 4.8.5, all versions between 4.9.0 and 4.18.2, and versions 4.19.0, 4.19.1, 4.20.0, 4.20.1, 4.20.2, 4.21.0, 4.22.0, 4.23.0."
1889,CVE-2019-11926,"  static int exif_scan_JPEG_header(image_info_type *ImageInfo) {
       case M_SOF13:
       case M_SOF14:
       case M_SOF15:
        if ((itemlen - 2) < 6) {
          return 0;
        }

         exif_process_SOFn(Data, marker, &sof_info);
         ImageInfo->Width  = sof_info.width;
         ImageInfo->Height = sof_info.height;","Insufficient boundary checks when processing M_SOFx markers from JPEG headers in the GD extension could allow access to out-of-bounds memory via a maliciously constructed invalid JPEG input. This issue affects HHVM versions prior to 3.30.9, all versions between 4.0.0 and 4.8.3, all versions between 4.9.0 and 4.15.2, and versions 4.16.0 to 4.16.3, 4.17.0 to 4.17.2, 4.18.0 to 4.18.1, 4.19.0, 4.20.0 to 4.20.1."
1890,CVE-2019-11925,"  static void exif_process_APP12(image_info_type *ImageInfo,
     exif_iif_add_tag(ImageInfo, SECTION_APP12, ""Company"",
                      TAG_NONE, TAG_FMT_STRING, l1, buffer+2);
     if (length > 2+l1+1) {
      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);
       exif_iif_add_tag(ImageInfo, SECTION_APP12, ""Info"",
                        TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);
     }","Insufficient boundary checks when processing the JPEG APP12 block marker in the GD extension could allow access to out-of-bounds memory via a maliciously constructed invalid JPEG input. This issue affects HHVM versions prior to 3.30.9, all versions between 4.0.0 and 4.8.3, all versions between 4.9.0 and 4.15.2, and versions 4.16.0 to 4.16.3, 4.17.0 to 4.17.2, 4.18.0 to 4.18.1, 4.19.0, 4.20.0 to 4.20.1."
1891,CVE-2019-11924,"  folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
           static_cast<ContentTypeType>(msg.type)));
   }
 
  if (!msg.fragment || msg.fragment->empty()) {
     if (msg.type == ContentType::application_data) {
       msg.fragment = folly::IOBuf::create(0);
     } else {","A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00."
1892,CVE-2019-11922,"  ZSTD_buildCTable(void* dst, size_t dstCapacity,
 {
     BYTE* op = (BYTE*)dst;
     const BYTE* const oend = op + dstCapacity;
    DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);
 
     switch (type) {
     case set_rle:
         CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
        if (dstCapacity==0) return ERROR(dstSize_tooSmall);
        *op = codeTable[0];
         return 1;
     case set_repeat:
         memcpy(nextCTable, prevCTable, prevCTableSize);
  ZSTD_encodeSequences_body(
     FSE_CState_t  stateLitLength;
 
     CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall);  
    DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",
                (int)(blockStream.endPtr - blockStream.startPtr),
                (unsigned)dstCapacity);
 
      
     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
  ZSTD_encodeSequences_body(
                 BIT_addBits(&blockStream, sequences[n].offset, ofBits);      
             }
             BIT_flushBits(&blockStream);                                     
            DEBUGLOG(7, ""remaining space : %i"", (int)(blockStream.endPtr - blockStream.ptr));
     }   }
 
     DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", stateMatchLength.stateLog);
  static size_t ZSTD_encodeSequences(
             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
             seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
 {
    DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)dstCapacity);
 #if DYNAMIC_BMI2
     if (bmi2) {
         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
  ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,
      
     {   U32 max = MaxML;
         size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);    
        DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(oend-op));
         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;
         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);
         assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none));  ",A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.
1893,CVE-2019-11921," 
  */
 
 #include ""StructuredHeadersUtilities.h""
 #include ""StructuredHeadersConstants.h""
 
#include ""proxygen/lib/utils/Base64.h""

 namespace proxygen {
 namespace StructuredHeaders {
 
  std::string decodeBase64(
 
   if (encoded.size() == 0) {
      
    return std::string();
   }
 
  int padding = 0;
  for (auto it = encoded.rbegin();
       padding < 2 && it != encoded.rend() && *it == '=';
       ++it) {
    ++padding;
  }
 
  return Base64::decode(encoded, padding);
 }
 
 std::string encodeBase64(const std::string& input) {
  return Base64::encode(folly::ByteRange(
                            reinterpret_cast<const uint8_t*>(input.c_str()),
                            input.length()));
 }
 
 }",An out of bounds write is possible via a specially crafted packet in certain configurations of Proxygen due to improper handling of Base64 when parsing malformed binary content in Structured HTTP Headers. This issue affects versions of proxygen prior to v2019.07.22.00.
1894,CVE-2019-11884,"  static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user
 			sockfd_put(csock);
 			return err;
 		}
		ca.name[sizeof(ca.name)-1] = 0;
 
 		err = hidp_connection_add(&ca, csock, isock);
 		if (!err && copy_to_user(argp, &ca, sizeof(ca)))","The do_hidp_sock_ioctl function in net/bluetooth/hidp/sock.c in the Linux kernel before 5.0.15 allows a local user to obtain potentially sensitive information from kernel stack memory via a HIDPCONNADD command, because a name field may not end with a '0' character."
1895,CVE-2019-11833,"  static int ext4_ext_split(handle_t *handle, struct inode *inode,
 	__le32 border;
 	ext4_fsblk_t *ablocks = NULL;  
 	int err = 0;
	size_t ext_size = 0;
 
 	 
 	 
  static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		le16_add_cpu(&neh->eh_entries, m);
 	}
 
	 
	ext_size = sizeof(struct ext4_extent_header) +
		sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);
	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 	ext4_extent_block_csum_set(inode, neh);
 	set_buffer_uptodate(bh);
 	unlock_buffer(bh);
  static int ext4_ext_split(handle_t *handle, struct inode *inode,
 				sizeof(struct ext4_extent_idx) * m);
 			le16_add_cpu(&neh->eh_entries, m);
 		}
		 
		ext_size = sizeof(struct ext4_extent_header) +
		   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));
		memset(bh->b_data + ext_size, 0,
			inode->i_sb->s_blocksize - ext_size);
 		ext4_extent_block_csum_set(inode, neh);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
  static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
 	ext4_fsblk_t newblock, goal = 0;
 	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
 	int err = 0;
	size_t ext_size = 0;
 
 	 
 	if (ext_depth(inode))
  static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
 		goto out;
 	}
 
	ext_size = sizeof(EXT4_I(inode)->i_data);
 	 
	memmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);
	 
	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 
 	 
 	neh = ext_block_hdr(bh);","fs/ext4/extents.c in the Linux kernel through 5.1.2 does not zero out the unused memory region in the extent tree block, which might allow local users to obtain sensitive information by reading uninitialized data in the filesystem."
1896,CVE-2019-11815,"  static void rds_tcp_kill_sock(struct net *net)
 	list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {
 		struct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);
 
		if (net != c_net)
 			continue;
 		if (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {
 			list_move_tail(&tc->t_tcp_node, &tmp_list);","An issue was discovered in rds_tcp_kill_sock in net/rds/tcp.c in the Linux kernel before 5.0.8. There is a race condition leading to a use-after-free, related to net namespace cleanup."
1897,CVE-2019-11811,"  static int try_smi_init(struct smi_info *new_smi)
 	WARN_ON(new_smi->io.dev->init_name != NULL);
 
  out_err:
	if (rv && new_smi->io.io_cleanup) {
		new_smi->io.io_cleanup(&new_smi->io);
		new_smi->io.io_cleanup = NULL;
	}

 	kfree(init_name);
 	return rv;
 }","An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c."
1898,CVE-2019-11810,"  int megasas_alloc_cmds(struct megasas_instance *instance)
 	if (megasas_create_frame_pool(instance)) {
 		dev_printk(KERN_DEBUG, &instance->pdev->dev, ""Error creating frame DMA pool\n"");
 		megasas_free_cmds(instance);
		return -ENOMEM;
 	}
 
 	return 0;","An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free."
1899,CVE-2019-11599,"  void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)
 		 * will only be one mm, so no big deal.
 		 */
 		down_write(&mm->mmap_sem);
		if (!mmget_still_valid(mm))
			goto skip_mm;
 		mutex_lock(&ufile->umap_lock);
 		list_for_each_entry_safe (priv, next_priv, &ufile->umaps,
 					  list) {
  void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)
 			vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);
 		}
 		mutex_unlock(&ufile->umap_lock);
	skip_mm:
 		up_write(&mm->mmap_sem);
 		mmput(mm);
 	}","The coredump implementation in the Linux kernel before 5.0.10 does not use locking or other mechanisms to prevent vma layout or vma flags changes while it runs, which allows local users to obtain sensitive information, cause a denial of service, or possibly have unspecified other impact by triggering a race condition with mmget_not_zero or get_task_mm calls. This is related to fs/userfaultfd.c, mm/mmap.c, fs/proc/task_mmu.c, and drivers/infiniband/core/uverbs_main.c."
1900,CVE-2019-11596,"  static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens)
                 out_string(c, ""OK"");
             }
         }
    } else if (strcmp(tokens[1].value, ""mode"") == 0 && ntokens >= 4 &&
                settings.lru_maintainer_thread) {
         if (strcmp(tokens[2].value, ""flat"") == 0) {
             settings.lru_segmented = false;
  static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens)
         } else {
             out_string(c, ""ERROR"");
         }
    } else if (strcmp(tokens[1].value, ""temp_ttl"") == 0 && ntokens >= 4 &&
                settings.lru_maintainer_thread) {
         if (!safe_strtol(tokens[2].value, &ttl)) {
             out_string(c, ""ERROR"");","In memcached before 1.5.14, a NULL pointer dereference was found in the *lru mode* and *lru temp_ttl* commands. This causes a denial of service when parsing crafted lru command messages in process_lru_command in memcached.c."
1901,CVE-2019-11498,"  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
             if (!strncmp (prop_chunk, ""SND "", 4)) {
                 char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;
                 uint16_t numChannels = 0, chansSpecified, chanMask = 0;
                uint32_t sampleRate = 0;
 
                 while (eptr - cptr >= sizeof (dff_chunk_header)) {
                     memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));
  int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpa
         }
         else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) {
 
            if (!config->num_channels || !config->sample_rate) {
                 error_line (""%s is not a valid .DFF file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }","WavpackSetConfiguration64 in pack_utils.c in libwavpack.a in WavPack through 5.1.0 has a *Conditional jump or move depends on uninitialised value* condition, which might allow attackers to cause a denial of service (application crash) via a DFF file that lacks valid sample-rate data."
1902,CVE-2019-11487,"  static inline bool is_pci_p2pdma_page(const struct page *page)
 }
 #endif  
 
 
#define page_ref_zero_or_close_to_overflow(page) \
	((unsigned int) page_ref_count(page) + 127u <= 127u)

 static inline void get_page(struct page *page)
 {
 	page = compound_head(page);
 	 
	VM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page);
 	page_ref_inc(page);
 }
 ","The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests."
1903,CVE-2019-11472,"  static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if ((header.bits_per_pixel == 0) || (header.bits_per_pixel > 32))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if ((header.bitmap_bit_order != MSBFirst) &&
      (header.bitmap_bit_order != LSBFirst))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (header.bitmap_unit > 32)",ReadXWDImage in coders/xwd.c in the XWD image parsing component of ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (divide-by-zero error) by crafting an XWD image file in which the header indicates neither LSB first nor MSB first.
1904,CVE-2019-11470,"  static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
       (void) CloseBlob(image);
       return(image);
     }
  if (((MagickSizeType) image->columns*image->rows) > GetBlobSize(image))
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
   for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
   {
     int",The cineon parsing component in ImageMagick 7.0.8-26 Q16 allows attackers to cause a denial-of-service (uncontrolled resource consumption) by crafting a Cineon image with an incorrect claimed image size. This occurs because ReadCINImage in coders/cin.c lacks a check for insufficient image data in a file.
1905,CVE-2019-11463,"  archive_read_format_zip_cleanup(struct archive_read *a)
 		inflateEnd(&zip->stream);
 #endif
 
#if HAVE_LZMA_H && HAVE_LIBLZMA
     if (zip->zipx_lzma_valid) {
 		lzma_end(&zip->zipx_lzma_stream);
 	}",A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.
1906,CVE-2019-11413,"  void js_newregexp(js_State *J, const char *pattern, int flags)
 
 void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 {
	int result;
 	int i;
 	int opts;
 	Resub m;
  void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)
 		}
 	}
 
	result = js_regexec(re->prog, text, &m, opts);
	if (result < 0)
		js_error(J, ""regexec failed"");
	if (result == 0) {
 		js_newarray(J);
 		js_pushstring(J, text);
 		js_setproperty(J, -2, ""input"");
  static void Rp_test(js_State *J)
 {
 	js_Regexp *re;
 	const char *text;
	int result;
 	int opts;
 	Resub m;
 
  static void Rp_test(js_State *J)
 		}
 	}
 
	result = js_regexec(re->prog, text, &m, opts);
	if (result < 0)
		js_error(J, ""regexec failed"");
	if (result == 0) {
 		if (re->flags & JS_REGEXP_G)
 			re->last = re->last + (m.sub[0].ep - text);
 		js_pushboolean(J, 1);",An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.
1907,CVE-2019-11412,"  static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catch
 		emitstring(J, F, OP_CATCH, catchvar->string);
 		cstm(J, F, catchstm);
 		emit(J, F, OP_ENDCATCH);
		emit(J, F, OP_ENDTRY);
 		L3 = emitjump(J, F, OP_JUMP);  
 	}
 	label(J, F, L1);",An issue was discovered in Artifex MuJS 1.0.5. jscompile.c can cause a denial of service (invalid stack-frame jump) because it lacks an ENDTRY opcode call.
1908,CVE-2019-11411,"  static void Np_valueOf(js_State *J)
 
 static void Np_toString(js_State *J)
 {
	char buf[100];
 	js_Object *self = js_toobject(J, 0);
 	int radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);
 	if (self->type != JS_CNUMBER)
  static void Np_toString(js_State *J)
 	 
 	{
 		static const char digits[] = ""0123456789abcdefghijklmnopqrstuvwxyz"";
 		double number = self->u.number;
 		int sign = self->u.number < 0;
 		js_Buffer *sb = NULL;
  static void Np_toString(js_State *J)
  
 static void numtostr(js_State *J, const char *fmt, int w, double n)
 {
	 
	char buf[50], *e;
 	sprintf(buf, fmt, w, n);
 	e = strchr(buf, 'e');
 	if (e) {",An issue was discovered in Artifex MuJS 1.0.5. The Number#toFixed() and numtostr implementations in jsnumber.c have a stack-based buffer overflow.
1909,CVE-2019-11339,"  static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n
             code >>= 1;
             run = (1 << (additional_code_len - 1)) + code;
             idx += run;
            if (idx > 63)
                return AVERROR_INVALIDDATA;
             j = scantable[idx++];
             block[j] = sign ? 1 : -1;
         } else if (group >= 13 && group <= 20) {
              
            if (idx > 63)
                return AVERROR_INVALIDDATA;
             j = scantable[idx++];
             block[j] = get_xbits(&s->gb, additional_code_len);
         } else if (group == 21) {
              
            if (idx > 63)
                return AVERROR_INVALIDDATA;
             j = scantable[idx++];
             additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;
             flc = get_bits(&s->gb, additional_code_len);",The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.
1910,CVE-2019-11338,"  static int hls_slice_header(HEVCContext *s)
 
      
     sh->first_slice_in_pic_flag = get_bits1(gb);
    if (s->ref && sh->first_slice_in_pic_flag) {
        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
        return 1;  
    }

     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
         s->seq_decode = (s->seq_decode + 1) & 0xff;
         s->max_ra     = INT_MAX;
  static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         ret = hls_slice_header(s);
         if (ret < 0)
             return ret;
        if (ret == 1) {
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }

 
         if (
             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
  static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         }
 
         if (s->sh.first_slice_in_pic_flag) {
             if (s->max_ra == INT_MAX) {
                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                     s->max_ra = s->poc;","libavcodec/hevcdec.c in FFmpeg 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data."
1911,CVE-2019-11222,"  GF_Err gf_bin128_parse(const char *string, bin128 value)
 			sscanf(szV, ""%x"", &v);
 			value[i] = v;
 			i++;
			if (i > 15) {
				 
				i++;
				break;
			}
 		}
 	}
 	if (i != 16) {",gf_bin128_parse in utils/os_divers.c in GPAC 0.7.1 has a buffer overflow issue for the crypt feature when encountering a crafted_drm_file.xml file.
1912,CVE-2019-11072,"  static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
         }
     }
     if (qs >= 0) {
        const int qslen = blen - qs;
        memmove(s+j, s+qs, (size_t)qslen);
        qs = j;
        j += qslen;
     }
     buffer_string_set_length(b, j);
     return qs;","** DISPUTED ** lighttpd before 1.4.54 has a signed integer overflow, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a malicious HTTP GET request, as demonstrated by mishandling of /%2F? in burl_normalize_2F_to_slash_fix in burl.c. NOTE: The developer states *The feature which can be abused to cause the crash is a new feature in lighttpd 1.4.50, and is not enabled by default. It must be explicitly configured in the config file (e.g. lighttpd.conf). Certain input will trigger an abort() in lighttpd when that feature is enabled. lighttpd detects the underflow or realloc() will fail (in both 32-bit and 64-bit executables), also detected in lighttpd. Either triggers an explicit abort() by lighttpd. This is not exploitable beyond triggering the explicit abort() with subsequent application exit.*"
1913,CVE-2019-10678,"  const char *szInsecureArgumentOptions[] = {
 	""$"",
 	""<"",
 	"">"",
	""\n"",
	""\r"",
 	NULL
 };
 ",Domoticz before 4.10579 neglects to categorize n and r as insecure argument options.
1914,CVE-2019-10672,"  int treeRead(struct READER *reader, struct DATAOBJECT *data) {
 				for (i = 0; i < olen; i++) {
 					b = i / elements;
 					x = i % elements + start[0];
					j = x * size + b;
					if (j>=0 && j < elements * size) {
 						((char*)data->data)[j] = output[i];
 					}
 				}
  int treeRead(struct READER *reader, struct DATAOBJECT *data) {
 					x = i % elements;
 					y = x % dy + start[1];
 					x = x / dy + start[0];
					j = ((x * sy + y) * size) + b;
					if (j>=0 && j < elements * size) {
 						((char*)data->data)[j] = output[i];
 					}
 				}
  int treeRead(struct READER *reader, struct DATAOBJECT *data) {
 					z = x % dz + start[2];
 					y = (x / dz) % dy + start[1];
 					x = (x / dzy) + start[0];
					j = (x * szy + y * sz + z) * size + b;
					if (j>=0 && j < elements * size) {
 						((char*)data->data)[j] = output[i];
 					}
 				}",treeRead in hdf/btree.c in libmysofa before 0.7 does not properly validate multiplications and additions.
1915,CVE-2019-10664,"  namespace http {
 				return;
 			}
 			std::vector<std::vector<std::string> > result;
			result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%d"", atol(idx.c_str()));
 			if (result.empty())
 				return;
 			reply::set_content(&rep, result[0][0].begin(), result[0][0].end());",Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.
1916,CVE-2019-10639,"  struct net {
 						 */
 	spinlock_t		rules_mod_lock;
 
	u32			hash_mix;
 	atomic64_t		cookie_gen;
 
 	struct list_head	list;		 ","The Linux kernel 4.x (starting from 4.1) and 5.x before 5.0.8 allows Information Exposure (partial kernel address disclosure), leading to a KASLR bypass. Specifically, it is possible to extract the KASLR kernel image offset using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). This key contains enough bits from a kernel address (of a static variable) so when the key is extracted (via enumeration), the offset of the kernel image is exposed. This attack can be carried out remotely, by the attacker forcing the target device to send UDP or ICMP (or certain other) traffic to attacker-controlled IP addresses. Forcing a server to send UDP traffic is trivial if the server is a DNS server. ICMP traffic is trivial if the server answers ICMP Echo requests (ping). For client targets, if the target visits the attacker's web page, then WebRTC or gQUIC can be used to force UDP traffic to attacker-controlled IP addresses. NOTE: this attack against KASLR became viable in 4.1 because IP ID generation was changed to have a dependency on an address associated with a network namespace."
1917,CVE-2019-10638,"  typedef struct {
 	u64 key[2];
 } siphash_key_t;
 
static inline bool siphash_key_is_zero(const siphash_key_t *key)
{
	return !(key->key[0] | key->key[1]);
}

 u64 __siphash_aligned(const void *data, size_t len, const siphash_key_t *key);
 #ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
 u64 __siphash_unaligned(const void *data, size_t len, const siphash_key_t *key);","In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses."
1918,CVE-2019-10131,"  static int format8BIM(Image *ifile, Image *ofile)
         return -1;
       }
      
    str=(unsigned char *) AcquireQuantumMemory((size_t) count+1,sizeof(*str));
     if (str == (unsigned char *) NULL)
       {
         PString=(unsigned char *) RelinquishMagickMemory(PString);",An off-by-one read vulnerability was discovered in ImageMagick before version 7.0.7-28 in the formatIPTCfromBuffer function in coders/meta.c. A local attacker may use this flaw to read beyond the end of the buffer or to crash the program.
1919,CVE-2019-9917,"  class CAdminMod : public CModule {
 #ifdef HAVE_ICU
         else if (sVar == ""clientencoding"") {
             pUser->SetClientEncoding(sValue);
            PutModule(""ClientEncoding = "" + pUser->GetClientEncoding());
         }
 #endif
         else",ZNC before 1.7.3-rc1 allows an existing remote user to cause a Denial of Service (crash) via invalid encoding.
1920,CVE-2019-9578,"  init_device (u2fh_devs * devs, struct u2fdevice *dev)
       (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,
        &resplen) == U2FH_OK)
     {
      int offs = sizeof (nonce);
       
      if (resplen < 17)
 	{
	  return U2FH_SIZE_ERROR;
 	}

       
      if (memcmp (nonce, resp, sizeof (nonce)) != 0)
	{
	  return U2FH_TRANSPORT_ERROR;
	}

      dev->cid =
	resp[offs] << 24 | resp[offs + 1] << 16 | resp[offs +
						       2] << 8 | resp[offs +
								      3];
      offs += 4;
      dev->versionInterface = resp[offs++];
      dev->versionMajor = resp[offs++];
      dev->versionMinor = resp[offs++];
      dev->versionBuild = resp[offs++];
      dev->capFlags = resp[offs++];
     }
   else
     {","In devs.c in Yubico libu2f-host before 1.1.8, the response to init is misparsed, leaking uninitialized stack memory back to the device."
1921,CVE-2019-9213,"  int expand_downwards(struct vm_area_struct *vma,
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct vm_area_struct *prev;
	int error = 0;
 
 	address &= PAGE_MASK;
	if (address < mmap_min_addr)
		return -EPERM;
 
 	 
 	prev = vma->vm_prev;","In the Linux kernel before 4.20.14, expand_downwards in mm/mmap.c lacks a check for the mmap minimum address, which makes it easier for attackers to exploit kernel NULL pointer dereferences on non-SMAP platforms. This is related to a capability check for the wrong task."
1922,CVE-2019-9162,"  static void fast_csum(struct snmp_ctx *ctx, unsigned char offset)
 int snmp_version(void *context, size_t hdrlen, unsigned char tag,
 		 const void *data, size_t datalen)
 {
	if (datalen != 1)
		return -EINVAL;
 	if (*(unsigned char *)data > 1)
 		return -ENOTSUPP;
 	return 1;
  int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
 		const void *data, size_t datalen)
 {
 	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata;
 
	if (datalen != 4)
		return -EINVAL;
	pdata = (__be32 *)data;
 	if (*pdata == ctx->from) {
 		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
 			 (void *)&ctx->from, (void *)&ctx->to);","In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper."
1923,CVE-2019-9003,"  EXPORT_SYMBOL(ipmi_get_smi_info);
 static void free_user(struct kref *ref)
 {
 	struct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);
	cleanup_srcu_struct(&user->release_barrier);
 	kfree(user);
 }
 
  int ipmi_destroy_user(struct ipmi_user *user)
 {
 	_ipmi_destroy_user(user);
 
 	kref_put(&user->refcount, free_user);
 
 	return 0;","In the Linux kernel before 4.20.5, attackers can trigger a drivers/char/ipmi/ipmi_msghandler.c use-after-free and OOPS by arranging for certain simultaneous execution of the code, as demonstrated by a *service ipmievd restart* loop."
1924,CVE-2019-8906," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.157 2019/01/02 19:44:14 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,
 			char sbuf[512];
 			struct NetBSD_elfcore_procinfo pi;
 			memset(&pi, 0, sizeof(pi));
			memcpy(&pi, nbuf + doff, MIN(descsz, sizeof(pi)));
 
 			if (file_printf(ms, "", from '%.31s', pid=%u, uid=%u, ""
 			    ""gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)"",",do_core_note in readelf.c in libmagic.a in file 5.35 has an out-of-bounds read because memcpy is misused.
1925,CVE-2019-8460," 
 
  
 
  
 #define	MAX_SACK_BLKS	6	 
#define	TCP_MAX_SACK	3	 
#define	TCP_SACKHOLE_LIMIT 128	 
 
 #define	TCP_MAXBURST	4	 
 ","Reuven Plevinsky and Tal Vainshtein of Check Point Software Technologies Ltd. discovered that OpenBSD kernel (all versions, including 6.5) can be forced to create long chains of TCP SACK holes that cause very expensive calls to tcp_sack_option() for every incoming SACK packet which can lead to a denial of service."
1926,CVE-2019-7397,"  RestoreMSCWarning
             status=InjectImageBlob(image_info,image,image,""jpeg"",exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             status=InjectImageBlob(image_info,image,image,""jp2"",exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             pixel_info=RelinquishVirtualMemory(pixel_info);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             status=InjectImageBlob(image_info,image,image,""jpeg"",exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             status=InjectImageBlob(image_info,image,image,""jp2"",exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;
             pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));
             if (pixel_info == (MemoryInfo *) NULL)
              ThrowPDFException(ResourceLimitError,""MemoryAllocationFailed"");
             pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
             /*
               Dump runoffset encoded pixels.
  RestoreMSCWarning
             pixel_info=RelinquishVirtualMemory(pixel_info);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
               length=(size_t) number_pixels;
               pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));
               if (pixel_info == (MemoryInfo *) NULL)
                ThrowPDFException(ResourceLimitError,""MemoryAllocationFailed"");
               pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
               /*
                 Dump Runlength encoded pixels.
  RestoreMSCWarning
               pixel_info=RelinquishVirtualMemory(pixel_info);
               if (status == MagickFalse)
                 {
                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                   (void) CloseBlob(image);
                   return(MagickFalse);
                 }
  RestoreMSCWarning
               exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             status=InjectImageBlob(image_info,image,tile_image,""jp2"",exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             pixel_info=RelinquishVirtualMemory(pixel_info);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
               exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             status=InjectImageBlob(image_info,image,tile_image,""jp2"",exception);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
             pixel_info=RelinquishVirtualMemory(pixel_info);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }
  RestoreMSCWarning
               pixel_info=RelinquishVirtualMemory(pixel_info);
               if (status == MagickFalse)
                 {
                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                   (void) CloseBlob(image);
                   return(MagickFalse);
                 }
  RestoreMSCWarning
             pixel_info=RelinquishVirtualMemory(pixel_info);
             if (status == MagickFalse)
               {
                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);
                 (void) CloseBlob(image);
                 return(MagickFalse);
               }","In ImageMagick before 7.0.8-25 and GraphicsMagick through 1.3.31, several memory leaks exist in WritePDFImage in coders/pdf.c."
1927,CVE-2019-7396,"  static Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exceptio
   if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)
     {
       sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);
      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);
       ThrowReaderException(CorruptImageError,""CorruptImage"");
     }
   sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);","In ImageMagick before 7.0.8-25, a memory leak exists in ReadSIXELImage in coders/sixel.c."
1928,CVE-2019-7395,"  static size_t WritePSDChannel(const PSDInfo *psd_info,
       if (deflateInit(&stream,level) != Z_OK)
         {
           quantum_info=DestroyQuantumInfo(quantum_info);
          compressed_pixels=(unsigned char *) RelinquishMagickMemory(
            compressed_pixels);
           return(0);
         }
     }","In ImageMagick before 7.0.8-25, a memory leak exists in WritePSDChannel in coders/psd.c."
1929,CVE-2019-7308,"  struct bpf_verifier_state_list {
 #define BPF_ALU_SANITIZE_SRC		1U
 #define BPF_ALU_SANITIZE_DST		2U
 #define BPF_ALU_NEG_VALUE		(1U << 2)
#define BPF_ALU_NON_POINTER		(1U << 3)
 #define BPF_ALU_SANITIZE		(BPF_ALU_SANITIZE_SRC | \
 					 BPF_ALU_SANITIZE_DST)
 ","kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks."
1930,CVE-2019-7175,"  static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,
     if (pcd_table[i] == (PCDTable *) NULL)
       {
         buffer=(unsigned char *) RelinquishMagickMemory(buffer);
        for (j=0; j < i; j++)
          pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);
         ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
           image->filename);
       }
  static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,
       if (r->length > 16)
         {
           buffer=(unsigned char *) RelinquishMagickMemory(buffer);
          for (j=0; j <= i; j++)
            pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);
           return(MagickFalse);
         }
       PCDGetBits(16);","In ImageMagick before 7.0.8-25, some memory leaks exist in DecodeImage in coders/pcd.c."
1931,CVE-2019-6978,"  static void cl_hash (register count_int chsize, GifCtx *ctx);
 static void char_init (GifCtx *ctx);
 static void char_out (int c, GifCtx *ctx);
 static void flush_char (GifCtx *ctx);

static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);

 void * gdImageGifPtr (gdImagePtr im, int *size)
 {
   void *rv;
   gdIOCtx *out = gdNewDynamicCtx (2048, NULL);
	if (!_gdImageGifCtx(im, out)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
   out->gd_free (out);
   return rv;
 }
  void gdImageGif (gdImagePtr im, FILE * outFile)
 }
 
 void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
{
	_gdImageGifCtx(im, out);
}

 
static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
  void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return 1;
 		}
 		tim = pim;
 	}
  void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 		 
 		gdImageDestroy(	pim);
 	}

    return 0;
 }
 
 static int","The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected."
1932,CVE-2019-6974,"  static int kvm_ioctl_create_device(struct kvm *kvm,
 	if (ops->init)
 		ops->init(dev);
 
	kvm_get_kvm(kvm);
 	ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);
 	if (ret < 0) {
		kvm_put_kvm(kvm);
 		mutex_lock(&kvm->lock);
 		list_del(&dev->vm_node);
 		mutex_unlock(&kvm->lock);
 		ops->destroy(dev);
 		return ret;
 	}
 
 	cd->fd = ret;
 	return 0;
 }","In the Linux kernel before 4.20.8, kvm_ioctl_create_device in virt/kvm/kvm_main.c mishandles reference counting because of a race condition, leading to a use-after-free."
1933,CVE-2019-5892,"  static const struct message attr_str[] = {
 	{BGP_ATTR_AS_PATHLIMIT, ""AS_PATHLIMIT""},
 	{BGP_ATTR_PMSI_TUNNEL, ""PMSI_TUNNEL_ATTRIBUTE""},
 	{BGP_ATTR_ENCAP, ""ENCAP""},
#if ENABLE_BGP_VNC_ATTR
 	{BGP_ATTR_VNC, ""VNC""},
 #endif
 	{BGP_ATTR_LARGE_COMMUNITIES, ""LARGE_COMMUNITY""},
  bgp_attr_parse_ret_t bgp_attr_parse(struct peer *peer, struct attr *attr,
 		case BGP_ATTR_EXT_COMMUNITIES:
 			ret = bgp_attr_ext_communities(&attr_args);
 			break;
#if ENABLE_BGP_VNC_ATTR
 		case BGP_ATTR_VNC:
 #endif
 		case BGP_ATTR_ENCAP:
  static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,
 		attrhdrlen = 1 + 1;    
 		break;
 
#if ENABLE_BGP_VNC_ATTR
 	case BGP_ATTR_VNC:
 		attrname = ""VNC"";
 		subtlvs = attr->vnc_subtlvs;
  bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,
 		 
 		bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);
 
#if ENABLE_BGP_VNC_ATTR
 		 
 		bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);
 #endif","bgpd in FRRouting FRR (aka Free Range Routing) 2.x and 3.x before 3.0.4, 4.x before 4.0.1, 5.x before 5.0.2, and 6.x before 6.0.2 (not affecting Cumulus Linux or VyOS), when ENABLE_BGP_VNC is used for Virtual Network Control, allows remote attackers to cause a denial of service (peering session flap) via attribute 255 in a BGP UPDATE packet. This occurred during Disco in January 2019 because FRR does not implement RFC 7606, and therefore the packets with 255 were considered invalid VNC data and the BGP session was closed."
1934,CVE-2019-5489,"  static int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,
 	return 0;
 }
 
 static int mincore_unmapped_range(unsigned long addr, unsigned long end,
 				   struct mm_walk *walk)
 {
	unsigned char *vec = walk->private;
	unsigned long nr = (end - addr) >> PAGE_SHIFT;

	memset(vec, 0, nr);
	walk->private += nr;
 	return 0;
 }
 
  static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 		goto out;
 	}
 
	 
 	if (pmd_trans_unstable(pmd)) {
		memset(vec, 1, nr);
 		goto out;
 	}
 
  static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 		pte_t pte = *ptep;
 
 		if (pte_none(pte))
			*vec = 0;
 		else if (pte_present(pte))
 			*vec = 1;
 		else {  
 			swp_entry_t entry = pte_to_swp_entry(pte);
 
			 
			*vec = !!non_swap_entry(entry);
 		}
 		vec++;
 	}","The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server."
1935,CVE-2019-3877,"  int am_check_url(request_rec *r, const char *url)
                           ""Control character detected in URL."");
             return HTTP_BAD_REQUEST;
         }
        if (*i == '\\') {
             
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Backslash character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
     }
 
     return OK;","A vulnerability was found in mod_auth_mellon before v0.14.2. An open redirect in the logout URL allows requests with backslashes to pass through by assuming that it is a relative URL, while the browsers silently convert backslash characters into forward slashes treating them as an absolute URL. This mismatch allows an attacker to bypass the redirect URL validation logic in apr_uri_parse function."
1936,CVE-2019-3817,"  void comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {
     struct Pair {
         COMPS_HSList * subnodes;
         char * key;
     } *pair, *parent_pair;
 
     pair = malloc(sizeof(struct Pair));
  void comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {
         parent_pair = (struct Pair*) it->data;
         free(it);
 
         for (it = tmp_subnodes->first; it != NULL; it=it->next) {
             pair = malloc(sizeof(struct Pair));
             pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;","A use-after-free flaw has been discovered in libcomps before version 0.1.10 in the way ObjMRTrees are merged. An attacker, who is able to make an application read a crafted comps XML file, may be able to crash the application or execute malicious code."
1937,CVE-2019-3569,"  FastCGIServer::FastCGIServer(const std::string &address,
   if (useFileSocket) {
     sock_addr.setFromPath(address);
   } else if (address.empty()) {
    sock_addr.setFromHostPort(""localhost"", port);
    assert(sock_addr.isLoopbackAddress());
   } else {
     sock_addr.setFromHostPort(address, port);
   }","HHVM, when used with FastCGI, would bind by default to all available interfaces. This behavior could allow a malicious individual unintended direct access to the application, which could result in information disclosure. This issue affects versions 4.3.0, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, versions 3.30.5 and below, and all versions in the 4.0, 4.1, and 4.2 series."
1938,CVE-2019-3565,"  uint32_t skip(Protocol_& prot, TType arg_type) {
       result += prot.readListEnd();
       return result;
     }
    default: {
      TProtocolException::throwInvalidSkipType(arg_type);
    }
   }
 }
 ","Legacy C++ Facebook Thrift servers (using cpp instead of cpp2) would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.05.06.00."
1939,CVE-2019-3563,"  int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {
     auto b = c.read<char>();
     if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {
       return i;
    } else if (
        terminatorType_ != TerminatorType::NEWLINE && b == '\r' &&
        !c.isAtEnd() && *c.peekBytes().data() == '\n') {
       return i;
     }
   }","Wangle's LineBasedFrameDecoder contains logic for identifying newlines which incorrectly advances a buffer, leading to a potential underflow. This affects versions of Wangle prior to v2019.04.22.00"
1940,CVE-2019-3561," 
 
 #include ""hphp/util/lock.h""
 #include ""hphp/util/overflow.h""
#include <algorithm>
 #include <cmath>
 
 #ifndef _MSC_VER
  int string_rfind(const char *input, int len, const char *s, int s_len,
     if (pos >= 0) {
       ptr = bstrrstr(input + pos, len - pos, s, s_len);
     } else {
      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);
     }
   } else {
     if (pos >= 0) {
       ptr = bstrrcasestr(input + pos, len - pos, s, s_len);
     } else {
      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);
     }
   }
   if (ptr != nullptr) {","Insufficient boundary checks for the strrpos and strripos functions allow access to out-of-bounds memory. This affects all supported versions of HHVM (4.0.3, 3.30.4, and 3.27.7 and below)."
1941,CVE-2019-3560,"  folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(
         if (buf.chainLength() < (cursor - buf.front()) + length) {
           return folly::none;
         }
        buf.trimStart(static_cast<size_t>(kPlaintextHeaderSize) + length);
         continue;
       } else if (msg.type != ContentType::change_cipher_spec) {
         skipEncryptedRecords_ = false;",An improperly performed length calculation on a buffer in PlaintextRecordLayer could lead to an infinite loop and denial-of-service based on user input. This issue affected versions of fizz prior to v2019.03.04.00.
1942,CVE-2019-3558,"  namespace apache { namespace thrift { namespace protocol {
           ""Attempt to interpret value {} as bool, probably the data is corrupted"",
           value));
 }

[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      folly::sformat(
          ""Encountered invalid field/element type ({}) during skipping"",
          static_cast<uint8_t>(type)));
}
 }}}","Python Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00."
1943,CVE-2019-3557,"  bool OutputFile::closeImpl() {
 
 int64_t OutputFile::readImpl(char*  , int64_t  ) {
   raise_warning(""cannot read from a php://output stream"");
  return 0;
 }
 
 int OutputFile::getc() {","The implementations of streams for bz2 and php://output improperly implemented their readImpl functions, returning -1 consistently. This behavior caused some stream functions, such as stream_get_line, to trigger an out-of-bounds read when operating on such malformed streams. The implementations were updated to return valid values consistently. This affects all supported versions of HHVM (3.30 and 3.27.4 and below)."
1944,CVE-2019-3554,"  void AcceptRoutingHandler<Pipeline, R>::onRoutingData(
 
    
    
  auto socket = std::dynamic_pointer_cast<folly::AsyncTransportWrapper>(
       routingPipeline->getTransport());
  CHECK(socket);
   routingPipeline->transportInactive();
   socket->detachEventBase();
 ","Wangle's AcceptRoutingHandler incorrectly casts a socket when accepting a TLS 1.3 connection, leading to a potential denial of service attack against systems accepting such connections. This affects versions of Wangle prior to v2019.01.14.00"
1945,CVE-2018-21028,"  scandir(const char *dir, struct dirent ***namelist,
 
     while (NULL != readdir(d))
         count++;
	
	closedir(d);
	
     names = malloc(sizeof (struct dirent *) * count);
	if (!names) 
		return -1;
 
     d = opendir(dir);
    if (NULL == d) {
		free(names);
         return -1;
    }
 
     while (NULL != (current = readdir(d))) {
         if (NULL == select || select(current)) {
             struct dirent *copyentry = malloc(current->d_reclen);
			 
			if (!copyentry)
				continue;
			
             memcpy(copyentry, current, current->d_reclen);
 
             names[pos] = copyentry;",Boa through 0.94.14rc21 allows remote attackers to trigger a memory leak because of missing calls to the free function.
1946,CVE-2018-21017,"  GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
 		return e;
 	}
 	if (!((GF_DataInformationBox *)s)->dref) {
		GF_Box* dref;
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
		gf_isom_box_add_for_dump_mode(s, dref);
 	}
 	return GF_OK;
 }",GPAC 0.7.1 has a memory leak in dinf_Read in isomedia/box_code_base.c.
1947,CVE-2018-21010,"  void color_apply_icc_profile(opj_image_t *image)
     }
 
     if (image->numcomps > 2) {  
        if ((image->comps[0].w == image->comps[1].w &&
                image->comps[0].w == image->comps[2].w) &&
                (image->comps[0].h == image->comps[1].h &&
                 image->comps[0].h == image->comps[2].h)) {
            if (prec <= 8) {
                unsigned char *inbuf, *outbuf, *in, *out;

                max = max_w * max_h;
                nr_samples = (size_t)(max * 3U * sizeof(unsigned char));
                in = inbuf = (unsigned char*)opj_image_data_alloc(nr_samples);
                out = outbuf = (unsigned char*)opj_image_data_alloc(nr_samples);

                if (inbuf == NULL || outbuf == NULL) {
                    goto fails0;
                }

                r = image->comps[0].data;
                g = image->comps[1].data;
                b = image->comps[2].data;

                for (i = 0U; i < max; ++i) {
                    *in++ = (unsigned char) * r++;
                    *in++ = (unsigned char) * g++;
                    *in++ = (unsigned char) * b++;
                }

                cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);

                r = image->comps[0].data;
                g = image->comps[1].data;
                b = image->comps[2].data;

                for (i = 0U; i < max; ++i) {
                    *r++ = (int) * out++;
                    *g++ = (int) * out++;
                    *b++ = (int) * out++;
                }
                ok = 1;
 
 fails0:
                opj_image_data_free(inbuf);
                opj_image_data_free(outbuf);
            } else {  
                unsigned short *inbuf, *outbuf, *in, *out;

                max = max_w * max_h;
                nr_samples = (size_t)(max * 3U * sizeof(unsigned short));
                in = inbuf = (unsigned short*)opj_image_data_alloc(nr_samples);
                out = outbuf = (unsigned short*)opj_image_data_alloc(nr_samples);

                if (inbuf == NULL || outbuf == NULL) {
                    goto fails1;
                }

                r = image->comps[0].data;
                g = image->comps[1].data;
                b = image->comps[2].data;

                for (i = 0U  ; i < max; ++i) {
                    *in++ = (unsigned short) * r++;
                    *in++ = (unsigned short) * g++;
                    *in++ = (unsigned short) * b++;
                }

                cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);

                r = image->comps[0].data;
                g = image->comps[1].data;
                b = image->comps[2].data;

                for (i = 0; i < max; ++i) {
                    *r++ = (int) * out++;
                    *g++ = (int) * out++;
                    *b++ = (int) * out++;
                }
                ok = 1;
 
 fails1:
                opj_image_data_free(inbuf);
                opj_image_data_free(outbuf);
            }
        } else {
            fprintf(stderr,
                    ""[ERROR] Image components should have the same width and height\n"");
            cmsDeleteTransform(transform);
            return;
         }
     } else {  
         if (prec <= 8) {",OpenJPEG before 2.3.1 has a heap buffer overflow in color_apply_icc_profile in bin/common/color.c.
1948,CVE-2018-20961,"  static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		if (err) {
 			ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
 				    midi->out_ep->name, err);
			if (req->buf != NULL)
				free_ep_req(midi->out_ep, req);
 			return err;
 		}
 	}","In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact."
1949,CVE-2018-20856,"  int blk_init_allocated_queue(struct request_queue *q)
 		q->exit_rq_fn(q, q->fq->flush_rq);
 out_free_flush_queue:
 	blk_free_flush_queue(q->fq);
	q->fq = NULL;
 	return -ENOMEM;
 }
 EXPORT_SYMBOL(blk_init_allocated_queue);","An issue was discovered in the Linux kernel before 4.18.7. In block/blk-core.c, there is an __blk_drain_queue() use-after-free because a certain error case is mishandled."
1950,CVE-2018-20855,"  static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,
 	struct mlx5_ib_resources *devr = &dev->devr;
 	int inlen = MLX5_ST_SZ_BYTES(create_qp_in);
 	struct mlx5_core_dev *mdev = dev->mdev;
	struct mlx5_ib_create_qp_resp resp = {};
 	struct mlx5_ib_cq *send_cq;
 	struct mlx5_ib_cq *recv_cq;
 	unsigned long flags;","An issue was discovered in the Linux kernel before 4.18.7. In create_qp_common in drivers/infiniband/hw/mlx5/qp.c, mlx5_ib_create_qp_resp was never initialized, resulting in a leak of stack memory to userspace."
1951,CVE-2018-20854,"  static struct phy *serdes_simple_xlate(struct device *dev,
 	port = args->args[0];
 	idx = args->args[1];
 
	for (i = 0; i < SERDES_MAX; i++) {
 		struct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);
 
 		if (idx != macro->idx)
  static int serdes_probe(struct platform_device *pdev)
 	if (IS_ERR(ctrl->regs))
 		return PTR_ERR(ctrl->regs);
 
	for (i = 0; i < SERDES_MAX; i++) {
 		ret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);
 		if (ret)
 			return ret;",An issue was discovered in the Linux kernel before 4.20. drivers/phy/mscc/phy-ocelot-serdes.c has an off-by-one error with a resultant ctrl->phys out-of-bounds read.
1952,CVE-2018-20847,"  static void opj_get_encoding_parameters(const opj_image_t *p_image,
      
     OPJ_UINT32 p, q;
 
     
    OPJ_UINT32 l_tx0, l_ty0;

      
     assert(p_cp != 00);
     assert(p_image != 00);
  static void opj_get_encoding_parameters(const opj_image_t *p_image,
     q = p_tileno / p_cp->tw;
 
      
    l_tx0 = p_cp->tx0 + p *
            p_cp->tdx;  
    *p_tx0 = (OPJ_INT32)opj_uint_max(l_tx0, p_image->x0);
    *p_tx1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, p_cp->tdx), p_image->x1);
    l_ty0 = p_cp->ty0 + q *
            p_cp->tdy;  
    *p_ty0 = (OPJ_INT32)opj_uint_max(l_ty0, p_image->y0);
    *p_ty1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, p_cp->tdy), p_image->y1);
 
      
     *p_max_prec = 0;","An improper computation of p_tx0, p_tx1, p_ty0 and p_ty1 in the function opj_get_encoding_parameters in openjp2/pi.c in OpenJPEG through 2.3.0 can lead to an integer overflow."
1953,CVE-2018-20846,"  static opj_bool pi_next_cprl(opj_pi_iterator_t * pi);
 ==========================================================
 */
 
static void opj_pi_emit_error(opj_pi_iterator_t * pi, const char* msg)
{
    (void)pi;
    (void)msg;
}

 static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)
 {
     opj_pi_comp_t *comp = NULL;
  static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)
                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                             pi->step_c + pi->precno * pi->step_p;
                     
                    if (index >= pi->include_size) {
                        opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                        return OPJ_FALSE;
                    }
                     if (!pi->include[index]) {
                         pi->include[index] = 1;
                         return OPJ_TRUE;
  static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)
                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                             pi->step_c + pi->precno * pi->step_p;
                     
                    if (index >= pi->include_size) {
                        opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                        return OPJ_FALSE;
                    }
                     if (!pi->include[index]) {
                         pi->include[index] = 1;
                         return OPJ_TRUE;
  static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)
                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                                 pi->step_c + pi->precno * pi->step_p;
                         
                        if (index >= pi->include_size) {
                            opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                            return OPJ_FALSE;
                        }
                         if (!pi->include[index]) {
                             pi->include[index] = 1;
                             return OPJ_TRUE;
  static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)
                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                                 pi->step_c + pi->precno * pi->step_p;
                         
                        if (index >= pi->include_size) {
                            opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                            return OPJ_FALSE;
                        }
                         if (!pi->include[index]) {
                             pi->include[index] = 1;
                             return OPJ_TRUE;
  static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)
                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                                 pi->step_c + pi->precno * pi->step_p;
                         
                        if (index >= pi->include_size) {
                            opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                            return OPJ_FALSE;
                        }
                         if (!pi->include[index]) {
                             pi->include[index] = 1;
                             return OPJ_TRUE;","Out-of-bounds accesses in the functions pi_next_lrcp, pi_next_rlcp, pi_next_rpcl, pi_next_pcrl, pi_next_rpcl, and pi_next_cprl in openmj2/pi.c in OpenJPEG through 2.3.0 allow remote attackers to cause a denial of service (application crash)."
1954,CVE-2018-20845,"  static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)
                     try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;

                     
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                     if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
  static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)
                     try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;

                     
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                     if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
  static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)
                     try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;

                     
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                     if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;","Division-by-zero vulnerabilities in the functions pi_next_pcrl, pi_next_cprl, and pi_next_rpcl in openmj2/pi.c in OpenJPEG through 2.3.0 allow remote attackers to cause a denial of service (application crash)."
1955,CVE-2018-20843,"  setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
       else
         poolDiscard(&dtd->pool);
       elementType->prefix = prefix;
      break;
     }
   }
   return 1;","In libexpat in Expat before 2.2.7, XML input including XML names that contain a large number of colons could make the XML parser consume a high amount of RAM and CPU resources while processing (enough to be usable for denial-of-service attacks)."
1956,CVE-2018-20839,"  int vt_default_utf8(void) {
         return parse_boolean(b);
 }
 
int vt_verify_kbmode(int fd) {
        int curr_mode;

         

        if (ioctl(fd, KDGKBMODE, &curr_mode) < 0)
                return -errno;

        return IN_SET(curr_mode, K_XLATE, K_UNICODE) ? 0 : -EBUSY;
}

 int vt_reset_keyboard(int fd) {
        int kb, r;
 
          
         kb = vt_default_utf8() != 0 ? K_UNICODE : K_XLATE;
 
        r = vt_verify_kbmode(fd);
        if (r == -EBUSY) {
                log_debug_errno(r, ""Keyboard is not in XLATE or UNICODE mode, not resetting: %m"");
                return 0;
        } else if (r < 0)
                return r;

         if (ioctl(fd, KDSKBMODE, kb) < 0)
                 return -errno;
 ","systemd 242 changes the VT1 mode upon a logout, which allows attackers to read cleartext passwords in certain circumstances, such as watching a shutdown, or using Ctrl-Alt-F1 and Ctrl-Alt-F2. This occurs because the KDGKBMODE (aka current keyboard mode) check is mishandled."
1957,CVE-2018-20836,"  static void smp_task_timedout(struct timer_list *t)
 	unsigned long flags;
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
	if (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {
 		task->task_state_flags |= SAS_TASK_STATE_ABORTED;
		complete(&task->slow_task->completion);
	}
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
 }
 
 static void smp_task_done(struct sas_task *task)
 {
	del_timer(&task->slow_task->timer);
 	complete(&task->slow_task->completion);
 }
 ","An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free."
1958,CVE-2018-20820,"  bool read_ujpg( void )
                               Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),
                                                                 compressed_header_buffer.size(),
                                                                 JpegAllocator<uint8_t>(),
                                                                ((size_t)max_file_size) * 2 + 128 * 1024 * 1024));
                 if (uncompressed_header_buffer.second) {
                     always_assert(false && ""Data not properly zlib coded"");
                     return false;",read_ujpg in jpgcoder.cc in Dropbox Lepton 1.2.1 allows attackers to cause a denial-of-service (application runtime crash because of an integer overflow) via a crafted file.
1959,CVE-2018-20784,"  static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 	}
 }
 
 
#define for_each_leaf_cfs_rq(rq, cfs_rq) \
	list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
 
  
 static inline struct cfs_rq *
  static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 {
 }
 
#define for_each_leaf_cfs_rq(rq, cfs_rq)	\
		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)
 
 static inline struct sched_entity *parent_entity(struct sched_entity *se)
 {
  static inline bool others_have_blocked(struct rq *rq)
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
 
 static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;
  static void update_blocked_averages(int cpu)
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		 
  static void update_blocked_averages(int cpu)
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
 		 
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
  const struct sched_class fair_sched_class = {
 #ifdef CONFIG_SCHED_DEBUG
 void print_cfs_stats(struct seq_file *m, int cpu)
 {
	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }","In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load."
1960,CVE-2018-20763,"  int mp4client_main(int argc, char **argv)
 					e = gf_dm_sess_process(sess);
 					if (!e) {
 						strncpy(the_url, gf_dm_sess_get_cache_name(sess), sizeof(the_url) - 1);
						the_url[sizeof(the_url) - 1] = 0;
 					}
 					gf_dm_sess_del(sess);
 				}","In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because of missing szLineConv bounds checking."
1961,CVE-2018-20762,"  GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Do
 	cat_enum.align_timelines = align_timelines;
 	cat_enum.allow_add_in_command = allow_add_in_command;
 
	if (strlen(fileName) >= sizeof(cat_enum.szPath)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", fileName));
		return GF_NOT_SUPPORTED;
	}
 	strcpy(cat_enum.szPath, fileName);
 	sep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);
 	if (!sep) sep = strrchr(cat_enum.szPath, '/');
 	if (!sep) {
 		strcpy(cat_enum.szPath, ""."");
		if (strlen(fileName) >= sizeof(cat_enum.szRad1)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", fileName));
			return GF_NOT_SUPPORTED;
		}
 		strcpy(cat_enum.szRad1, fileName);
 	} else {
		if (strlen(sep + 1) >= sizeof(cat_enum.szRad1)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", (sep + 1)));
			return GF_NOT_SUPPORTED;
		}
 		strcpy(cat_enum.szRad1, sep+1);
 		sep[0] = 0;
 	}
 	sep = strchr(cat_enum.szRad1, '*');
	if (strlen(sep + 1) >= sizeof(cat_enum.szRad2)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""File name %s is too long.\n"", (sep + 1)));
		return GF_NOT_SUPPORTED;
	}
 	strcpy(cat_enum.szRad2, sep+1);
 	sep[0] = 0;
 	sep = strchr(cat_enum.szRad2, '%');
 	if (!sep) sep = strchr(cat_enum.szRad2, '#');
 	if (!sep) sep = strchr(cat_enum.szRad2, ':');
 	strcpy(cat_enum.szOpt, """");
 	if (sep) {
		if (strlen(sep) >= sizeof(cat_enum.szOpt)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Invalid option: %s.\n"", sep));
			return GF_NOT_SUPPORTED;
		}
 		strcpy(cat_enum.szOpt, sep);
 		sep[0] = 0;
 	}",GPAC version 0.7.1 and earlier has a buffer overflow vulnerability in the cat_multiple_files function in applications/mp4box/fileimport.c when MP4Box is used for a local directory containing crafted filenames.
1962,CVE-2018-20760,"  char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicod
 	}
 	sptr = (u16 *)szLine;
 	i = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);
	if (i >= (u32)ARRAY_LENGTH(szLineConv))
		return NULL;
 	szLineConv[i] = 0;
 	strcpy(szLine, szLineConv);
 	 ","In GPAC 0.7.1 and earlier, gf_text_get_utf8_line in media_tools/text_import.c in libgpac_static.a allows an out-of-bounds write because a certain -1 return value is mishandled."
1963,CVE-2018-20742,"  void ocall_print_string(const char *str)
   fflush(stdout);
 }
 
void unsafe_ocall_malloc(size_t size, uint8_t **ret) {
   *ret = static_cast<uint8_t *>(malloc(size));
 }
 ",An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.
1964,CVE-2018-20685," 
 
 /*
  * scp - secure remote copy.  This is basically patched BSD rcp which
  * uses ssh to do the data transfer (instead of using rcmd).
  sink(int argc, char **argv)
 			SCREWUP(""size out of range"");
 		size = (off_t)ull;
 
		if (*cp == '\0' || strchr(cp, '/') != NULL ||
		    strcmp(cp, ""."") == 0 || strcmp(cp, "".."") == 0) {
 			run_err(""error: unexpected filename: %s"", cp);
 			exit(1);
 		}","In OpenSSH 7.9, scp.c in the scp client allows remote SSH servers to bypass intended access restrictions via the filename of . or an empty filename. The impact is modifying the permissions of the target directory on the client side."
1965,CVE-2018-20684,"  void __fastcall TSCPFileSystem::SCPSink(const UnicodeString TargetDir,
           {
             FTerminal->LogEvent(FORMAT(L""Warning: Remote host set a compound pathname '%s'"", (Line)));
           }
          if ((Level == 0) && (OnlyFileName != UnixExtractFileName(FileName)))
          {
            SCPError(LoadStr(UNREQUESTED_FILE), False);
          }
 
           FullFileName = SourceDir + OnlyFileName;
           OperationProgress->SetFile(FullFileName);
","In WinSCP before 5.14 beta, due to missing validation, the scp implementation would accept arbitrary files sent by the server, potentially overwriting unrelated files. This affects TSCPFileSystem::SCPSink in core/ScpFileSystem.cpp."
1966,CVE-2018-20182," 
 
  
 RD_BOOL
ber_parse_header(STREAM s, int tagval, uint32 *length)
 {
 	int tag, len;
 ",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.
1967,CVE-2018-18839,"  char *url_decode_r(char *to, char *url, size_t size) {
     while(*s && d < e) {
         if(unlikely(*s == '%')) {
             if(likely(s[1] && s[2])) {
                char t = from_hex(s[1]) << 4 | from_hex(s[2]);
                 
                *d++ = (char)((isprint(t))? t : ' ');
                 s += 2;
             }
         }",** DISPUTED ** An issue was discovered in Netdata 1.10.0. Full Path Disclosure (FPD) exists via api/v1/alarms. NOTE: the vendor says *is intentional.*
1968,CVE-2018-16452,"  smb_fdata(netdissect_options *ndo,
 	    while (buf < maxbuf) {
 		const u_char *buf2;
 		depth++;
		 
		if (depth == 10)
			ND_PRINT((ndo, ""(too many nested levels, not recursing)""));
		else
			buf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);
 		depth--;
 		if (buf2 == NULL)
 		    return(NULL);",The SMB parser in tcpdump before 4.9.3 has stack exhaustion in smbutil.c:smb_fdata() via recursion.
1969,CVE-2018-16451,"  print_trans(netdissect_options *ndo,
     ND_PRINT((ndo, ""smb_bcc=%u\n"", bcc));
     if (bcc > 0) {
 	smb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);
#define MAILSLOT_BROWSE_STR ""\\MAILSLOT\\BROWSE""
	ND_TCHECK2(*(data1 + 2), strlen(MAILSLOT_BROWSE_STR) + 1);
	if (strcmp((const char *)(data1 + 2), MAILSLOT_BROWSE_STR) == 0) {
 	    print_browse(ndo, param, paramlen, data, datalen);
 	    return;
 	}
#undef MAILSLOT_BROWSE_STR
 
#define PIPE_LANMAN_STR ""\\PIPE\\LANMAN""
	ND_TCHECK2(*(data1 + 2), strlen(PIPE_LANMAN_STR) + 1);
	if (strcmp((const char *)(data1 + 2), PIPE_LANMAN_STR) == 0) {
 	    print_ipc(ndo, param, paramlen, data, datalen);
 	    return;
 	}
#undef PIPE_LANMAN_STR
 
 	if (paramlen)
 	    smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr);",The SMB parser in tcpdump before 4.9.3 has buffer over-reads in print-smb.c:print_trans() for MAILSLOTBROWSE and PIPELANMAN.
1970,CVE-2018-16300,"  bgp_attr_get_as_size(netdissect_options *ndo,
 
 static int
 bgp_attr_print(netdissect_options *ndo,
               u_int atype, const u_char *pptr, u_int len, const unsigned attr_set_level)
 {
 	int i;
 	uint16_t af;
  bgp_attr_print(netdissect_options *ndo,
                             ND_PRINT((ndo, ""+%x"", aflags & 0xf));
                         ND_PRINT((ndo, ""]: ""));
                     }
                     
                    if (attr_set_level == 10)
                        ND_PRINT((ndo, ""(too many nested levels, not recursing)""));
                    else if (!bgp_attr_print(ndo, atype, tptr, alen, attr_set_level + 1))
                         return 0;
                     tptr += alen;
                     len -= alen;
  bgp_update_print(netdissect_options *ndo,
 				goto trunc;
 			if (length < alen)
 				goto trunc;
			if (!bgp_attr_print(ndo, atype, p, alen, 0))
 				goto trunc;
 			p += alen;
 			len -= alen;",The BGP parser in tcpdump before 4.9.3 allows stack consumption in print-bgp.c:bgp_attr_print() because of unlimited recursion.
1971,CVE-2018-16230,"  bgp_attr_print(netdissect_options *ndo,
                                        bgp_vpn_rd_print(ndo, tptr),
                                        isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));
                                  
                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)
                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
                                     ND_PRINT((ndo, "" = %s"", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));
                                  
                                else if (tlen == BGP_VPN_RD_LEN + 3 + sizeof(struct in6_addr)
                                         && EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
                                     ND_PRINT((ndo, "" = %s"", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));
                                 tptr += tlen;
                                 tlen = 0;",The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_attr_print() (MP_REACH_NLRI).
1972,CVE-2018-16229,"  static const struct tok dccp_option_values[] = {
 	{ 0, NULL }
 };
 
static int
dccp_print_option(netdissect_options *ndo, const u_char *option, u_int hlen)
 {
 	uint8_t optlen, i;
 
  static int dccp_print_option(netdissect_options *ndo, const u_char *option, u_in
 			}
 			break;
 		case 41:
		 
			if (optlen == 6)
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));
 			else
				ND_PRINT((ndo, "" [optlen != 6]""));
 			break;
 		case 42:
		 
			switch (optlen) {
			case 6:
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));
				break;
			case 8:
				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));
				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_16BITS(option + 6)));
				break;
			case 10:
				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));
				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_32BITS(option + 6)));
				break;
			default:
				ND_PRINT((ndo, "" [optlen != 6 or 8 or 10]""));
				break;
			}
 			break;
 		case 43:
 			if (optlen == 6)
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));
 			else if (optlen == 4)
 				ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2)));
 			else
				ND_PRINT((ndo, "" [optlen != 4 or 6]""));
 			break;
 		case 44:
 			if (optlen > 2) {",The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option().
1973,CVE-2018-16228,"  print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)
         plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;
     } else {
         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));
        if (plenbytes < 0)
            return plenbytes;
     }
 
     ND_PRINT((ndo, ""%s"", buf));",The HNCP parser in tcpdump before 4.9.3 has a buffer over-read in print-hncp.c:print_prefix().
1974,CVE-2018-16227,"  ieee802_11_print(netdissect_options *ndo,
 		hdrlen = roundup2(hdrlen, 4);
 	if (ndo->ndo_Hflag && FC_TYPE(fc) == T_DATA &&
 	    DATA_FRAME_IS_QOS(FC_SUBTYPE(fc))) {
		if (caplen < hdrlen + 1) {
			ND_PRINT((ndo, ""%s"", tstr));
			return hdrlen;
		}
 		meshdrlen = extract_mesh_header_length(p+hdrlen);
 		hdrlen += meshdrlen;
 	} else",The IEEE 802.11 parser in tcpdump before 4.9.3 has a buffer over-read in print-802_11.c for the Mesh Flags subfield.
1975,CVE-2018-14882," 
 #include ""udp.h""
 #include ""ah.h""
 
static const char icmp6_tstr[] = "" [|icmp6]"";
static const char rpl_tstr[] = "" [|rpl]"";
static const char mldv2_tstr[] = "" [|mldv2]"";

  
  
 
  rpl_dio_printopt(netdissect_options *ndo,
                 }
                 opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);
                 length -= optlen;
                ND_TCHECK(opt->rpl_dio_len);
         }
         return;
 trunc:
	ND_PRINT((ndo, ""%s"", rpl_tstr));
 	return;
 }
 
  rpl_dio_print(netdissect_options *ndo,
         }
 	return;
 trunc:
	ND_PRINT((ndo, ""%s"", rpl_tstr));
 	return;
 }
 
  rpl_dao_print(netdissect_options *ndo,
 	return;
 
 trunc:
	ND_PRINT((ndo, ""%s"", rpl_tstr));
 	return;
 
 tooshort:
  rpl_daoack_print(netdissect_options *ndo,
 	return;
 
 trunc:
	ND_PRINT((ndo, ""%s"", rpl_tstr));
 	return;
 
 tooshort:
  rpl_print(netdissect_options *ndo,
 
 #if 0
 trunc:
	ND_PRINT((ndo, ""%s"", rpl_tstr));
 	return;
 #endif
 
  icmp6_print(netdissect_options *ndo,
                 ND_PRINT((ndo,"", length %u"", length));
 	return;
 trunc:
	ND_PRINT((ndo, ""%s"", icmp6_tstr));
 }
 
 static const struct udphdr *
  icmp6_opt_print(netdissect_options *ndo, const u_char *bp, int resid)
 	}
 	return;
 
trunc:
	ND_PRINT((ndo, ""%s"", icmp6_tstr));
 	return;
 #undef ECHECK
 }
  mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)
     }
     return;
 trunc:
    ND_PRINT((ndo, ""%s"", mldv2_tstr));
     return;
 }
 
  mldv2_query_print(netdissect_options *ndo, const u_char *bp, u_int len)
     ND_PRINT((ndo,""]""));
     return;
 trunc:
    ND_PRINT((ndo, ""%s"", mldv2_tstr));
     return;
 }
 
  icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp,
 	return;
 
 trunc:
	ND_PRINT((ndo, ""%s"", icmp6_tstr));
 }
 
 static void
  icmp6_rrenum_print(netdissect_options *ndo, const u_char *bp, const u_char *ep)
 	return;
 
 trunc:
	ND_PRINT((ndo, ""%s"", icmp6_tstr));
 }
 
 /*",The ICMPv6 parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp6.c.
1976,CVE-2018-14881,"  bgp_capabilities_print(netdissect_options *ndo,
                            opt[i+5]));
                     break;
                 case BGP_CAPCODE_RESTART:
                     
                    ND_TCHECK_16BITS(opt + i + 2);
                     ND_PRINT((ndo, ""\n\t\tRestart Flags: [%s], Restart Time %us"",
                            ((opt[i+2])&0x80) ? ""R"" : ""none"",
                            EXTRACT_16BITS(opt+i+2)&0xfff));",The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).
1977,CVE-2018-14880,"  ospf6_print_lshdr(netdissect_options *ndo,
 {
 	if ((const u_char *)(lshp + 1) > dataend)
 		goto trunc;
	ND_TCHECK(lshp->ls_length);	 
 
 	ND_PRINT((ndo, ""\n\t  Advertising Router %s, seq 0x%08x, age %us, length %u"",
                ipaddr_string(ndo, &lshp->ls_router),",The OSPFv3 parser in tcpdump before 4.9.3 has a buffer over-read in print-ospf6.c:ospf6_print_lshdr().
1978,CVE-2018-14879,"  static char *
 get_next_file(FILE *VFile, char *ptr)
 {
 	char *ret;
	size_t len;
 
 	ret = fgets(ptr, PATH_MAX, VFile);
 	if (!ret)
 		return NULL;
 
	len = strlen (ptr);
	if (len > 0 && ptr[len - 1] == '\n')
		ptr[len - 1] = '\0';
 
 	return ret;
 }",The command-line argument parser in tcpdump before 4.9.3 has a buffer overflow in tcpdump.c:get_next_file().
1979,CVE-2018-14470,"  babel_print_v2(netdissect_options *ndo,
         case MESSAGE_UPDATE: {
             if (!ndo->ndo_vflag) {
                 ND_PRINT((ndo, "" update""));
                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));
                 else
                     ND_PRINT((ndo, ""%s%s%s"",",The Babel parser in tcpdump before 4.9.3 has a buffer over-read in print-babel.c:babel_print_v2().
1980,CVE-2018-14469,"  ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
 		    }
 		case IPSECDOI_NTYPE_REPLAY_STATUS:
 			ND_PRINT((ndo,"" status=(""));
			ND_TCHECK_32BITS(cp);
 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
 			ND_PRINT((ndo,"")""));",The IKEv1 parser in tcpdump before 4.9.3 has a buffer over-read in print-isakmp.c:ikev1_n_print().
1981,CVE-2018-14468,"  mfr_print(netdissect_options *ndo,
             switch (ie_type) {
 
             case MFR_CTRL_IE_MAGIC_NUM:
                 
                if (ie_len != 4) {
                    ND_PRINT((ndo, ""(invalid length)""));
                    break;
                }
                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));
                 break;
 ",The FRF.16 parser in tcpdump before 4.9.3 has a buffer over-read in print-fr.c:mfr_print().
1982,CVE-2018-14467,"  bgp_capabilities_print(netdissect_options *ndo,
                 ND_TCHECK2(opt[i+2], cap_len);
                 switch (cap_type) {
                 case BGP_CAPCODE_MP:
                     
                    ND_TCHECK_8BITS(opt + i + 5);
                     ND_PRINT((ndo, ""\n\t\tAFI %s (%u), SAFI %s (%u)"",
                            tok2str(af_values, ""Unknown"",
                                       EXTRACT_16BITS(opt+i+2)),",The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_MP).
1983,CVE-2018-14466,"  rx_cache_insert(netdissect_options *ndo,
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
 
  rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,
 		if (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&
 		    rxent->client.s_addr == clip &&
 		    rxent->server.s_addr == sip &&
		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
 		    rxent->dport == sport) {
 
 			 ",The Rx parser in tcpdump before 4.9.3 has a buffer over-read in print-rx.c:rx_cache_find() and rx_cache_insert().
1984,CVE-2018-14465,"  rsvp_obj_print(netdissect_options *ndo,
         case RSVP_OBJ_CLASSTYPE_OLD:  
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                ND_TCHECK_32BITS(obj_tptr);
                 ND_PRINT((ndo, ""%s  CT: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr) & 0x7));",The RSVP parser in tcpdump before 4.9.3 has a buffer over-read in print-rsvp.c:rsvp_obj_print().
1985,CVE-2018-14464,"  lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,
 			""Unknown"",
 			EXTRACT_8BITS(obj_tptr + offset + 3)),
 			EXTRACT_8BITS(obj_tptr + offset + 3)));
	    ND_TCHECK_32BITS(obj_tptr + offset + 4);
 	    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);
 	    ND_PRINT((ndo, ""\n\t      Min Reservable Bandwidth: %.3f Mbps"",
                 bw.f*8/1000000));
  lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,
 	offset+=subobj_len;
     }
     return (hexdump);
trunc:
    return -1;
 }
 
 void
  lmp_print(netdissect_options *ndo,
     const struct lmp_object_header *lmp_obj_header;
     const u_char *tptr,*obj_tptr;
     u_int tlen,lmp_obj_len,lmp_obj_ctype,obj_tlen;
    int hexdump, ret;
     u_int offset;
     u_int link_type;
 
  lmp_print(netdissect_options *ndo,
                        ipaddr_string(ndo, obj_tptr+8),
                        EXTRACT_32BITS(obj_tptr+8)));
 
		ret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);
		if (ret == -1)
		    goto trunc;
		if (ret == TRUE)
 		    hexdump=TRUE;
 		break;
 
  lmp_print(netdissect_options *ndo,
                        ip6addr_string(ndo, obj_tptr+20),
                        EXTRACT_32BITS(obj_tptr+20)));
 
		ret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 36, 36);
		if (ret == -1)
		    goto trunc;
		if (ret == TRUE)
 		    hexdump=TRUE;
 		break;
 
  lmp_print(netdissect_options *ndo,
                        EXTRACT_32BITS(obj_tptr+8),
                        EXTRACT_32BITS(obj_tptr+8)));
 
		ret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);
		if (ret == -1)
		    goto trunc;
		if (ret == TRUE)
 		    hexdump=TRUE;
 		break;
 ",The LMP parser in tcpdump before 4.9.3 has a buffer over-read in print-lmp.c:lmp_print_data_link_subobjs().
1986,CVE-2018-14463,"  vrrp_print(netdissect_options *ndo,
 
 			vec[0].ptr = bp;
 			vec[0].len = len;
			if (in_cksum(vec, 1)) {
				ND_TCHECK_16BITS(&bp[6]);
 				ND_PRINT((ndo, "", (bad vrrp cksum %x)"",
 					EXTRACT_16BITS(&bp[6])));
			}
 		}
 
 		if (version == 3 && ND_TTEST2(bp[0], len)) {",The VRRP parser in tcpdump before 4.9.3 has a buffer over-read in print-vrrp.c:vrrp_print().
1987,CVE-2018-14462,"  icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *
 			vec[0].len = plen;
 			sum = in_cksum(vec, 1);
 			if (sum != 0) {
				ND_TCHECK_16BITS(&dp->icmp_cksum);
 				uint16_t icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
 				ND_PRINT((ndo, "" (wrong icmp cksum %x (->%x)!)"",
 					     icmp_sum,",The ICMP parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp.c:icmp_print().
1988,CVE-2018-14461," 
 #include ""l2vpn.h""
 #include ""af.h""
 
static const char tstr[] = "" [|LDP]"";

  
 	tptr+=4;
 	ui = EXTRACT_32BITS(tptr);
 	if (ui)
  ldp_tlv_print(netdissect_options *ndo,
     return(tlv_len+4);  
 
 trunc:
    ND_PRINT((ndo, ""%s"", tstr));
     return 0;
 
 badtlv:
  ldp_pdu_print(netdissect_options *ndo,
     }
     return pdu_len+4;
 trunc:
    ND_PRINT((ndo, ""%s"", tstr));
     return 0;
 }
 ",The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print().
1989,CVE-2018-7191,"  static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
 
 		if (!dev)
 			return -ENOMEM;
		err = dev_get_valid_name(net, dev, name);
		if (err)
			goto err_free_dev;
 
 		dev_net_set(dev, net);
 		dev->rtnl_link_ops = &tun_link_ops;","In the tun subsystem in the Linux kernel before 4.13.14, dev_get_valid_name is not called before register_netdevice. This allows local users to cause a denial of service (NULL pointer dereference and panic) via an ioctl(TUNSETIFF) call with a dev name containing a / character. This is similar to CVE-2013-4343."
1990,CVE-2018-6345,"  String string_number_format(double d, int dec,
   String tmpstr(63, ReserveString);
   tmpbuf = tmpstr.mutableData();
   tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d);
  if (tmplen < 0) return empty_string();
   if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
     tmpstr.setSize(tmplen);
     return tmpstr;
  String string_number_format(double d, int dec,
     tmpstr = String(tmplen, ReserveString);
     tmpbuf = tmpstr.mutableData();
     tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d);
    if (tmplen < 0) return empty_string();
     if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
       tmpstr.setSize(tmplen);
       return tmpstr;","The function number_format is vulnerable to a heap overflow issue when its second argument ($dec_points) is excessively large. The internal implementation of the function will cause a string to be created with an invalid length, which can then interact poorly with other functions. This affects all supported versions of HHVM (3.30.1 and 3.27.5 and below)."
1991,CVE-2017-18594,"  extern ""C"" {
 }
 #include ""nse_lua.h""
 
 #include ""nse_nsock.h""
 #include ""nse_utility.h""
 
  static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {
 
     if (rc) {
         libssh2_session_free(sshu->session);
        sshu->session = NULL;
         return luaL_error(L, ""Unable to complete libssh2 handshake."");
     }
 
  static int userauth_list (lua_State *L, int status, lua_KContext ctx) {
 }
 
  
 static int l_userauth_list (lua_State *L) {
     return userauth_list(L, 0, 0);","nse_libssh2.cc in Nmap 7.70 is subject to a denial of service condition due to a double free when an SSH connection fails, as demonstrated by a leading n character to ssh-brute.nse or ssh-auth-methods.nse."
1992,CVE-2017-18509,"  int ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, uns
 	struct net *net = sock_net(sk);
 	struct mr6_table *mrt;
 
	if (sk->sk_type != SOCK_RAW ||
	    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)
		return -EOPNOTSUPP;

 	mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);
 	if (!mrt)
 		return -ENOENT;
  int ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, uns
 
 	switch (optname) {
 	case MRT6_INIT:
 		if (optlen < sizeof(int))
 			return -EINVAL;
 
  int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,
 	struct net *net = sock_net(sk);
 	struct mr6_table *mrt;
 
	if (sk->sk_type != SOCK_RAW ||
	    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)
		return -EOPNOTSUPP;

 	mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);
 	if (!mrt)
 		return -ENOENT;","An issue was discovered in net/ipv6/ip6mr.c in the Linux kernel before 4.11. By setting a specific socket option, an attacker can control a pointer in kernel land and cause an inet_csk_listen_stop general protection fault, or potentially execute arbitrary code under certain circumstances. The issue can be triggered as root (e.g., inside a default LXC container or with the CAP_NET_ADMIN capability) or after namespace unsharing. This occurs because sk_type and protocol are not checked in the appropriate part of the ip6_mroute_* functions. NOTE: this affects Linux distributions that use 4.9.x longterm kernels before 4.9.187."
1993,CVE-2017-18379,"  nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,
 	u16 qid = nvmet_fc_getqueueid(connection_id);
 	unsigned long flags;
 
	if (qid > NVMET_NR_QUEUES)
		return NULL;

 	spin_lock_irqsave(&tgtport->lock, flags);
 	list_for_each_entry(assoc, &tgtport->assoc_list, a_list) {
 		if (association_id == assoc->association_id) {","In the Linux kernel before 4.14, an out of boundary access happened in drivers/nvme/target/fc.c."
1994,CVE-2017-18360,"  static void change_port_settings(struct tty_struct *tty,
 	if (!baud) {
 		 
 		baud = 9600;
	} else {
		 
		baud = min(baud, 461550);
 		tty_encode_baud_rate(tty, baud, baud);
	}
 
 	edge_port->baud_rate = baud;
 	config->wBaudRate = (__u16)((461550L + baud/2) / baud);","In change_port_settings in drivers/usb/serial/io_ti.c in the Linux kernel before 4.11.3, local users could cause a denial of service by division-by-zero in the serial device layer by trying to set very high baud rates."
1995,CVE-2016-10764,"  static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)
 			goto err;
 		}
 
		if (cs >= CQSPI_MAX_CHIPSELECT) {
 			dev_err(dev, ""Chip select %d out of range.\n"", cs);
 			goto err;
 		}","In the Linux kernel before 4.9.6, there is an off by one in the drivers/mtd/spi-nor/cadence-quadspi.c cqspi_setup_flash() function. There are CQSPI_MAX_CHIPSELECT elements in the ->f_pdata array so the *>* should be *>=* instead."
1996,CVE-2016-10749,"  static const char *parse_string(cJSON *item,const char *str,const char **ep)
 {
 	const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
 	if (*str!='\""') {*ep=str;return 0;}	 

	while (*end_ptr!='\""' && *end_ptr && ++len)
	{
	    if (*end_ptr++ == '\\')
	    {
		if (*end_ptr == '\0')
		{
		     
		    return 0;
		}
		end_ptr++;	 
	    }
	}

 	out=(char*)cJSON_malloc(len+1);	 
 	if (!out) return 0;
 	item->valuestring=out;  ","parse_string in cJSON.c in cJSON before 2016-10-02 has a buffer over-read, as demonstrated by a string that begins with a * character and ends with a  character."
1997,CVE-2016-10746,"  virDomainGetTime(virDomainPtr dom,
     virResetLastError();
 
     virCheckDomainReturn(dom, -1);
    virCheckReadOnlyGoto(dom->conn->flags, error);
 
     if (dom->conn->driver->domainGetTime) {
         int ret = dom->conn->driver->domainGetTime(dom, seconds,","libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886."
1998,CVE-2016-10741,"  __xfs_get_blocks(
 	if (error)
 		goto out_unlock;
 
	 
	if (direct && imap.br_startblock == DELAYSTARTBLOCK) {
		if (!create || offset < i_size_read(VFS_I(ip))) {
			WARN_ON_ONCE(1);
			error = -EIO;
			goto out_unlock;
		}
		WARN_ON_ONCE(mapping_mapped(VFS_I(ip)->i_mapping));
	}

 	 
 	if (create &&
 	    (!nimaps ||
  __xfs_get_blocks(
 	     (new || ISUNWRITTEN(&imap))))
 		set_buffer_new(bh_result);
 
 	return 0;
 
 out_unlock:","In the Linux kernel before 4.9.3, fs/xfs/xfs_aops.c allows local users to cause a denial of service (system crash) because there is a race condition between direct and memory-mapped I/O (associated with a hole) that is handled with BUG_ON instead of an I/O failure."
1999,CVE-2016-7151,"  static int regs_cmp(const void *a, const void *b)
 	return (l - r);
 }
 
  
  
  
 x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)
 {
	static bool intel_regs_sorted = false;
 	unsigned int first = 0;
 	unsigned int last = ARR_SIZE(insn_regs_intel) - 1;
	unsigned int mid;
 
 	if (!intel_regs_sorted) {
 		memcpy(insn_regs_intel_sorted, insn_regs_intel,
  x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)
 		intel_regs_sorted = true;
 	}
 
	if (insn_regs_intel_sorted[0].insn > id ||
			insn_regs_intel_sorted[last].insn < id) {
		return 0;
	}

 	while (first <= last) {
		mid = (first + last) / 2;
 		if (insn_regs_intel_sorted[mid].insn < id) {
 			first = mid + 1;
 		} else if (insn_regs_intel_sorted[mid].insn == id) {
  x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)
 				break;
 			last = mid - 1;
 		}
 	}
 
 	 ",Capstone 3.0.4 has an out-of-bounds vulnerability (SEGV caused by a read memory access) in X86_insn_reg_intel in arch/X86/X86Mapping.c.
2000,CVE-2015-9289,"  static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
 	struct cx24116_state *state = fe->demodulator_priv;
 	int i, ret;
 
	 
	if (d->msg_len > sizeof(d->msg))
                return -EINVAL;

 	 
 	if (debug) {
 		printk(KERN_INFO ""cx24116: %s("", __func__);
  static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
 		printk("") toneburst=%d\n"", toneburst);
 	}
 
 	 
 	for (i = 0; i < d->msg_len; i++)
 		state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];","In the Linux kernel before 4.1.4, a buffer overflow occurs when checking userspace params in drivers/media/dvb-frontends/cx24116.c. The maximum size for a DiSEqC command is 6, according to the userspace API. However, the code allows larger values such as 23."
2001,CVE-2013-7470,"  static inline int cipso_v4_validate(const struct sk_buff *skb,
 	unsigned char err_offset = 0;
 	u8 opt_len = opt[1];
 	u8 opt_iter;
	u8 tag_len;
 
 	if (opt_len < 8) {
 		err_offset = 1;
  static inline int cipso_v4_validate(const struct sk_buff *skb,
 	}
 
 	for (opt_iter = 6; opt_iter < opt_len;) {
		tag_len = opt[opt_iter + 1];
		if ((tag_len == 0) || (opt[opt_iter + 1] > (opt_len - opt_iter))) {
 			err_offset = opt_iter + 1;
 			goto out;
 		}
		opt_iter += tag_len;
 	}
 
 out:","cipso_v4_validate in include/net/cipso_ipv4.h in the Linux kernel before 3.11.7, when CONFIG_NETLABEL is disabled, allows attackers to cause a denial of service (infinite loop and crash), as demonstrated by icmpsic, a different vulnerability than CVE-2013-0310."
2002,CVE-2012-6712," 
 #include ""iwl-trans.h""
 
  
static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
 {
	if (sta_id >= IWLAGN_STATION_COUNT) {
		IWL_ERR(priv, ""invalid sta_id %u"", sta_id);
		return -EINVAL;
	}
 	if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))
 		IWL_ERR(priv, ""ACTIVATE a non DRIVER active station id %u ""
 			""addr %pM\n"",
  static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
 		IWL_DEBUG_ASSOC(priv, ""Added STA id %u addr %pM to uCode\n"",
 				sta_id, priv->stations[sta_id].sta.sta.addr);
 	}
	return 0;
 }
 
 static int iwl_process_add_sta_resp(struct iwl_priv *priv,
  static int iwl_process_add_sta_resp(struct iwl_priv *priv,
 	switch (pkt->u.add_sta.status) {
 	case ADD_STA_SUCCESS_MSK:
 		IWL_DEBUG_INFO(priv, ""REPLY_ADD_STA PASSED\n"");
		ret = iwl_sta_ucode_activate(priv, sta_id);
 		break;
 	case ADD_STA_NO_ROOM_IN_TABLE:
 		IWL_ERR(priv, ""Adding station %d failed, no room in table.\n"",","In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption."
2003,CVE-2011-5327,"  struct se_portal_group *tcm_loop_make_naa_tpg(
 	tpgt_str += 5;  
 	tpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);
 
	if (tpgt >= TL_TPGS_PER_HBA) {
 		printk(KERN_ERR ""Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:""
 				"" %u\n"", tpgt, TL_TPGS_PER_HBA);
 		return ERR_PTR(-EINVAL);","In the Linux kernel before 3.1, an off by one in the drivers/target/loopback/tcm_loop.c tcm_loop_make_naa_tpg() function could result in at least memory corruption."
2004,CVE-2010-5332,"  int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)
 			goto out;
 		}
 	}

	if (free < 0) {
		err = -ENOMEM;
		goto out;
	}

 	mlx4_dbg(dev, ""Free MAC index is %d\n"", free);
 
 	if (table->total == table->max) {
  int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)
 		}
 	}
 
	if (free < 0) {
		err = -ENOMEM;
		goto out;
	}

 	if (table->total == table->max) {
 		 
 		err = -ENOSPC;","In the Linux kernel before 2.6.37, an out of bounds array access happened in drivers/net/mlx4/port.c. When searching for a free entry in either mlx4_register_vlan() or mlx4_register_mac(), and there is no free entry, the loop terminates without updating the local variable free thus causing out of array bounds access."
2005,CVE-2010-5331,"  typedef struct _ATOM_ANALOG_TV_INFO_V1_2
   UCHAR                    ucTV_BootUpDefaultStandard; 
   UCHAR                    ucExt_TV_ASIC_ID;
   UCHAR                    ucExt_TV_ASIC_SlaveAddr;
  ATOM_DTD_FORMAT          aModeTimings[MAX_SUPPORTED_TV_TIMING_V1_2];
 }ATOM_ANALOG_TV_INFO_V1_2;
 
 typedef struct _ATOM_DPCD_INFO","In the Linux kernel before 2.6.34, a range check issue in drivers/gpu/drm/radeon/atombios.c could cause an off by one (buffer overflow) problem."
2006,CVE-2007-6762,"  static int netlbl_cipsov4_add_common(struct genl_info *info,
 
 	nla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)
 		if (nla->nla_type == NLBL_CIPSOV4_A_TAG) {
			if (iter >= CIPSO_V4_TAG_MAXCNT)
 				return -EINVAL;
 			doi_def->tags[iter++] = nla_get_u8(nla);
 		}
	while (iter < CIPSO_V4_TAG_MAXCNT)
		doi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;
 
 	return 0;
 }","In the Linux kernel before 2.6.20, there is an off-by-one bug in net/netlabel/netlabel_cipso_v4.c where it is possible to overflow the doi_def->tags[] array."
2007,CVE-2010-1152,"  static int try_read_command(conn *c) {
 
         if (c->rbytes == 0)
             return 0;

         el = memchr(c->rcurr, '\n', c->rbytes);
        if (!el) {
            if (c->rbytes > 1024) {
                 
                char *ptr = c->rcurr;
                while (*ptr == ' ') {  
                    ++ptr;
                }

                if (strcmp(ptr, ""get "") && strcmp(ptr, ""gets "")) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }

             return 0;
        }
         cont = el + 1;
         if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
             el--;
  static enum try_read_result try_read_udp(conn *c) {
  * close.
  * before reading, move the remaining incomplete fragment of a command
  * (if any) to the beginning of the buffer.
 *
 * To protect us from someone flooding a connection with bogus data causing
 * the connection to eat up all available memory, break out and start looking
 * at the data I've got after a number of reallocs...
 *
  * @return enum try_read_result
  */
 static enum try_read_result try_read_network(conn *c) {
     enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
     int res;
    int num_allocs = 0;
     assert(c != NULL);
 
     if (c->rcurr != c->rbuf) {
  static enum try_read_result try_read_network(conn *c) {
 
     while (1) {
         if (c->rbytes >= c->rsize) {
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
             char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
             if (!new_rbuf) {
                 if (settings.verbose > 0)",memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation.  NOTE: some of these details are obtained from third party information.
2008,CVE-2012-3400," 
 #include <linux/seq_file.h>
 #include <linux/bitmap.h>
 #include <linux/crc-itu-t.h>
#include <linux/log2.h>
 #include <asm/byteorder.h>
 
 #include ""udf_sb.h""
  static int udf_load_partdesc(struct super_block *sb, sector_t block)
 	return ret;
 }
 
static int udf_load_sparable_map(struct super_block *sb,
				 struct udf_part_map *map,
				 struct sparablePartitionMap *spm)
{
	uint32_t loc;
	uint16_t ident;
	struct sparingTable *st;
	struct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;
	int i;
	struct buffer_head *bh;

	map->s_partition_type = UDF_SPARABLE_MAP15;
	sdata->s_packet_len = le16_to_cpu(spm->packetLength);
	if (!is_power_of_2(sdata->s_packet_len)) {
		udf_err(sb, ""error loading logical volume descriptor: ""
			""Invalid packet length %u\n"",
			(unsigned)sdata->s_packet_len);
		return -EIO;
	}
	if (spm->numSparingTables > 4) {
		udf_err(sb, ""error loading logical volume descriptor: ""
			""Too many sparing tables (%d)\n"",
			(int)spm->numSparingTables);
		return -EIO;
	}

	for (i = 0; i < spm->numSparingTables; i++) {
		loc = le32_to_cpu(spm->locSparingTable[i]);
		bh = udf_read_tagged(sb, loc, loc, &ident);
		if (!bh)
			continue;

		st = (struct sparingTable *)bh->b_data;
		if (ident != 0 ||
		    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,
			    strlen(UDF_ID_SPARING)) ||
		    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >
							sb->s_blocksize) {
			brelse(bh);
			continue;
		}

		sdata->s_spar_map[i] = bh;
	}
	map->s_partition_func = udf_get_pblock_spar15;
	return 0;
}

 static int udf_load_logicalvol(struct super_block *sb, sector_t block,
 			       struct kernel_lb_addr *fileset)
 {
 	struct logicalVolDesc *lvd;
	int i, offset;
 	uint8_t type;
 	struct udf_sb_info *sbi = UDF_SB(sb);
 	struct genericPartitionMap *gpm;
  static int udf_load_logicalvol(struct super_block *sb, sector_t block,
 			} else if (!strncmp(upm2->partIdent.ident,
 						UDF_ID_SPARABLE,
 						strlen(UDF_ID_SPARABLE))) {
				if (udf_load_sparable_map(sb, map,
				    (struct sparablePartitionMap *)gpm) < 0)
					goto out_bh;
 			} else if (!strncmp(upm2->partIdent.ident,
 						UDF_ID_METADATA,
 						strlen(UDF_ID_METADATA))) {",Heap-based buffer overflow in the udf_load_logicalvol function in fs/udf/super.c in the Linux kernel before 3.4.5 allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted UDF filesystem.
2009,CVE-2012-2675,"  NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpmalloc(nedpool *p, size_t size)
 }
 NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC
 {
	size_t bytes=no*size;
	 
	if(size && no!=bytes/size)
		return 0;
	unsigned flags=NEDMALLOC_FORCERESERVE(p, 0, bytes);
	return nedpmalloc2(p, bytes, 0, M2_ZERO_MEMORY|flags);
 }
 NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedprealloc(nedpool *p, void *mem, size_t size) THROWSPEC
 {
","Multiple integer overflows in the (1) CallMalloc (malloc) and (2) nedpcalloc (calloc) functions in nedmalloc (nedmalloc.c) before 1.10 beta2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected."
2010,CVE-2012-2673,"  GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)
         GC_bool init;
         lg = ROUNDED_UP_GRANULES(lb);
         lb_rounded = GRANULES_TO_BYTES(lg);
        if (lb_rounded < lb)
            return((*GC_get_oom_fn())(lb));
         n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);
         init = GC_obj_kinds[k].ok_init;
         LOCK();","Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected."
2011,CVE-2012-2673,"  void * malloc(size_t lb)
   }
 #endif  
 
#include <limits.h>
#ifdef SIZE_MAX
# define GC_SIZE_MAX SIZE_MAX
#else
# define GC_SIZE_MAX (~(size_t)0)
 #endif

 void * calloc(size_t n, size_t lb)
 {
    if (lb && n > GC_SIZE_MAX / lb)
       return NULL;
 #   if defined(GC_LINUX_THREADS)  
          ","Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected."
2012,CVE-2012-2673,"  void * malloc(size_t lb)
 # define GC_SIZE_MAX (~(size_t)0)
 #endif
 
#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ / 2)) - 1)

 void * calloc(size_t n, size_t lb)
 {
    if ((lb | n) > GC_SQRT_SIZE_MAX  
        && lb && n > GC_SIZE_MAX / lb)
       return NULL;
 #   if defined(GC_LINUX_THREADS)  
          ","Multiple integer overflows in the (1) GC_generic_malloc and (2) calloc functions in malloc.c, and the (3) GC_generic_malloc_ignore_off_page function in mallocx.c in Boehm-Demers-Weiser GC (libgc) before 7.2 make it easier for context-dependent attackers to perform memory-related attacks such as buffer overflows via a large size value, which causes less memory to be allocated than expected."
2013,CVE-2012-1571," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.46 2011/09/16 21:23:59 christos Exp $"")
 #endif
 
 #include <assert.h>
  ssize_t
 cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,
     const cdf_header_t *h, cdf_secid_t id)
 {
	size_t ss = CDF_SEC_SIZE(h);
	size_t pos = CDF_SEC_POS(h, id);
	assert(ss == len);
	return cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);
 }
 
 ssize_t
 cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,
     size_t len, const cdf_header_t *h, cdf_secid_t id)
 {
	size_t ss = CDF_SHORT_SEC_SIZE(h);
	size_t pos = CDF_SHORT_SEC_POS(h, id);
	assert(ss == len);
	if (sst->sst_len < (size_t)id) {
		DPRINTF((""bad sector id %d > %d\n"", id, sst->sst_len));
		return -1;
	}
 	(void)memcpy(((char *)buf) + offs,
	    ((const char *)sst->sst_tab) + pos, len);
 	return len;
 }
 
  cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
 				    inp[i].pi_str.s_buf));
 				l = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));
 				o += l >> 2;
				if (q + o >= e)
					goto out;
 				o4 = o * sizeof(uint32_t);
 			}
 			i--;",file before 5.11 and libmagic allow remote attackers to cause a denial of service (crash) via a crafted Composite Document File (CDF) file that triggers (1) an out-of-bounds read or (2) an invalid pointer dereference.
2014,CVE-2012-0879,"  static void cfq_exit(struct io_context *ioc)
 }
 
  
void exit_io_context(struct task_struct *task)
 {
 	struct io_context *ioc;
 
	task_lock(task);
	ioc = task->io_context;
	task->io_context = NULL;
	task_unlock(task);
 
 	if (atomic_dec_and_test(&ioc->nr_tasks)) {
 		if (ioc->aic && ioc->aic->exit)","The I/O implementation for block devices in the Linux kernel before 2.6.33 does not properly handle the CLONE_IO feature, which allows local users to cause a denial of service (I/O instability) by starting multiple processes that share an I/O context."
2015,CVE-2012-0207,"  static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,
 		 * to be intended in a v3 query.
 		 */
 		max_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);
		if (!max_delay)
			max_delay = 1;	 
 	} else {  
 		if (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))
 			return;",The igmp_heard_query function in net/ipv4/igmp.c in the Linux kernel before 3.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and panic) via IGMP packets.
2016,CVE-2012-0038,"  xfs_acl_from_disk(struct xfs_acl *aclp)
 	struct posix_acl_entry *acl_e;
 	struct posix_acl *acl;
 	struct xfs_acl_entry *ace;
	unsigned int count, i;
 
 	count = be32_to_cpu(aclp->acl_cnt);
 	if (count > XFS_ACL_MAX_ENTRIES)","Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow."
2017,CVE-2011-4127," 
 #include <linux/capability.h>
 #include <linux/completion.h>
 #include <linux/cdrom.h>
#include <linux/ratelimit.h>
 #include <linux/slab.h>
 #include <linux/times.h>
 #include <asm/uaccess.h>
  int scsi_cmd_ioctl(struct request_queue *q, struct gendisk *bd_disk, fmode_t mod
 }
 EXPORT_SYMBOL(scsi_cmd_ioctl);
 
int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)
{
	if (bd && bd == bd->bd_contains)
		return 0;

	 
	switch (cmd) {
	case SCSI_IOCTL_GET_IDLUN:
	case SCSI_IOCTL_GET_BUS_NUMBER:
	case SCSI_IOCTL_GET_PCI:
	case SCSI_IOCTL_PROBE_HOST:
	case SG_GET_VERSION_NUM:
	case SG_SET_TIMEOUT:
	case SG_GET_TIMEOUT:
	case SG_GET_RESERVED_SIZE:
	case SG_SET_RESERVED_SIZE:
	case SG_EMULATED_HOST:
		return 0;
	case CDROM_GET_CAPABILITY:
		 
		return -ENOIOCTLCMD;
	default:
		break;
	}

	 
	printk_ratelimited(KERN_WARNING
			   ""%s: sending ioctl %x to a partition!\n"", current->comm, cmd);

	return capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;
}
EXPORT_SYMBOL(scsi_verify_blk_ioctl);

 int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,
 		       unsigned int cmd, void __user *arg)
 {
	int ret;

	ret = scsi_verify_blk_ioctl(bd, cmd);
	if (ret < 0)
		return ret;

 	return scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);
 }
 EXPORT_SYMBOL(scsi_cmd_blk_ioctl);","The Linux kernel before 3.2.2 does not properly restrict SG_IO ioctl calls, which allows local users to bypass intended restrictions on disk read and write operations by sending a SCSI command to (1) a partition block device or (2) an LVM volume."
2018,CVE-2011-3188," 
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/types.h>
#include <linux/cryptohash.h>
 #include <asm/byteorder.h>
 
  
 static inline void le32_to_cpu_array(u32 *buf, unsigned int words)
 {","The (1) IPv4 and (2) IPv6 implementations in the Linux kernel before 3.1 use a modified MD4 algorithm to generate sequence numbers and Fragment Identification values, which makes it easier for remote attackers to cause a denial of service (disrupted networking) or hijack network sessions by predicting these values and sending crafted packets."
2019,CVE-2013-4592,"  int __kvm_set_memory_region(struct kvm *kvm,
 		old_memslots = kvm->memslots;
 		rcu_assign_pointer(kvm->memslots, slots);
 		synchronize_srcu_expedited(&kvm->srcu);
		 
		kvm_iommu_unmap_pages(kvm, &old);
 		 
 	r = -ENOMEM;
 	slots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),
 			GFP_KERNEL);
 	if (!slots)
 		goto out_free;
 
	 
	if (npages) {
		r = kvm_iommu_map_pages(kvm, &new);
		if (r)
			goto out_slots;
	}

 	 
 	if (!npages) {
 		new.dirty_bitmap = NULL;
  int __kvm_set_memory_region(struct kvm *kvm,
 
 	return 0;
 
out_slots:
	kfree(slots);
 out_free:
 	kvm_free_physmem_slot(&new, &old);
 out:",Memory leak in the __kvm_set_memory_region function in virt/kvm/kvm_main.c in the Linux kernel before 3.9 allows local users to cause a denial of service (memory consumption) by leveraging certain device access to trigger movement of memory slots.
2020,CVE-2013-4470,"  static inline int ip6_ufo_append_data(struct sock *sk,
 
 {
 	struct sk_buff *skb;
	struct frag_hdr fhdr;
 	int err;
 
 	 
 	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
 		skb = sock_alloc_send_skb(sk,
 			hh_len + fragheaderlen + transhdrlen + 20,
 			(flags & MSG_DONTWAIT), &err);
  static inline int ip6_ufo_append_data(struct sock *sk,
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->protocol = htons(ETH_P_IPV6);
 		skb->csum = 0;
 
 		__skb_queue_tail(&sk->sk_write_queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	 
	skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -
				     sizeof(struct frag_hdr)) & ~7;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
	ipv6_select_ident(&fhdr, rt);
	skb_shinfo(skb)->ip6_frag_id = fhdr.identification;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }","The Linux kernel before 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly initialize certain data structures, which allows local users to cause a denial of service (memory corruption and system crash) or possibly gain privileges via a crafted application that uses the UDP_CORK option in a setsockopt system call and sends both short and long packets, related to the ip_ufo_append_data function in net/ipv4/ip_output.c and the ip6_ufo_append_data function in net/ipv6/ip6_output.c."
2021,CVE-2013-3232,"  static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,
 	}
 
 	if (sax != NULL) {
		memset(sax, 0, sizeof(*sax));
 		sax->sax25_family = AF_NETROM;
 		skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,
 			      AX25_ADDR_LEN);","The nr_recvmsg function in net/netrom/af_netrom.c in the Linux kernel before 3.9-rc7 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
2022,CVE-2013-2596,"  int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
 int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,
 			unsigned long pfn);
int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);

 
 struct page *follow_page_mask(struct vm_area_struct *vma,
 			      unsigned long address, unsigned int foll_flags,","Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program."
2023,CVE-2013-1959,"  static bool new_idmap_permitted(const struct file *file,
 		u32 id = new_map->extent[0].lower_first;
 		if (cap_setid == CAP_SETUID) {
 			kuid_t uid = make_kuid(ns->parent, id);
			if (uid_eq(uid, file->f_cred->fsuid))
 				return true;
 		}
 		else if (cap_setid == CAP_SETGID) {
 			kgid_t gid = make_kgid(ns->parent, id);
			if (gid_eq(gid, file->f_cred->fsgid))
 				return true;
 		}
 	}","kernel/user_namespace.c in the Linux kernel before 3.8.9 does not have appropriate capability requirements for the uid_map and gid_map files, which allows local users to gain privileges by opening a file within an unprivileged process and then modifying the file within a privileged process."
2024,CVE-2012-6546,"  static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
 		return -ENOTCONN;
 	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
 	addr = (struct sockaddr_atmpvc *)sockaddr;
	memset(addr, 0, sizeof(*addr));
 	addr->sap_family = AF_ATMPVC;
 	addr->sap_addr.itf = vcc->dev->number;
 	addr->sap_addr.vpi = vcc->vpi;","The ATM implementation in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
2025,CVE-2012-6545,"  static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, c
 		}
 
 		sec.level = rfcomm_pi(sk)->sec_level;
		sec.key_size = 0;
 
 		len = min_t(unsigned int, len, sizeof(sec));
 		if (copy_to_user(optval, (char *) &sec, len))","The Bluetooth RFCOMM implementation in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."
2026,CVE-2012-6545,"  static int rfcomm_get_dev_list(void __user *arg)
 
 	size = sizeof(*dl) + dev_num * sizeof(*di);
 
	dl = kzalloc(size, GFP_KERNEL);
 	if (!dl)
 		return -ENOMEM;
 ","The Bluetooth RFCOMM implementation in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."
2027,CVE-2012-6544,"  static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 ","The Bluetooth protocol stack in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application that targets the (1) L2CAP or (2) HCI implementation."
2028,CVE-2012-6544,"  static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
	haddr->hci_channel= 0;
 
 	release_sock(sk);
 	return 0;","The Bluetooth protocol stack in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application that targets the (1) L2CAP or (2) HCI implementation."
2029,CVE-2012-6537,"  static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)
 		struct xfrm_user_tmpl *up = &vec[i];
 		struct xfrm_tmpl *kp = &xp->xfrm_vec[i];
 
		memset(up, 0, sizeof(*up));
 		memcpy(&up->id, &kp->id, sizeof(up->id));
 		up->family = kp->encap_family;
 		memcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));","net/xfrm/xfrm_user.c in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability."
2030,CVE-2012-6537,"  static void copy_from_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy
 
 static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)
 {
	memset(p, 0, sizeof(*p));
 	memcpy(&p->sel, &xp->selector, sizeof(p->sel));
 	memcpy(&p->lft, &xp->lft, sizeof(p->lft));
 	memcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));","net/xfrm/xfrm_user.c in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel memory by leveraging the CAP_NET_ADMIN capability."
2031,CVE-2014-8116," 
 	switch (type) {
 #ifdef ELFCORE
 	case ET_CORE:
		phnum = elf_getu16(swap, elfhdr.e_phnum);
		if (phnum > MAX_PHNUM)
			return toomany(ms, ""program"", phnum);
 		flags |= FLAGS_IS_CORE;
 		if (dophn_core(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,
 		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
 		    fsize, &flags) == -1)
 			return -1;
 		break;
 #endif
 	case ET_EXEC:
 	case ET_DYN:
		phnum = elf_getu16(swap, elfhdr.e_phnum);
		if (phnum > MAX_PHNUM)
			return toomany(ms, ""program"", phnum);
		shnum = elf_getu16(swap, elfhdr.e_shnum);
		if (shnum > MAX_SHNUM)
			return toomany(ms, ""section"", shnum);
 		if (dophn_exec(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,
 		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags, shnum) == -1)
 			return -1;
 		 
 	case ET_REL:
		shnum = elf_getu16(swap, elfhdr.e_shnum);
		if (shnum > MAX_SHNUM)
			return toomany(ms, ""section"", shnum);
 		if (doshn(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_shoff), shnum,
 		    (size_t)elf_getu16(swap, elfhdr.e_shentsize),
 		    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),
 		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)",The ELF parser (readelf.c) in file before 5.21 allows remote attackers to cause a denial of service (CPU consumption or crash) via a large number of (1) program or (2) section headers or (3) invalid capabilities.
2032,CVE-2014-4656,"  int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)
 	if (snd_BUG_ON(!card || !kcontrol->info))
 		goto error;
 	id = kcontrol->id;
	if (id.index > UINT_MAX - kcontrol->count)
		goto error;

 	down_write(&card->controls_rwsem);
 	if (snd_ctl_find_id(card, &id)) {
 		up_write(&card->controls_rwsem);","Multiple integer overflows in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allow local users to cause a denial of service by leveraging /dev/snd/controlCX access, related to (1) index values in the snd_ctl_add function and (2) numid values in the snd_ctl_remove_numid_conflict function."
2033,CVE-2014-4502,"  bool initiate_stratum(struct pool *pool)
 		goto out;
 	}
 	n2size = json_integer_value(json_array_get(res_val, 2));
	if (n2size < 1)
	{
 		applog(LOG_INFO, ""Failed to get n2size in initiate_stratum"");
 		free(sessionid);
 		free(nonce1);","Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request."
2034,CVE-2014-4502,"  bool initiate_stratum(struct pool *pool)
 		goto out;
 	}
 	n2size = json_integer_value(json_array_get(res_val, 2));
	if (n2size < 1)
	{
 		applog(LOG_INFO, ""Failed to get n2size in initiate_stratum"");
 		free(sessionid);
 		free(nonce1);","Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request."
2035,CVE-2014-4501,"  static void __suspend_stratum(struct pool *pool)
 
 static bool parse_reconnect(struct pool *pool, json_t *val)
 {
 	if (opt_disable_client_reconnect) {
		applog(LOG_WARNING, ""Stratum client.reconnect received but is disabled, not reconnecting."");
 		return false;
 	}
 
	char *url, *port, address[256];
	char *sockaddr_url, *stratum_port, *tmp;  

 	url = (char *)json_string_value(json_array_get(val, 0));
 	if (!url)
 		url = pool->sockaddr_url;
  static bool parse_reconnect(struct pool *pool, json_t *val)
 	if (!port)
 		port = pool->stratum_port;
 
	snprintf(address, sizeof(address), ""%s:%s"", url, port);
 	if (!extract_sockaddr(address, &sockaddr_url, &stratum_port))
 		return false;
 ","Multiple stack-based buffer overflows in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 3.3.0 allow remote pool servers to have unspecified impact via a long URL in a client.reconnect stratum message to the (1) extract_sockaddr or (2) parse_reconnect functions in util.c."
2036,CVE-2014-4501,"  bool extract_sockaddr(struct pool *pool, char *url)
 
 	if (url_len < 1)
 		return false;
	
	if (url_len >= sizeof(url_address))
	{
		applog(LOG_WARNING, ""%s: Truncating overflowed address '%.*s'"",
		       __func__, url_len, url_begin);
		url_len = sizeof(url_address) - 1;
	}
 
 	sprintf(url_address, ""%.*s"", url_len, url_begin);
 ","Multiple stack-based buffer overflows in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 3.3.0 allow remote pool servers to have unspecified impact via a long URL in a client.reconnect stratum message to the (1) extract_sockaddr or (2) parse_reconnect functions in util.c."
2037,CVE-2014-4501," 
  
		free(job_id);
		free(coinbase1);
		free(coinbase2);
 		goto out;
 	}
 
  static bool parse_reconnect(struct pool *pool, json_t *val)
 	if (!port)
 		port = pool->stratum_port;
 
	snprintf(address, 254, ""%s:%s"", url, port);
 
 	if (!extract_sockaddr(address, &sockaddr_url, &stratum_port))
 		return false;
  bool initiate_stratum(struct pool *pool)
 	if (!sessionid)
 		applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum"");
 	nonce1 = json_array_string(res_val, 1);
	if (!valid_hex(nonce1)) {
		applog(LOG_INFO, ""Failed to get valid nonce1 in initiate_stratum"");
 		free(sessionid);
 		goto out;
 	}
 	n2size = json_integer_value(json_array_get(res_val, 2));
	if (n2size < 2 || n2size > 16) {
		applog(LOG_INFO, ""Failed to get valid n2size in initiate_stratum"");
 		free(sessionid);
 		free(nonce1);
 		goto out;","Multiple stack-based buffer overflows in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 3.3.0 allow remote pool servers to have unspecified impact via a long URL in a client.reconnect stratum message to the (1) extract_sockaddr or (2) parse_reconnect functions in util.c."
2038,CVE-2014-4344,"  acc_ctx_cont(OM_uint32 *minstat,
 
 	ptr = bufstart = buf->value;
 #define REMAIN (buf->length - (ptr - bufstart))
	if (REMAIN == 0 || REMAIN > INT_MAX)
 		return GSS_S_DEFECTIVE_TOKEN;
 
 	/*",The acc_ctx_cont function in the SPNEGO acceptor in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.5.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an empty continuation token at a certain point during a SPNEGO negotiation.
2039,CVE-2014-3647,"  static int emulate_nm(struct x86_emulate_ctxt *ctxt)
 	return emulate_exception(ctxt, NM_VECTOR, 0, false);
 }
 
static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,
			       int cs_l)
 {
 	switch (ctxt->op_bytes) {
 	case 2:
  static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)
 		ctxt->_eip = (u32)dst;
 		break;
 	case 8:
		if ((cs_l && is_noncanonical_address(dst)) ||
		    (!cs_l && (dst & ~(u32)-1)))
			return emulate_gp(ctxt, 0);
 		ctxt->_eip = dst;
 		break;
 	default:
 		WARN(1, ""unsupported eip assignment size\n"");
 	}
	return X86EMUL_CONTINUE;
}

static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)
{
	return assign_eip_far(ctxt, dst, ctxt->mode == X86EMUL_MODE_PROT64);
 }
 
static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)
 {
	return assign_eip_near(ctxt, ctxt->_eip + rel);
 }
 
 static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)
  static int em_grp45(struct x86_emulate_ctxt *ctxt)
 	case 2:   {
 		long int old_eip;
 		old_eip = ctxt->_eip;
		rc = assign_eip_near(ctxt, ctxt->src.val);
		if (rc != X86EMUL_CONTINUE)
			break;
 		ctxt->src.val = old_eip;
 		rc = em_push(ctxt);
 		break;
 	}
 	case 4:  
		rc = assign_eip_near(ctxt, ctxt->src.val);
 		break;
 	case 5:  
 		rc = em_jmp_far(ctxt);
  static int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)
 
 static int em_ret(struct x86_emulate_ctxt *ctxt)
 {
	int rc;
	unsigned long eip;

	rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);
	if (rc != X86EMUL_CONTINUE)
		return rc;

	return assign_eip_near(ctxt, eip);
 }
 
 static int em_ret_far(struct x86_emulate_ctxt *ctxt)
  static int em_sysexit(struct x86_emulate_ctxt *ctxt)
 {
 	const struct x86_emulate_ops *ops = ctxt->ops;
 	struct desc_struct cs, ss;
	u64 msr_data, rcx, rdx;
 	int usermode;
 	u16 cs_sel = 0, ss_sel = 0;
 
  static int em_sysexit(struct x86_emulate_ctxt *ctxt)
 	else
 		usermode = X86EMUL_MODE_PROT32;
 
	rcx = reg_read(ctxt, VCPU_REGS_RCX);
	rdx = reg_read(ctxt, VCPU_REGS_RDX);

 	cs.dpl = 3;
 	ss.dpl = 3;
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);
  static int em_sysexit(struct x86_emulate_ctxt *ctxt)
 		ss_sel = cs_sel + 8;
 		cs.d = 0;
 		cs.l = 1;
		if (is_noncanonical_address(rcx) ||
		    is_noncanonical_address(rdx))
			return emulate_gp(ctxt, 0);
 		break;
 	}
 	cs_sel |= SELECTOR_RPL_MASK;
  static int em_sysexit(struct x86_emulate_ctxt *ctxt)
 	ops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);
 	ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);
 
	ctxt->_eip = rdx;
	*reg_write(ctxt, VCPU_REGS_RSP) = rcx;
 
 	return X86EMUL_CONTINUE;
 }
  static int em_aad(struct x86_emulate_ctxt *ctxt)
 
 static int em_call(struct x86_emulate_ctxt *ctxt)
 {
	int rc;
 	long rel = ctxt->src.val;
 
 	ctxt->src.val = (unsigned long)ctxt->_eip;
	rc = jmp_rel(ctxt, rel);
	if (rc != X86EMUL_CONTINUE)
		return rc;
 	return em_push(ctxt);
 }
 
  static int em_call_far(struct x86_emulate_ctxt *ctxt)
 static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
	unsigned long eip;
 
	rc = emulate_pop(ctxt, &eip, ctxt->op_bytes);
	if (rc != X86EMUL_CONTINUE)
		return rc;
	rc = assign_eip_near(ctxt, eip);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 	rsp_increment(ctxt, ctxt->src.val);
  static int em_lmsw(struct x86_emulate_ctxt *ctxt)
 
 static int em_loop(struct x86_emulate_ctxt *ctxt)
 {
	int rc = X86EMUL_CONTINUE;

 	register_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);
 	if ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&
 	    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))
		rc = jmp_rel(ctxt, ctxt->src.val);
 
	return rc;
 }
 
 static int em_jcxz(struct x86_emulate_ctxt *ctxt)
 {
	int rc = X86EMUL_CONTINUE;

 	if (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)
		rc = jmp_rel(ctxt, ctxt->src.val);
 
	return rc;
 }
 
 static int em_in(struct x86_emulate_ctxt *ctxt)
  int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)
 		break;
 	case 0x70 ... 0x7f:  
 		if (test_cc(ctxt->b, ctxt->eflags))
			rc = jmp_rel(ctxt, ctxt->src.val);
 		break;
 	case 0x8d:  
 		ctxt->dst.val = ctxt->src.addr.mem.ea;
  int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)
 		break;
 	case 0xe9:  
 	case 0xeb:  
		rc = jmp_rel(ctxt, ctxt->src.val);
 		ctxt->dst.type = OP_NONE;  
 		break;
 	case 0xf4:               
  int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)
 		break;
 	case 0x80 ... 0x8f:  
 		if (test_cc(ctxt->b, ctxt->eflags))
			rc = jmp_rel(ctxt, ctxt->src.val);
 		break;
 	case 0x90 ... 0x9f:      
 		ctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);","arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel through 3.17.2 does not properly perform RIP changes, which allows guest OS users to cause a denial of service (guest OS crash) via a crafted application."
2040,CVE-2014-3587," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: cdf.c,v 1.64 2014/07/24 19:35:39 christos Exp $"")
 #endif
 
 #include <assert.h>
  cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
 		q = (const uint8_t *)(const void *)
 		    ((const char *)(const void *)p + ofs
 		    - 2 * sizeof(uint32_t));
		if (q < p) {
			DPRINTF((""Wrapped around %p < %p\n"", q, p));
			goto out;
		}
 		if (q > e) {
 			DPRINTF((""Ran of the end %p > %p\n"", q, e));
 			goto out;","Integer overflow in the cdf_read_property_info function in cdf.c in file through 5.19, as used in the Fileinfo component in PHP before 5.4.32 and 5.5.x before 5.5.16, allows remote attackers to cause a denial of service (application crash) via a crafted CDF file.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-1571."
2041,CVE-2014-3538," 
 #include ""file.h""
 
 #ifndef	lint
FILE_RCSID(""@(#)$File: softmagic.c,v 1.188 2014/05/14 23:15:42 christos Exp $"")
 #endif	 
 
 #include ""magic.h""
  magiccheck(struct magic_set *ms, struct magic *m)
 			file_regerror(&rx, rc, ms);
 			v = (uint64_t)-1;
 		} else {
#ifndef REG_STARTEND
			char c;
#endif
 			regmatch_t pmatch[1];
			size_t slen = ms->search.s_len;
			 
			if (m->str_range > 0)
				slen = MIN(slen, m->str_range);
 #ifndef REG_STARTEND
 #define	REG_STARTEND	0
			if (slen != 0)
				slen--;
			c = ms->search.s[slen];
			((char *)(intptr_t)ms->search.s)[slen] = '\0';
 #else
 			pmatch[0].rm_so = 0;
			pmatch[0].rm_eo = slen;
 #endif
 			rc = file_regexec(&rx, (const char *)ms->search.s,
 			    1, pmatch, REG_STARTEND);","file before 5.19 does not properly restrict the amount of data read during a regex search, which allows remote attackers to cause a denial of service (CPU consumption) via a crafted file that triggers backtracking during processing of an awk rule.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7345."
2042,CVE-2011-3346,"  static void scsi_cancel_io(SCSIRequest *req)
     r->req.aiocb = NULL;
 }
 
static uint32_t scsi_init_iovec(SCSIDiskReq *r)
{
    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);
    qemu_iovec_init_external(&r->qiov, &r->iov, 1);
    return r->qiov.size / 512;
}

 static void scsi_read_complete(void * opaque, int ret)
 {
     SCSIDiskReq *r = (SCSIDiskReq *)opaque;
  static void scsi_read_complete(void * opaque, int ret)
         }
     }
 
    DPRINTF(""Data ready tag=0x%x len=%zd\n"", r->req.tag, r->qiov.size);
 
    n = r->qiov.size / 512;
     r->sector += n;
     r->sector_count -= n;
    scsi_req_data(&r->req, r->qiov.size);
 }
 
 static void scsi_flush_complete(void * opaque, int ret)
  static void scsi_read_data(SCSIRequest *req)
         return;
     }
 
     if (s->tray_open) {
         scsi_read_complete(r, -ENOMEDIUM);
     }
    n = scsi_init_iovec(r);
     bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);
     r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,
                               scsi_read_complete, r);
  static void scsi_write_complete(void * opaque, int ret)
 {
     SCSIDiskReq *r = (SCSIDiskReq *)opaque;
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
     uint32_t n;
 
     if (r->req.aiocb != NULL) {
  static void scsi_write_complete(void * opaque, int ret)
         }
     }
 
    n = r->qiov.size / 512;
     r->sector += n;
     r->sector_count -= n;
     if (r->sector_count == 0) {
         scsi_req_complete(&r->req, GOOD);
     } else {
        scsi_init_iovec(r);
        DPRINTF(""Write complete tag=0x%x more=%d\n"", r->req.tag, r->qiov.size);
        scsi_req_data(&r->req, r->qiov.size);
     }
 }
 
  static void scsi_write_data(SCSIRequest *req)
         return;
     }
 
    n = r->qiov.size / 512;
     if (n) {
         if (s->tray_open) {
             scsi_write_complete(r, -ENOMEDIUM);
         }
         bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);
         r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,
                                       scsi_write_complete, r);
         if (r->req.aiocb == NULL) {
             scsi_write_complete(r, -ENOMEM);
         }
     } else {
         
         scsi_write_complete(r, 0);
     }
 }","Buffer overflow in hw/scsi-disk.c in the SCSI subsystem in QEMU before 0.15.2, as used by Xen, might allow local guest users with permission to access the CD-ROM to cause a denial of service (guest crash) via a crafted SAI READ CAPACITY SCSI command.  NOTE: this is only a vulnerability when root has manually modified certain permissions or ACLs."
2043,CVE-2015-7872,"  static noinline void key_gc_unused_keys(struct list_head *keys)
 		kdebug(""- %u"", key->serial);
 		key_check(key);
 
		 
		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
		    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&
		    key->type->destroy)
 			key->type->destroy(key);
 
 		security_key_free(key);",The key_gc_unused_keys function in security/keys/gc.c in the Linux kernel through 4.2.6 allows local users to cause a denial of service (OOPS) via crafted keyctl commands.
2044,CVE-2015-5707,"  sg_start_req(Sg_request *srp, unsigned char *cmd)
 			md->from_user = 0;
 	}
 
 	if (iov_count) {
		struct iovec *iov = NULL;
 		struct iov_iter i;
 
		res = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i);
		if (res < 0)
			return res;
 
		iov_iter_truncate(&i, hp->dxfer_len);
 
 		res = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);
 		kfree(iov);",Integer overflow in the sg_start_req function in drivers/scsi/sg.c in the Linux kernel 2.6.x through 4.x before 4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large iov_count value in a write request.
2045,CVE-2015-4002,"  static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			unsigned int n;
			if (!body->unit_size ||
				len < sizeof(struct oz_multiple_fixed) - 1)
 				break;
			n = (len - (sizeof(struct oz_multiple_fixed) - 1))
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,","drivers/staging/ozwpan/ozusbsvc1.c in the OZWPAN driver in the Linux kernel through 4.0.5 does not ensure that certain length values are sufficiently large, which allows remote attackers to cause a denial of service (system crash or large loop) or possibly execute arbitrary code via a crafted packet, related to the (1) oz_usb_rx and (2) oz_usb_handle_ep_data functions."
2046,CVE-2015-2925,"  static int prepend_path(const struct path *path,
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			struct mount *parent = ACCESS_ONCE(mnt->mnt_parent);
			 
			if (dentry != vfsmnt->mnt_root) {
				bptr = *buffer;
				blen = *buflen;
				error = 3;
				break;
			}
 			 
 			if (mnt != parent) {
 				dentry = ACCESS_ONCE(mnt->mnt_mountpoint);","The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a *double-chroot attack.*"
2047,CVE-2015-1805,"  pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
 	return 0;
 }
 
  
  pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 	ssize_t ret;
 	struct iovec *iov = (struct iovec *)_iov;
 	size_t total_len;
	struct iov_iter iter;
 
 	total_len = iov_length(iov, nr_segs);
 	 
 	if (unlikely(total_len == 0))
 		return 0;
 
	iov_iter_init(&iter, iov, nr_segs, total_len, 0);

 	do_wakeup = 0;
 	ret = 0;
 	__pipe_lock(pipe);
  pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			int curbuf = pipe->curbuf;
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
 			size_t chars = buf->len;
			size_t written;
			int error;
 
 			if (chars > total_len)
 				chars = total_len;
  pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 				break;
 			}
 
			written = copy_page_to_iter(buf->page, buf->offset, chars, &iter);
			if (unlikely(written < chars)) {
 				if (!ret)
					ret = -EFAULT;
 				break;
 			}
 			ret += chars;","The (1) pipe_read and (2) pipe_write implementations in fs/pipe.c in the Linux kernel before 3.16 do not properly consider the side effects of failed __copy_to_user_inatomic and __copy_from_user_inatomic calls, which allows local users to cause a denial of service (system crash) or possibly gain privileges via a crafted application, aka an *I/O vector array overrun.*"
2048,CVE-2014-9728,"  static int udf_read_inode(struct inode *inode, bool hidden_inode)
 	}
 	inode->i_generation = iinfo->i_unique;
 
	 
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		 
		if (iinfo->i_lenAlloc != inode->i_size)
			goto out;
		 
		if (inode->i_size > inode->i_sb->s_blocksize -
					udf_file_entry_alloc_offset(inode))
			goto out;
	}

 	switch (fe->icbTag.fileType) {
 	case ICBTAG_FILE_TYPE_DIRECTORY:
 		inode->i_op = &udf_dir_inode_operations;","The UDF filesystem implementation in the Linux kernel before 3.18.2 does not validate certain lengths, which allows local users to cause a denial of service (buffer over-read and system crash) via a crafted filesystem image, related to fs/udf/inode.c and fs/udf/symlink.c."
2049,CVE-2014-9728,"  static int udf_symlink_filler(struct file *file, struct page *page)
 	struct inode *inode = page->mapping->host;
 	struct buffer_head *bh = NULL;
 	unsigned char *symlink;
	int err;
 	unsigned char *p = kmap(page);
 	struct udf_inode_info *iinfo;
 	uint32_t pos;
 
	 
	if (inode->i_size > inode->i_sb->s_blocksize) {
		err = -ENAMETOOLONG;
		goto out_unmap;
	}

 	iinfo = UDF_I(inode);
 	pos = udf_block_map(inode, 0);
 
  static int udf_symlink_filler(struct file *file, struct page *page)
 	} else {
 		bh = sb_bread(inode->i_sb, pos);
 
		if (!bh) {
			err = -EIO;
			goto out_unlock_inode;
		}
 
 		symlink = bh->b_data;
 	}
  static int udf_symlink_filler(struct file *file, struct page *page)
 	unlock_page(page);
 	return 0;
 
out_unlock_inode:
 	up_read(&iinfo->i_data_sem);
 	SetPageError(page);
out_unmap:
 	kunmap(page);
 	unlock_page(page);
 	return err;","The UDF filesystem implementation in the Linux kernel before 3.18.2 does not validate certain lengths, which allows local users to cause a denial of service (buffer over-read and system crash) via a crafted filesystem image, related to fs/udf/inode.c and fs/udf/symlink.c."
2050,CVE-2014-3571,"  int dtls1_get_record(SSL *s)
 		 
 		i=rr->length;
 		n=ssl3_read_n(s,i,i,1);
 		 
 		if ( n != i)
 			{","OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted DTLS message that is processed with a different read operation for the handshake header than for the handshake body, related to the dtls1_get_record function in d1_pkt.c and the ssl3_read_n function in s3_pkt.c."
2051,CVE-2016-7163,"  opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,
 	l_current_pi->include = 00;
 	if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))
 	{
		l_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));
 	}
 
 	if","Integer overflow in the opj_pi_create_decode function in pi.c in OpenJPEG allows remote attackers to execute arbitrary code via a crafted JP2 file, which triggers an out-of-bounds read or write."
2052,CVE-2016-6905,"  int read_image_tga( gdIOCtx *ctx, oTga *tga )
 		buffer_caret = 0;
 
 		while( bitmap_caret < image_block_size ) {
			
 			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
 				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );
 				buffer_caret++;
 
				if (encoded_pixels != 0) {
				
					if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {
						gdFree( decompression_buffer );
						gdFree( conversion_buffer );
						return -1;
					}

					for (i = 0; i < encoded_pixels; i++) {
						for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {
							tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
						}
 					}
 				}
 				buffer_caret += pixel_block_size;
 			} else {
 				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
 				buffer_caret++;
 
				if (encoded_pixels != 0) {
				
					if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {
						gdFree( decompression_buffer );
						gdFree( conversion_buffer );
						return -1;
					}

					for (i = 0; i < encoded_pixels; i++) {
						for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {
							tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
						}
						buffer_caret += pixel_block_size;
 					}
 				}
 			}
 		}",The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA image.
2053,CVE-2016-6663," 
 #define MY_HOLD_ORIGINAL_MODES 128   
 #define MY_REDEL_MAKE_BACKUP 256
#define MY_REDEL_NO_COPY_STAT 512  
 #define MY_SEEK_NOT_DONE 32	 
 #define MY_DONT_WAIT	64	 
 #define MY_ZEROFILL	32	 ","Race condition in Oracle MySQL before 5.5.52, 5.6.x before 5.6.33, 5.7.x before 5.7.15, and 8.x before 8.0.1; MariaDB before 5.5.52, 10.0.x before 10.0.28, and 10.1.x before 10.1.18; Percona Server before 5.5.51-38.2, 5.6.x before 5.6.32-78-1, and 5.7.x before 5.7.14-8; and Percona XtraDB Cluster before 5.5.41-37.0, 5.6.x before 5.6.32-25.17, and 5.7.x before 5.7.14-26.17 allows local users with certain permissions to gain privileges by leveraging use of my_copystat by REPAIR TABLE to repair a MyISAM table."
2054,CVE-2016-6198,"  EXPORT_SYMBOL(file_path);
 int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
	struct inode *inode = vfs_select_inode(path->dentry, file->f_flags);
 
	if (IS_ERR(inode))
		return PTR_ERR(inode);
 
	file->f_path = *path;
 	return do_dentry_open(file, inode, NULL, cred);
 }
 ","The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c."
2055,CVE-2016-6128,"  BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int c
 		return NULL;
 	}
 
	if (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {
		return NULL;
	}

 	/* TODO: Add gdImageGetRowPtr and works with ptr at the row level
 	 * for the true color and palette images
 	 * new formats will simply work with ptr","The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index."
2056,CVE-2016-5842,"  static inline const unsigned char *ReadResourceByte(const unsigned char *p,
 static inline const unsigned char *ReadResourceLong(const unsigned char *p,
   unsigned int *quantum)
 {
  *quantum=(unsigned int) (*p++) << 24;
  *quantum|=(unsigned int) (*p++) << 16;
  *quantum|=(unsigned int) (*p++) << 8;
  *quantum|=(unsigned int) (*p++) << 0;
   return(p);
 }
 
 static inline const unsigned char *ReadResourceShort(const unsigned char *p,
   unsigned short *quantum)
 {
  *quantum=(unsigned short) (*p++) << 8;
  *quantum|=(unsigned short) (*p++);
   return(p);
}

static inline void WriteResourceLong(unsigned char *p,
   const unsigned int quantum)
 {
   unsigned char
  static inline signed short ReadProfileShort(const EndianType endian,
 
   if (endian == LSBEndian)
     {
      value=(unsigned short) buffer[1] << 8;
      value|=(unsigned short) buffer[0];
      quantum.unsigned_value=value & 0xffff;
       return(quantum.signed_value);
     }
  value=(unsigned short) buffer[0] << 8;
  value|=(unsigned short) buffer[1];
  quantum.unsigned_value=value & 0xffff;
   return(quantum.signed_value);
 }
 
  static inline signed int ReadProfileLong(const EndianType endian,
 
   if (endian == LSBEndian)
     {
      value=(unsigned int) buffer[3] << 24;
      value|=(unsigned int) buffer[2] << 16;
      value|=(unsigned int) buffer[1] << 8;
      value|=(unsigned int) buffer[0];
      quantum.unsigned_value=value & 0xffffffff;
       return(quantum.signed_value);
     }
  value=(unsigned int) buffer[0] << 24;
  value|=(unsigned int) buffer[1] << 16;
  value|=(unsigned int) buffer[2] << 8;
  value|=(unsigned int) buffer[3];
  quantum.unsigned_value=value & 0xffffffff;
   return(quantum.signed_value);
 }
 
  MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)
         tag_value;
 
       q=(unsigned char *) (directory+2+(12*entry));
      if (q > (exif+length-12))
        break;   
       tag_value=(ssize_t) ReadProfileShort(endian,q);
       format=(ssize_t) ReadProfileShort(endian,q+2);
       if ((format-1) >= EXIF_NUM_FORMATS)
         break;
       components=(ssize_t) ReadProfileLong(endian,q+4);
      if (components < 0)
        break;   
       number_bytes=(size_t) components*format_bytes[format];
       if ((ssize_t) number_bytes < components)
         break;   ","MagickCore/property.c in ImageMagick before 7.0.2-1 allows remote attackers to obtain sensitive memory information via vectors involving the q variable, which triggers an out-of-bounds read."
2057,CVE-2016-5688,"  static Image *ReadWPGImage(const ImageInfo *image_info,
               bpp=BitmapHeader2.Depth;
 
             UnpackRaster:      
              status=SetImageExtent(image,image->columns,image->rows,exception);
              if (status == MagickFalse)
                break;
               if ((image->colors == 0) && (bpp != 24))
                 {
                   image->colors=one << bpp;
  static Image *ReadWPGImage(const ImageInfo *image_info,
                 }
               image->columns=Bitmap2Header1.Width;
               image->rows=Bitmap2Header1.Height;
              status=SetImageExtent(image,image->columns,image->rows,exception);
              if (status == MagickFalse)
                break;
 
               if ((image->colors == 0) && (bpp != 24))
                 {
  static Image *ReadWPGImage(const ImageInfo *image_info,
          ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
       }
    }
 
  Finish:
   (void) CloseBlob(image);","The WPG parser in ImageMagick before 6.9.4-4 and 7.x before 7.0.1-5, when a memory limit is set, allows remote attackers to have unspecified impact via vectors related to the SetImageExtent return-value check, which trigger (1) a heap-based buffer overflow in the SetPixelIndex function or an invalid write operation in the (2) ScaleCharToQuantum or (3) SetPixelIndex functions."
2058,CVE-2016-5688,"  static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
             }
         }
       RelinquishMagickResource(DiskResource,cache_info->length);
      cache_info->type=UndefinedCache;
       (void) ThrowMagickException(exception,GetMagickModule(),CacheError,
         ""CacheResourcesExhausted"",""`%s'"",image->filename);
       return(MagickFalse);
  static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
   if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)
     {
       RelinquishMagickResource(DiskResource,cache_info->length);
      cache_info->type=UndefinedCache;
       ThrowFileException(exception,CacheError,""UnableToOpenPixelCache"",
         image->filename);
       return(MagickFalse);
  static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
     cache_info->length);
   if (status == MagickFalse)
     {
      cache_info->type=UndefinedCache;
       ThrowFileException(exception,CacheError,""UnableToExtendCache"",
         image->filename);
       return(MagickFalse);
  static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
                   (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
                     message);
                 }
              if (status == MagickFalse)
                cache_info->type=UndefinedCache;
               return(status);
             }
         }
  static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
         cache_info->number_channels,format);
       (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",message);
     }
  if (status == MagickFalse)
    cache_info->type=UndefinedCache;
   return(status);
 }
 ","The WPG parser in ImageMagick before 6.9.4-4 and 7.x before 7.0.1-5, when a memory limit is set, allows remote attackers to have unspecified impact via vectors related to the SetImageExtent return-value check, which trigger (1) a heap-based buffer overflow in the SetPixelIndex function or an invalid write operation in the (2) ScaleCharToQuantum or (3) SetPixelIndex functions."
2059,CVE-2016-5357,"  static gboolean
 parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,
     char *line, int *err, gchar **err_info)
 {
	int		pkt_len;
 	int		sec;
 	int		dsec;
 	char		cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];
 	char		direction[2];
 	char		cap_src[13];
 	char		cap_dst[13];
 	guint8		*pd;
 	gchar		*p;
 	int		n, i = 0;
	int		offset = 0;
 	gchar		dststr[13];
 
 	phdr->rec_type = REC_TYPE_PACKET;
 	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
 
	if (sscanf(line, ""%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/"",
 		   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""netscreen: Can't parse packet-header"");
 		return -1;
 	}
	if (pkt_len < 0) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""netscreen: packet header has a negative packet length"");
		return FALSE;
	}
 	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
 		/*
 		 * Probably a corrupt capture file; don't blow up trying","wiretap/netscreen.c in the NetScreen file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
2060,CVE-2016-5356," 
 #define COSINE_HEADER_LINES_TO_CHECK	200
 #define COSINE_LINE_LENGTH		240
 
 static gboolean empty_line(const gchar *line);
 static gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,
 	char *hdr);
  static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
 	gint64 *data_offset);
 static gboolean cosine_seek_read(wtap *wth, gint64 seek_off,
 	struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);
static int parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,
	char *line, int *err, gchar **err_info);
 static int parse_single_hex_dump_line(char* rec, guint8 *buf,
 	guint byte_offset);
 
  static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
     gint64 *data_offset)
 {
 	gint64	offset;
 	char	line[COSINE_LINE_LENGTH];
 
 	 
  static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
 		return FALSE;
 	*data_offset = offset;
 
	 
	return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,
	    line, err, err_info);
 }
 
  
 static gboolean
 cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,
 	Buffer *buf, int *err, gchar **err_info)
 {
 	char	line[COSINE_LINE_LENGTH];
 
 	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
  cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,
 		return FALSE;
 	}
 
	 
	return parse_cosine_packet(wth->random_fh, phdr, buf, line, err,
 	    err_info);
 }
 
  cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,
         2002-5-10,20:1:31.4:  l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0]
     2) output to PE without date and time
         l2-tx (FR:3/7/1:1), Length:18, Pro:0, Off:0, Pri:0, RM:0, Err:0 [0x4000, 0x0] */
static gboolean
parse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
    char *line, int *err, gchar **err_info)
 {
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	int	num_items_scanned;
	int	yy, mm, dd, hr, min, sec, csec;
	guint	pkt_len;
 	int	pro, off, pri, rm, error;
 	guint	code1, code2;
 	char	if_name[COSINE_MAX_IF_NAME_LEN] = """", direction[6] = """";
 	struct	tm tm;
	guint8 *pd;
	int	i, hex_lines, n, caplen = 0;
 
 	if (sscanf(line, ""%4d-%2d-%2d,%2d:%2d:%2d.%9d:"",
 		   &yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {
 		 
 		num_items_scanned = sscanf(line,
		   ""%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]"",
 			&yy, &mm, &dd, &hr, &min, &sec, &csec,
 				   direction, if_name, &pkt_len,
 				   &pro, &off, &pri, &rm, &error,
  parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,
 		if (num_items_scanned != 17) {
 			*err = WTAP_ERR_BAD_FILE;
 			*err_info = g_strdup(""cosine: purported control blade line doesn't have code values"");
			return FALSE;
 		}
 	} else {
 		 
 		num_items_scanned = sscanf(line,
		   ""%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]"",
 				   direction, if_name, &pkt_len,
 				   &pro, &off, &pri, &rm, &error,
 				   &code1, &code2);
 
 		if (num_items_scanned != 10) {
 			*err = WTAP_ERR_BAD_FILE;
 			*err_info = g_strdup(""cosine: header line is neither control blade nor PE output"");
			return FALSE;
 		}
 		yy = mm = dd = hr = min = sec = csec = 0;
 	}
	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
		 
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf(""cosine: File has %u-byte packet, bigger than maximum of %u"",
		    pkt_len, WTAP_MAX_PACKET_SIZE);
		return FALSE;
	}
 
 	phdr->rec_type = REC_TYPE_PACKET;
 	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
  parse_cosine_rec_hdr(struct wtap_pkthdr *phdr, const char *line,
 	pseudo_header->cosine.rm = rm;
 	pseudo_header->cosine.err = error;
 
 	 
	ws_buffer_assure_space(buf, pkt_len);
 	pd = ws_buffer_start_ptr(buf);
 
 	/* Calculate the number of hex dump lines, each
  parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,
 	return TRUE;
 }
 
 /* Take a string representing one line from a hex dump and converts
  * the text to binary data. We place the bytes in the buffer at the
  * specified offset.","wiretap/cosine.c in the CoSine file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
2061,CVE-2016-5355,"  static const char toshiba_hdr_magic[]  =
 static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };
 #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  / sizeof toshiba_rec_magic[0])
 
 static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,
 	gint64 *data_offset);
 static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,
  parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	char	line[TOSHIBA_LINE_LENGTH];
 	int	num_items_scanned;
	guint	pkt_len;
	int	pktnum, hr, min, sec, csec;
 	char	channel[10], direction[10];
 	int	i, hex_lines;
 	guint8	*pd;
  parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 
 	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
 
	num_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);
 	if (num_items_scanned != 1) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
 		return FALSE;
 	}
	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
		 
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
		    pkt_len, WTAP_MAX_PACKET_SIZE);
		return FALSE;
	}
 
 	phdr->rec_type = REC_TYPE_PACKET;
 	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
  parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
 	}
 
 	 
	ws_buffer_assure_space(buf, pkt_len);
 	pd = ws_buffer_start_ptr(buf);
 
 	/* Calculate the number of hex dump lines, each","wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
2062,CVE-2016-5104,"  int socket_create(uint16_t port)
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
  int socket_accept(int fd, uint16_t port)
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 	addr.sin_port = htons(port);
 
 	addr_len = sizeof(addr);",The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.
2063,CVE-2016-4578,"  static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 		tu->tstamp = *tstamp;
 	if ((tu->filter & (1 << event)) == 0 || !tu->tread)
 		return;
	memset(&r1, 0, sizeof(r1));
 	r1.event = event;
 	r1.tstamp = *tstamp;
 	r1.val = resolution;","sound/core/timer.c in the Linux kernel through 4.6 does not initialize certain r1 data structures, which allows local users to obtain sensitive information from kernel stack memory via crafted use of the ALSA timer interface, related to the (1) snd_timer_user_ccallback and (2) snd_timer_user_tinterrupt functions."
2064,CVE-2016-3951,"  usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
 	if (info->unbind)
 		info->unbind (dev, udev);
 out1:
	 
	cancel_work_sync(&dev->kevent);
	del_timer_sync(&dev->delay);
 	free_netdev(net);
 out:
 	return status;",Double free vulnerability in drivers/net/usb/cdc_ncm.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (system crash) or possibly have unspecified other impact by inserting a USB device with an invalid USB descriptor.
2065,CVE-2016-3698,"  struct ndp_msg_type_info {
 	uint8_t raw_type;
 	size_t raw_struct_size;
 	void (*addrto_adjust)(struct in6_addr *addr);
	bool (*addrto_validate)(struct in6_addr *addr);
 };
 
 static void ndp_msg_addrto_adjust_all_nodes(struct in6_addr *addr)
  static void ndp_msg_addrto_adjust_all_routers(struct in6_addr *addr)
 	addr->s6_addr32[3] = htonl(0x2);
 }
 
static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)
{
	return IN6_IS_ADDR_LINKLOCAL (addr);
}

 static struct ndp_msg_type_info ndp_msg_type_info_list[] =
 {
 	[NDP_MSG_RS] = {
  static struct ndp_msg_type_info ndp_msg_type_info_list[] =
 		.strabbr = ""RA"",
 		.raw_type = ND_ROUTER_ADVERT,
 		.raw_struct_size = sizeof(struct nd_router_advert),
		.addrto_validate = ndp_msg_addrto_validate_link_local,
 	},
 	[NDP_MSG_NS] = {
 		.strabbr = ""NS"",
  static struct ndp_msg_type_info ndp_msg_type_info_list[] =
 		.strabbr = ""R"",
 		.raw_type = ND_REDIRECT,
 		.raw_struct_size = sizeof(struct nd_redirect),
		.addrto_validate = ndp_msg_addrto_validate_link_local,
 	},
 };
 
  static bool ndp_msg_check_valid(struct ndp_msg *msg)
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;

	if (ndp_msg_type_info(msg_type)->addrto_validate)
		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
	else
		return true;
 }
 
 static struct ndp_msg *ndp_msg_alloc(void)","libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network."
2066,CVE-2016-2315,"  static void show_commit(struct commit *commit, void *data)
 		index_commit_for_bitmap(commit);
 }
 
static void show_object(struct object *obj, const char *name, void *data)
 {
 	add_preferred_base_object(name);
 	add_object_entry(obj->oid.hash, obj->type, name, 0);
 	obj->flags |= OBJECT_ADDED;
 }
 
 static void show_edge(struct commit *commit)
  static int get_object_list_from_bitmap(struct rev_info *revs)
 }
 
 static void record_recent_object(struct object *obj,
				 const char *name,
 				 void *data)
 {
 	sha1_array_append(&recent_objects, obj->oid.hash);","revision.c in git before 2.7.4 uses an incorrect integer data type, which allows remote attackers to execute arbitrary code via a (1) long filename or (2) many nested trees, leading to a heap-based buffer overflow."
2067,CVE-2016-1583,"  static int read_or_initialize_metadata(struct dentry *dentry)
 	return rc;
 }
 
static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)
{
	struct file *lower_file = ecryptfs_file_to_lower(file);
	 
	if (!lower_file->f_op->mmap)
		return -ENODEV;
	return generic_file_mmap(file, vma);
}

 /**
  * ecryptfs_open
  * @inode: inode specifying file to open
  const struct file_operations ecryptfs_main_fops = {
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = ecryptfs_compat_ioctl,
 #endif
	.mmap = ecryptfs_mmap,
 	.open = ecryptfs_open,
 	.flush = ecryptfs_flush,
 	.release = ecryptfs_release,","The ecryptfs_privileged_open function in fs/ecryptfs/kthread.c in the Linux kernel before 4.6.3 allows local users to gain privileges or cause a denial of service (stack memory consumption) via vectors involving crafted mmap calls for /proc pathnames, leading to recursive pagefault handling."
2068,CVE-2016-1583," 
 #include <linux/slab.h>
 #include <linux/wait.h>
 #include <linux/mount.h>
#include <linux/file.h>
 #include ""ecryptfs_kernel.h""
 
 struct ecryptfs_open_req {
  int ecryptfs_privileged_open(struct file **lower_file,
 	flags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;
 	(*lower_file) = dentry_open(&req.path, flags, cred);
 	if (!IS_ERR(*lower_file))
		goto have_file;
 	if ((flags & O_ACCMODE) == O_RDONLY) {
 		rc = PTR_ERR((*lower_file));
 		goto out;
  int ecryptfs_privileged_open(struct file **lower_file,
 	mutex_unlock(&ecryptfs_kthread_ctl.mux);
 	wake_up(&ecryptfs_kthread_ctl.wait);
 	wait_for_completion(&req.done);
	if (IS_ERR(*lower_file)) {
 		rc = PTR_ERR(*lower_file);
		goto out;
	}
have_file:
	if ((*lower_file)->f_op->mmap == NULL) {
		fput(*lower_file);
		*lower_file = NULL;
		rc = -EMEDIUMTYPE;
	}
 out:
 	return rc;
 }","The ecryptfs_privileged_open function in fs/ecryptfs/kthread.c in the Linux kernel before 4.6.3 allows local users to gain privileges or cause a denial of service (stack memory consumption) via vectors involving crafted mmap calls for /proc pathnames, leading to recursive pagefault handling."
2069,CVE-2015-8952,"  struct ext2_block_alloc_info {
 #define rsv_start rsv_window._rsv_start
 #define rsv_end rsv_window._rsv_end
 
struct mb2_cache;

  
  struct ext2_sb_info {
 	 * of the mount options.
 	 */
 	spinlock_t s_lock;
	struct mb2_cache *s_mb_cache;
 };
 
 static inline spinlock_t *","The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba."
2070,CVE-2015-8952,"  struct ext4_sb_info {
 	struct list_head s_es_list;	 
 	long s_es_nr_inode;
 	struct ext4_es_stats s_es_stats;
	struct mb2_cache *s_mb_cache;
 	spinlock_t s_es_lock ____cacheline_aligned_in_smp;
 
 	 ","The mbcache feature in the ext2 and ext4 filesystem implementations in the Linux kernel before 4.6 mishandles xattr block caching, which allows local users to cause a denial of service (soft lockup) via filesystem operations in environments that use many attributes, as demonstrated by Ceph and Samba."
2071,CVE-2015-8852,"  http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,
 		 
 		q = r = p;
 		while (r < t.e) {
			if (!vct_iscrlf(r)) {
 				r++;
 				continue;
 			}
  http_splitline(struct worker *w, int fd, struct http *hp,
 
 	 
 	q = p;
	if (!vct_iscrlf(p)) {
		for (; !vct_iscrlf(p); p++)
 			if (!vct_issep(*p) && vct_isctl(*p))
 				return (400);
 	}","Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request."
2072,CVE-2015-8830,"  static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,
 				     unsigned long *nr_segs,
 				     size_t *len,
 				     struct iovec **iovec,
				     bool compat,
				     struct iov_iter *iter)
 {
 	ssize_t ret;
 
  static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,
 
 	 
 	*len = ret;
	iov_iter_init(iter, rw, *iovec, *nr_segs, *len);
 	return 0;
 }
 
 static ssize_t aio_setup_single_vector(struct kiocb *kiocb,
 				       int rw, char __user *buf,
 				       unsigned long *nr_segs,
 				       size_t len,
				       struct iovec *iovec,
				       struct iov_iter *iter)
 {
	if (len > MAX_RW_COUNT)
		len = MAX_RW_COUNT;
 	if (unlikely(!access_ok(!rw, buf, len)))
 		return -EFAULT;
 
 	iovec->iov_base = buf;
 	iovec->iov_len = len;
 	*nr_segs = 1;
	iov_iter_init(iter, rw, iovec, *nr_segs, len);
 	return 0;
 }
 
  static ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,
 
 		if (opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV)
 			ret = aio_setup_vectored_rw(req, rw, buf, &nr_segs,
						&len, &iovec, compat, &iter);
 		else
 			ret = aio_setup_single_vector(req, rw, buf, &nr_segs,
						  len, iovec, &iter);
 		if (!ret)
 			ret = rw_verify_area(rw, file, &req->ki_pos, len);
 		if (ret < 0) {
  static ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,
 			file_start_write(file);
 
 		if (iter_op) {
 			ret = iter_op(req, &iter);
 		} else {
			ret = rw_op(req, iter.iov, iter.nr_segs, req->ki_pos);
 		}
 
 		if (rw == WRITE)",Integer overflow in the aio_setup_single_vector function in fs/aio.c in the Linux kernel 4.0 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.  NOTE: this vulnerability exists because of a CVE-2012-6701 regression.
2073,CVE-2013-7456," 
 	downscaling using the fixed point implementations are usually much faster
 	than the existing gdImageCopyResampled while having a similar or better
 	quality.

	For image rotations, the optimized versions have a lazy antialiasing for
 	the edges of the images. For a much better antialiased result, the affine
 	function is recommended.
 */
  static inline int _color_blend (const int dst, const int src)
 	}
 }
 
static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)
 {
 	const gdFixed f_127 = gd_itofx(127);
 	register int c = src->tpixels[y][x];
  static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi
         double dTotalWeight = 0.0;
 		int iSrc;
 
          
         if (iRight - iLeft + 1 > windows_size)  {
             if (iLeft < ((int)src_size - 1 / 2))  {
  static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi
             }
         }
 
        res->ContribRow[u].Left = iLeft;
        res->ContribRow[u].Right = iRight;

         for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
             dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
         }
  int gdTransformAffineGetImage(gdImagePtr *dst,
 	if (!src->trueColor) {
 		gdImagePaletteToTrueColor(src);
 	}

 	 
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);
  int gdTransformAffineCopy(gdImagePtr dst,
 	if (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {
 		interpolation_id_bak = src->interpolation_id;
 		interpolation_bak = src->interpolation;

 		gdImageSetInterpolationMethod(src, GD_BICUBIC);
 	}
 ","gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function."
2074,CVE-2017-1000380,"  static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 
 	tu = file->private_data;
 	unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
	mutex_lock(&tu->ioctl_lock);
 	spin_lock_irq(&tu->qlock);
 	while ((long)count - result >= unit) {
 		while (!tu->qused) {
  static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 			add_wait_queue(&tu->qchange_sleep, &wait);
 
 			spin_unlock_irq(&tu->qlock);
			mutex_unlock(&tu->ioctl_lock);
 			schedule();
			mutex_lock(&tu->ioctl_lock);
 			spin_lock_irq(&tu->qlock);
 
 			remove_wait_queue(&tu->qchange_sleep, &wait);
  static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 		tu->qused--;
 		spin_unlock_irq(&tu->qlock);
 
 		if (tu->tread) {
 			if (copy_to_user(buffer, &tu->tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
  static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
 
 		spin_lock_irq(&tu->qlock);
 		if (err < 0)
  static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
 	}
  _error:
 	spin_unlock_irq(&tu->qlock);
	mutex_unlock(&tu->ioctl_lock);
 	return result > 0 ? result : err;
 }
 ","sound/core/timer.c in the Linux kernel before 4.11.5 is vulnerable to a data race in the ALSA /dev/snd/timer driver resulting in local users being able to read information belonging to other users, i.e., uninitialized memory contents may be disclosed when a read and an ioctl happen at the same time."
2075,CVE-2017-1000252,"  static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,
 	struct kvm_lapic_irq irq;
 	struct kvm_vcpu *vcpu;
 	struct vcpu_data vcpu_info;
	int idx, ret = 0;
 
 	if (!kvm_arch_has_assigned_device(kvm) ||
 		!irq_remapping_cap(IRQ_POSTING_CAP) ||
  static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
	if (guest_irq >= irq_rt->nr_rt_entries ||
	    hlist_empty(&irq_rt->map[guest_irq])) {
		pr_warn_once(""no route for guest_irq %u/%u (broken user space?)\n"",
			     guest_irq, irq_rt->nr_rt_entries);
		goto out;
	}
 
 	hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {
 		if (e->type != KVM_IRQ_ROUTING_MSI)","The KVM subsystem in the Linux kernel through 4.13.3 allows guest OS users to cause a denial of service (assertion failure, and hypervisor hang or crash) via an out-of bounds guest_irq value, related to arch/x86/kvm/vmx.c and virt/kvm/eventfd.c."
2076,CVE-2017-1000249," 
 #include ""file.h""
 
 #ifndef lint
FILE_RCSID(""@(#)$File: readelf.c,v 1.127 2015/11/18 12:29:29 christos Exp $"")
 #endif
 
 #ifdef BUILTIN_ELF
  do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,
     size_t noff, size_t doff, int *flags)
 {
 	if (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&
	    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {
 		uint8_t desc[20];
		const char *btype;
 		uint32_t i;
 		*flags |= FLAGS_DID_BUILD_ID;
		switch (descsz) {
		case 8:
		    btype = ""xxHash"";
		    break;
		case 16:
		    btype = ""md5/uuid"";
		    break;
		case 20:
		    btype = ""sha1"";
		    break;
		default:
		    btype = ""unknown"";
		    break;
		}
		if (file_printf(ms, "", BuildID[%s]="", btype) == -1)
 			return 1;
 		(void)memcpy(desc, &nbuf[doff], descsz);
 		for (i = 0; i < descsz; i++)",An issue in file() was introduced in commit 9611f31313a93aa036389c5f3b15eea53510d4d1 (Oct 2016) lets an attacker overwrite a fixed 20 bytes stack buffer with a specially crafted .notes section in an ELF binary. This was fixed in commit 35c94dc6acc418f1ad7f6241a6680e5327495793 (Aug 2017).
2077,CVE-2017-17499,"  void Magick::Image::read(MagickCore::Image *image,
       if (!quiet())
         throwExceptionExplicit(MagickCore::ImageWarning,
           ""No image was loaded."");
      return;
     }
   ThrowImageException;
 }",ImageMagick before 6.9.9-24 and 7.x before 7.0.7-12 has a use-after-free in Magick::Image::read in Magick++/lib/Image.cpp.
2078,CVE-2017-16546,"  static Image *ReadWPGImage(const ImageInfo *image_info,
               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                   (Rec2.RecordLength-2-2) / 3)
                 ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
              if (WPG_Palette.StartIndex > WPG_Palette.NumOfEntries)
                ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
               image->colors=WPG_Palette.NumOfEntries;
               if (!AcquireImageColormap(image,image->colors))
                 goto NoMemory;","The ReadWPGImage function in coders/wpg.c in ImageMagick 7.0.7-9 does not properly validate the colormap index in a WPG palette, which allows remote attackers to cause a denial of service (use of uninitialized data or invalid memory allocation) or possibly have unspecified other impact via a malformed WPG file."
2079,CVE-2017-16525,"  static struct console usbcons = {
 
 void usb_serial_console_disconnect(struct usb_serial *serial)
 {
	if (serial->port[0] && serial->port[0] == usbcons_info.port) {
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}","The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup."
2080,CVE-2017-16359,"  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || vstart + vdaux < vstart) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}","In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c."
2081,CVE-2017-16359,"  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
		size_t vstart_off = i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 		verdef->vd_aux = READ32 (dfs, j)
 		verdef->vd_next = READ32 (dfs, j)
 		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		vstart += vdaux;
		vstart_off += vdaux;
 		if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 			sdb_free (sdb_verdef);
 			goto out_error;
  static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
			vstart_off += aux.vda_next;
 			if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);","In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c."
2082,CVE-2017-15649,"  static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 
 	mutex_lock(&fanout_mutex);
 
 	err = -EALREADY;
 	if (po->fanout)
 		goto out;
  static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 		list_add(&match->list, &fanout_list);
 	}
 	err = -EINVAL;

	spin_lock(&po->bind_lock);
	if (po->running &&
	    match->type == type &&
 	    match->prot_hook.type == po->prot_hook.type &&
 	    match->prot_hook.dev == po->prot_hook.dev) {
 		err = -ENOSPC;
  static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
 			err = 0;
 		}
 	}
	spin_unlock(&po->bind_lock);

	if (err && !refcount_read(&match->sk_ref)) {
		list_del(&match->list);
		kfree(match);
	}

 out:
 	if (err && rollover) {
 		kfree(rollover);","net/packet/af_packet.c in the Linux kernel before 4.13.6 allows local users to gain privileges via crafted system calls that trigger mishandling of packet_fanout data structures, because of a race condition (involving fanout_add and packet_do_bind) that leads to a use-after-free, a different vulnerability than CVE-2017-6346."
2083,CVE-2017-14500,"  void pb_controller::play_file(const std::string& file) {
 	if (player == """")
 		return;
 	cmdline.append(player);
	cmdline.append("" \'"");
	cmdline.append(utils::replace_all(file,""'"", ""%27""));
	cmdline.append(""\'"");
 	stfl::reset();
 	LOG(LOG_DEBUG, ""pb_controller::play_file: running `%s'"", cmdline.c_str());
 	::system(cmdline.c_str());","Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904."
2084,CVE-2017-14174,"  static MagickBooleanType ReadPSDChannel(Image *image,
       if ((layer_info->channel_info[channel].type != -2) ||
           (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
            (IsStringTrue(option) == MagickFalse)))
        {
          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
          return(MagickTrue);
        }
       mask=CloneImage(image,layer_info->mask.page.width,
         layer_info->mask.page.height,MagickFalse,exception);
       if (mask != (Image *) NULL)
  static MagickBooleanType ReadPSDLayersInternal(Image *image,
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      layer blending ranges: length=%.20g"",(double)
                     ((MagickOffsetType) length));
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
               }
             /*
               Layer name.","In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large *length* field in the header but does not contain sufficient backing data, is provided, the loop over *length* would consume huge CPU resources, since there is no EOF check inside the loop."
2085,CVE-2017-13687,"  static const struct tok chdlc_cast_values[] = {
 u_int
 chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)
 {
	return chdlc_print(ndo, p, h->len);
 }
 
 u_int
 chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)
 {
 	u_int proto;
	const u_char *bp = p;
 
	if (length < CHDLC_HDRLEN)
		goto trunc;
	ND_TCHECK2(*p, CHDLC_HDRLEN);
 	proto = EXTRACT_16BITS(&p[2]);
 	if (ndo->ndo_eflag) {
                 ND_PRINT((ndo, ""%s, ethertype %s (0x%04x), length %u: "",
  chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)
 		break;
         case ETHERTYPE_ISO:
                  
                if (length < 2)
                    goto trunc;
                ND_TCHECK_16BITS(p);
                 if (*(p+1) == 0x81 ||
                     *(p+1) == 0x82 ||
                     *(p+1) == 0x83)
  chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)
 	}
 
 	return (CHDLC_HDRLEN);

trunc:
	ND_PRINT((ndo, ""[|chdlc]""));
	return ndo->ndo_snapend - bp;
 }
 
 /*",The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print().
2086,CVE-2017-13145,"  static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)
   opj_stream_destroy(jp2_stream);
   for (i=0; i < (ssize_t) jp2_image->numcomps; i++)
   {
    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||
        (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||
        (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||
        (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||
        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))
       {
         opj_destroy_codec(jp2_codec);
         opj_image_destroy(jp2_image);","In ImageMagick before 6.9.8-8 and 7.x before 7.0.5-9, the ReadJP2Image function in coders/jp2.c does not properly validate the channel geometry, leading to a crash."
2087,CVE-2017-13145,"  static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)
         (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||
         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||
         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||
        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||
        (jp2_image->comps[i].data == NULL))
       {
         opj_destroy_codec(jp2_codec);
         opj_image_destroy(jp2_image);","In ImageMagick before 6.9.8-8 and 7.x before 7.0.5-9, the ReadJP2Image function in coders/jp2.c does not properly validate the channel geometry, leading to a crash."
2088,CVE-2017-13142,"  static Image *ReadOneJNGImage(MngInfo *mng_info,
             c;
 
           c=ReadBlobByte(image);
          if (c == EOF)
            break;
           chunk[i]=(unsigned char) c;
         }
 
  static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,
                 c;
 
               c=ReadBlobByte(image);
              if (c == EOF)
                break;
               chunk[i]=(unsigned char) c;
             }
 ","In ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1, a crafted PNG file could trigger a crash because there was an insufficient check for short files."
2089,CVE-2017-13028,"  bootp_print(netdissect_options *ndo,
 	if (EXTRACT_16BITS(&bp->bp_secs))
 		ND_PRINT((ndo, "", secs %d"", EXTRACT_16BITS(&bp->bp_secs)));
 
	ND_TCHECK(bp->bp_flags);
 	ND_PRINT((ndo, "", Flags [%s]"",
 		  bittok2str(bootp_flag_values, ""none"", EXTRACT_16BITS(&bp->bp_flags))));
 	if (ndo->ndo_vflag > 1)",The BOOTP parser in tcpdump before 4.9.2 has a buffer over-read in print-bootp.c:bootp_print().
2090,CVE-2017-13004,"  juniper_parse_header(netdissect_options *ndo,
             if (ndo->ndo_eflag) ND_PRINT((ndo, "": ""));  
 
 
            ND_TCHECK_16BITS(p+l2info->cookie_len);
             l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);
             break;
         }",The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c:juniper_parse_header().
2091,CVE-2017-13000,"  static const char *ftypes[] = {
 	""Data"",				 
 	""ACK"",				 
 	""Command"",			 
	""Reserved (0x4)"",		 
	""Reserved (0x5)"",		 
	""Reserved (0x6)"",		 
	""Reserved (0x7)"",		 
 };
 
 
#define FC_FRAME_TYPE(fc)		((fc) & 0x7)
#define FC_SECURITY_ENABLED		0x0008
#define FC_FRAME_PENDING		0x0010
#define FC_ACK_REQUEST			0x0020
#define FC_PAN_ID_COMPRESSION		0x0040
#define FC_DEST_ADDRESSING_MODE(fc)	(((fc) >> 10) & 0x3)
#define FC_FRAME_VERSION(fc)		(((fc) >> 12) & 0x3)
#define FC_SRC_ADDRESSING_MODE(fc)	(((fc) >> 14) & 0x3)

#define FC_ADDRESSING_MODE_NONE		0x00
#define FC_ADDRESSING_MODE_RESERVED	0x01
#define FC_ADDRESSING_MODE_SHORT	0x02
#define FC_ADDRESSING_MODE_LONG		0x03
 
 u_int
 ieee802_15_4_if_print(netdissect_options *ndo,
                       const struct pcap_pkthdr *h, const u_char *p)
 {
 	u_int caplen = h->caplen;
	u_int hdrlen;
 	uint16_t fc;
 	uint8_t seq;
	uint16_t panid = 0;
 
 	if (caplen < 3) {
		ND_PRINT((ndo, ""[|802.15.4]""));
 		return caplen;
 	}
	hdrlen = 3;
 
 	fc = EXTRACT_LE_16BITS(p);
 	seq = EXTRACT_LE_8BITS(p + 2);
 
 	p += 3;
 	caplen -= 3;
 
	ND_PRINT((ndo,""IEEE 802.15.4 %s packet "", ftypes[FC_FRAME_TYPE(fc)]));
 	if (ndo->ndo_vflag)
 		ND_PRINT((ndo,""seq %02x "", seq));
 
	 
	switch (FC_DEST_ADDRESSING_MODE(fc)) {
	case FC_ADDRESSING_MODE_NONE:
		if (fc & FC_PAN_ID_COMPRESSION) {
			 
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
		}
		if (ndo->ndo_vflag)
 			ND_PRINT((ndo,""none ""));
		break;
	case FC_ADDRESSING_MODE_RESERVED:
		if (ndo->ndo_vflag)
 			ND_PRINT((ndo,""reserved destination addressing mode""));
		return hdrlen;
	case FC_ADDRESSING_MODE_SHORT:
		if (caplen < 2) {
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
		}
		panid = EXTRACT_LE_16BITS(p);
		p += 2;
		caplen -= 2;
		hdrlen += 2;
		if (caplen < 2) {
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
 		}
		if (ndo->ndo_vflag)
			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p + 2)));
		p += 2;
		caplen -= 2;
		hdrlen += 2;
		break;
	case FC_ADDRESSING_MODE_LONG:
		if (caplen < 2) {
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
		}
		panid = EXTRACT_LE_16BITS(p);
		p += 2;
		caplen -= 2;
		hdrlen += 2;
		if (caplen < 8) {
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
		}
		if (ndo->ndo_vflag)
			ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p + 2)));
		p += 8;
		caplen -= 8;
		hdrlen += 8;
		break;
	}
	if (ndo->ndo_vflag)
 		ND_PRINT((ndo,""< ""));
 
	 
	switch (FC_SRC_ADDRESSING_MODE(fc)) {
	case FC_ADDRESSING_MODE_NONE:
		if (ndo->ndo_vflag)
 			ND_PRINT((ndo,""none ""));
		break;
	case FC_ADDRESSING_MODE_RESERVED:
		if (ndo->ndo_vflag)
 			ND_PRINT((ndo,""reserved source addressing mode""));
		return 0;
	case FC_ADDRESSING_MODE_SHORT:
		if (!(fc & FC_PAN_ID_COMPRESSION)) {
			 
			if (caplen < 2) {
				ND_PRINT((ndo, ""[|802.15.4]""));
				return hdrlen;
 			}
			panid = EXTRACT_LE_16BITS(p);
 			p += 2;
			caplen -= 2;
			hdrlen += 2;
		}
		if (caplen < 2) {
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
		}
		if (ndo->ndo_vflag)
			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));
		p += 2;
		caplen -= 2;
		hdrlen += 2;
		break;
	case FC_ADDRESSING_MODE_LONG:
		if (!(fc & FC_PAN_ID_COMPRESSION)) {
			 
			if (caplen < 2) {
				ND_PRINT((ndo, ""[|802.15.4]""));
				return hdrlen;
 			}
			panid = EXTRACT_LE_16BITS(p);
			p += 2;
			caplen -= 2;
			hdrlen += 2;
 		}
		if (caplen < 8) {
			ND_PRINT((ndo, ""[|802.15.4]""));
			return hdrlen;
		}
		if (ndo->ndo_vflag)
			ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p)));
		p += 8;
		caplen -= 8;
		hdrlen += 8;
		break;
 	}
 
 	if (!ndo->ndo_suppress_default_print)
 		ND_DEFAULTPRINT(p, caplen);
 
	return hdrlen;
 }",The IEEE 802.15.4 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_15_4.c:ieee802_15_4_if_print().
2092,CVE-2017-13000,"  ieee802_15_4_if_print(netdissect_options *ndo,
 			return hdrlen;
 		}
 		if (ndo->ndo_vflag)
			ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p)));
 		p += 8;
 		caplen -= 8;
 		hdrlen += 8;",The IEEE 802.15.4 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_15_4.c:ieee802_15_4_if_print().
2093,CVE-2017-12987,"  parse_elements(netdissect_options *ndo,
 			offset += 3;
 			length -= 3;
 
			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);
 			offset += tim.length - 3;
 			length -= tim.length - 3;
 			/*",The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().
2094,CVE-2017-12899,"  decnet_print(netdissect_options *ndo,
 	    length -= padlen;
 	    caplen -= padlen;
 	    rhp = (const union routehdr *)&(ap[sizeof(short)]);
	    ND_TCHECK(rhp->rh_short.sh_flags);
 	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
 	}
 
  print_decnet_ctlmsg(netdissect_options *ndo,
                     register const union routehdr *rhp, u_int length,
                     u_int caplen)
 {
	 
 	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
 	register const union controlmsg *cmp = (const union controlmsg *)rhp;
 	int src, dst, info, blksize, eco, ueco, hello, other, vers;",The DECnet parser in tcpdump before 4.9.2 has a buffer over-read in print-decnet.c:decnet_print().
2095,CVE-2017-12896,"  isakmp_rfc3948_print(netdissect_options *ndo,
 		     const u_char *bp, u_int length,
 		     const u_char *bp2)
 {
	ND_TCHECK(bp[0]);
 	if(length == 1 && bp[0]==0xff) {
 		ND_PRINT((ndo, ""isakmp-nat-keep-alive""));
 		return;
  isakmp_rfc3948_print(netdissect_options *ndo,
 	if(length < 4) {
 		goto trunc;
 	}
	ND_TCHECK(bp[3]);
 
 	/*
 	 * see if this is an IKE packet",The ISAKMP parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:isakmp_rfc3948_print().
2096,CVE-2017-12843,"  static void cmdloop(void)
                 snmp_increment(SCAN_COUNT, 1);
             }
             else if (!strcmp(cmd.s, ""Syncapply"")) {
                if (!imapd_userisadmin) goto badcmd;

                 struct dlist *kl = sync_parseline(imapd_in);
 
                 if (kl) {
  static void cmdloop(void)
                 else goto extraargs;
             }
             else if (!strcmp(cmd.s, ""Syncget"")) {
                if (!imapd_userisadmin) goto badcmd;

                 struct dlist *kl = sync_parseline(imapd_in);
 
                 if (kl) {
  static void cmdloop(void)
                 else goto extraargs;
             }
             else if (!strcmp(cmd.s, ""Syncrestart"")) {
                if (!imapd_userisadmin) goto badcmd;

                 if (c == '\r') c = prot_getc(imapd_in);
                 if (c != '\n') goto extraargs;
 
                  
                 cmd_syncrestart(tag.s, &reserve_list, 1);
             }
             else if (!strcmp(cmd.s, ""Syncrestore"")) {
                if (!imapd_userisadmin) goto badcmd;

                 struct dlist *kl = sync_parseline(imapd_in);
 
                 if (kl) {","Cyrus IMAP before 3.0.3 allows remote authenticated users to write to arbitrary files via a crafted (1) SYNCAPPLY, (2) SYNCGET or (3) SYNCRESTORE command."
2097,CVE-2017-12190,"  struct bio *bio_map_user_iov(struct request_queue *q,
 	int ret, offset;
 	struct iov_iter i;
 	struct iovec iov;
	struct bio_vec *bvec;
 
 	iov_for_each(iov, i, *iter) {
 		unsigned long uaddr = (unsigned long) iov.iov_base;
  struct bio *bio_map_user_iov(struct request_queue *q,
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				(iter->type & WRITE) != WRITE,
 				&pages[cur_page]);
		if (unlikely(ret < local_nr_pages)) {
			for (j = cur_page; j < page_limit; j++) {
				if (!pages[j])
					break;
				put_page(pages[j]);
			}
 			ret = -EFAULT;
 			goto out_unmap;
 		}
  struct bio *bio_map_user_iov(struct request_queue *q,
 	return bio;
 
  out_unmap:
	bio_for_each_segment_all(bvec, bio, j) {
		put_page(bvec->bv_page);
 	}
  out:
 	kfree(pages);","The bio_map_user_iov and bio_unmap_user functions in block/bio.c in the Linux kernel before 4.13.8 do unbalanced refcounting when a SCSI I/O vector has small consecutive buffers belonging to the same page. The bio_add_pc_page function merges them into one, but the page reference is never dropped. This causes a memory leak and possible system lockup (exploitable against the host OS by a guest OS user, if a SCSI disk is passed through to a virtual machine) due to an out-of-memory condition."
2098,CVE-2017-11523,"  static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           break;
       }
     }
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
     (void) ReadBlobString(image,text);
     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
       {","The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered."
2099,CVE-2017-11472,"  AcpiNsTerminate (
     void)
 {
     ACPI_STATUS             Status;
    ACPI_OPERAND_OBJECT     *Prev;
    ACPI_OPERAND_OBJECT     *Next;
 
 
     ACPI_FUNCTION_TRACE (NsTerminate);
 
 
     
 
    Next = AcpiGbl_ModuleCodeList;
    while (Next)
    {
        Prev = Next;
        Next = Next->Method.Mutex;
        Prev->Method.Mutex = NULL;  
        AcpiUtRemoveReference (Prev);
     }
 
     /*
      * Free the entire namespace -- all nodes and all objects","The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."
2100,CVE-2017-11449,"  ModuleExport size_t RegisterMPCImage(void)
   entry=SetMagickInfo(""CACHE"");
   entry->description=ConstantString(""Magick Persistent Cache image format"");
   entry->module=ConstantString(""MPC"");
   entry->stealth=MagickTrue;
   (void) RegisterMagickInfo(entry);
   entry=SetMagickInfo(""MPC"");","coders/mpc.c in ImageMagick before 7.0.6-1 does not enable seekable streams and thus cannot validate blob sizes, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an image received from stdin."
2101,CVE-2017-9996,"  static int cdxl_decode_frame(AVCodecContext *avctx, void *data,
     c->padded_bits  = aligned_width - c->avctx->width;
     if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)
         return AVERROR_INVALIDDATA;
    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {
         avctx->pix_fmt = AV_PIX_FMT_PAL8;
     } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
         if (c->palette_size != (1 << (c->bpp - 1)))","The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
2102,CVE-2017-9995,"  static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigne
             break;
         c++;
     }
    if (x >= 16 || c >= 256) {
        return AVERROR_INVALIDDATA;
    }
 
     if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)
         return ret;","libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
2103,CVE-2017-9993,"  typedef struct HLSContext {
     char *http_proxy;                     
     AVDictionary *avio_opts;
     int strict_std_compliance;
    char *allowed_extensions;
 } HLSContext;
 
 static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)
  static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         return AVERROR_INVALIDDATA;
 
      
    if (av_strstart(proto_name, ""file"", NULL)) {
        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
            av_log(s, AV_LOG_ERROR,
                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
                url);
            return AVERROR_INVALIDDATA;
        }
    } else if (av_strstart(proto_name, ""http"", NULL)) {
        ;
    } else
         return AVERROR_INVALIDDATA;

     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')
         ;
     else if (av_strstart(url, ""crypto"", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')
  static int hls_probe(AVProbeData *p)
 static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };
 ","FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data."
2104,CVE-2017-9608,"  static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
                int remaining;
 
                 if (cid <= 0)
                     continue;
 
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                 }
                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 ","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file."
2105,CVE-2017-9608,"  static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
                 dctx->w = (state >> 32) & 0xFFFF;
             } else if (dctx->cur_byte == 42) {
                 int cid = (state >> 32) & 0xFFFFFFFF;
                int remaining;
 
                 if (cid <= 0)
                     continue;
 
                remaining = avpriv_dnxhd_get_frame_size(cid);
                if (remaining <= 0) {
                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (remaining <= 0)
                        continue;
                 }
                dctx->remaining = remaining;
                 if (buf_size - i + 47 >= dctx->remaining) {
                     int remaining = dctx->remaining;
 ","The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file."
2106,CVE-2017-9250,"  lexer_process_char_literal (parser_context_t *context_p,  
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
  if (length == 0)
  {
    has_escape = false;
  }

   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;","The lexer_process_char_literal function in jerry-core/parser/js/js-lexer.c in JerryScript 1.0 does not skip memory allocation for empty strings, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via malformed JavaScript source code, related to the jmem_heap_free_block function."
2107,CVE-2017-9226,"  fetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
         PUNFETCH;
         prev = p;
         num = scan_unsigned_octal_number(&p, end, 3, enc);
        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;
         if (p == prev) {   
           num = 0;  
         }
  fetch_token(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)
       if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {
         prev = p;
         num = scan_unsigned_octal_number(&p, end, (c == '0' ? 2:3), enc);
        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;
         if (p == prev) {   
           num = 0;  
         }","An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write or read occurs in next_state_val() during regular expression compilation. Octal numbers larger than 0xff are not handled correctly in fetch_token() and fetch_token_in_cc(). A malformed regular expression containing an octal number in the form of '700' would produce an invalid code point value larger than 0xff in next_state_val(), resulting in an out-of-bounds write memory corruption."
2108,CVE-2017-8797,"  nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,
 		struct nfsd4_getdeviceinfo *gdev)
 {
 	struct xdr_stream *xdr = &resp->xdr;
	const struct nfsd4_layout_ops *ops;
 	u32 starting_len = xdr->buf->len, needed_len;
 	__be32 *p;
 
  nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,
 
 	 
 	if (gdev->gd_maxcount != 0) {
		ops = nfsd4_layout_ops[gdev->gd_layout_type];
 		nfserr = ops->encode_getdeviceinfo(xdr, gdev);
 		if (nfserr) {
 			/*
  nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,
 		struct nfsd4_layoutget *lgp)
 {
 	struct xdr_stream *xdr = &resp->xdr;
	const struct nfsd4_layout_ops *ops;
 	__be32 *p;
 
 	dprintk(""%s: err %d\n"", __func__, nfserr);
  nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,
 	*p++ = cpu_to_be32(lgp->lg_seg.iomode);
 	*p++ = cpu_to_be32(lgp->lg_layout_type);
 
	ops = nfsd4_layout_ops[lgp->lg_layout_type];
 	nfserr = ops->encode_layoutget(xdr, lgp);
 out:
 	kfree(lgp->lg_content);","The NFSv4 server in the Linux kernel before 4.11.3 does not properly validate the layout type when processing the NFSv4 pNFS GETDEVICEINFO or LAYOUTGET operand in a UDP packet from a remote attacker. This type value is uninitialized upon encountering certain error conditions. This value is used as an array index for dereferencing, which leads to an OOPS and eventually a DoS of knfsd and a soft-lockup of the whole system."
2109,CVE-2017-7586," 
 #include ""sfendian.h""
 #include ""common.h""
 
#define	INITAL_HEADER_SIZE	256

 
SF_PRIVATE *
psf_allocate (void)
{	SF_PRIVATE * psf ;

	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
		return	NULL ;

	if ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)
	{	free (psf) ;
		return	NULL ;
		} ;
	psf->header.len = INITAL_HEADER_SIZE ;

	return psf ;
}  

static int
psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)
{
	sf_count_t newlen, smallest = INITAL_HEADER_SIZE ;
	void * ptr ;

	newlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;

	if (newlen > 100 * 1024)
	{	psf_log_printf (psf, ""Request for header allocation of %D denined.\n"", newlen) ;
		return 1 ;
		}

	if ((ptr = realloc (psf->header.ptr, newlen)) == NULL)
	{	psf_log_printf (psf, ""realloc (%p, %D) failed\n"", psf->header.ptr, newlen) ;
		psf->error = SFE_MALLOC_FAILED ;
		return 1 ;
		} ;

	psf->header.ptr = ptr ;
	psf->header.len = newlen ;
	return 0 ;
}  

  
 	start [maxlen - 1] = 0 ;
 
	psf->header.indx = strlen ((char*) psf->header.ptr) ;
 
 	return ;
 }  
  psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
 
 static inline void
 header_put_byte (SF_PRIVATE *psf, char x)
{	psf->header.ptr [psf->header.indx++] = x ;
 }  
 
 #if (CPU_IS_BIG_ENDIAN == 1)
 static inline void
 header_put_marker (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = (x >> 24) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = x ;
 }  
 
 #elif (CPU_IS_LITTLE_ENDIAN == 1)
 static inline void
 header_put_marker (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = x ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 24) ;
 }  
 
 #else
  header_put_marker (SF_PRIVATE *psf, int x)
 
 static inline void
 header_put_be_short (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = x ;
 }  
 
 static inline void
 header_put_le_short (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = x ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
 }  
 
 static inline void
 header_put_be_3byte (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = x ;
 }  
 
 static inline void
 header_put_le_3byte (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = x ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
 }  
 
 static inline void
 header_put_be_int (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = (x >> 24) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = x ;
 }  
 
 static inline void
 header_put_le_int (SF_PRIVATE *psf, int x)
{	psf->header.ptr [psf->header.indx++] = x ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 24) ;
 }  
 
#if (SIZEOF_SF_COUNT_T == 8)
 
 static inline void
 header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)
{	psf->header.ptr [psf->header.indx++] = (x >> 56) ;
	psf->header.ptr [psf->header.indx++] = (x >> 48) ;
	psf->header.ptr [psf->header.indx++] = (x >> 40) ;
	psf->header.ptr [psf->header.indx++] = (x >> 32) ;
	psf->header.ptr [psf->header.indx++] = (x >> 24) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = x ;
 }  
 
 static inline void
 header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	psf->header.ptr [psf->header.indx++] = x ;
	psf->header.ptr [psf->header.indx++] = (x >> 8) ;
	psf->header.ptr [psf->header.indx++] = (x >> 16) ;
	psf->header.ptr [psf->header.indx++] = (x >> 24) ;
	psf->header.ptr [psf->header.indx++] = (x >> 32) ;
	psf->header.ptr [psf->header.indx++] = (x >> 40) ;
	psf->header.ptr [psf->header.indx++] = (x >> 48) ;
	psf->header.ptr [psf->header.indx++] = (x >> 56) ;
 }  
 
 #else
#error ""SIZEOF_SF_COUNT_T != 8""
 #endif
 
 int
  psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
 	va_start (argptr, format) ;
 
 	while ((c = *format++))
	{
		if (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))
			return count ;

		switch (c)
 		{	case ' ' :  
 					break ;
 
  psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
 					 
 					floatdata = (float) va_arg (argptr, double) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
						float32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;
 					else
						float32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;
					psf->header.indx += 4 ;
 					count += 4 ;
 					break ;
 
 			case 'd' :
 					doubledata = va_arg (argptr, double) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
						double64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;
 					else
						double64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;
					psf->header.indx += 8 ;
 					count += 8 ;
 					break ;
 
  psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
 					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) + 1 ;
 					size += (size & 1) ;

					if (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))
						return count ;

 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						header_put_be_int (psf, size) ;
 					else
 						header_put_le_int (psf, size) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
					psf->header.indx += size ;
					psf->header.ptr [psf->header.indx - 1] = 0 ;
 					count += 4 + size ;
 					break ;
 
  psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
 					*/
 					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) ;
					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						header_put_be_int (psf, size) ;
 					else
 						header_put_le_int (psf, size) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;
 					size += (size & 1) ;
					psf->header.indx += size ;
					psf->header.ptr [psf->header.indx] = 0 ;
 					count += 4 + size ;
 					break ;
 
  psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
 					size = strlen (strptr) ;
 					size = (size & 1) ? size : size + 1 ;
 					size = (size > 254) ? 254 : size ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

 					header_put_byte (psf, size) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
					psf->header.indx += size ;
 					count += 1 + size ;
 					break ;
 
 			case 'b' :
 					bindata	= va_arg (argptr, void *) ;
 					size	= va_arg (argptr, size_t) ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

					memcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;
					psf->header.indx += size ;
					count += size ;
 					break ;
 
 			case 'z' :
 					size = va_arg (argptr, size_t) ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

 					count += size ;
 					while (size)
					{	psf->header.ptr [psf->header.indx] = 0 ;
						psf->header.indx ++ ;
 						size -- ;
 						} ;
 					break ;
 
 			case 'h' :
 					bindata = va_arg (argptr, void *) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;
					psf->header.indx += 16 ;
 					count += 16 ;
 					break ;
 
 			case 'j' :	 
 					size = va_arg (argptr, size_t) ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

					psf->header.indx += size ;
 					count += size ;
 					break ;
 
 			case 'o' :	 
 					size = va_arg (argptr, size_t) ;

					if ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

					psf->header.indx = size ;
 					break ;
 
 			default :
  static int
 header_read (SF_PRIVATE *psf, void *ptr, int bytes)
 {	int count = 0 ;
 
	if (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))
		return count ;
 
	if (psf->header.indx + bytes > psf->header.end)
	{	count = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;
		if (count != bytes - (int) (psf->header.end - psf->header.indx))
 		{	psf_log_printf (psf, ""Error : psf_fread returned short count.\n"") ;
 			return count ;
 			} ;
		psf->header.end += count ;
 		} ;
 
	memcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;
	psf->header.indx += bytes ;
 
 	return bytes ;
 }  
  header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)
 {
 	switch (whence)
 	{	case SEEK_SET :
			if (psf->header.indx + position >= psf->header.len)
				psf_bump_header_allocation (psf, position) ;
			if (position > psf->header.len)
 			{	 
 				psf_fseek (psf, position, whence) ;
 				return ;
 				} ;
			if (position > psf->header.end)
				psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;
			psf->header.indx = position ;
 			break ;
 
 		case SEEK_CUR :
			if (psf->header.indx + position >= psf->header.len)
				psf_bump_header_allocation (psf, position) ;

			if (psf->header.indx + position < 0)
 				break ;
 
			if (psf->header.indx >= psf->header.len)
 			{	psf_fseek (psf, position, whence) ;
 				return ;
 				} ;
 
			if (psf->header.indx + position <= psf->header.end)
			{	psf->header.indx += position ;
 				break ;
 				} ;
 
			if (psf->header.indx + position > psf->header.len)
 			{	 
				psf->header.indx = psf->header.end ;
 				psf_fseek (psf, position, SEEK_CUR) ;
 				break ;
 				} ;
 
			psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;
			psf->header.indx = psf->header.end ;
 			break ;
 
 		case SEEK_END :
  static int
 header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)
 {	int		k ;
 
	if (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))
		return 0 ;

 	for (k = 0 ; k < bufsize - 1 ; k++)
	{	if (psf->header.indx < psf->header.end)
		{	ptr [k] = psf->header.ptr [psf->header.indx] ;
			psf->header.indx ++ ;
 			}
 		else
		{	psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;
			ptr [k] = psf->header.ptr [psf->header.indx] ;
			psf->header.indx = psf->header.end ;
 			} ;
 
 		if (ptr [k] == '\n')
  psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)
 	float			*floatptr ;
 	double			*doubleptr ;
 	char			c ;
	int				byte_count = 0, count = 0 ;
 
 	if (! format)
 		return psf_ftell (psf) ;
 
 	va_start (argptr, format) ;
 
 	while ((c = *format++))
	{
		if (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))
			return count ;

		switch (c)
 		{	case 'e' :  
 					psf->rwf_endian = SF_ENDIAN_LITTLE ;
 					break ;
  psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)
 
 			case 'm' :  
 					intptr = va_arg (argptr, unsigned int*) ;
					*intptr = 0 ;
 					ucptr = (unsigned char*) intptr ;
 					byte_count += header_read (psf, ucptr, sizeof (int)) ;
 					*intptr = GET_MARKER (ucptr) ;
 					break ;
 
 			case 'h' :
 					intptr = va_arg (argptr, unsigned int*) ;
					*intptr = 0 ;
 					ucptr = (unsigned char*) intptr ;
 					byte_count += header_read (psf, sixteen_bytes, sizeof (sixteen_bytes)) ;
 					{	int k ;
  psf_binheader_readf (SF_PRIVATE *psf, char const *format, ...)
 					size  += (size & 1) ;
 					longdata = H2LE_32 (size) ;
 					get_int (psf, longdata) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
					psf->header.indx += size ;
 					*/
 					break ;
 
 			case 'b' :  
 					charptr = va_arg (argptr, char*) ;
 					count = va_arg (argptr, size_t) ;
					memset (charptr, 0, count) ;
					byte_count += header_read (psf, charptr, count) ;
 					break ;
 
 			case 'G' :
 					charptr = va_arg (argptr, char*) ;
 					count = va_arg (argptr, size_t) ;
					memset (charptr, 0, count) ;

					if (psf->header.indx + count >= psf->header.len && psf_bump_header_allocation (psf, count))
						return 0 ;

					byte_count += header_gets (psf, charptr, count) ;
 					break ;
 
 			case 'z' :
 					psf_log_printf (psf, ""Format conversion 'z' not implemented yet.\n"") ;
 					 
 					break ;
 
			case 'p' :	 
 					count = va_arg (argptr, size_t) ;
 					header_seek (psf, count, SEEK_SET) ;
 					byte_count = count ;
 					break ;
 
			case 'j' :	 
 					count = va_arg (argptr, size_t) ;
					header_seek (psf, count, SEEK_CUR) ;
					byte_count += count ;
 					break ;
 
 			default :","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."
2110,CVE-2017-7418," 
  * ProFTPD - FTP server daemon
  * Copyright (c) 1997, 1998 Public Flood Software
  * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
 * Copyright (c) 2001-2017 The ProFTPD Project team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  static char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
  int res, xerrno = 0;
  struct stat st;
  char *ptr;

  if (pathlen == 0) {
    return 0;
  }

  pr_fs_clear_cache();
  res = pr_fsio_lstat(path, &st);
  if (res < 0) {
    xerrno = errno;

    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
      strerror(xerrno));

    errno = xerrno;
    return -1;
  }
 
  if (S_ISLNK(st.st_mode)) {
    errno = EPERM;
    return -1;
  }

   

  ptr = strrchr(path, '/');
  if (ptr != NULL) {
    char *new_path;
    size_t new_pathlen;

    pr_signals_handle();

    new_pathlen = ptr - path;

     
    if (new_pathlen == pathlen) {
      return 0;
    }

    new_path = pstrndup(p, path, new_pathlen);

    pr_log_debug(DEBUG10,
      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
      new_path);
    res = is_symlink_path(p, new_path, new_pathlen);
    if (res < 0) {
      return -1;
    }
  }

  return 0;
}

 
 static int get_default_root(pool *p, int allow_symlinks, char **root) {
   config_rec *c = NULL;
   char *dir = NULL;
  static int get_default_root(pool *p, int allow_symlinks, char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
  static int get_default_root(pool *p, int allow_symlinks, char **root) {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }","ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user."
2111,CVE-2017-7418,"  static const char *get_default_chdir(pool *p, xaset_t *conf) {
   return dir;
 }
 
static int is_symlink_path(pool *p, const char *path, size_t pathlen) {
  int res, xerrno = 0;
  struct stat st;
  char *ptr;

  if (pathlen == 0) {
    return 0;
  }

  pr_fs_clear_cache2(path);
  res = pr_fsio_lstat(path, &st);
  if (res < 0) {
    xerrno = errno;

    pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
      strerror(xerrno));

    errno = xerrno;
    return -1;
  }

  if (S_ISLNK(st.st_mode)) {
    errno = EPERM;
    return -1;
  }

   

  ptr = strrchr(path, '/');
  if (ptr != NULL) {
    char *new_path;
    size_t new_pathlen;

    pr_signals_handle();

    new_pathlen = ptr - path;
    new_path = pstrndup(p, path, new_pathlen);

    pr_log_debug(DEBUG10,
      ""AllowChrootSymlink: path '%s' not a symlink, checking '%s'"", path,
      new_path);
    res = is_symlink_path(p, new_path, new_pathlen);
    if (res < 0) {
      return -1;
    }
  }

  return 0;
}

  
 static int get_default_root(pool *p, int allow_symlinks, const char **root) {
   config_rec *c = NULL;
  static int get_default_root(pool *p, int allow_symlinks, const char **root) {
 
       if (allow_symlinks == FALSE) {
         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
         size_t pathlen;
 
         /* First, deal with any possible interpolation.  dir_realpath() will
  static int get_default_root(pool *p, int allow_symlinks, const char **root) {
           path[pathlen-1] = '\0';
         }
 
        res = is_symlink_path(p, path, pathlen);
         if (res < 0) {
          if (errno == EPERM) {
            pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
              ""(denied by AllowChrootSymlinks config)"", path);
          }
 
           errno = EPERM;
           return -1;
         }","ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user."
2112,CVE-2017-7277,"  struct sock_exterr_skb {
 	struct sock_extended_err	ee;
 	u16				addr_offset;
 	__be16				port;
	u8				opt_stats:1,
					unused:7;
 };
 
 #endif","The TCP stack in the Linux kernel through 4.10.6 mishandles the SCM_TIMESTAMPING_OPT_STATS feature, which allows local users to obtain sensitive information from the kernel's internal socket data structures or cause a denial of service (out-of-bounds read) via crafted system calls, related to net/core/skbuff.c and net/socket.c."
2113,CVE-2017-7185,"  static int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {
   struct mbuf *io = &c->recv_mbuf;
   struct mg_http_proto_data *pd = mg_http_get_proto_data(c);
 
  if (pd->mp_stream.boundary == NULL) {
    pd->mp_stream.state = MPS_FINALIZE;
    DBG((""Invalid request: boundary not initilaized""));
    return 0;
  }

   if ((int) io->len < pd->mp_stream.boundary_len + 2) {
     return 0;
   }",Use-after-free vulnerability in the mg_http_multipart_wait_for_boundary function in mongoose.c in Cesanta Mongoose Embedded Web Server Library 6.7 and earlier and Mongoose OS 1.2 and earlier allows remote attackers to cause a denial of service (crash) via a multipart/form-data POST request without a MIME boundary string.
2114,CVE-2017-7184,"  static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_es
 	if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
 		return -EINVAL;
 
	if (up->replay_window > up->bmp_len * sizeof(__u32) * 8)
		return -EINVAL;

 	return 0;
 }
 ","The xfrm_replay_verify_len function in net/xfrm/xfrm_user.c in the Linux kernel through 4.10.6 does not validate certain size data after an XFRM_MSG_NEWAE update, which allows local users to obtain root privileges or cause a denial of service (heap-based out-of-bounds access) by leveraging the CAP_NET_ADMIN capability, as demonstrated during a Pwn2Own competition at CanSecWest 2017 for the Ubuntu 16.10 linux-image-* package 4.8.0.41.52."
2115,CVE-2017-6903,"  void Con_Dump_f (void)
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
	if (!COM_CompareExtension(filename, "".txt""))
	{
		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
		return;
	}

 	f = FS_FOpenFileWrite( filename );
 	if (!f)
 	{","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
2116,CVE-2017-6903,"  qboolean S_AL_Init( soundInterface_t *si )
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	 
 	if( !QAL_Init( s_alDriver->string ) )
 	{","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
2117,CVE-2017-6903,"  void Con_Dump_f( void ) {
 	Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );
 	COM_DefaultExtension( filename, sizeof( filename ), "".txt"" );
 
	if (!COM_CompareExtension(filename, "".txt""))
	{
		Com_Printf(""Con_Dump_f: Only the \"".txt\"" extension is supported by this command!\n"");
		return;
	}

 	f = FS_FOpenFileWrite( filename );
 	if ( !f ) {
 		Com_Printf (""ERROR: couldn't open %s.\n"", filename);","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
2118,CVE-2017-6903,"  qboolean S_AL_Init( soundInterface_t *si )
 	s_alRolloff = Cvar_Get( ""s_alRolloff"", ""2"", CVAR_CHEAT);
 	s_alGraceDistance = Cvar_Get(""s_alGraceDistance"", ""512"", CVAR_CHEAT);
 
	s_alDriver = Cvar_Get( ""s_alDriver"", ALDRIVER_DEFAULT, CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED );
 
 	s_alInputDevice = Cvar_Get( ""s_alInputDevice"", """", CVAR_ARCHIVE | CVAR_LATCH );
 	s_alDevice = Cvar_Get(""s_alDevice"", """", CVAR_ARCHIVE | CVAR_LATCH);
 
	if ( COM_CompareExtension( s_alDriver->string, "".pk3"" ) )
	{
		Com_Printf( ""Rejecting DLL named \""%s\"""", s_alDriver->string );
		return qfalse;
	}

 	 
 	if( !QAL_Init( s_alDriver->string ) )
  	{","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
2119,CVE-2017-6903,"  void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
  void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE );
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	 ","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
2120,CVE-2017-6903,"  void CL_InitRef( void ) {
 	Com_Printf( ""----- Initializing Renderer ----\n"" );
 
 #ifdef USE_RENDERER_DLOPEN
	cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);
 
 	Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string);
 
  void CL_Init( void ) {
 
 	cl_allowDownload = Cvar_Get (""cl_allowDownload"", ""0"", CVAR_ARCHIVE);
 #ifdef USE_CURL_DLOPEN
	cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);
 #endif
 
 	cl_conXOffset = Cvar_Get (""cl_conXOffset"", ""0"", 0);","In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape."
2121,CVE-2017-5940,"  void logmsg(const char *msg);
 void logargs(int argc, char **argv) ;
 void logerr(const char *msg);
 int copy_file(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);
void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);
void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);
 int is_dir(const char *fname);
 int is_link(const char *fname);
 char *line_remove_spaces(const char *buf);","Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."
2122,CVE-2017-5940,"  void logmsg(const char *msg);
 void logargs(int argc, char **argv) ;
 void logerr(const char *msg);
 int copy_file(const char *srcname, const char *destname);
void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode);
void touch_file_as_user(const char *fname, uid_t uid, gid_t gid, mode_t mode);
 int is_dir(const char *fname);
 int is_link(const char *fname);
 char *line_remove_spaces(const char *buf);","Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."
2123,CVE-2017-5511,"  ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
              
            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
             combined_length+=length+1;
             if (length > 0)
               (void) ReadBlob(image,(size_t) length++,layer_info[i].name);","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact by leveraging an improper cast, which triggers a heap-based buffer overflow."
2124,CVE-2017-5510,"  static size_t WritePSDChannel(const PSDInfo *psd_info,
     next_image->depth=16;
   monochrome=IsMonochromeImage(image,&image->exception) && (image->depth == 1)
     ? MagickTrue : MagickFalse;
  quantum_info=AcquireQuantumInfo(image_info,next_image);
   if (quantum_info == (QuantumInfo *) NULL)
     return(0);
   pixels=GetQuantumPixels(quantum_info);","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."
2125,CVE-2017-5509,"  static ssize_t WritePSDChannels(const PSDInfo *psd_info,
   compact_pixels=(unsigned char *) NULL;
   if (next_image->compression == RLECompression)
     {
      compact_pixels=AcquireCompactPixels(next_image);
       if (compact_pixels == (unsigned char *) NULL)
         return(0);
     }","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."
2126,CVE-2016-10156,"  int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi
         if (fd < 0)
                 return -errno;
 
        if (mode != MODE_INVALID) {
                 r = fchmod(fd, mode);
                 if (r < 0)
                         return -errno;
  int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi
 }
 
 int touch(const char *path) {
        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);
 }
 
 int symlink_idempotent(const char *from, const char *to) {","A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229."
2127,CVE-2016-10130,"  static int http_connect(http_subtransport *t)
 	if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&
 	    git_stream_is_encrypted(t->io)) {
 		git_cert *cert;
		int is_valid = (error == GIT_OK);
 
 		if ((error = git_stream_certificate(&cert, t->io)) < 0)
 			return error;
 
 		giterr_clear();
 		error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);
 
 		if (error < 0) {",The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.
2128,CVE-2016-10129,"  int git_pkt_parse_line(
 
 	line += PKT_LEN_SIZE;
 	 
 	if (len == PKT_LEN_SIZE) {
		giterr_set_str(GITERR_NET, ""Invalid empty packet"");
		return GIT_ERROR;
 	}
 
 	if (len == 0) {  ",The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.
2129,CVE-2016-10128,"  int git_pkt_parse_line(
 	if (bufflen > 0 && bufflen < (size_t)len)
 		return GIT_EBUFS;
 
	 
	if (len != 0 && len < PKT_LEN_SIZE)
		return GIT_ERROR;

 	line += PKT_LEN_SIZE;
 	/*
 	 * TODO: How do we deal with empty lines? Try again? with the next",Buffer overflow in the git_pkt_parse_line function in transports/smart_pkt.c in the Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to have unspecified impact via a crafted non-flush packet.
2130,CVE-2016-9933,"  BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border,
 	int i;
 	int restoreAlphaBleding;
 
	if (border < 0 || color < 0) {
 		 
 		return;
 	}
 
	if (!im->trueColor) {
		if ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1))) {
			return;
		}
    }

 	leftLimit = (-1);
 
 	restoreAlphaBleding = im->alphaBlendingFlag;","Stack consumption vulnerability in the gdImageFillToBorder function in gd.c in the GD Graphics Library (aka libgd) before 2.2.2, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (segmentation violation) via a crafted imagefilltoborder call that triggers use of a negative color value."
2131,CVE-2016-7530,"  int main( int  , char ** argv)
      
     appendImages( &appended, imageList.begin(), imageList.end(), true );
     if (( appended.signature() != ""d73d25ccd6011936d08b6d0d89183b7a61790544c2195269aff4db2f782ffc08"" ) &&
        ( appended.signature() != ""f3590c183018757da798613a23505ab9600b35935988eee12f096cb6219f2bc3"" ) &&
         ( appended.signature() != ""11b97ba6ac1664aa1c2faed4c86195472ae9cce2ed75402d975bb4ffcf1de751"" ) &&
         ( appended.signature() != ""cae4815eeb3cb689e73b94d897a9957d3414d1d4f513e8b5e52579b05d164bfe"" ))
       {",The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.
2132,CVE-2016-7530,"  MagickExport MagickBooleanType SetQuantumDepth(const Image *image,
     DestroyQuantumPixels(quantum_info);
   quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;
   extent=image->columns*quantum;
  if ((image->columns != 0) && (quantum != (extent/image->columns)))
     return(MagickFalse);
   return(AcquireQuantumPixels(quantum_info,extent));
 }",The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.
2133,CVE-2016-7526,"  static void InsertRow(unsigned char *p,ssize_t y,Image *image, int bpp)
         if (q == (PixelPacket *) NULL)
           break;
         indexes=GetAuthenticIndexQueue(image);
        for (x=0; x < ((ssize_t) image->columns-3); x+=4)
         {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);
             SetPixelIndex(indexes+x,index);
  static void InsertRow(unsigned char *p,ssize_t y,Image *image, int bpp)
             index=ConstrainColormapIndex(image,(*p) & 0x3);
             SetPixelIndex(indexes+x+1,index);
             SetPixelRGBO(q,image->colormap+(ssize_t) index);
             q++;
            p++;
         }
        if ((image->columns % 4) != 0)
           {
             index=ConstrainColormapIndex(image,(*p >> 6) & 0x3);
             SetPixelIndex(indexes+x,index);
             SetPixelRGBO(q,image->colormap+(ssize_t) index);
             q++;
            if ((image->columns % 4) > 1)
               {
                 index=ConstrainColormapIndex(image,(*p >> 4) & 0x3);
                 SetPixelIndex(indexes+x,index);
                 SetPixelRGBO(q,image->colormap+(ssize_t) index);
                 q++;
                if ((image->columns % 4) > 2)
                   {
                     index=ConstrainColormapIndex(image,(*p >> 2) & 0x3);
                     SetPixelIndex(indexes+x,index);
  static Image *ReadWPGImage(const ImageInfo *image_info,
                         AppendImageToList(&image,flip_image);
                       }
                     }
                   
                   if(BitmapHeader2.RotAngle & 0x0FFF)
                     {
                       Image
  static Image *ReadWPGImage(const ImageInfo *image_info,
               if (image->next == (Image *) NULL)
                 goto Finish;
               image=SyncNextImageInList(image);
              image->columns=image->rows=1;
               image->colors=0;
               break;
 
  static Image *ReadWPGImage(const ImageInfo *image_info,
                       }
 
                     if(BImgBuff)
                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                     break;
                   }
                 case 1:     ",coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds write) via a crafted file.
2134,CVE-2016-7514,"  static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)
           image->alpha_trait=UndefinedPixelTrait;
         }
     }
  if ((image->depth == 1) && (image->storage_class != PseudoClass))
    ThrowReaderException(CorruptImageError, ""ImproperImageHeader"");
   has_merged_image=MagickTrue;
   length=ReadBlobMSBLong(image);
   if (length != 0)",The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
2135,CVE-2016-7514,"  static inline void ReversePSDString(Image *image,char *p,size_t length)
   }
 }
 
static inline void SetPSDPixel(Image *image,const size_t channels,
  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,
  ExceptionInfo *exception)
{
  if (image->storage_class == PseudoClass)
    {
      if (packet_size == 1)
        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);
      else
        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);
      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);
      return;
    }
  switch (type)
  {
    case -1:
    {
      SetPixelAlpha(image, pixel,q);
      break;
    }
    case -2:
    case 0:
    {
      SetPixelRed(image,pixel,q);
      if (channels == 1 || type == -2)
        SetPixelGray(image,pixel,q);
      break;
    }
    case 1:
    {
      if (image->storage_class == PseudoClass)
        SetPixelAlpha(image,pixel,q);
      else
        SetPixelGreen(image,pixel,q);
      break;
    }
    case 2:
    {
      if (image->storage_class == PseudoClass)
        SetPixelAlpha(image,pixel,q);
      else
        SetPixelBlue(image,pixel,q);
      break;
    }
    case 3:
    {
      if (image->colorspace == CMYKColorspace)
        SetPixelBlack(image,pixel,q);
      else
        if (image->alpha_trait != UndefinedPixelTrait)
          SetPixelAlpha(image,pixel,q);
      break;
    }
    case 4:
    {
      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&
          (channels > 3))
        break;
      if (image->alpha_trait != UndefinedPixelTrait)
        SetPixelAlpha(image,pixel,q);
      break;
    }
  }
}

 static MagickBooleanType ReadPSDChannelPixels(Image *image,
   const size_t channels,const size_t row,const ssize_t type,
   const unsigned char *pixels,ExceptionInfo *exception)
  static MagickBooleanType ReadPSDChannelPixels(Image *image,
         p=PushShortPixel(MSBEndian,p,&nibble);
         pixel=ScaleShortToQuantum(nibble);
       }
    if (image->depth > 1)
       {
        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);
        q+=GetPixelChannels(image);
       }
    else
       {
        ssize_t
          bit,
          number_bits;
      
        number_bits=image->columns-x;
        if (number_bits > 8)
          number_bits=8;
        for (bit = 0; bit < number_bits; bit++)
        {
          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)
            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);
          q+=GetPixelChannels(image);
          x++;
        }
        if (x != image->columns)
          x--;
        continue;
       }
   }
   return(SyncAuthenticPixels(image,exception));
 }",The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
2136,CVE-2016-7514,"  static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,
   compact_pixels=(unsigned char *) NULL;
   if (next_image->compression == RLECompression)
     {
      compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*
        next_image->columns)+1,packet_size*sizeof(*compact_pixels));
       if (compact_pixels == (unsigned char *) NULL)
         ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
     }",The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.
2137,CVE-2016-7101,"  static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
     iris_info.minimum_value=ReadBlobMSBLong(image);
     iris_info.maximum_value=ReadBlobMSBLong(image);
     iris_info.sans=ReadBlobMSBLong(image);
    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)
       iris_info.name);
    if (count != sizeof(iris_info.name))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.name[sizeof(iris_info.name)-1]='\0';
     if (*iris_info.name != '\0')
       (void) SetImageProperty(image,""label"",iris_info.name,exception);
     iris_info.pixel_format=ReadBlobMSBLong(image);
     if (iris_info.pixel_format != 0)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);
    if (count != sizeof(iris_info.filler))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     image->columns=iris_info.columns;
     image->rows=iris_info.rows;
     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);
  static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
         image->storage_class=PseudoClass;
         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;
       }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageExtent(image,image->columns,image->rows,exception);",The SGI coder in ImageMagick before 7.0.2-10 allows remote attackers to cause a denial of service (out-of-bounds read) via a large row value in an sgi file.
2138,CVE-2016-6906,"  int read_image_tga( gdIOCtx *ctx, oTga *tga )
 		buffer_caret = 0;
 
 		while( bitmap_caret < image_block_size ) {

			if (buffer_caret + pixel_block_size > rle_size) {
				gdFree( decompression_buffer );
				gdFree( conversion_buffer );
				return -1;
			}

 			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
 				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;","The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file, related to the decompression buffer."
2139,CVE-2015-8959,"  static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,
       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) w * h * pixel_size;
        if (SeekBlob(image,offset,SEEK_CUR) < 0)
          break;
         w = DIV2(w);
         h = DIV2(h);
       }",coders/dds.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (CPU consumption) via a crafted DDS file.
2140,CVE-2015-8958,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
   size_t
     bytes_per_line,
     extent,
    height;
 
   ssize_t
     count,
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
     else
       if (image->storage_class == PseudoClass)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
             bytes_per_pixel++;
           if (bytes_per_line == 0)
             bytes_per_line=bytes_per_pixel*image->columns;
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);",coders/sun.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted SUN file.
2141,CVE-2015-8958,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
   size_t
     bytes_per_line,
     extent,
    height,
     length;
 
   ssize_t
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
     if (count != (ssize_t) sun_info.length)
       ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
    height=sun_info.height;
    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
        ((bytes_per_line/sun_info.depth) != sun_info.width))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    bytes_per_line+=15;
    bytes_per_line<<=1;
    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    bytes_per_line>>=4;
    sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
      bytes_per_line*sizeof(*sun_pixels));
    if (sun_pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     if (sun_info.type == RT_ENCODED)
      (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
        height);
    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
      ",coders/sun.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted SUN file.
2142,CVE-2015-8958,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
       return(DestroyImageList(image));
     if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=
         sun_info.length || !sun_info.length)
      ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
     number_pixels=(MagickSizeType) image->columns*image->rows;
     if ((sun_info.type != RT_ENCODED) && 
         ((number_pixels*sun_info.depth) > (8*sun_info.length)))
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
     height=sun_info.height;
     if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
         ((bytes_per_line/sun_info.depth) != sun_info.width))
      ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
     bytes_per_line+=15;
     bytes_per_line<<=1;
     if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))
      ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
     bytes_per_line>>=4;
     sun_pixels=(unsigned char *) AcquireQuantumMemory(height,
       bytes_per_line*sizeof(*sun_pixels));
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if (sun_info.type == RT_ENCODED)
       (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*
         height);
    else
      {
        if (sun_info.length > (height*bytes_per_line))
          ThrowReaderException(ResourceLimitError,""ImproperImageHeader"");
        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
      }
     sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
     /*
       Convert SUN raster image to pixel packets.",coders/sun.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted SUN file.
2143,CVE-2015-8957,"  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&
         ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    bytes_per_line=sun_info.width*sun_info.depth;
    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));
     if (sun_data == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
  static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
           Read run-length encoded raster pixels.
         */
         height=sun_info.height;
         if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
             ((bytes_per_line/sun_info.depth) != sun_info.width))
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");",Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.
2144,CVE-2015-8957,"  if (0)
             break;
           }
         }
        q[i]=ClampPixel(pixel);
       }
       p+=GetPixelChannels(composite_image);
       channels=GetPixelChannels(composite_image);",Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.
2145,CVE-2015-5232,"  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include ""hsm_config_srvr_api.h""
 
#define HSM_FM_SCK_PREFIX	""/opt/opafm/""
 #define HSM_FM_SCK_SM		""sm_""
 #define HSM_FM_SCK_PM		""pm_""
 #define HSM_FM_SCK_FE		""fe_""
 
 typedef struct	_fm_config_conx_hdl{
",Race conditions in opa-fm before 10.4.0.0.196 and opa-ff before 10.4.0.0.197.
2146,CVE-2015-4054,"  static bool check_client_passwd(PgSocket *client, const char *passwd)
 	const char *correct;
 	PgUser *user = client->auth_user;
 
	 
	if (!user) {
		slog_error(client, ""Password packet before auth packet?"");
		return false;
	}

 	 
 	if (!*passwd || !*user->passwd)
 		return false;",PgBouncer before 1.5.5 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) by sending a password packet before a startup packet.
2147,CVE-2015-3400,"  static int update_zfs_shares(sa_handle_impl_t impl_handle, const char *proto);
 static int fstypes_count;
 static sa_fstype_t *fstypes;
 
 
int
foreach_shareopt(const char *shareopts,
    nfs_shareopt_callback_t callback, void *cookie)
{
	char *shareopts_dup, *opt, *cur, *value;
	int was_nul, rc;

	if (shareopts == NULL)
		return (SA_OK);

	shareopts_dup = strdup(shareopts);
	if (shareopts_dup == NULL)
		return (SA_NO_MEMORY);

	opt = shareopts_dup;
	was_nul = 0;

	while (1) {
		cur = opt;

		while (*cur != ',' && *cur != '\0')
			cur++;

		if (*cur == '\0')
			was_nul = 1;

		*cur = '\0';

		if (cur > opt) {
			value = strchr(opt, '=');

			if (value != NULL) {
				*value = '\0';
				value++;
			}

			rc = callback(opt, value, cookie);

			if (rc != SA_OK) {
				free(shareopts_dup);
				return (rc);
			}
		}

		opt = cur + 1;

		if (was_nul)
			break;
	}

	free(shareopts_dup);

	return (SA_OK);
}

 sa_fstype_t *
 register_fstype(const char *name, const sa_share_ops_t *ops)
 {","sharenfs 0.6.4, when built with commits bcdd594 and 7d08880 from the zfs repository, provides world readable access to the shared zfs file system, which might allow remote authenticated users to obtain sensitive information by reading shared files."
2148,CVE-2015-3315,"  int main(int argc, char** argv)
     {
         char *rootdir = get_rootdir(pid);
 
        dd_create_basic_files(dd, fsuid, NULL);
 
         char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
         int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);","Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."
2149,CVE-2015-3315,"  static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
     return user_core_fd;
 }
 
static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
     FILE *fp = fopen(dest_filename, ""w"");
     if (!fp)
  static bool dump_fd_info(const char *dest_filename, char *source_filename, int s
         }
         fclose(in);
     }

    const int dest_fd = fileno(fp);
    if (fchown(dest_fd, uid, gid) < 0)
    {
        perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
        fclose(fp);
        unlink(dest_filename);
        return false;
    }

     fclose(fp);
     return true;
 }
  int main(int argc, char** argv)
 
          
          
         
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
 
         free(dest_filename);
 ","Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."
2150,CVE-2015-3315,"  static int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_valu
 
 static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
 {
    FILE *fp = fopen(dest_filename, ""wx"");
     if (!fp)
         return false;
 ","Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."
2151,CVE-2015-3215,"  tChecksumCheckResult ParaNdis_CheckRxChecksum(
                                             ULONG virtioFlags,
                                             tCompletePhysicalAddress *pPacketPages,
                                             ULONG ulPacketLength,
                                            ULONG ulDataOffset,
                                            BOOLEAN verifyLength)
 {
     tOffloadSettingsFlags f = pContext->Offload.flags;
     tChecksumCheckResult res;
  tChecksumCheckResult ParaNdis_CheckRxChecksum(
         }
     }
 
    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate,
        verifyLength, __FUNCTION__);
 
     if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)
     {","The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options."
2152,CVE-2015-1870," 
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include ""problem_api.h""
 #include ""libabrt.h""
 
  
  static int run_post_create(const char *dirname)
         error_msg(""Bad problem directory name '%s', should start with: '%s'"", dirname, g_settings_dump_location);
         return 400;  
     }
    if (g_settings_privatereports)
    {
        struct stat statbuf;
        if (lstat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))
        {
            error_msg(""Path '%s' isn't directory"", dirname);
            return 404;  
        }
         
        struct group *gr = getgrnam(""abrt"");
        if (!gr)
        {
            error_msg(""Group 'abrt' does not exist"");
            return 500;
        }
        if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)
        {
            error_msg(""Problem directory '%s' isn't owned by root:abrt or others are not restricted from access"", dirname);
            return 403;
        }
        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);
        const bool complete = dd && problem_dump_dir_is_complete(dd);
        dd_close(dd);
        if (complete)
        {
            error_msg(""Problem directory '%s' has already been processed"", dirname);
            return 403;
        }
    }
    else if (!dump_dir_accessible_by_uid(dirname, client_uid))
     {
         if (errno == ENOTDIR)
         {
  static int create_problem_dir(GHashTable *problem_info, unsigned pid)
      
    struct dump_dir *dd = dd_create(path, g_settings_privatereports ? 0 : client_uid, DEFAULT_DUMP_DIR_MODE);
     if (!dd)
     {
         error_msg_and_die(""Error creating problem directory '%s'"", path);","The event scripts in Automatic Bug Reporting Tool (ABRT) uses world-readable permission on a copy of sosreport file in problem directories, which allows local users to obtain sensitive information from /var/log/messages via unspecified vectors."
2153,CVE-2014-9907,"  static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)
   {
     if (n != 0)
       {
        if (EOFBlob(image) != MagickFalse)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)",coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.
2154,CVE-2014-9907,"  static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
    
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
     {
       w = DIV2(dds_info->width);
       h = DIV2(dds_info->height);
 
  static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,
    
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
     {
       w = DIV2(dds_info->width);
       h = DIV2(dds_info->height);
 ",coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.
2155,CVE-2010-5328,"  extern struct group_info init_groups;
 #define INIT_STRUCT_PID {						\
 	.count 		= ATOMIC_INIT(1),				\
 	.tasks		= {						\
		{ .first = NULL },					\
		{ .first = NULL },					\
		{ .first = NULL },					\
 	},								\
 	.level		= 0,						\
 	.numbers	= { {						\
  extern struct group_info init_groups;
 {								\
 	.node = {						\
 		.next = NULL,					\
		.pprev = NULL,					\
 	},							\
 	.pid = &init_struct_pid,				\
 }","include/linux/init_task.h in the Linux kernel before 2.6.35 does not prevent signals with a process group ID of zero from reaching the swapper process, which allows local users to cause a denial of service (system crash) by leveraging access to this process group."
2156,CVE-2010-5328,"  noinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_re
 	return regs;
 }
 
static inline void init_idle_pids(struct pid_link *links)
{
	enum pid_type type;

	for (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {
		INIT_HLIST_NODE(&links[type].node);  
		links[type].pid = &init_struct_pid;
	}
}

 struct task_struct * __cpuinit fork_idle(int cpu)
 {
 	struct task_struct *task;
 	struct pt_regs regs;
 
 	task = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,
 			    &init_struct_pid, 0);
	if (!IS_ERR(task)) {
		init_idle_pids(task->pids);
 		init_idle(task, cpu);
	}
 
 	return task;
 }","include/linux/init_task.h in the Linux kernel before 2.6.35 does not prevent signals with a process group ID of zero from reaching the swapper process, which allows local users to cause a denial of service (system crash) by leveraging access to this process group."
2157,CVE-2018-1000041,"  _rsvg_io_get_file_path (const gchar * filename,
 {
     gchar *absolute_filename;
 
    if (g_path_is_absolute (filename)) {
         absolute_filename = g_strdup (filename);
     } else {
         gchar *tmpcdir;",GNOME librsvg version before commit c6ddf2ed4d768fd88adbea2b63f575cd523022ea contains a Improper input validation vulnerability in rsvg-io.c that can result in the victim's Windows username and NTLM password hash being leaked to remote attackers through SMB. This attack appear to be exploitable via The victim must process a specially crafted SVG file containing an UNC path on Windows.
2158,CVE-2018-19045,"  set_umask(const char *optarg)
 
 	if (*endptr || umask_long < 0 || umask_long & ~0777L) {
 		fprintf(stderr, ""Invalid --umask option %s"", optarg);
		return 0;
 	}
 
 	umask_val = umask_long & 0777;","keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information."
2159,CVE-2018-18021,"  static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 	}
 
 	if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {
		u64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;
 		switch (mode) {
 		case PSR_AA32_MODE_USR:
			if (!system_supports_32bit_el0())
				return -EINVAL;
			break;
 		case PSR_AA32_MODE_FIQ:
 		case PSR_AA32_MODE_IRQ:
 		case PSR_AA32_MODE_SVC:
 		case PSR_AA32_MODE_ABT:
 		case PSR_AA32_MODE_UND:
			if (!vcpu_el1_is_32bit(vcpu))
				return -EINVAL;
			break;
 		case PSR_MODE_EL0t:
 		case PSR_MODE_EL1t:
 		case PSR_MODE_EL1h:
			if (vcpu_el1_is_32bit(vcpu))
				return -EINVAL;
 			break;
 		default:
 			err = -EINVAL;","arch/arm64/kvm/guest.c in KVM in the Linux kernel before 4.18.12 on the arm64 platform mishandles the KVM_SET_ON_REG ioctl. This is exploitable by attackers who can create virtual machines. An attacker can arbitrarily redirect the hypervisor flow of control (with full register control). An attacker can also cause a denial of service (hypervisor panic) via an illegal exception return. This occurs because of insufficient restrictions on userspace access to the core register file, and because PSTATE.M validation does not prevent unintended execution modes."
2160,CVE-2018-17456,"  static struct oidset gitmodules_done = OIDSET_INIT;
 	FUNC(GITMODULES_NAME, ERROR) \
 	FUNC(GITMODULES_SYMLINK, ERROR) \
 	FUNC(GITMODULES_URL, ERROR) \
	FUNC(GITMODULES_PATH, ERROR) \
 	  \
 	FUNC(BAD_FILEMODE, WARN) \
 	FUNC(EMPTY_NAME, WARN) \
  static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
 				    FSCK_MSG_GITMODULES_URL,
 				    ""disallowed submodule url: %s"",
 				    value);
	if (!strcmp(key, ""path"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_PATH,
				    ""disallowed submodule path: %s"",
				    value);
 	free(name);
 
 	return 0;","Git before 2.14.5, 2.15.x before 2.15.3, 2.16.x before 2.16.5, 2.17.x before 2.17.2, 2.18.x before 2.18.1, and 2.19.x before 2.19.1 allows remote code execution during processing of a recursive *git clone* of a superproject if a .gitmodules file has a URL field beginning with a '-' character."
2161,CVE-2018-16644,"  static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |
             ReadBlobLSBShort(image);
           length=(size_t) ReadBlobLSBLong(image);
          if (length > (size_t) GetBlobSize(image))
            ThrowDCMException(CorruptImageError,""InsufficientImageDataInFile"");
           if (tag == 0xFFFEE0DD)
             break;  
           if (tag != 0xFFFEE000)","There is a missing check for length in the functions ReadDCMImage of coders/dcm.c and ReadPICTImage of coders/pict.c in ImageMagick 7.0.8-11, which allows remote attackers to cause a denial of service via a crafted image."
2162,CVE-2018-14055,"  bool CConfig::Parse(CFile& file, CString& sErrorMsg) {
 void CConfig::Write(CFile& File, unsigned int iIndentation) {
     CString sIndentation = CString(iIndentation, '\t');
 
    auto SingleLine = [](const CString& s) {
        return s.Replace_n(""\r"", """").Replace_n(""\n"", """");
    };

     for (const auto& it : m_ConfigEntries) {
         for (const CString& sValue : it.second) {
            File.Write(SingleLine(sIndentation + it.first + "" = "" + sValue) +
                       ""\n"");
         }
     }
 
     for (const auto& it : m_SubConfigs) {
         for (const auto& it2 : it.second) {
             File.Write(""\n"");
 
            File.Write(SingleLine(sIndentation + ""<"" + it.first + "" "" +
                                  it2.first + "">"") +
                       ""\n"");
             it2.second.m_pSubConfig->Write(File, iIndentation + 1);
            File.Write(SingleLine(sIndentation + ""</"" + it.first + "">"") + ""\n"");
         }
     }
 }","ZNC before 1.7.1-rc1 does not properly validate untrusted lines coming from the network, allowing a non-admin user to escalate his privilege and inject rogue values into znc.conf."
2163,CVE-2018-11377,"  OPCODE_DESC opcodes[] = {
 
 static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {
 	OPCODE_DESC *opcode_desc;
	if (len < 2) {
		return NULL;
	}
 	ut16 ins = (buf[1] << 8) | buf[0];
 	int fail;
 	char *t;",The avr_op_analyze() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
2164,CVE-2018-11219," 
  
 
 ** h/H - signed/unsigned short
 ** l/L - signed/unsigned long
 ** T   - size_t
** i/In - signed/unsigned integer with size 'n' (default is size of int)
** cn - sequence of 'n' chars (from/to a string); when packing, n==0 means
         the whole string; when unpacking, n==0 means use the previous
         read number as the string length
 ** s - zero-terminated string
  typedef struct Header {
 } Header;
 
 
static int getnum (const char **fmt, int df) {
   if (!isdigit(**fmt))   
     return df;   
   else {
     int a = 0;
     do {
       a = a*10 + *((*fmt)++) - '0';
     } while (isdigit(**fmt));
     return a;
  static size_t optsize (lua_State *L, char opt, const char **fmt) {
     case 'f':  return sizeof(float);
     case 'd':  return sizeof(double);
     case 'x': return 1;
    case 'c': return getnum(fmt, 1);
     case 'i': case 'I': {
      int sz = getnum(fmt, sizeof(int));
       if (sz > MAXINTSIZE)
         luaL_error(L, ""integral size %d is larger than limit of %d"",
                        sz, MAXINTSIZE);
  static void controloptions (lua_State *L, int opt, const char **fmt,
     case '>': h->endian = BIG; return;
     case '<': h->endian = LITTLE; return;
     case '!': {
      int a = getnum(fmt, MAXALIGN);
       if (!isp2(a))
         luaL_error(L, ""alignment %d is not a power of 2"", a);
       h->align = a;
  static int b_unpack (lua_State *L) {
   size_t ld;
   const char *data = luaL_checklstring(L, 2, &ld);
   size_t pos = luaL_optinteger(L, 3, 1) - 1;
  int n = 0;   
   defaultoptions(&h);
   while (*fmt) {
     int opt = *fmt++;
     size_t size = optsize(L, opt, &fmt);
     pos += gettoalign(pos, &h, opt, size);
     luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
     
    luaL_checkstack(L, 2, ""too many results"");
     switch (opt) {
       case 'b': case 'B': case 'h': case 'H':
       case 'l': case 'L': case 'T': case 'i':  case 'I': {   
         int issigned = islower(opt);
         lua_Number res = getinteger(data+pos, h.endian, issigned, size);
        lua_pushnumber(L, res); n++;
         break;
       }
       case 'x': {
  static int b_unpack (lua_State *L) {
         float f;
         memcpy(&f, data+pos, size);
         correctbytes((char *)&f, sizeof(f), h.endian);
        lua_pushnumber(L, f); n++;
         break;
       }
       case 'd': {
         double d;
         memcpy(&d, data+pos, size);
         correctbytes((char *)&d, sizeof(d), h.endian);
        lua_pushnumber(L, d); n++;
         break;
       }
       case 'c': {
         if (size == 0) {
          if (n == 0 || !lua_isnumber(L, -1))
            luaL_error(L, ""format 'c0' needs a previous size"");
           size = lua_tonumber(L, -1);
          lua_pop(L, 1); n--;
          luaL_argcheck(L, size <= ld && pos <= ld - size,
                           2, ""data string too short"");
         }
        lua_pushlstring(L, data+pos, size); n++;
         break;
       }
       case 's': {
         const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
         if (e == NULL)
           luaL_error(L, ""unfinished string in data"");
         size = (e - (data+pos)) + 1;
        lua_pushlstring(L, data+pos, size - 1); n++;
         break;
       }
       default: controloptions(L, opt, &fmt, &h);
     }
     pos += size;
   }
  lua_pushinteger(L, pos + 1);   
  return n + 1;
 }
 
 
  LUALIB_API int luaopen_struct (lua_State *L) {
 
 
 /******************************************************************************
* Copyright (C) 2010-2018 Lua.org, PUC-Rio.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the","An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking."
2165,CVE-2018-11218,"  int mp_pack(lua_State *L) {
     if (nargs == 0)
         return luaL_argerror(L, 0, ""MessagePack pack needs input."");
 
    if (!lua_checkstack(L, nargs))
        return luaL_argerror(L, 0, ""Too many arguments for MessagePack pack."");

     buf = mp_buf_new(L);
     for(i = 1; i <= nargs; i++) {
         /* Copy argument i to top of stack for _encode processing;","Memory Corruption was discovered in the cmsgpack library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2 because of stack-based buffer overflows."
2166,CVE-2018-10887,"  int git_delta_apply(
 	*out = NULL;
 	*out_len = 0;
 
	 
 	if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {
 		giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
 		return -1;
  int git_delta_apply(
 	while (delta < delta_end) {
 		unsigned char cmd = *delta++;
 		if (cmd & 0x80) {
			 
 			size_t off = 0, len = 0;
 
 			if (cmd & 0x01) off = *delta++;
 			if (cmd & 0x02) off |= *delta++ << 8UL;
 			if (cmd & 0x04) off |= *delta++ << 16UL;
			if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);
 
 			if (cmd & 0x10) len = *delta++;
 			if (cmd & 0x20) len |= *delta++ << 8UL;
 			if (cmd & 0x40) len |= *delta++ << 16UL;
			if (!len)       len = 0x10000;
 
 			if (base_len < off + len || res_sz < len)
 				goto fail;
 			memcpy(res_dp, base + off, len);
 			res_dp += len;
 			res_sz -= len;
 
		} else if (cmd) {
			 
 			if (delta_end - delta < cmd || res_sz < cmd)
 				goto fail;
 			memcpy(res_dp, delta, cmd);
 			delta += cmd;
 			res_dp += cmd;
 			res_sz -= cmd;
 
		} else {
			 
 			goto fail;
 		}
 	}","A flaw was found in libgit2 before version 0.27.3. It has been discovered that an unexpected sign extension in git_delta_apply function in delta.c file may lead to an integer overflow which in turn leads to an out of bound read, allowing to read before the base object. An attacker may use this flaw to leak memory addresses or cause a Denial of Service."
2167,CVE-2018-9989,"  static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
     len = (*p)[0] << 8 | (*p)[1];
     *p += 2;
 
    if( (*p) > end - len )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                     ""(psk_identity_hint length)"" ) );","ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_psk_hint() that could cause a crash on invalid input."
2168,CVE-2018-9988,"  static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )
         sig_len = ( p[0] << 8 ) | p[1];
         p += 2;
 
        if( p != end - sig_len )
         {
             MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) );
             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,","ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input."
2169,CVE-2018-8098,"  static int read_entry(
 
 		GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);
 		GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);

		if (path_len > GIT_PATH_MAX)
			return index_error_invalid(""unreasonable path length"");

 		tmp_path = git__malloc(path_len);
 		GITERR_CHECK_ALLOC(tmp_path);
 ",Integer overflow in the index.c:read_entry() function while decompressing a compressed prefix length in libgit2 before v0.26.2 allows an attacker to cause a denial of service (out-of-bounds read) via a crafted repository index file.
2170,CVE-2017-18174,"  static int amd_gpio_probe(struct platform_device *pdev)
 	gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);
 
 	amd_pinctrl_desc.name = dev_name(&pdev->dev);
	gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
						gpio_dev);
 	if (IS_ERR(gpio_dev->pctrl)) {
 		dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n"");
 		return PTR_ERR(gpio_dev->pctrl);
 	}
 
 	ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);
 	if (ret)
		return ret;
 
 	ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),
 				0, 0, TOTAL_NUMBER_OF_PINS);
  static int amd_gpio_probe(struct platform_device *pdev)
 out2:
 	gpiochip_remove(&gpio_dev->gc);
 
 	return ret;
 }
 
  static int amd_gpio_remove(struct platform_device *pdev)
 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
 
 	return 0;
 }","In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free."
2171,CVE-2017-7562,"  crypto_retrieve_X509_sans(krb5_context context,
 
     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
         pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
         goto cleanup;
     }
     num_sans = sk_GENERAL_NAME_num(ialt);
  crypto_retrieve_X509_sans(krb5_context context,
     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
 
     retval = 0;
    if (princs != NULL && *princs != NULL) {
         *princs_ret = princs;
        princs = NULL;
    }
    if (upns != NULL && *upns != NULL) {
         *upn_ret = upns;
        upns = NULL;
    }
    if (dnss != NULL && *dnss != NULL) {
         *dns_ret = dnss;
        dnss = NULL;
    }
 
 cleanup:
    for (i = 0; princs != NULL && princs[i] != NULL; i++)
        krb5_free_principal(context, princs[i]);
    free(princs);
    for (i = 0; upns != NULL && upns[i] != NULL; i++)
        krb5_free_principal(context, upns[i]);
    free(upns);
    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
        free(dnss[i]);
    free(dnss);
     return retval;
 }
 ",An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.
2172,CVE-2017-7500,"  static int fsmUtime(const char *path, mode_t mode, time_t mtime)
     return rc;
 }
 
static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)
 {
     int rc;
     int saveerrno = errno;
  static int fsmVerify(const char *path, rpmfi fi)
     } else if (S_ISDIR(mode)) {
         if (S_ISDIR(dsb.st_mode)) return 0;
         if (S_ISLNK(dsb.st_mode)) {
	    uid_t luid = dsb.st_uid;
             rc = fsmStat(path, 0, &dsb);
             if (rc == RPMERR_ENOENT) rc = 0;
             if (rc) return rc;
             errno = saveerrno;
	     
            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))
		    return 0;
         }
     } else if (S_ISLNK(mode)) {
         if (S_ISLNK(dsb.st_mode)) {
  int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,
 	    }
 	     
 	    if (!suffix) {
		rc = fsmVerify(fpath, fi, &sb);
 	    } else {
 		rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;
 	    }","It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege."
2173,CVE-2019-1010251,"  AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,
             (direction & STREAM_TOSERVER) ? ""toserver"" : ""toclient"");
 
     AppProto alproto = ALPROTO_UNKNOWN;
    AppProto pm_alproto = ALPROTO_UNKNOWN;
 
     if (!FLOW_IS_PM_DONE(f, direction)) {
         AppProto pm_results[ALPROTO_MAX];
  AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,
                                                    pm_results);
         if (pm_matches > 0) {
             alproto = pm_results[0];

             
            if (!(ipproto == IPPROTO_UDP && alproto == ALPROTO_DCERPC))
                goto end;

            pm_alproto = alproto;

             
         }
     }
 
  AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,
     }
 
  end:
    if (alproto == ALPROTO_UNKNOWN)
        alproto = pm_alproto;

     SCReturnUInt(alproto);
 }
 ","Open Information Security Foundation Suricata prior to version 4.1.2 is affected by: Denial of Service - DNS detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed network packet. The component is: app-layer-detect-proto.c, decode.c, decode-teredo.c and decode-ipv6.c (https://github.com/OISF/suricata/pull/3590/commits/11f3659f64a4e42e90cb3c09fcef66894205aefe, https://github.com/OISF/suricata/pull/3590/commits/8357ef3f8ffc7d99ef6571350724160de356158b). The attack vector is: An attacker can trigger the vulnerability by sending a specifically crafted network request. The fixed version is: 4.1.2."
2174,CVE-2019-16718,"  static char *__filterQuotedShell(const char *arg) {
 		switch (*arg) {
 		case ' ':
 		case '=':
		case '""':
		case '\\':
 		case '\r':
 		case '\n':
 			break;
  static char *__filterShell(const char *arg) {
 	}
 	char *b = a;
 	while (*arg) {
		char ch = *arg;
		switch (ch) {
 		case '@':
 		case '`':
 		case '|':
 		case ';':
		case '=':
 		case '\n':
 			break;
 		default:
			*b++ = ch;
 			break;
 		}
 		arg++;
  static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const ch
 						char *m = __filterShell (module);
 						*p = 0;
 						if (r->bin->prefix) {
							r_cons_printf (""\""k bin/pe/%s/%d=%s.%s\""\n"",
 								module, symbol->ordinal, r->bin->prefix, symname);
 						} else {
							r_cons_printf (""\""k bin/pe/%s/%d=%s\""\n"",
 								module, symbol->ordinal, symname);
 						}
 						free (symname);","In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables."
2175,CVE-2019-15165,"  struct option_header {
  * Section Header Block.
  */
 #define BT_SHB			0x0A0D0D0A
#define BT_SHB_INSANE_MAX       1024*1024*1   
 struct section_header_block {
 	bpf_u_int32	byte_order_magic;
 	u_short		major_version;
  read_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,
 			if (amt_read == 0 && !fail_on_eof)
 				return (0);	 
 			pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
			    ""truncated pcapng dump file; tried to read %"" PRIsize "" bytes, only got %"" PRIsize,
 			    bytes_to_read, amt_read);
 		}
 		return (-1);
  pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
 	 
	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
            (total_length > BT_SHB_INSANE_MAX)) {
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
		    ""Section Header Block in pcapng dump file has invalid length %"" PRIsize "" < _%lu_ < %lu (BT_SHB_INSANE_MAX)"",
                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
                              total_length,
                              BT_SHB_INSANE_MAX);
 
 		*err = 1;
 		return (NULL);
 	}
 


 	/*
 	 * OK, this is a good pcapng file.
 	 * Allocate a pcap_t for it.",sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.
2176,CVE-2019-14981,"  MagickExport Image *MeanShiftImage(const Image *image,const size_t width,
               }
           }
         }
        gamma=PerceptibleReciprocal(count);
         mean_location.x=gamma*sum_location.x;
         mean_location.y=gamma*sum_location.y;
         mean_pixel.red=gamma*sum_pixel.red;","In ImageMagick 7.x before 7.0.8-41 and 6.x before 6.9.10-41, there is a divide-by-zero vulnerability in the MeanShiftImage function. It allows an attacker to cause a denial of service by sending a crafted file."
2177,CVE-2019-14980,"  MagickExport void *DetachBlob(BlobInfo *blob_info)
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;","In ImageMagick 7.x before 7.0.8-42 and 6.x before 6.9.10-42, there is a use after free vulnerability in the UnmapBlob function that allows an attacker to cause a denial of service by sending a crafted file."
2178,CVE-2019-14763,"  static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
 	req->complete = f_hidg_req_complete;
 	req->context  = hidg;
 
	spin_unlock_irqrestore(&hidg->write_spinlock, flags);

 	status = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);
 	if (status < 0) {
 		ERROR(hidg->func.config->cdev,
 			""usb_ep_queue error on int endpoint %zd\n"", status);
		goto release_write_pending;
 	} else {
 		status = count;
 	}
 
 	return status;
 release_write_pending:
 	spin_lock_irqsave(&hidg->write_spinlock, flags);
 	hidg->write_pending = 0;
 	spin_unlock_irqrestore(&hidg->write_spinlock, flags);
 ","In the Linux kernel before 4.16.4, a double-locking error in drivers/usb/dwc3/gadget.c may potentially cause a deadlock with f_hid."
2179,CVE-2019-14452," 
 /************************************************************************
 **
**  Copyright (C) 2019   Kevin B. Hendricks, Stratford, Ontario Canada
 **  Copyright (C) 2009, 2010, 2011  Strahinja Markovic  <strahinja.markovic@gmail.com>
 **
 **  This file is part of Sigil.
  bool Utility::UnZip(const QString &zippath, const QString &destpath)
 
              
             if (!qfile_name.isEmpty()) {

	         
	         
	         
	         
	         
	         

	        QString original_path = qfile_name;
	        bool evil_or_corrupt_epub = false;

	        if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true; 
	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");

	        if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        qfile_name = qfile_name.replace(""/../"",""/"");

	        while(qfile_name.startsWith(""/"")) { 
		  qfile_name = qfile_name.remove(0,1);
	        }
                
	        if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true; 
	        cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");

	        if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");

	        while(cp437_file_name.startsWith(""/"")) { 
		  cp437_file_name = cp437_file_name.remove(0,1);
	        }

	        if (evil_or_corrupt_epub) {
		    unzCloseCurrentFile(zfile);
		    unzClose(zfile);
		     
                    return false;
	        }

                  
                  
                  ","Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction."
2180,CVE-2019-14452,"  void ImportEPUB::ExtractContainer()
              
             if (!qfile_name.isEmpty()) {
 
	         
                 
                 
                 
                 
                 

	        QString original_path = qfile_name;
	        bool evil_or_corrupt_epub = false;

                if (qfile_name.contains(""\\"")) evil_or_corrupt_epub = true; 
	        qfile_name = ""/"" + qfile_name.replace(""\\"","""");

                if (qfile_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        qfile_name = qfile_name.replace(""/../"",""/"");

                while(qfile_name.startsWith(""/"")) { 
		    qfile_name = qfile_name.remove(0,1);
		}

                if (cp437_file_name.contains(""\\"")) evil_or_corrupt_epub = true; 
                cp437_file_name = ""/"" + cp437_file_name.replace(""\\"","""");

                if (cp437_file_name.contains(""/../"")) evil_or_corrupt_epub = true;
	        cp437_file_name = cp437_file_name.replace(""/../"",""/"");

                while(cp437_file_name.startsWith(""/"")) { 
		    cp437_file_name = cp437_file_name.remove(0,1);
		}

                if (evil_or_corrupt_epub) {
                    unzCloseCurrentFile(zfile);
                    unzClose(zfile);
                    throw (EPUBLoadParseError(QString(QObject::tr(""Possible evil or corrupt epub file name: %1"")).arg(original_path).toStdString()));
                }
 
                  
                  ","Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction."
2181,CVE-2019-13615,"  EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSe
         memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex);
       }
 
      if (MaxDataSize <= ReadSize)
        break;
       if (DataStream.read(&PossibleIdNSize[ReadIndex++], 1) == 0) {
         return NULL;  
       }
       ReadSize++;
 
    } while (!bFound);
 
     if (!bFound)
        
  EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSe
         bFound = false;
         break;
       }
      if (MaxDataSize <= ReadSize) {
        bFound = false;
        break;
      }
       if( DataStream.read( &PossibleIdNSize[SizeIdx++], 1 ) == 0 ) {
         return NULL;  
       }","libebml before 1.3.6, as used in the MKV module in VideoLAN VLC Media Player binaries before 3.0.3, has a heap-based buffer over-read in EbmlElement::FindNextElement."
2182,CVE-2019-13454,"  MagickExport void OptimizeImageTransparency(const Image *image,
 %    o exception: return any errors or warnings in this structure.
 %
 */
MagickExport void RemoveDuplicateLayers(Image **images,ExceptionInfo *exception)
 {
   RectangleInfo
     bounds;
 
  register Image
    *image,
    *next;

   assert((*images) != (const Image *) NULL);
   assert((*images)->signature == MagickCoreSignature);
   if ((*images)->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      (*images)->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
  image=GetFirstImageInList(*images);
  for ( ; (next=GetNextImageInList(image)) != (Image *) NULL; image=next)
   {
    if ((image->columns != next->columns) || (image->rows != next->rows) ||
        (image->page.x != next->page.x) || (image->page.y != next->page.y))
       continue;
    bounds=CompareImagesBounds(image,next,CompareAnyLayer,exception);
    if (bounds.x < 0)
      {
         
        size_t
          time;

        time=1000*image->delay*PerceptibleReciprocal(image->ticks_per_second);
        time+=1000*next->delay*PerceptibleReciprocal(next->ticks_per_second);
        next->ticks_per_second=100L;
        next->delay=time*image->ticks_per_second/1000;
        next->iterations=image->iterations;
        *images=image;
        (void) DeleteImageFromList(images);
      }
   }
  *images=GetFirstImageInList(*images);
 }
 
 /*",ImageMagick 7.0.8-54 Q16 allows Division by Zero in RemoveDuplicateLayers in MagickCore/layer.c.
2183,CVE-2019-13391,"  MagickExport MagickBooleanType AnnotateImage(Image *image,
     {
       annotate_info=DestroyDrawInfo(annotate_info);
       annotate=DestroyDrawInfo(annotate);
      text=DestroyString(text);
       return(MagickFalse);
     }
   p=text;
  MagickExport MagickBooleanType AnnotateImage(Image *image,
       annotate_info=DestroyDrawInfo(annotate_info);
       annotate=DestroyDrawInfo(annotate);
       textlist=(char **) RelinquishMagickMemory(textlist);
      text=DestroyString(text);
       return(MagickFalse);
     }
   if (IsGrayColorspace(image->colorspace) != MagickFalse)
  MagickExport MagickBooleanType AnnotateImage(Image *image,
   annotate_info=DestroyDrawInfo(annotate_info);
   annotate=DestroyDrawInfo(annotate);
   textlist=(char **) RelinquishMagickMemory(textlist);
  text=DestroyString(text);
   return(status);
 }
 ","In ImageMagick 7.0.8-50 Q16, ComplexImages in MagickCore/fourier.c has a heap-based buffer over-read because of incorrect calls to GetCacheViewVirtualPixels."
2184,CVE-2019-13311,"  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             clut_image=RemoveFirstImageFromList(images);
             if (clut_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             reconstruct_image=RemoveFirstImageFromList(images);
             if (reconstruct_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             new_images=RemoveFirstImageFromList(images);
             source_image=RemoveFirstImageFromList(images);
             if (source_image == (Image *) NULL)
              {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                new_images=DestroyImage(new_images);
                status=MagickFalse;
                break;
              }
 
              
             if (source_image->geometry != (char *) NULL)
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             hald_image=RemoveFirstImageFromList(images);
             if (hald_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                image=DestroyImage(image);
                 status=MagickFalse;
                 break;
               }
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             phase_image=RemoveFirstImageFromList(images);
             if (phase_image == (Image *) NULL)
               {
                (void) ThrowMagickException(exception,GetMagickModule(),
                  OptionError,""ImageSequenceRequired"",""`%s'"",option);
                magnitude_image=DestroyImage(magnitude_image);
                 status=MagickFalse;
                 break;
               }
             fourier_image=InverseFourierTransformImage(magnitude_image,
               phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);
            magnitude_image=DestroyImage(magnitude_image);
            phase_image=DestroyImage(phase_image);
             if (fourier_image == (Image *) NULL)
               break;
             if (*images != (Image *) NULL)",ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of a wand/mogrify.c error.
2185,CVE-2019-13310,"  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
               &distortion,exception);
             if (difference_image == (Image *) NULL)
               break;
            reconstruct_image=DestroyImage(reconstruct_image);
            image=DestroyImage(image);
             if (*images != (Image *) NULL)
               *images=DestroyImageList(*images);
             *images=difference_image;
  WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
                    q=GetImageFromList(*images,index-1);
                    if (q == (Image *) NULL)
                      {
                       p=DestroyImage(p);
                        (void) ThrowMagickException(exception,GetMagickModule(),
                          OptionError,""NoSuchImage"",""`%s'"",argv[i+1]);
                        status=MagickFalse;",ImageMagick 7.0.8-50 Q16 has memory leaks at AcquireMagickMemory because of an error in MagickWand/mogrify.c.
2186,CVE-2019-13308,"  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
   progress=0;
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(progress,status) \
    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)
 #endif
  for (y=0; y < (ssize_t) Cr_image->rows; y++)
   {
     register const Quantum
       *magick_restrict Ai,
  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
 
     if (status == MagickFalse)
       continue;
    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);
    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);
    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);
    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);
     Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);
     Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);
     if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || 
  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
         status=MagickFalse;
         continue;
       }
    for (x=0; x < (ssize_t) Cr_image->columns; x++)
     {
       register ssize_t
         i;
 
      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)
       {
         switch (op)
         {
  MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
             double
               gamma;
 
            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);
            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);
            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);
             break;
           }
           case MagnitudePhaseComplexOperator:
           {
            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);
            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;
             break;
           }
           case MultiplyComplexOperator:
           {
            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);
            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);
             break;
           }
           case RealImaginaryComplexOperator:",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow in MagickCore/fourier.c in ComplexImage.
2187,CVE-2019-13307,"  static PixelChannels **AcquirePixelThreadSet(const Image *images)
 
   size_t
     columns,
    rows;
 
  rows=MagickMax(GetImageListLength(images),
    (size_t) GetMagickResourceLimit(ThreadResource));
  pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels));
   if (pixels == (PixelChannels **) NULL)
     return((PixelChannels **) NULL);
  columns=MaxPixelChannels;
   for (next=images; next != (Image *) NULL; next=next->next)
     columns=MagickMax(next->columns,columns);
  for (i=0; i < (ssize_t) rows; i++)
   {
     register ssize_t
       j;",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling rows.
2188,CVE-2019-13306,"  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
             extent=(size_t) count;
             (void) strncpy((char *) q,buffer,extent);
             q+=extent;
            if ((q-pixels+extent+2) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
             extent=(size_t) count;
             (void) strncpy((char *) q,buffer,extent);
             q+=extent;
            if ((q-pixels+extent+2) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of off-by-one errors.
2189,CVE-2019-13305,"  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,
                   ""%u "",ScaleQuantumToLong(index));
             extent=(size_t) count;
            if ((q-pixels+extent+1) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
            (void) strncpy((char *) q,buffer,extent);
            q+=extent;
             p+=GetPixelChannels(image);
           }
           *q++='\n';
  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,
                   ScaleQuantumToLong(GetPixelGreen(image,p)),
                   ScaleQuantumToLong(GetPixelBlue(image,p)));
             extent=(size_t) count;
             if ((q-pixels+extent+2) >= sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
            (void) strncpy((char *) q,buffer,extent);
            q+=extent;
             p+=GetPixelChannels(image);
           }
           *q++='\n';",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of a misplaced strncpy and an off-by-one error.
2190,CVE-2019-13304,"  static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image)
           {
             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?
               '0' : '1');
             if ((q-pixels+1) >= (ssize_t) sizeof(pixels))
               {
                 *q++='\n';
                 (void) WriteBlob(image,q-pixels,pixels);
                 q=pixels;
               }
            *q++=' ';
             p++;
           }
           *q++='\n';",ImageMagick 7.0.8-50 Q16 has a stack-based buffer overflow at coders/pnm.c in WritePNMImage because of a misplaced assignment.
2191,CVE-2019-13300,"  static PixelChannels **DestroyPixelThreadSet(PixelChannels **pixels)
   return(pixels);
 }
 
static PixelChannels **AcquirePixelThreadSet(const Image *images)
 {
  const Image
    *next;

   PixelChannels
     **pixels;
 
   register ssize_t
     i;
 
   size_t
    columns,
     number_threads;
 
   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
  static PixelChannels **AcquirePixelThreadSet(const Image *image)
   if (pixels == (PixelChannels **) NULL)
     return((PixelChannels **) NULL);
   (void) memset(pixels,0,number_threads*sizeof(*pixels));
  columns=images->columns;
  for (next=images; next != (Image *) NULL; next=next->next)
    columns=MagickMax(next->columns,columns);
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     register ssize_t
       j;
 
    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));
     if (pixels[i] == (PixelChannels *) NULL)
       return(DestroyPixelThreadSet(pixels));
    for (j=0; j < (ssize_t) columns; j++)
     {
       register ssize_t
         k;",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling columns.
2192,CVE-2019-13297,"  MagickExport Image *AdaptiveThresholdImage(const Image *image,
   threshold_image=CloneImage(image,0,0,MagickTrue,exception);
   if (threshold_image == (Image *) NULL)
     return((Image *) NULL);
  if ((width == 0) || (height == 0))
     return(threshold_image);
   status=SetImageStorageClass(threshold_image,DirectClass,exception);
   if (status == MagickFalse)",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a height of zero is mishandled.
2193,CVE-2019-13295,"  MagickExport Image *AdaptiveThresholdImage(const Image *image,
   threshold_image=CloneImage(image,0,0,MagickTrue,exception);
   if (threshold_image == (Image *) NULL)
     return((Image *) NULL);
  if (width == 0)
    return(threshold_image);
   if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)
     {
       InheritException(exception,&threshold_image->exception);",ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read at MagickCore/threshold.c in AdaptiveThresholdImage because a width of zero is mishandled.
2194,CVE-2019-13217," 
  
  
  
 
  
  
  
  static int lookup1_values(int entries, int dim)
    int r = (int) floor(exp((float) log((float) entries) / dim));
    if ((int) floor(pow((float) r+1, dim)) <= entries)    
       ++r;                                               
   if (pow((float) r+1, dim) <= entries)
      return -1;
   if ((int) floor(pow((float) r, dim)) > entries)
      return -1;
    return r;
 }
 
  static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y
    ady -= abs(base) * adx;
    if (x1 > n) x1 = n;
    if (x < x1) {
      LINE_OP(output[x], inverse_db_table[y&255]);
       for (++x; x < x1; ++x) {
          err += ady;
          if (err >= adx) {
             err -= adx;
             y += sy;
          } else
             y += base;
         LINE_OP(output[x], inverse_db_table[y&255]);
       }
    }
 }
  static float *get_window(vorb *f, int len)
    len <<= 1;
    if (len == f->blocksize_0) return f->window[0];
    if (len == f->blocksize_1) return f->window[1];
    return NULL;
 }
 
  static int vorbis_finish_frame(stb_vorbis *f, int len, int left, int right)
    if (f->previous_length) {
       int i,j, n = f->previous_length;
       float *w = get_window(f, n);
      if (w == NULL) return 0;
       for (i=0; i < f->channels; ++i) {
          for (j=0; j < n; ++j)
             f->channel_buffers[i][left+j] =
  static int start_decoder(vorb *f)
          while (current_entry < c->entries) {
             int limit = c->entries - current_entry;
             int n = get_bits(f, ilog(limit));
            if (current_length >= 32) return error(f, VORBIS_invalid_setup);
             if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }
             memset(lengths + current_entry, current_length, n);
             current_entry += n;
  static int start_decoder(vorb *f)
          c->value_bits = get_bits(f, 4)+1;
          c->sequence_p = get_bits(f,1);
          if (c->lookup_type == 1) {
            int values = lookup1_values(c->entries, c->dimensions);
            if (values < 0) return error(f, VORBIS_invalid_setup);
            c->lookup_values = (uint32) values;
          } else {
             c->lookup_values = c->entries * c->dimensions;
          }
  static int start_decoder(vorb *f)
             p[j].id = j;
          }
          qsort(p, g->values, sizeof(p[0]), point_compare);
         for (j=0; j < g->values-1; ++j)
            if (p[j].x == p[j+1].x)
               return error(f, VORBIS_invalid_setup);
          for (j=0; j < g->values; ++j)
             g->sorted_order[j] = (uint8) p[j].id;
           
  static int start_decoder(vorb *f)
          max_submaps = m->submaps;
       if (get_bits(f,1)) {
          m->coupling_steps = get_bits(f,8)+1;
         if (m->coupling_steps > f->channels) return error(f, VORBIS_invalid_setup);
          for (k=0; k < m->coupling_steps; ++k) {
             m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));
             m->chan[k].angle = get_bits(f, ilog(f->channels-1));
  int stb_vorbis_get_samples_float(stb_vorbis *f, int channels, float **buffer, in
 #endif  
 
 /* Version history
    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13223, -13223
                           found with Mayhem by ForAllSecure
    1.16    - 2019-03-04 - fix warnings
    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found
    1.14    - 2018-02-11 - delete bogus dealloca usage
    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)
     1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files
     1.11    - 2017-07-23 - fix MinGW compilation 
     1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory",A heap buffer overflow in the start_decoder function in stb_vorbis through 2019-03-04 allows an attacker to cause a denial of service or execute arbitrary code by opening a crafted Ogg Vorbis file.
2195,CVE-2019-13137,"  static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
         {
           (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
             ""InvalidGeometry"",""`%s'"",option);
          page_geometry=DestroyString(page_geometry);
           image=DestroyImage(image);
           return((Image *) NULL);
         }",ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadPSImage in coders/ps.c.
2196,CVE-2019-13135,"  static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)
   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
     sizeof(*BImgBuff));   
   if(BImgBuff==NULL) goto NoMemory;
  (void) memset(BImgBuff,0,(size_t) ldblk*sizeof(*BImgBuff));
 
   offset=SeekBlob(image,6  ,SEEK_SET);
   if (offset < 0)",ImageMagick before 7.0.8-50 has a *use of uninitialized value* vulnerability in the function ReadCUTImage in coders/cut.c.
2197,CVE-2019-12973,"  static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
 static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
  static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
                written++;
             }
         } else {  
             c = getc(IN);
  static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,
                         c1 = (OPJ_UINT8)getc(IN);
                     }
                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));
                    written++;
                 }
                 if (((c & 3) == 1) || ((c & 3) == 2)) {  
                     getc(IN);
                 }
             }
         }
     }   
    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }
     return OPJ_TRUE;
 }
 ","In OpenJPEG 2.3.1, there is excessive iteration in the opj_t1_encode_cblks function of openjp2/t1.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file. This issue is similar to CVE-2018-6616."
2198,CVE-2019-12904," 
 #define BLOCKSIZE               (128/8)
 
 
 
 #ifdef HAVE_GCC_ATTRIBUTE_ALIGNED
 # define ATTR_ALIGNED_16  __attribute__ ((aligned (16)))
# define ATTR_ALIGNED_64  __attribute__ ((aligned (64)))
 #else
 # define ATTR_ALIGNED_16
# define ATTR_ALIGNED_64
 #endif
 
 ","In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.)"
2199,CVE-2019-12109,"  GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *
 	rem_port = GetValueFromNameValueList(&data, ""RemotePort"");
 	protocol = GetValueFromNameValueList(&data, ""Protocol"");
 
	if (!int_port || !rem_port || !protocol)
 	{
 		ClearNameValueList(&data);
 		SoapError(h, 402, ""Invalid Args"");",A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for rem_port.
2200,CVE-2019-11924,"  folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(
     return folly::none;
   }
 
  TLSMessage msg{};
    
    
    ","A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00."
2201,CVE-2019-11487,"  static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
 		rem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;
 
 	ret = -EINVAL;
	if (rem < len)
		goto out_free;
 
 	rem = len;
 	while (rem) {
  static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
 			pipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);
 			pipe->nrbufs--;
 		} else {
			if (!pipe_buf_get(pipe, ibuf))
				goto out_free;

 			*obuf = *ibuf;
 			obuf->flags &= ~PIPE_BUF_FLAG_GIFT;
 			obuf->len = rem;
  static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
 	ret = fuse_dev_do_write(fud, &cs, len);
 
 	pipe_lock(pipe);
out_free:
 	for (idx = 0; idx < nbuf; idx++)
 		pipe_buf_release(pipe, &bufs[idx]);
 	pipe_unlock(pipe);
 
 	kvfree(bufs);
 	return ret;
 }","The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests."
2202,CVE-2019-11487,"  static inline void get_page(struct page *page)
 	page_ref_inc(page);
 }
 
static inline __must_check bool try_get_page(struct page *page)
{
	page = compound_head(page);
	if (WARN_ON_ONCE(page_ref_count(page) <= 0))
		return false;
	page_ref_inc(page);
	return true;
}

 static inline void put_page(struct page *page)
 {
 	page = compound_head(page);","The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests."
2203,CVE-2019-11487,"  static struct page *follow_page_pte(struct vm_area_struct *vma,
 		goto retry;
 	}
 
	if (flags & FOLL_GET) {
		if (unlikely(!try_get_page(page))) {
			page = ERR_PTR(-ENOMEM);
			goto out;
		}
	}
 	if (flags & FOLL_TOUCH) {
 		if ((flags & FOLL_WRITE) &&
 		    !pte_dirty(pte) && !PageDirty(page))
  static struct page *follow_pmd_mask(struct vm_area_struct *vma,
 			if (pmd_trans_unstable(pmd))
 				ret = -EBUSY;
 		} else {
			if (unlikely(!try_get_page(page))) {
				spin_unlock(ptl);
				return ERR_PTR(-ENOMEM);
			}
 			spin_unlock(ptl);
 			lock_page(page);
 			ret = split_huge_page(page);
  static int get_gate_page(struct mm_struct *mm, unsigned long address,
 		if (is_device_public_page(*page))
 			goto unmap;
 	}
	if (unlikely(!try_get_page(*page))) {
		ret = -ENOMEM;
		goto unmap;
	}
 out:
 	ret = 0;
 unmap:
  static void undo_dev_pagemap(int *nr, int nr_start, struct page **pages)
 	}
 }
 
 
static inline struct page *try_get_compound_head(struct page *page, int refs)
{
	struct page *head = compound_head(page);
	if (WARN_ON_ONCE(page_ref_count(head) < 0))
		return NULL;
	if (unlikely(!page_cache_add_speculative(head, refs)))
		return NULL;
	return head;
}

 #ifdef CONFIG_ARCH_HAS_PTE_SPECIAL
 static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,
 			 int write, struct page **pages, int *nr)
  static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,
 
 		VM_BUG_ON(!pfn_valid(pte_pfn(pte)));
 		page = pte_page(pte);
 
		head = try_get_compound_head(page, 1);
		if (!head)
 			goto pte_unmap;
 
 		if (unlikely(pte_val(pte) != pte_val(*ptep))) {
  static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,
 		refs++;
 	} while (addr += PAGE_SIZE, addr != end);
 
	head = try_get_compound_head(pmd_page(orig), refs);
	if (!head) {
 		*nr -= refs;
 		return 0;
 	}
  static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,
 		refs++;
 	} while (addr += PAGE_SIZE, addr != end);
 
	head = try_get_compound_head(pud_page(orig), refs);
	if (!head) {
 		*nr -= refs;
 		return 0;
 	}
  static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,
 		refs++;
 	} while (addr += PAGE_SIZE, addr != end);
 
	head = try_get_compound_head(pgd_page(orig), refs);
	if (!head) {
 		*nr -= refs;
 		return 0;
 	}","The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests."
2204,CVE-2019-11487,"  static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
 		rem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;
 
 	ret = -EINVAL;
	if (rem < len)
		goto out_free;
 
 	rem = len;
 	while (rem) {
  static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
 			pipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);
 			pipe->nrbufs--;
 		} else {
			if (!pipe_buf_get(pipe, ibuf))
				goto out_free;

 			*obuf = *ibuf;
 			obuf->flags &= ~PIPE_BUF_FLAG_GIFT;
 			obuf->len = rem;
  static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,
 	ret = fuse_dev_do_write(fud, &cs, len);
 
 	pipe_lock(pipe);
out_free:
 	for (idx = 0; idx < nbuf; idx++)
 		pipe_buf_release(pipe, &bufs[idx]);
 	pipe_unlock(pipe);
 
 	kvfree(bufs);
 	return ret;
 }","The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests."
2205,CVE-2019-11339,"  static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)
         return 0;
 
     s->partitioned_frame = 0;
    s->interlaced_dct = 0;
     s->decode_mb = mpeg4_decode_studio_mb;
 
     decode_smpte_tc(ctx, gb);",The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.
2206,CVE-2019-10714,"  MagickExport int LocaleLowercase(const int c)
 {
 #if defined(MAGICKCORE_LOCALE_SUPPORT)
   if (c_locale != (locale_t) NULL)
    return(tolower_l((int) ((unsigned char) c),c_locale));
 #endif
  return(tolower((int) ((unsigned char) c)));
 }
 
 /*
  MagickExport int LocaleUppercase(const int c)
 {
 #if defined(MAGICKCORE_LOCALE_SUPPORT)
   if (c_locale != (locale_t) NULL)
    return(toupper_l((int) ((unsigned char) c),c_locale));
 #endif
  return(toupper((int) ((unsigned char) c)));
 }
 
 /*","LocaleLowercase in MagickCore/locale.c in ImageMagick before 7.0.8-32 allows out-of-bounds access, leading to a SIGSEGV."
2207,CVE-2019-10714,"  MagickExport void LocaleLower(char *string)
 */
 MagickExport int LocaleLowercase(const int c)
 {
  if (c == EOF)
     return(c);
 #if defined(MAGICKCORE_LOCALE_SUPPORT)
   if (c_locale != (locale_t) NULL)
  MagickExport void LocaleUpper(char *string)
 */
 MagickExport int LocaleUppercase(const int c)
 {
  if (c == EOF)
     return(c);
 #if defined(MAGICKCORE_LOCALE_SUPPORT)
   if (c_locale != (locale_t) NULL)","LocaleLowercase in MagickCore/locale.c in ImageMagick before 7.0.8-32 allows out-of-bounds access, leading to a SIGSEGV."
2208,CVE-2019-10638,"  EXPORT_SYMBOL(ip_idents_reserve);
 void __ip_select_ident(struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
	static u32 ip_idents_hashrnd_extra __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
	net_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));
 
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol ^ ip_idents_hashrnd_extra,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);","In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses."
2209,CVE-2019-10638,"  struct net {
 						 */
 	spinlock_t		rules_mod_lock;
 
	u32			hash_mix;
 	atomic64_t		cookie_gen;
 
 	struct list_head	list;		 ","In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses."
2210,CVE-2019-7308,"  struct bpf_verifier_state {
 	 
 	struct bpf_func_state *frame[MAX_CALL_FRAMES];
 	u32 curframe;
	bool speculative;
 };
 
 #define bpf_get_spilled_reg(slot, frame)				\
  struct bpf_verifier_state_list {
 	struct bpf_verifier_state_list *next;
 };
 
 
#define BPF_ALU_SANITIZE_SRC		1U
#define BPF_ALU_SANITIZE_DST		2U
#define BPF_ALU_NEG_VALUE		(1U << 2)
#define BPF_ALU_SANITIZE		(BPF_ALU_SANITIZE_SRC | \
					 BPF_ALU_SANITIZE_DST)

 struct bpf_insn_aux_data {
 	union {
 		enum bpf_reg_type ptr_type;	 
 		unsigned long map_state;	 
 		s32 call_imm;			 
		u32 alu_limit;			 
 	};
 	int ctx_field_size;  
 	int sanitize_stack_off;  
 	bool seen;  
	u8 alu_state;  
 };
 
 #define MAX_USED_MAPS 64  ","kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks."
2211,CVE-2019-6978,"  static void char_init(GifCtx *ctx);
 static void char_out(int c, GifCtx *ctx);
 static void flush_char(GifCtx *ctx);
 
static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);
 
 
 
  BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
	if (!_gdImageGifCtx(im, out)) {
		rv = gdDPExtractData(out, size);
	} else {
		rv = NULL;
	}
 	out->gd_free(out);
 	return rv;
 }
  BGD_DECLARE(void) gdImageGif(gdImagePtr im, FILE *outFile)
 
 */
 BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
{
	_gdImageGifCtx(im, out);
}

 
static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
  BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 		based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if(!pim) {
			return 1;
 		}
 		tim = pim;
 	}
  BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 		 
 		gdImageDestroy(	pim);
 	}

	return 0;
 }
 
 ","The GD Graphics Library (aka LibGD) 2.2.5 has a double free in the gdImage*Ptr() functions in gd_gif_out.c, gd_jpeg.c, and gd_wbmp.c. NOTE: PHP is unaffected."
2212,CVE-2018-20847,"  void opj_get_all_encoding_parameters(   const opj_image_t *p_image,
 	q = tileno / p_cp->tw;
 
 	 
	*p_tx0 = (OPJ_INT32)opj_uint_max(p_cp->tx0 + p * p_cp->tdx, p_image->x0);
	*p_tx1 = (OPJ_INT32)opj_uint_min(p_cp->tx0 + (p + 1) * p_cp->tdx, p_image->x1);
	*p_ty0 = (OPJ_INT32)opj_uint_max(p_cp->ty0 + q * p_cp->tdy, p_image->y0);
	*p_ty1 = (OPJ_INT32)opj_uint_min(p_cp->ty0 + (q + 1) * p_cp->tdy, p_image->y1);
 
 	 
 	*p_max_prec = 0;","An improper computation of p_tx0, p_tx1, p_ty0 and p_ty1 in the function opj_get_encoding_parameters in openjp2/pi.c in OpenJPEG through 2.3.0 can lead to an integer overflow."
2213,CVE-2018-7191,"  static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)
 		if (!dev)
 			return -ENOMEM;
 		err = dev_get_valid_name(net, dev, name);
		if (err < 0)
 			goto err_free_dev;
 
 		dev_net_set(dev, net);","In the tun subsystem in the Linux kernel before 4.13.14, dev_get_valid_name is not called before register_netdevice. This allows local users to cause a denial of service (NULL pointer dereference and panic) via an ioctl(TUNSETIFF) call with a dev name containing a / character. This is similar to CVE-2013-4343."
2214,CVE-2015-6575," 

     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * (uint64_t)sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
 

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
    uint64_t allocSize = numEntries * 2 * (uint64_t)sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
 

         ALOGV(""Table of sync samples is empty or has only a single entry!"");
     }
 
    uint64_t allocSize = mNumSyncSamples * (uint64_t)sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
","SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I does not properly consider integer promotion, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow and memory corruption) via crafted atoms in MP4 data, aka internal bug 20139950, a different vulnerability than CVE-2015-1538. NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-7915, CVE-2014-7916, and/or CVE-2014-7917."
2215,CVE-2015-3864," 

                 size = 0;
             }
 
            if ((chunk_size > SIZE_MAX) || (SIZE_MAX - chunk_size <= size)) {
                 return ERROR_MALFORMED;
             }
 
","Integer underflow in the MPEG4Extractor::parseChunk function in MPEG4Extractor.cpp in libstagefright in mediaserver in Android before 5.1.1 LMY48M allows remote attackers to execute arbitrary code via crafted MPEG-4 data, aka internal bug 23034759.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-3824."
2216,CVE-2015-3863," 

 
 class Blob {
 public:
    Blob(const uint8_t* value, size_t valueLength, const uint8_t* info, uint8_t infoLength,
             BlobType type) {
        if (valueLength > sizeof(mBlob.value)) {
            valueLength = sizeof(mBlob.value);
            ALOGW(""Provided blob length too large"");
        }
        if (infoLength + valueLength > sizeof(mBlob.value)) {
            infoLength = sizeof(mBlob.value) - valueLength;
            ALOGW(""Provided info length too large"");
        }
         mBlob.length = valueLength;
         memcpy(mBlob.value, value, valueLength);
 
","Multiple integer overflows in the Blob class in keystore/keystore.cpp in Keystore in Android before 5.1.1 LMY48M allow attackers to execute arbitrary code and read arbitrary Keystore keys via an application that uses a crafted blob in an insert operation, aka internal bug 22802399."
2217,CVE-2015-3861," 

 
     mType = type;
     allocateStorage(size);
    void *dst = storage();
    if (!dst) {
        ALOGE(""Couldn't allocate %zu bytes for item"", size);
        return;
    }
    memcpy(dst, data, size);
 }
 
 void MetaData::typed_data::getData(
","Multiple integer overflows in the addVorbisCodecInfo function in matroska/MatroskaExtractor.cpp in libstagefright in mediaserver in Android before 5.1.1 LMY48M allow remote attackers to cause a denial of service (device inoperability) via crafted Matroska data, aka internal bug 21296336."
2218,CVE-2015-3849," 

 
     android::Parcel* p = android::parcelForJavaObject(env, parcel);
 
    const size_t size = p->readInt32();
    const void* regionData = p->readInplace(size);
    if (regionData == NULL) {
        return NULL;
    }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
","The Region_createFromParcel function in core/jni/android/graphics/Region.cpp in Region in Android before 5.1.1 LMY48M does not check the return values of certain read operations, which allows attackers to execute arbitrary code via an application that sends a crafted message to a service, aka internal bug 21585255."
2219,CVE-2015-3845," 

      
     for (int i = 0; i < (int) size; i++) {
         size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
             if (firstIndex == -1) {
                 firstIndex = i;
             }
","The Parcel::appendFrom function in libs/binder/Parcel.cpp in Binder in Android before 5.1.1 LMY48M does not consider parcel boundaries during identification of binder objects in an append operation, which allows attackers to obtain a different application's privileges via a crafted application, aka internal bug 17312693."
2220,CVE-2015-3842," 

  
 
 int32_t DownmixLib_Create(const effect_uuid_t *uuid,
        int32_t sessionId __unused,
        int32_t ioId __unused,
         effect_handle_t *pHandle) {
     int ret;
     int i;
 

 
     switch (cmdCode) {
     case EFFECT_CMD_INIT:
        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
             return -EINVAL;
         }
         *(int *) pReplyData = Downmix_Init(pDwmModule);
 

 
     case EFFECT_CMD_SET_CONFIG:
         if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
                || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
             return -EINVAL;
         }
         *(int *) pReplyData = Downmix_Configure(pDwmModule,
 

         ALOGV(""Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %"" PRIu32 "", pReplyData: %p"",
                 pCmdData, *replySize, pReplyData);
         if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
                pReplyData == NULL || replySize == NULL ||
                 *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {
             return -EINVAL;
         }
 

         ALOGV(""Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %"" PRIu32
                 "", pReplyData %p"", cmdSize, pCmdData, *replySize, pReplyData);
         if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))
                || pReplyData == NULL || replySize == NULL || *replySize != (int)sizeof(int32_t)) {
             return -EINVAL;
         }
         effect_param_t *cmd = (effect_param_t *) pCmdData;
 

         break;
 
     case EFFECT_CMD_ENABLE:
        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
             return -EINVAL;
         }
         if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {
 

         break;
 
     case EFFECT_CMD_DISABLE:
        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
             return -EINVAL;
         }
         if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {
 

  *----------------------------------------------------------------------------
  */
 
int Downmix_Reset(downmix_object_t *pDownmixer __unused, bool init __unused) {
      
     return 0;
 }
","Multiple heap-based buffer overflows in libeffects in the Audio Policy Service in mediaserver in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application, aka internal bug 21953516."
2221,CVE-2015-3836," 

     }
 
      
    if (dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE)
     {
         return EAS_ERROR_SOUND_LIBRARY;
     }
","The Parse_wave function in arm-wt-22k/lib_src/eas_mdls.c in the Sonivox DLS-to-EAS converter in Android before 5.1.1 LMY48I does not reject a negative value for a certain size field, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via crafted XMF data, aka internal bug 21132860."
2222,CVE-2015-3835," 

         OMX::buffer_id mID;
     };
     Vector<ActiveBuffer> mActiveBuffers;
     
     Mutex mBufferIDLock;
     uint32_t mBufferIDCount;
     KeyedVector<OMX::buffer_id, OMX_BUFFERHEADERTYPE *> mBufferIDToBufferHeader;
     KeyedVector<OMX_BUFFERHEADERTYPE *, OMX::buffer_id> mBufferHeaderToBufferID;
 
      
     char *mName;
","Buffer overflow in the OMXNodeInstance::emptyBuffer function in omx/OMXNodeInstance.cpp in libstagefright in Android before 5.1.1 LMY48I allows attackers to execute arbitrary code via a crafted application, aka internal bug 20634516."
2223,CVE-2015-3834," 

         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
            size_t bufSize = 2 * size;
 
             
            void *inData = NULL;
            if (bufSize > size) {
                inData = malloc(bufSize);
            }

            if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
                return OK;
            }

             void *outData = (uint8_t *)inData + size;
 
             data.read(inData, size);
 

         case HDCP_DECRYPT:
         {
             size_t size = data.readInt32();
            size_t bufSize = 2 * size;
 
             
            void *inData = NULL;
            if (bufSize > size) {
                inData = malloc(bufSize);
            }

            if (inData == NULL) {
                reply->writeInt32(ERROR_OUT_OF_RANGE);
                return OK;
            }

             void *outData = (uint8_t *)inData + size;
 
             data.read(inData, size);
","Multiple integer overflows in the BnHDCP::onTransact function in media/libmedia/IHDCP.cpp in libstagefright in Android before 5.1.1 LMY48I allow attackers to execute arbitrary code via a crafted application that uses HDCP encryption, leading to a heap-based buffer overflow, aka internal bug 20222489."
2224,CVE-2015-3832," 

     return a > b ? a : b;
 }
 
template<class T>
void ENSURE_UNSIGNED_TYPE() {
    T TYPE_MUST_BE_UNSIGNED[(T)-1 < 0 ? -1 : 0] __unused;
}

 
template<class T, class U>
inline static bool isInRange(const T &hayStart, const U &haySize, const T &needle) {
    ENSURE_UNSIGNED_TYPE<U>();
    return (T)(hayStart + haySize) >= hayStart && needle >= hayStart && (U)(needle - hayStart) < haySize;
}

 
template<class T, class U>
inline static bool isInRange(
        const T &hayStart, const U &haySize, const T &needleStart, const U &needleSize) {
    ENSURE_UNSIGNED_TYPE<U>();
    return isInRange(hayStart, haySize, needleStart)
            && (T)(needleStart + needleSize) >= needleStart
            && (U)(needleStart + needleSize - hayStart) <= haySize;
}

  
 template<class T>
 inline static T periodicError(const T &val, const T &period) {
","Multiple buffer overflows in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via invalid size values of NAL units in MP4 data, aka internal bug 19641538."
2225,CVE-2015-3831," 

 #include <binder/Parcel.h>
 #include <utils/String8.h>
 #include <media/stagefright/foundation/ADebug.h>
#include <media/stagefright/MediaErrors.h>
 
 namespace android {
 
 

             return UNKNOWN_ERROR;
         }
 
        size_t len = reply.readInt32();
 
        if (len > size) {
            ALOGE(""requested %zu, got %zu"", size, len);
            return ERROR_OUT_OF_RANGE;
         }
        if (len > mMemory->size()) {
            ALOGE(""got %zu, but memory has %zu"", len, mMemory->size());
            return ERROR_OUT_OF_RANGE;
        }

        memcpy(buffer, mMemory->pointer(), len);
 
         return len;
     }
","Buffer overflow in the readAt function in BpMediaHTTPConnection in media/libmedia/IMediaHTTPConnection.cpp in the mediaserver service in Android before 5.1.1 LMY48I allows attackers to execute arbitrary code via a crafted application, aka internal bug 19400722."
2226,CVE-2015-3829," 

             if (mFileMetaData != NULL) {
                 ALOGV(""chunk_data_size = %lld and data_offset = %lld"",
                         chunk_data_size, data_offset);

                if (chunk_data_size >= SIZE_MAX - 1) {
                    return ERROR_MALFORMED;
                }
                 sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);
                 if (mDataSource->readAt(
                     data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
","Off-by-one error in the MPEG4Extractor::parseChunk function in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow and memory corruption) via crafted MPEG-4 covr atoms with a size equal to SIZE_MAX, aka internal bug 20923261."
2227,CVE-2015-3828," 

         int len16 = 0;  
 
          
        if (size < 6) {
            return ERROR_MALFORMED;
        }

         if (size - 6 >= 4) {
             len16 = ((size - 6) / 2) - 1;  
             framedata = (char16_t *)(buffer + 6);
","The MPEG4Extractor::parse3GPPMetaData function in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I does not enforce a minimum size for UTF-16 strings containing a Byte Order Mark (BOM), which allows remote attackers to execute arbitrary code or cause a denial of service (integer underflow and memory corruption) via crafted 3GPP metadata, aka internal bug 20923261, a related issue to CVE-2015-3826."
2228,CVE-2015-3827," 

                     return ERROR_IO;
                 }
                 const int kSkipBytesOfDataBox = 16;
                if (chunk_data_size <= kSkipBytesOfDataBox) {
                    return ERROR_MALFORMED;
                }

                 mFileMetaData->setData(
                     kKeyAlbumArt, MetaData::TYPE_NONE,
                     buffer->data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);
","The MPEG4Extractor::parseChunk function in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I does not validate the relationship between chunk sizes and skip sizes, which allows remote attackers to execute arbitrary code or cause a denial of service (integer underflow and memory corruption) via crafted MPEG-4 covr atoms, aka internal bug 20923261."
2229,CVE-2015-3824," 

                 size = 0;
             }
 
            if (SIZE_MAX - chunk_size <= size) {
                return ERROR_MALFORMED;
            }

            uint8_t *buffer = new uint8_t[size + chunk_size];
             if (buffer == NULL) {
                 return ERROR_MALFORMED;
             }
","The MPEG4Extractor::parseChunk function in MPEG4Extractor.cpp in libstagefright in Android before 5.1.1 LMY48I does not properly restrict size addition, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow and memory corruption) via a crafted MPEG-4 tx3g atom, aka internal bug 20923261."
2230,CVE-2015-1539," 

     --size;
 
     if (streamDependenceFlag) {
        if (size < 2)
            return ERROR_MALFORMED;
         offset += 2;
         size -= 2;
     }
 

             return ERROR_MALFORMED;
         }
         unsigned URLlength = mData[offset];
        if (URLlength >= size)
            return ERROR_MALFORMED;
         offset += URLlength + 1;
         size -= URLlength + 1;
     }
 
     if (OCRstreamFlag) {
        if (size < 2)
            return ERROR_MALFORMED;
         offset += 2;
         size -= 2;
 
","Multiple integer underflows in the ESDS::parseESDescriptor function in ESDS.cpp in libstagefright in Android before 5.1.1 LMY48I allow remote attackers to execute arbitrary code via crafted ESDS atoms, aka internal bug 20139950, a related issue to CVE-2015-4493."
2231,CVE-2015-1538," 

         return ERROR_MALFORMED;
     }
 
    if (SIZE_MAX / sizeof(SampleToChunkEntry) <= mNumSampleToChunkOffsets)
        return ERROR_OUT_OF_RANGE;

     mSampleToChunkEntries =
         new SampleToChunkEntry[mNumSampleToChunkOffsets];
 
","Integer overflow in the SampleTable::setSampleToChunkParams function in SampleTable.cpp in libstagefright in Android before 5.1.1 LMY48I allows remote attackers to execute arbitrary code via crafted atoms in MP4 data that trigger an unchecked multiplication, aka internal bug 20139950, a related issue to CVE-2015-4496."
2232,CVE-2015-1536," 

         return NULL;
     }
 
    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);
 
    if (!bitmap->setInfo(SkImageInfo::Make(width, height, colorType, alphaType), rowBytes)) {
        return NULL;
    }
 
     SkColorTable* ctable = NULL;
     if (colorType == kIndex_8_SkColorType) {
         int count = p->readInt32();
        if (count < 0 || count > 256) {
             
             
            return NULL;
        }
         if (count > 0) {
             size_t size = count * sizeof(SkPMColor);
             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);
            if (src == NULL) {
                return NULL;
            }
             ctable = new SkColorTable(src, count);
         }
     }
 
    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);
     if (NULL == buffer) {
         SkSafeUnref(ctable);
         return NULL;
     }
 
 

     android::status_t status = p->readBlob(size, &blob);
     if (status) {
         doThrowRE(env, ""Could not read bitmap from parcel blob."");
         return NULL;
     }
 
 

 
     blob.release();
 
    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,
            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);
 }
 
 static jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,
","Integer overflow in the Bitmap_createFromParcel function in core/jni/android/graphics/Bitmap.cpp in Android before 5.1.1 LMY48I allows attackers to cause a denial of service (system_server crash) or obtain sensitive system_server memory-content information via a crafted application that leverages improper unmarshalling of bitmaps, aka internal bug 19666945."
2233,CVE-2015-1528," 

     if (err != NO_ERROR) return 0;
 
     native_handle* h = native_handle_create(numFds, numInts);
    if (!h) {
        return 0;
    }

     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
         if (h->data[i] < 0) err = BAD_VALUE;
","Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482."
2234,CVE-2015-1474," 

     const size_t numFds  = buf[8];
     const size_t numInts = buf[9];
 
    const size_t maxNumber = UINT_MAX / sizeof(int);
    if (numFds >= maxNumber || numInts >= (maxNumber - 10)) {
        width = height = stride = format = usage = 0;
        handle = NULL;
        ALOGE(""unflatten: numFds or numInts is too large: %d, %d"",
                numFds, numInts);
        return BAD_VALUE;
    }

     const size_t sizeNeeded = (10 + numInts) * sizeof(int);
     if (size < sizeNeeded) return NO_MEMORY;
 
    size_t fdCountNeeded = numFds;
     if (count < fdCountNeeded) return NO_MEMORY;
 
     if (handle) {
 

         format = buf[4];
         usage  = buf[5];
         native_handle* h = native_handle_create(numFds, numInts);
        if (!h) {
            width = height = stride = format = usage = 0;
            handle = NULL;
            ALOGE(""unflatten: native_handle_create failed"");
            return NO_MEMORY;
        }
         memcpy(h->data,          fds,     numFds*sizeof(int));
         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));
         handle = h;
",Multiple integer overflows in the GraphicBuffer::unflatten function in platform/frameworks/native/libs/ui/GraphicBuffer.cpp in Android through 5.0 allow attackers to gain privileges or cause a denial of service (memory corruption) via vectors that trigger a large number of (1) file descriptors or (2) integer values.
2235,CVE-2014-7917," 

     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
    if (allocSize > SIZE_MAX) {
        return ERROR_OUT_OF_RANGE;
    }
     mTimeToSample = new uint32_t[mTimeToSampleCount * 2];
 
     size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
 

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);
    if (allocSize > SIZE_MAX) {
        return ERROR_OUT_OF_RANGE;
    }

     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
 
     if (mDataSource->readAt(
 

         ALOGV(""Table of sync samples is empty or has only a single entry!"");
     }
 
    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);
    if (allocSize > SIZE_MAX) {
        return ERROR_OUT_OF_RANGE;
    }

     mSyncSamples = new uint32_t[mNumSyncSamples];
     size_t size = mNumSyncSamples * sizeof(uint32_t);
     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
","Integer overflow in SampleTable.cpp in libstagefright in Android before 5.0.0 has unspecified impact and attack vectors, aka internal bug 15342615."
2236,CVE-2016-6722," 

         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
 

 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
                + mSamplesPerChunk * (chunk - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
                mCurrentChunkSampleSizes.clear();
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }

        mCurrentChunkIndex = chunk;
     }
 
     uint32_t chunkRelativeSampleIndex =
","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-31091777."
2237,CVE-2016-6720," 

 status_t OMXNodeInstance::sendCommand(
         OMX_COMMANDTYPE cmd, OMX_S32 param) {
     if (cmd == OMX_CommandStateSet) {
         
         mSailed = true;
     }
     const sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 

             && arg2 == OMX_StateExecuting) {
         bufferSource->omxExecuting();
     }

     
    if (event == OMX_EventCmdComplete
            && arg1 == OMX_CommandStateSet
            && arg2 == OMX_StateLoaded) {
        mSailed = false;
    }
 }
 
  
","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
2238,CVE-2016-6712," 

   return 0;
 
  fail:
  vp9_set_mb_mi(cm, 0, 0);
   vp9_free_context_buffers(cm);
   return 1;
 }
","A remote denial of service vulnerability in libvpx in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-11-01 could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Android ID: A-30593752."
2239,CVE-2016-6711," 

             si->h = (clear[8] | (clear[9] << 8)) & 0x3fff;
 
              
            if (!(si->h && si->w))
                res = VPX_CODEC_CORRUPT_FRAME;
         }
         else
         {
 

                 if (setjmp(pbi->common.error.jmp))
                 {
                     pbi->common.error.setjmp = 0;
                     
                    ctx->si.w = 0;
                    ctx->si.h = 0;
                     vp8_clear_system_state();
                      
                     return -1;
","A remote denial of service vulnerability in libvpx in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-11-01 could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Android ID: A-30593765."
2240,CVE-2016-6706," 

 
 status_t OMXNodeInstance::enableNativeBuffers(
         OMX_U32 portIndex, OMX_BOOL graphic, OMX_BOOL enable) {
    if (portIndex >= NELEM(mSecureBufferType)) {
        ALOGE(""b/31385713, portIndex(%u)"", portIndex);
        android_errorWriteLog(0x534e4554, ""31385713"");
        return BAD_VALUE;
    }

     Mutex::Autolock autoLock(mLock);
     CLOG_CONFIG(enableNativeBuffers, ""%s:%u%s, %d"", portString(portIndex), portIndex,
                 graphic ? "", graphic"" : """", enable);
 

         return BAD_VALUE;
     }
 
    if (portIndex >= NELEM(mSecureBufferType)) {
        ALOGE(""b/31385713, portIndex(%u)"", portIndex);
        android_errorWriteLog(0x534e4554, ""31385713"");
        return BAD_VALUE;
    }

     Mutex::Autolock autoLock(mLock);
 
     BufferMeta *buffer_meta = new BufferMeta(size, portIndex);
","An elevation of privilege vulnerability in libstagefright in Mediaserver in Android 7.0 before 2016-11-01 could enable a local malicious application to execute arbitrary code within the context of a privileged process. This issue is rated as High because it could be used to gain local access to elevated capabilities, which are not normally accessible to a third-party application. Android ID: A-31385713."
2241,CVE-2016-6699," 

         extHeaders.add(String8(""User-Agent""), String8(MakeUserAgent().c_str()));
     }
 
    mLastURI = uri;
     
     
    uri = NULL;

    bool success = mHTTPConnection->connect(mLastURI.c_str(), &extHeaders);
 
     mLastHeaders = extHeaders;
 
     mCachedSizeValid = false;
 
     if (success) {
        AString sanitized = uriDebugString(mLastURI);
         mName = String8::format(""MediaHTTP(%s)"", sanitized.c_str());
     }
 
",A remote code execution vulnerability in libstagefright in Mediaserver in Android 7.0 before 2016-11-01 could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Android ID: A-31373622.
2242,CVE-2016-3924," 

     return NO_ERROR;
 }
 
 
template <typename T>
static T roundUpDelta(const T &value, const T &divisor) {
    T remainder = value % divisor;
    return remainder == 0 ? 0 : divisor - remainder;
}

 status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                              uint32_t cmdSize,
                                              void *pCmdData,
 

         android_errorWriteLog(0x534e4554, ""29251553"");
         return -EINVAL;
     }
    if ((cmdCode == EFFECT_CMD_SET_PARAM
            || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&   
        (sizeof(effect_param_t) > cmdSize
            || ((effect_param_t *)pCmdData)->psize > cmdSize
                                                     - sizeof(effect_param_t)
            || ((effect_param_t *)pCmdData)->vsize > cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
            || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
                                                     cmdSize
                                                     - sizeof(effect_param_t)
                                                     - ((effect_param_t *)pCmdData)->psize
                                                     - ((effect_param_t *)pCmdData)->vsize)) {
        android_errorWriteLog(0x534e4554, ""30204301"");
        return -EINVAL;
    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
","services/audioflinger/Effects.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not validate EFFECT_CMD_SET_PARAM and EFFECT_CMD_SET_PARAM_DEFERRED commands, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 30204301."
2243,CVE-2016-3922," 

     if ((success = pb_get_encoded_size(&encoded_size, MsgHeader_fields,
         hdr)) && encoded_size <= INT32_MAX && commandFd != -1) {
         buffer_size = encoded_size + sizeof(uint32_t);
        uint8_t* buffer = (uint8_t*)malloc(buffer_size);
        if (!buffer) {
            RLOGE(""sendResponse: OOM"");
            pthread_mutex_unlock(&write_lock);
            return;
        }
         written_size = htonl((uint32_t) encoded_size);
         ostream = pb_ostream_from_buffer(buffer, buffer_size);
         pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
 

             RLOGE(""Error while encoding response of type %d id %d buffer_size: %d: %s."",
             hdr->type, hdr->id, buffer_size, PB_GET_ERROR(&ostream));
         }
        free(buffer);
     } else {
     RLOGE(""Not sending response type %d: encoded_size: %u. commandFd: %d. encoded size result: %d"",
         hdr->type, encoded_size, commandFd, success);
 

    if ((success = pb_get_encoded_size(&encoded_size, RIL_SIM_SAP_DISCONNECT_REQ_fields,
         &disconnectReq)) && encoded_size <= INT32_MAX) {
         buffer_size = encoded_size + sizeof(uint32_t);
        uint8_t* buffer = (uint8_t*)malloc(buffer_size);
        if (!buffer) {
            RLOGE(""sendDisconnect: OOM"");
            return;
        }
         written_size = htonl((uint32_t) encoded_size);
         ostream = pb_ostream_from_buffer(buffer, buffer_size);
         pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
 

         else {
             RLOGE(""Encode failed in send disconnect!"");
         }
        free(buffer);
     }
 }
 
","libril/RilSapSocket.cpp in Telephony in Android 6.x before 2016-10-01 and 7.0 before 2016-10-01 relies on variable-length arrays, which allows attackers to gain privileges via a crafted application, aka internal bug 30202619."
2244,CVE-2016-3921," 

     int mCommandCount;
     bool mWithSeq;
     FrameworkCommandCollection *mCommands;
    bool mSkipToNextNullByte;
 
 public:
     FrameworkListener(const char *socketName);
","libsysutils/src/FrameworkListener.cpp in Framework Listener in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 29831647."
2245,CVE-2016-3920," 

       mFirstFrameOffset(0),
       mVersion(ID3_UNKNOWN),
       mRawSize(0) {
    sp<MemorySource> source = new (std::nothrow) MemorySource(data, size);

    if (source == NULL)
        return;
 
     mIsValid = parseV2(source, 0);
 
 

         n -= skipped;
     }
 
    if (n <= 0) {
       return;
    }

     if (encoding == 0x00) {
          
         id->setTo((const char*)frameData + 1, n);
 

         const char16_t *framedata = (const char16_t *) (frameData + 1);
         char16_t *framedatacopy = NULL;
 #if BYTE_ORDER == LITTLE_ENDIAN
        if (len > 0) {
            framedatacopy = new (std::nothrow) char16_t[len];
            if (framedatacopy == NULL) {
                return;
            }
            for (int i = 0; i < len; i++) {
                framedatacopy[i] = bswap_16(framedata[i]);
            }
            framedata = framedatacopy;
         }
 #endif
         id->setTo(framedata, len);
         if (framedatacopy != NULL) {
 

         const char16_t *framedata = (const char16_t *) (frameData + 1);
         char16_t *framedatacopy = NULL;
         if (*framedata == 0xfffe) {
             
            if (len <= 1) {
                return;          
            }
            framedatacopy = new (std::nothrow) char16_t[len];
            if (framedatacopy == NULL) {
                return;
            }
             for (int i = 0; i < len; i++) {
                 framedatacopy[i] = bswap_16(framedata[i]);
             }
             framedata = framedatacopy;
             
            framedata++;
            len--;
        } else if (*framedata == 0xfeff) {
             
            if (len <= 1) {
                return;          
            }
             framedata++;
             len--;
         }
 

         }
         if (eightBit) {
              
            char *frame8 = new (std::nothrow) char[len];
            if (frame8 != NULL) {
                for (int i = 0; i < len; i++) {
                    frame8[i] = framedata[i];
                }
                id->setTo(frame8, len);
                delete [] frame8;
            } else {
                id->setTo(framedata, len);
             }
         } else {
             id->setTo(framedata, len);
         }
","id3/ID3.cpp in libstagefright in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows remote attackers to cause a denial of service (device hang or reboot) via a crafted file, aka internal bug 30744884."
2246,CVE-2016-3916," 

 #include <stdlib.h>
 #include <errno.h>
 
#define OK              0
#define ERROR           1
#define NOT_FOUND       -ENOENT
#define SN_EVENT_LOG_ID 0x534e4554
 
 #define ALIGN_TO(val, alignment) \
     (((uintptr_t)(val) + ((alignment) - 1)) & ~((alignment) - 1))
 

     return metadata;
 }
 
 
 
static int validate_and_calculate_camera_metadata_entry_data_size(size_t *data_size, uint8_t type,
        size_t data_count) {
    if (type >= NUM_TYPES) return ERROR;

     
    if (data_count != 0 &&
            camera_metadata_type_size[type] > (SIZE_MAX - DATA_ALIGNMENT + 1) / data_count) {
        android_errorWriteLog(SN_EVENT_LOG_ID, ""30741779"");
        return ERROR;
    }

    size_t data_bytes = data_count * camera_metadata_type_size[type];

    if (data_size) {
        *data_size = data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
    }

    return OK;
}

size_t calculate_camera_metadata_entry_data_size(uint8_t type,
        size_t data_count) {
    if (type >= NUM_TYPES) return 0;

    size_t data_bytes = data_count *
            camera_metadata_type_size[type];

    return data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
}

 int validate_camera_metadata_structure(const camera_metadata_t *metadata,
                                        const size_t *expected_size) {
 
 

             return ERROR;
         }
 
        size_t data_size;
        if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type,
                entry.count) != OK) {
            ALOGE(""%s: Entry data size is invalid. type: %u count: %u"", __FUNCTION__, entry.type,
                    entry.count);
            return ERROR;
        }
 
         if (data_size != 0) {
             camera_metadata_data_t *data =
 

     return clone;
 }
 
 static int add_camera_metadata_entry_raw(camera_metadata_t *dst,
         uint32_t tag,
         uint8_t  type,
","camera/src/camera_metadata.c in the Camera service in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30741779."
2247,CVE-2016-3915," 

  * limitations under the License.
  */
 
#define _GNU_SOURCE  
 #include <inttypes.h>
 #include <system/camera_metadata.h>
 #include <camera_metadata_hidden.h>
 

         return ERROR;
     }
 
    if (metadata->data_count > metadata->data_capacity) {
        ALOGE(""%s: Data count (%"" PRIu32 "") should be <= data capacity ""
              ""(%"" PRIu32 "")"",
              __FUNCTION__, metadata->data_count, metadata->data_capacity);
        android_errorWriteLog(SN_EVENT_LOG_ID, ""30591838"");
        return ERROR;
    }

    const metadata_uptrdiff_t entries_end = metadata->entries_start + metadata->entry_capacity;
     if (entries_end < metadata->entries_start ||  
         entries_end > metadata->data_start) {
 
 

         const camera_metadata_t *src) {
     if (dst == NULL || src == NULL ) return ERROR;
 
     
    if (src->entry_count + dst->entry_count < src->entry_count) return ERROR;
    if (src->data_count + dst->data_count < src->data_count) return ERROR;
     
     if (dst->entry_capacity < src->entry_count + dst->entry_count) return ERROR;
     if (dst->data_capacity < src->data_count + dst->data_count) return ERROR;
 
","camera/src/camera_metadata.c in the Camera service in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30591838."
2248,CVE-2016-3913," 

     mClients.remove(client);
 }
 
bool MediaPlayerService::hasClient(wp<Client> client)
{
    Mutex::Autolock lock(mLock);
    return mClients.indexOf(client) != NAME_NOT_FOUND;
}

 MediaPlayerService::Client::Client(
         const sp<MediaPlayerService>& service, pid_t pid,
         int32_t connId, const sp<IMediaPlayerClient>& client,
 

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
    if (!mService->hasClient(c)) {
      return BAD_VALUE;
    }

     mNextClient = c;
 
     if (c != NULL) {
","media/libmediaplayerservice/MediaPlayerService.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not validate a certain static_cast operation, which allows attackers to gain privileges via a crafted application, aka internal bug 30204103."
2249,CVE-2016-3910," 

     struct sound_trigger_sound_model *sound_model =
             (struct sound_trigger_sound_model *)modelMemory->pointer();
 
    size_t structSize;
    if (sound_model->type == SOUND_MODEL_TYPE_KEYPHRASE) {
        structSize = sizeof(struct sound_trigger_phrase_sound_model);
    } else {
        structSize = sizeof(struct sound_trigger_sound_model);
    }

    if (sound_model->data_offset < structSize ||
           sound_model->data_size > (UINT_MAX - sound_model->data_offset) ||
           modelMemory->size() < sound_model->data_offset ||
           sound_model->data_size > (modelMemory->size() - sound_model->data_offset)) {
        android_errorWriteLog(0x534e4554, ""30148546"");
        ALOGE(""loadSoundModel() data_size is too big"");
        return BAD_VALUE;
    }

     AutoMutex lock(mLock);
 
     if (mModels.size() >= mDescriptor.properties.max_sound_models) {
 

         return PERMISSION_DENIED;
     }
 
    if (dataMemory == 0 || dataMemory->pointer() == NULL) {
        ALOGE(""startRecognition() dataMemory is 0 or has NULL pointer()"");
         return BAD_VALUE;
 
     }

    struct sound_trigger_recognition_config *config =
            (struct sound_trigger_recognition_config *)dataMemory->pointer();

    if (config->data_offset < sizeof(struct sound_trigger_recognition_config) ||
            config->data_size > (UINT_MAX - config->data_offset) ||
            dataMemory->size() < config->data_offset ||
            config->data_size > (dataMemory->size() - config->data_offset)) {
        ALOGE(""startRecognition() data_size is too big"");
        return BAD_VALUE;
    }

     AutoMutex lock(mLock);
     if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {
         return INVALID_OPERATION;
 

     if (model == 0) {
         return BAD_VALUE;
     }
 
     if (model->mState == Model::STATE_ACTIVE) {
         return INVALID_OPERATION;
     }
 
 
      
     config->capture_handle = model->mCaptureIOHandle;
","services/soundtrigger/SoundTriggerHwService.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30148546."
2250,CVE-2016-3909," 

             PortInfo *port = editPortInfo(1);
             OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;
 
            OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
            if ((outHeader->nAllocLen < yFrameSize) ||
                    (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %zu bytes"",
                        outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""30033990"");
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
                return;
            }
             PVSetReferenceYUV(mHandle, outHeader->pBuffer);
             mFramesConfigured = true;
         }
 
 

         int32_t bufferSize = inHeader->nFilledLen;
         int32_t tmp = bufferSize;
 
        OMX_U32 frameSize;
        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
        if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
            ALOGE(""Frame size too large"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }
        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));

         if (outHeader->nAllocLen < frameSize) {
             android_errorWriteLog(0x534e4554, ""27833616"");
             ALOGE(""Insufficient output buffer size"");
","The SoftMPEG4 component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30033990."
2251,CVE-2016-3899," 

 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
        if (mem == NULL || mem->pointer() == NULL) {
            return NO_MEMORY;
        }
 
         BufferInfo info;
         info.mData = NULL;
","OMXCodec.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not validate a certain pointer, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29421811."
2252,CVE-2016-3895," 

         return NO_MEMORY;
     }
 
    if (numRects > (UINT32_MAX / sizeof(Rect))) {
        android_errorWriteWithInfoLog(0x534e4554, ""29983260"", -1, NULL, 0);
        return NO_MEMORY;
    }

     Region result;
     result.mStorage.clear();
     for (size_t r = 0; r < numRects; ++r) {
","Integer overflow in the Region::unflatten function in libs/ui/Region.cpp in mediaserver in Android 6.x before 2016-09-01 and 7.0 before 2016-09-01 allows attackers to obtain sensitive information via a crafted application, aka internal bug 29983260."
2253,CVE-2016-3890," 

 #include ""sysdeps/mutex.h""
 #include ""transport.h""
 
 static std::recursive_mutex& local_socket_list_lock = *new std::recursive_mutex();
 static unsigned local_socket_next_id = 1;
 
 

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            s->close(s);
             goto restart;
         }
     }
","The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842."
2254,CVE-2016-3885," 

    return allowed;
 }
 
static bool pid_contains_tid(pid_t pid, pid_t tid) {
  char task_path[PATH_MAX];
  if (snprintf(task_path, PATH_MAX, ""/proc/%d/task/%d"", pid, tid) >= PATH_MAX) {
    ALOGE(""debuggerd: task path overflow (pid = %d, tid = %d)\n"", pid, tid);
    exit(1);
  }

  return access(task_path, F_OK) == 0;
}

 static int read_request(int fd, debugger_request_t* out_request) {
   ucred cr;
   socklen_t len = sizeof(cr);
 

 
   if (msg.action == DEBUGGER_ACTION_CRASH) {
      
     
    if (!pid_contains_tid(out_request->pid, out_request->tid)) {
      ALOGE(""tid %d does not exist in pid %d. ignoring debug request\n"", out_request->tid,
            out_request->pid);
       return -1;
     }
  } else if (cr.uid == 0 || (cr.uid == AID_SYSTEM && msg.action == DEBUGGER_ACTION_DUMP_BACKTRACE)) {
      
      
     status = get_process_info(out_request->tid, &out_request->pid,
 

 }
 #endif
 
 
static bool ptrace_attach_thread(pid_t pid, pid_t tid) {
  if (ptrace(PTRACE_ATTACH, tid, 0, 0) != 0) {
    return false;
  }
 
   
  if (!pid_contains_tid(pid, tid)) {
    if (ptrace(PTRACE_DETACH, tid, 0, 0) != 0) {
      ALOGE(""debuggerd: failed to detach from thread '%d'"", tid);
      exit(1);
    }
    return false;
  }

  return true;
}

static void ptrace_siblings(pid_t pid, pid_t main_tid, std::set<pid_t>& tids) {
  char task_path[PATH_MAX];

  if (snprintf(task_path, PATH_MAX, ""/proc/%d/task"", pid) >= PATH_MAX) {
    ALOGE(""debuggerd: task path overflow (pid = %d)\n"", pid);
    abort();
  }
 
   std::unique_ptr<DIR, int (*)(DIR*)> d(opendir(task_path), closedir);
 
 

       continue;
     }
 
    if (!ptrace_attach_thread(pid, tid)) {
       ALOGE(""debuggerd: ptrace attach to %d failed: %s"", tid, strerror(errno));
       continue;
     }
 

    
 
    
  if (!ptrace_attach_thread(request.pid, request.tid)) {
     ALOGE(""debuggerd: ptrace attach failed: %s"", strerror(errno));
     exit(1);
   }
 
   
   
   
   
  if (request.action == DEBUGGER_ACTION_CRASH) {
    pid_t pid;
    uid_t uid;
    gid_t gid;
    if (get_process_info(request.tid, &pid, &uid, &gid) != 0) {
      ALOGE(""debuggerd: failed to get process info for tid '%d'"", request.tid);
      exit(1);
    }

    if (pid != request.pid || uid != request.uid || gid != request.gid) {
      ALOGE(
        ""debuggerd: attached task %d does not match request: ""
        ""expected pid=%d,uid=%d,gid=%d, actual pid=%d,uid=%d,gid=%d"",
        request.tid, request.pid, request.uid, request.gid, pid, uid, gid);
      exit(1);
    }
  }

    
    
   bool attach_gdb = should_attach_gdb(request);
","debuggerd/debuggerd.cpp in Debuggerd in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 mishandles the interaction between PTRACE_ATTACH operations and thread exits, which allows attackers to gain privileges via a crafted application, aka internal bug 29555636."
2255,CVE-2016-3881," 

                                                 vpx_decrypt_cb decrypt_cb,
                                                 void *decrypt_state) {
   int intra_only_flag = 0;
  uint8_t clear_buffer[10];
 
   if (data + data_sz <= data)
     return VPX_CODEC_INVALID_PARAM;
 

     data = clear_buffer;
   }
 
   
   
  if (data_sz < 1)
    return VPX_CODEC_UNSUP_BITSTREAM;

   {
     int show_frame;
     int error_resilient;
 

     if (profile >= MAX_PROFILES)
       return VPX_CODEC_UNSUP_BITSTREAM;
 
     if (vpx_rb_read_bit(&rb)) {   
       
       
      if (profile > 2 && data_sz < 2)
        return VPX_CODEC_UNSUP_BITSTREAM;
       vpx_rb_read_literal(&rb, 3);   
       return VPX_CODEC_OK;
     }
 
     
     
     
    if (data_sz < 10)
       return VPX_CODEC_UNSUP_BITSTREAM;
 
     si->is_kf = !vpx_rb_read_bit(&rb);
","The decoder_peek_si_internal function in vp9/vp9_dx_iface.c in libvpx in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allows remote attackers to cause a denial of service (buffer over-read, and device hang or reboot) via a crafted media file, aka internal bug 30013856."
2256,CVE-2016-3880," 

  
 #define LOG_TAG ""ASessionDescription""
 #include <utils/Log.h>
#include <cutils/log.h>
 
 #include ""ASessionDescription.h""
 
 

 
     *PT = x;
 
    char key[32];
    snprintf(key, sizeof(key), ""a=rtpmap:%lu"", x);
 
     CHECK(findAttribute(index, key, desc));
 
    snprintf(key, sizeof(key), ""a=fmtp:%lu"", x);
     if (!findAttribute(index, key, params)) {
         params->clear();
     }
 

     *width = 0;
     *height = 0;
 
    char key[33];
    snprintf(key, sizeof(key), ""a=framesize:%lu"", PT);
    if (PT > 9999999) {
        android_errorWriteLog(0x534e4554, ""25747670"");
    }
     AString value;
     if (!findAttribute(index, key, &value)) {
         return false;
","Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670."
2257,CVE-2016-3879," 

     }
 
      
    if (dls.pDLS) {
        Convert_art(&dls, &defaultArt, 0);
        dls.artCount = 1;
    }
 
      
     dls.regionCount = dls.instCount = 0;
","arm-wt-22k/lib_src/eas_mdls.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 allows remote attackers to cause a denial of service (NULL pointer dereference, and device hang or reboot) via a crafted media file, aka internal bug 29770686."
2258,CVE-2016-3878," 

         else
             prev_slice_err = 2;
 
        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
            prev_slice_err = 1;

         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
                                    &temp_poc, prev_slice_err);
 
","decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-09-01 mishandles the case of decoding zero MBs, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29493002."
2259,CVE-2016-3872," 

     uint64_t nFilledLen = width;
     nFilledLen *= height;
     if (nFilledLen > UINT32_MAX / 3) {
        ALOGE(""b/29421675, nFilledLen overflow %llu w %u h %u"",
                (unsigned long long)nFilledLen, width, height);
         android_errorWriteLog(0x534e4554, ""29421675"");
         return false;
     } else if (outHeader->nAllocLen < outHeader->nFilledLen) {
","Buffer overflow in codecs/on2/dec/SoftVPX.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allows attackers to gain privileges via a crafted application, aka internal bug 29421675."
2260,CVE-2016-3871," 

     mIsFirst = true;
 }
 
void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
    if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", outHeader->nAllocLen, len);
        android_errorWriteLog(0x534e4554, ""29422022"");
        notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
        mSignalledError = true;
        return NULL;
    }
    return memset(outHeader->pBuffer, c, len);
}

 OMX_ERRORTYPE SoftMP3::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
     switch (index) {
 

                     outHeader->nOffset = 0;
                     outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
 
                    if (!memsetSafe(outHeader, 0, outHeader->nFilledLen)) {
                        return;
                    }

                 }
                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;
                 mSignalledOutputEos = true;
 

                  
                  
                 ALOGV_IF(mIsFirst, ""insufficient data for first frame, sending silence"");
                if (!memsetSafe(outHeader, 0, mConfig->outputFrameSize * sizeof(int16_t))) {
                    return;
                }
 
                 if (inHeader) {
                     mConfig->inputBufferUsedLength = inHeader->nFilledLen;
","Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022."
2261,CVE-2016-3870," 

     CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);
     CHECK(port->mDef.bEnabled == !enable);
 
    if (port->mDef.eDir != OMX_DirOutput) {
        ALOGE(""Port enable/disable allowed only on output ports."");
        notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
        android_errorWriteLog(0x534e4554, ""29421804"");
        return;
    }

     if (!enable) {
         port->mDef.bEnabled = OMX_FALSE;
         port->mTransition = PortInfo::DISABLING;
","omx/SimpleSoftOMXComponent.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not prevent input-port changes, which allows attackers to gain privileges via a crafted application, aka internal bug 29421804."
2262,CVE-2016-3863," 

 #include <sys/stat.h>
 
 #include <utility>
#include <vector>
 
 #include ""include/ESDS.h""
 #include ""include/HevcUtils.h""
 

      
     sp<ABuffer> csd0, csd1, csd2;
     if (msg->findBuffer(""csd-0"", &csd0)) {
        int csd0size = csd0->size();
         if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {
             sp<ABuffer> csd1;
             if (msg->findBuffer(""csd-1"", &csd1)) {
                std::vector<char> avcc(csd0size + csd1->size() + 1024);
                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());
                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);
             }
         } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {
            std::vector<char> esds(csd0size + 31);
              
              
            reassembleESDS(csd0, esds.data());
            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());
         } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {
            std::vector<uint8_t> hvcc(csd0size + 1024);
            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);
            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);
         } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {
             meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());
         } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {
","Multiple stack-based buffer overflows in the AVCC reassembly implementation in Utils.cpp in libstagefright in MediaMuxer in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to execute arbitrary code via a crafted media file, aka internal bug 29161888."
2263,CVE-2016-3861," 

  * ""dst"" becomes \xE3\x81\x82\xE3\x81\x84
  * (note that ""dst"" is NOT null-terminated, like strncpy)
  */
void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst, size_t dst_len);
 
  
void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst, size_t dst_len);
 
 /**
  * Returns the length of ""src"" when ""src"" is valid UTF-8 string.
","LibUtils in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 mishandles conversions between Unicode character encodings with different encoding widths, which allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow) via a crafted file, aka internal bug 29250543."
2264,CVE-2016-3839," 

 
     ts_log(""skt_read recv"", len, NULL);
 
    if ((read = TEMP_FAILURE_RETRY(recv(fd, p, len, MSG_NOSIGNAL))) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 

      
 
      
    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)
         return 0;
 
     ts_log(""skt_write"", len, NULL);
 
    if ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 

 
 static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)
 {
    int ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
     if (ret < 0)
     {
         ERROR(""ack failed (%s)"", strerror(errno));
         if (errno == EINTR)
         {
              
            ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
             if (ret < 0)
             {
                ERROR(""ack failed (%s)"", strerror(errno));
 

     DEBUG(""A2DP COMMAND %s"", dump_a2dp_ctrl_event(cmd));
 
      
    if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""cmd failed (%s)"", strerror(errno));
         skt_disconnect(common->ctrl_fd);
 

                 break;
 
             ERROR(""error : a2dp not ready, wait 250 ms and retry"");
            TEMP_FAILURE_RETRY(usleep(250000));
             skt_disconnect(common->ctrl_fd);
             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
         }
 
          
        TEMP_FAILURE_RETRY(usleep(250000));
     }
 }
 
 

 
             DEBUG(""emulate a2dp write delay (%d us)"", us_delay);
 
            TEMP_FAILURE_RETRY(usleep(us_delay));
             pthread_mutex_unlock(&out->common.lock);
             return -1;
         }
 

 
             DEBUG(""emulate a2dp read delay (%d us)"", us_delay);
 
            TEMP_FAILURE_RETRY(usleep(us_delay));
             pthread_mutex_unlock(&in->common.lock);
             return -1;
         }
 

     DEBUG(""success"");
      
    TEMP_FAILURE_RETRY(usleep(250000));
     return 0;
 
 err_open:
","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
2265,CVE-2016-3837," 

 }
 
 static byte parseHexByte(const char * &str) {
    if (str[0] == '\0') {
        ALOGE(""Passed an empty string"");
        return 0;
    }
     byte b = parseHexChar(str[0]);
    if (str[1] == '\0' || str[1] == ':') {
        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
        str += 2;
     }

     
    if (str[0] != '\0') {
        str++;
    }
    return b;
 }
 
 static void parseMacAddress(const char *str, mac_addr addr) {
","service/jni/com_android_server_wifi_WifiNative.cpp in Wi-Fi in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to obtain sensitive information via a crafted application that provides a MAC address with too few characters, aka internal bug 28164077."
2266,CVE-2016-3836," 

 
 class FrameStats : public LightFlattenable<FrameStats> {
 public:
    FrameStats() : refreshPeriodNano(0) {};
 
     /*
      * Approximate refresh time, in nanoseconds.
","The SurfaceFlinger service in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to obtain sensitive information via a crafted application, related to lack of a default constructor in include/ui/FrameStats.h, aka internal bug 28592402."
2267,CVE-2016-3835," 

 
 #define SZ_4K                       0x1000
 #define SZ_1M                       0x100000
 
 typedef struct OMXComponentCapabilityFlagsType {
      
 

             m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;
             m_pInput_pmem[i].offset = 0;
 
            m_pInput_pmem[i].buffer = NULL;
             if(!secure_session) {
                 m_pInput_pmem[i].buffer = (unsigned char *)mmap(
                     NULL,m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,
 

 
             if (m_pInput_pmem[i].buffer == MAP_FAILED) {
                     DEBUG_PRINT_ERROR(""ERROR: mmap() Failed"");
                m_pInput_pmem[i].buffer = NULL;
                 close(m_pInput_pmem[i].fd);
 #ifdef USE_ION
                 free_ion_memory(&m_pInput_ion[i]);
 

                 m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;
                 m_pOutput_pmem[i].offset = 0;
 
                m_pOutput_pmem[i].buffer = NULL;
                 if(!secure_session) {
 #ifdef _MSM8974_
                     m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,
 

 #endif
                 if (m_pOutput_pmem[i].buffer == MAP_FAILED) {
                         DEBUG_PRINT_ERROR(""ERROR: mmap() Failed"");
                    m_pOutput_pmem[i].buffer = NULL;
                     close(m_pOutput_pmem[i].fd);
 #ifdef USE_ION
                     free_ion_memory(&m_pOutput_ion[i]);
 

         m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;
         m_pInput_pmem[i].offset = 0;
 
        m_pInput_pmem[i].buffer = NULL;
         if(!secure_session) {
             m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,
                 m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,
                 MAP_SHARED,m_pInput_pmem[i].fd,0);
         if (m_pInput_pmem[i].buffer == MAP_FAILED) {
                 DEBUG_PRINT_ERROR(""ERROR: mmap FAILED= %d"", errno);
            m_pInput_pmem[i].buffer = NULL;
             close(m_pInput_pmem[i].fd);
 #ifdef USE_ION
             free_ion_memory(&m_pInput_ion[i]);
 

              
              
             m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
            if (m_pInput_pmem[i].buffer == NULL) {
                DEBUG_PRINT_ERROR(""%s: failed to allocate native-handle"", __func__);
                return OMX_ErrorInsufficientResources;
            }
             (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);
         }
 
 

             m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;
             m_pOutput_pmem[i].offset = 0;
 
            m_pOutput_pmem[i].buffer = NULL;
             if(!secure_session) {
 #ifdef _MSM8974_
                 m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,
 

 #endif
             if (m_pOutput_pmem[i].buffer == MAP_FAILED) {
                     DEBUG_PRINT_ERROR(""ERROR: MMAP_FAILED in o/p alloc buffer"");
                m_pOutput_pmem[i].buffer = NULL;
                 close (m_pOutput_pmem[i].fd);
 #ifdef USE_ION
                 free_ion_memory(&m_pOutput_ion[i]);
 

                  
                  
                 m_pOutput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
                if (m_pOutput_pmem[i].buffer == NULL) {
                    DEBUG_PRINT_ERROR(""%s: Failed to allocate native-handle"", __func__);
                    return OMX_ErrorInsufficientResources;
                }
                 (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);
                 native_handle_t *handle = native_handle_create(1, 0);
                 handle->data[0] = m_pOutput_pmem[i].fd;
","The secure-session feature in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 mishandles heap pointers, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 28920116."
2268,CVE-2016-3834," 

     RELEASE_RECORDING_FRAME,
 };
 
uint8_t ICameraRecordingProxy::baseObject = 0;

size_t ICameraRecordingProxy::getCommonBaseAddress() {
    return (size_t)&baseObject;
}
 
 class BpCameraRecordingProxy: public BpInterface<ICameraRecordingProxy>
 {
 

  
 
 };  
","The camera APIs in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allow attackers to bypass intended access restrictions and obtain sensitive information about ANW buffer addresses via a crafted application, aka internal bug 28466701."
2269,CVE-2016-3830," 

                         signalError = true;
                     } else {
                         adtsHeaderSize = (protectionAbsent ? 7 : 9);
                        if (aac_frame_length < adtsHeaderSize) {
                            signalError = true;
                        } else {
                            inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
                            inBufferLength[0] = aac_frame_length - adtsHeaderSize;
 
                            inHeader->nOffset += adtsHeaderSize;
                            inHeader->nFilledLen -= adtsHeaderSize;
                        }
                     }
                 }
 
","codecs/aacdec/SoftAAC2.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows remote attackers to cause a denial of service (device hang or reboot) via crafted ADTS data, aka internal bug 29153599."
2270,CVE-2016-3829," 

     ps_dec->cur_dec_mb_num = 0;
     ps_dec->cur_recon_mb_num = 0;
     ps_dec->u4_first_slice_in_pic = 2;
    ps_dec->u1_first_pb_nal_in_pic = 1;
     ps_dec->u1_slice_header_done = 0;
     ps_dec->u1_dangling_field = 0;
 
","The ih264d decoder in mediaserver in Android 6.x before 2016-08-01 does not initialize certain structure members, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29023649."
2271,CVE-2016-3828," 

             if((ret == IVD_RES_CHANGED)
                             || (ret == IVD_MEM_ALLOC_FAILED)
                             || (ret == ERROR_UNAVAIL_PICBUF_T)
                            || (ret == ERROR_UNAVAIL_MVBUF_T)
                            || (ret == ERROR_INV_SPS_PPS_T))
             {
                ps_dec->u4_slice_start_code_found = 0;
                 break;
             }
 
 

     if((ret == IVD_RES_CHANGED)
                     || (ret == IVD_MEM_ALLOC_FAILED)
                     || (ret == ERROR_UNAVAIL_PICBUF_T)
                    || (ret == ERROR_UNAVAIL_MVBUF_T)
                    || (ret == ERROR_INV_SPS_PPS_T))
     {
 
          
","decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-08-01 mishandles invalid PPS and SPS NAL units, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28835995."
2272,CVE-2016-3827," 

 
     if (NULL == mCodecCtx) {
         if (OK != initDecoder()) {
            ALOGE(""Failed to initialize decoder"");
            notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);
            mSignalledError = true;
             return;
         }
     }
 

             IV_API_CALL_STATUS_T status;
             status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);
 
            bool unsupportedResolution =
                (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == (s_dec_op.u4_error_code & 0xFF));

             
            if (unsupportedResolution) {
                ALOGE(""Unsupported resolution : %dx%d"", mWidth, mHeight);
                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);
                mSignalledError = true;
                return;
            }

            bool allocationFailed = (IVD_MEM_ALLOC_FAILED == (s_dec_op.u4_error_code & 0xFF));
            if (allocationFailed) {
                ALOGE(""Allocation failure in decoder"");
                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, 0, NULL);
                mSignalledError = true;
                return;
            }

             bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));
 
             GETTIME(&mTimeEnd, NULL);
","codecs/hevcdec/SoftHEVC.cpp in libstagefright in mediaserver in Android 6.0.1 before 2016-08-01 mishandles decoder errors, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28816956."
2273,CVE-2016-3826," 

     if (mStatus != NO_ERROR) {
         return mStatus;
     }
    if (cmdCode == EFFECT_CMD_GET_PARAM &&
            (*replySize < sizeof(effect_param_t) ||
                    ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {
        android_errorWriteLog(0x534e4554, ""29251553"");
        return -EINVAL;
    }
     status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                    cmdCode,
                                                    cmdSize,
","services/audioflinger/Effects.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 does not validate the reply size for an AudioFlinger effect command, which allows attackers to gain privileges via a crafted application, aka internal bug 29251553."
2274,CVE-2016-3825," 

              
              
             m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
            (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);
         }
 
         (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;
 

                  
                  
                 m_pOutput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
                (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);
                 native_handle_t *handle = native_handle_create(1, 0);
                 handle->data[0] = m_pOutput_pmem[i].fd;
                 char *data = (char*) m_pOutput_pmem[i].buffer;
","mm-video-v4l2/vidc/venc/src/omx_video_base.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allocates an incorrect amount of memory, which allows attackers to gain privileges via a crafted application, aka internal bug 28816964."
2275,CVE-2016-3824," 

 
      
     OMX::buffer_id makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
    OMX_BUFFERHEADERTYPE *findBufferHeader(OMX::buffer_id buffer, OMX_U32 portIndex);
     OMX::buffer_id findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     void invalidateBufferID(OMX::buffer_id buffer);
 
","omx/OMXNodeInstance.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 does not validate the buffer port, which allows attackers to gain privileges via a crafted application, aka internal bug 28816827."
2276,CVE-2016-3822," 

             unsigned OffsetVal;
             OffsetVal = Get32u(DirEntry+8);
              
            if (OffsetVal > UINT32_MAX - ByteCount || OffsetVal+ByteCount > ExifLength){
                  
                 ErrNonfatal(""Illegal value pointer for tag %04x"", Tag,0);
                 continue;
","exif.c in Matthias Wandel jhead 2.87, as used in libjhead in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01, allows remote attackers to execute arbitrary code or cause a denial of service (out-of-bounds access) via crafted EXIF data, aka internal bug 28868315."
2277,CVE-2016-3821," 

     virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }
 
     virtual void died() = 0;
    static const sp<IMediaPlayerService> getMediaPlayerService();
 
 private:
     IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);
","libmedia in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 has certain incorrect declarations, which allows remote attackers to execute arbitrary code or cause a denial of service (NULL pointer dereference or memory corruption) via a crafted media file, aka internal bug 28166152."
2278,CVE-2016-3820," 

     ps_dec->u4_dec_thread_created = 0;
     ps_dec->u4_bs_deblk_thread_created = 0;
     ps_dec->u4_cur_bs_mb_num = 0;
    ps_dec->u4_start_recon_deblk  = 0;
 
     DEBUG_THREADS_PRINTF("" Starting process call\n"");
 
","The ih264d decoder in mediaserver in Android 6.x before 2016-08-01 mishandles slice numbers, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28673410."
2279,CVE-2016-3819," 

 #include ""h264bsd_util.h""
 #include ""basetype.h""
 
#include <log/log.h>
 /*------------------------------------------------------------------------------
     2. External compiler flags
 --------------------------------------------------------------------------------
 

     ASSERT(maxFrameNum);
     ASSERT(dpbSize);
 
     
    if (picSizeInMbs > (UINT32_MAX - 32 - 15) / 384) {
        ALOGE(""b/28533562"");
        android_errorWriteLog(0x534e4554, ""28533562"");
        return(MEMORY_ALLOCATION_ERROR);
    }

     dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;
     dpb->maxRefFrames        = MAX(maxRefFrames, 1);
     if (noReordering)
","Integer overflow in codecs/on2/h264dec/source/h264bsd_dpb.c in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28533562."
2280,CVE-2016-3766," 

     }
     if (psshsize > 0 && psshsize <= UINT32_MAX) {
         char *buf = (char*)malloc(psshsize);
        if (!buf) {
            ALOGE(""b/28471206"");
            return NO_MEMORY;
        }
         char *ptr = buf;
         for (size_t i = 0; i < mPssh.size(); i++) {
             memcpy(ptr, mPssh[i].uuid, 20);  
 

 
             sp<ABuffer> buffer = new ABuffer(chunk_data_size);
 
            if (buffer->data() == NULL) {
                ALOGE(""b/28471206"");
                return NO_MEMORY;
            }

             if (mDataSource->readAt(
                         data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                 return ERROR_IO;
 

         {
             sp<ABuffer> buffer = new ABuffer(chunk_data_size);
 
            if (buffer->data() == NULL) {
                ALOGE(""b/28471206"");
                return NO_MEMORY;
            }

             if (mDataSource->readAt(
                         data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                 return ERROR_IO;
 

                     return ERROR_MALFORMED;
                 }
                 sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);
                if (buffer->data() == NULL) {
                    ALOGE(""b/28471206"");
                    return NO_MEMORY;
                }
                 if (mDataSource->readAt(
                     data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
                     return ERROR_IO;
","MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not check whether memory allocation succeeds, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted file, aka internal bug 28471206."
2281,CVE-2016-3765," 

 INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
    if ((ps_stream->u4_offset + 64) < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
    else
    {
        UWORD32     u4_temp;

        if (((ps_stream->u4_offset & 0x1f) + u4_no_of_bits) >= 32)
        {
            ps_stream->u4_buf              = ps_stream->u4_buf_nxt;
            ps_stream->u4_buf_nxt          = 0;
        }
        ps_stream->u4_offset += u4_no_of_bits;
    }
     return;
 }
 /******************************************************************************
","decoder/impeg2d_bitstream.c in mediaserver in Android 6.x before 2016-07-01 allows attackers to obtain sensitive information from process memory or cause a denial of service (out-of-bounds read) via a crafted application, aka internal bug 28168413."
2282,CVE-2016-3764," 

     ALOGV(""rotation: %d"", frameCopy->mRotationAngle);
     frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);
     memcpy(frameCopy->mData, frame->mData, frame->mSize);
    frameCopy->mData = 0;
     delete frame;   
     return mThumbnail;
 }
","media/libmediaplayerservice/MetadataRetrieverClient.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to obtain sensitive pointer information via a crafted application, aka internal bug 28377502."
2283,CVE-2016-3760," 

 
  
bool is_restricted_mode(void);

/*******************************************************************************
**
 ** Function         btif_get_adapter_properties
 **
 ** Description      Fetches all local adapter properties
","Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683."
2284,CVE-2016-3758," 

             ALOGE(""Can't get CWD while opening jar file"");
             return NULL;
         }
        strncat(absoluteFile, ""/"", kBufLen - strlen(absoluteFile));
     }
    strncat(absoluteFile, fileName, kBufLen - strlen(absoluteFile));
 
      
     if (subFileName != NULL) {
        strncat(absoluteFile, ""/"", kBufLen - strlen(absoluteFile));
        strncat(absoluteFile, subFileName, kBufLen - strlen(absoluteFile));
     }
 
      
    strncat(nameBuf, absoluteFile, kBufLen - strlen(nameBuf));
 
     ALOGV(""Cache file for '%s' '%s' is '%s'"", fileName, subFileName, nameBuf);
     return strdup(nameBuf);
","Multiple buffer overflows in libdex/OptInvocation.cpp in DexClassLoader in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allow attackers to gain privileges via a crafted application that provides a long filename, aka internal bug 27840771."
2285,CVE-2016-3757," 

 static void print_maps(struct pid_info_t* info)
 {
     FILE *maps;

     size_t offset;
     char device[10];
     long int inode;
    char file[1024];
 
     strlcat(info->path, ""maps"", sizeof(info->path));
 
 

     if (!maps)
         goto out;
 
    while (fscanf(maps, ""%*x-%*x %*s %zx %5s %ld %1023s\n"",
                  &offset, device, &inode, file) == 4) {
          
         if (inode == 0 || !strcmp(device, ""00:00""))
             continue;
","The print_maps function in toolbox/lsof.c in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows user-assisted attackers to gain privileges via a crafted application that attempts to list a long name of a memory-mapped file, aka internal bug 28175237.  NOTE: print_maps is not related to the Vic Abell lsof product."
2286,CVE-2016-3756," 

 
  
 int res_unpack(vorbis_info_residue *info,
                vorbis_info *vi,oggpack_buffer *opb){
   int j,k;
   codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;
   memset(info,0,sizeof(*info));
 

   for(j=0;j<info->partitions;j++){
     for(k=0;k<8;k++){
       if((info->stagemasks[j]>>k)&1){
        unsigned char book=(unsigned char)oggpack_read(opb,8);
        if(book>=ci->books)goto errout;
        info->stagebooks[j*8+k]=book;
        if(k+1>info->stages)info->stages=k+1;
       }else
        info->stagebooks[j*8+k]=0xff;
     }
   }
 
 

 }
 
 int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,
                ogg_int32_t **in,int *nonzero,int ch){
 
   int i,j,k,s,used=0;
   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;
 

       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
 
       for(i=0;i<ch;i++)
        if(nonzero[i])
          in[used++]=in[i];
       ch=used;
 
       if(used){
 
        char **partword=(char **)alloca(ch*sizeof(*partword));
        for(j=0;j<ch;j++)
          partword[j]=(char *)alloca(partwords*partitions_per_word*
                                     sizeof(*partword[j]));
 
        for(s=0;s<info->stages;s++){
 
          for(i=0;i<partvals;){
            if(s==0){
               
 
              partword[0][i+partitions_per_word-1]=1;
              for(k=partitions_per_word-2;k>=0;k--)
                partword[0][i+k]=partword[0][i+k+1]*info->partitions;
 
              for(j=1;j<ch;j++)
                for(k=partitions_per_word-1;k>=0;k--)
                  partword[j][i+k]=partword[j-1][i+k];
 
              for(j=0;j<ch;j++){
                int temp=vorbis_book_decode(phrasebook,&vd->opb);
                if(temp==-1)goto eopbreak;
 
                 
                for(k=0;k<partitions_per_word;k++){
                  ogg_uint32_t div=partword[j][i+k];
                  partword[j][i+k]=temp/div;
                  temp-=partword[j][i+k]*div;
                }
 
              }
            }
 
             
            for(k=0;k<partitions_per_word && i<partvals;k++,i++)
              for(j=0;j<ch;j++){
                long offset=info->begin+i*samples_per_partition;
                int idx = (int)partword[j][i];
                if(idx < info->partitions && info->stagemasks[idx]&(1<<s)){
                  codebook *stagebook=ci->book_param+
                    info->stagebooks[(partword[j][i]<<3)+s];
                  if(info->type){
                    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,
                                               samples_per_partition,-8)==-1)
                      goto eopbreak;
                  }else{
                    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,
                                                samples_per_partition,-8)==-1)
                      goto eopbreak;
                  }
                }
              }
          }
        }
       }
     }
   }else{
 

       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
 
       char *partword=
        (char *)alloca(partwords*partitions_per_word*sizeof(*partword));
       int beginoff=info->begin/ch;
 
       for(i=0;i<ch;i++)if(nonzero[i])break;
","Tremolo/res012.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate the number of partitions, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28556125."
2287,CVE-2016-3755," 

         ih264d_err_pic_dispbuf_mgr(ps_dec);
         return 0;
     }
    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
     if(prev_slice_err == 1)
     {
          
","decoder/ih264d_parse_pslice.c in mediaserver in Android 6.x before 2016-07-01 does not properly select concealment frames, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28470138."
2288,CVE-2016-3750," 

 
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
        if (h->data[i] < 0) {
            for (int j = 0; j < i; j++) {
                close(h->data[j]);
            }
            native_handle_delete(h);
            return 0;
        }
     }
     err = read(h->data + numFds, sizeof(int)*numInts);
     if (err != NO_ERROR) {
","libs/binder/Parcel.cpp in the Parcels Framework APIs in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate the return value of the dup system call, which allows attackers to bypass an isolation protection mechanism via a crafted application, aka internal bug 28395952."
2289,CVE-2016-3747," 

     }
 
     if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {
        auto_lock l(m_lock);

         if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {
             DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case"");
             if(!secure_session) {
 

             } else {
                 free(m_pInput_pmem[index].buffer);
             }
            m_pInput_pmem[index].buffer = NULL;
             close (m_pInput_pmem[index].fd);
 #ifdef USE_ION
             free_ion_memory(&m_pInput_ion[index]);
 

                 DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf"");
             }
             if(!secure_session) {
                munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);
                m_pInput_pmem[index].buffer = NULL;
             }
             close (m_pInput_pmem[index].fd);
 #ifdef USE_ION
 

     unsigned int nBufferIndex ;
 
     DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", buffer, buffer->pBuffer);
    if (m_state != OMX_StateExecuting &&
            m_state != OMX_StatePause &&
            m_state != OMX_StateIdle) {
         DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
         return OMX_ErrorInvalidState;
     }
 

 #endif
     {
         DEBUG_PRINT_LOW(""Heap UseBuffer case, so memcpy the data"");

        auto_lock l(m_lock);
         pmem_data_buf = (OMX_U8 *)m_pInput_pmem[nBufIndex].buffer;
        if (pmem_data_buf) {
            memcpy (pmem_data_buf, (buffer->pBuffer + buffer->nOffset),
                    buffer->nFilledLen);
        }
         DEBUG_PRINT_LOW(""memcpy() done in ETBProxy for i/p Heap UseBuf"");
     } else if (mUseProxyColorFormat) {
          
 

         OMX_IN OMX_BUFFERHEADERTYPE* buffer)
 {
     DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", buffer->pBuffer);
    if (m_state != OMX_StateExecuting &&
            m_state != OMX_StatePause &&
            m_state != OMX_StateIdle) {
         DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
         return OMX_ErrorInvalidState;
     }
","Use-after-free vulnerability in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27903498."
2290,CVE-2016-3746," 

 
 #ifdef _ANDROID_
 #include <cstdio>
#include <pthread.h>
 
 enum {
    PRIO_ERROR=0x1,
 

         }                                                                      \
     }                                                                          \
 
class auto_lock {
    public:
        auto_lock(pthread_mutex_t &lock)
            : mLock(lock) {
                pthread_mutex_lock(&mLock);
            }
        ~auto_lock() {
            pthread_mutex_unlock(&mLock);
        }
    private:
        pthread_mutex_t &mLock;
};

 #endif
","Use-after-free vulnerability in the mm-video-v4l2 vdec component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27890802."
2291,CVE-2016-3745," 

         if (pCmdData == NULL ||
             cmdSize < (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
             pReplyData == NULL ||
            *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint16_t)) ||
             
            ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t)) {
             status = -EINVAL;
             ALOGV(""EFFECT_CMD_GET_PARAM invalid command cmdSize %d *replySize %d"",
                   cmdSize, *replySize);
","Multiple buffer overflows in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allow attackers to gain privileges via a crafted application that provides an AudioEffect reply, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 28173666."
2292,CVE-2016-3744," 

 
 #define LOG_TAG ""bt_btif_hh""
 
#include <cutils/log.h>

 #include ""bta_api.h""
 #include ""bta_hh_api.h""
 #include ""btif_storage.h""
 

 *******************************************************************************/
 static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)
 {
    UINT16 buflen = (UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR));
    if (buflen < len) {
      android_errorWriteWithInfoLog(0x534e4554, ""28672558"", -1, NULL, 0);
      return NULL;
    }
    BT_HDR* p_buf = GKI_getbuf(buflen);
 
     if (p_buf) {
         UINT8* pbuf_data;
","Buffer overflow in the create_pbuf function in btif/src/btif_hh.c in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows remote attackers to gain privileges via a crafted pairing operation, aka internal bug 27930580."
2293,CVE-2016-3743," 

     dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;
     dec_slice_params_t *ps_cur_slice;
     pocstruct_t *ps_prev_poc, *ps_cur_poc;
    WORD32 size;

    size = sizeof(pred_info_t) * 2 * 32;
    memset(ps_dec->ps_pred, 0 , size);

    size = sizeof(disp_mgr_t);
    memset(ps_dec->pv_disp_buf_mgr, 0 , size);

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    memset(ps_dec->pv_pic_buf_mgr, 0, size);

    size = sizeof(dec_err_status_t);
    memset(ps_dec->ps_dec_err_status, 0, size);

    size = sizeof(sei);
    memset(ps_dec->ps_sei, 0, size);

    size = sizeof(dpb_commands_t);
    memset(ps_dec->ps_dpb_cmds, 0, size);

    size = sizeof(dec_bit_stream_t);
    memset(ps_dec->ps_bitstrm, 0, size);

    size = sizeof(dec_slice_params_t);
    memset(ps_dec->ps_cur_slice, 0, size);

    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
    memset(ps_dec->pv_scratch_sps_pps, 0, size);

    size = sizeof(ctxt_inc_mb_info_t);
    memset(ps_dec->ps_left_mb_ctxt_info, 0, size);

    size = (sizeof(neighbouradd_t) << 2);
    memset(ps_dec->ps_left_mvpred_addr, 0 ,size);

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    memset(ps_dec->pv_mv_buf_mgr, 0, size);
 
      
     ih264d_free_dynamic_bufs(ps_dec);
","decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-07-01 does not initialize certain data structures, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 27907656."
2294,CVE-2016-3742," 

                                                     + (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]
                                                                     >= i1_intra_pred);
                 }
                i1_intra_pred = CLIP3(0, 8, i1_intra_pred);
                 {
                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];
 
 

                                     + (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]
                                                     >= i1_intra_pred);
                 }
                i1_intra_pred = CLIP3(0, 8, i1_intra_pred);
                 {
                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];
 
","decoder/ih264d_process_intra_mb.c in mediaserver in Android 6.x before 2016-07-01 mishandles intra mode, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28165659."
2295,CVE-2016-3741," 

            (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
     memset(ps_dec->u4_disp_buf_to_be_freed, 0,
            (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
    memset(ps_dec->ps_cur_slice, 0, sizeof(dec_slice_params_t));
 
     ih264d_init_arch(ps_dec);
     ih264d_init_function_ptr(ps_dec);
","The H.264 decoder in mediaserver in Android 6.x before 2016-07-01 does not initialize certain slice data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28165661."
2296,CVE-2016-2508," 

 
     for (size_t i = 0; i < numtracks; ++i) {
         sp<MediaSource> track = extractor->getTrack(i);
        if (track == NULL) {
            continue;
        }
 
         sp<MetaData> meta = extractor->getTrackMetaData(i);
 
 

             }
         }
 
        mSources.push(track);
        int64_t durationUs;
        if (meta->findInt64(kKeyDuration, &durationUs)) {
            if (durationUs > mDurationUs) {
                mDurationUs = durationUs;
             }
         }

        int32_t bitrate;
        if (totalBitrate >= 0 && meta->findInt32(kKeyBitRate, &bitrate)) {
            totalBitrate += bitrate;
        } else {
            totalBitrate = -1;
        }
    }

    if (mSources.size() == 0) {
        ALOGE(""b/23705695"");
        return UNKNOWN_ERROR;
     }
 
     mBitrate = totalBitrate;
 

 
 status_t NuPlayer::GenericSource::setBuffers(
         bool audio, Vector<MediaBuffer *> &buffers) {
    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {
         return mVideoTrack.mSource->setBuffers(buffers);
     }
     return INVALID_OPERATION;
","media/libmediaplayerservice/nuplayer/GenericSource.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate certain track data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28799341."
2297,CVE-2016-2507," 

     3. Module defines
 ------------------------------------------------------------------------------*/
 
#ifndef UINT32_MAX
#define UINT32_MAX       (4294967295U)
#endif

  
 

         pStorage->activePps = pStorage->pps[ppsId];
         pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;
         pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];

         
        if (pStorage->activeSps->picWidthInMbs == 0)
        {
            pStorage->picSizeInMbs = 0;
        }
        else if (pStorage->activeSps->picHeightInMbs >
                 UINT32_MAX / pStorage->activeSps->picWidthInMbs)
        {
            return(MEMORY_ALLOCATION_ERROR);
        }
        else
        {
            pStorage->picSizeInMbs =
                pStorage->activeSps->picWidthInMbs *
                pStorage->activeSps->picHeightInMbs;
        }
 
         pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;
         pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;
","Integer overflow in codecs/on2/h264dec/source/h264bsd_storage.c in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28532266."
2298,CVE-2016-2506," 

                 continue;
             }
 
            if (dstOffset > SIZE_MAX - 4 ||
                dstOffset + 4 > SIZE_MAX - nalLength ||
                dstOffset + 4 + nalLength > (*buffer)->size()) {
                (*buffer)->release();
                (*buffer) = NULL;
                if (decryptedDrmBuffer.data) {
                    delete [] decryptedDrmBuffer.data;
                    decryptedDrmBuffer.data = NULL;
                }
                return ERROR_MALFORMED;
            }
 
             dstData[dstOffset++] = 0;
             dstData[dstOffset++] = 0;
","DRMExtractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate a certain offset value, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28175045."
2299,CVE-2016-2505," 

     unsigned sectionLength = U16_AT(data + 1) & 0xfff;
     ALOGV(""sectionLength %u, skip %u"", sectionLength, mSkipBytes);
 

    if(sectionLength < mSkipBytes) {
        ALOGE(""b/28333006"");
        android_errorWriteLog(0x534e4554, ""28333006"");
        return false;
    }

      
     sectionLength -= mSkipBytes;
 
","mpeg2ts/ATSParser.cpp in libstagefright in mediaserver in Android 6.x before 2016-07-01 does not validate a certain section length, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28333006."
2300,CVE-2016-2499," 

     : mStarted(false),
       mSampleRate(sampleRate),
       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),
      mTrackMaxAmplitude(false),
      mStartTimeUs(0),
      mMaxAmplitude(0),
       mPrevSampleTimeUs(0),
       mFirstSampleTimeUs(-1ll),
      mInitialReadTimeUs(0),
       mNumFramesReceived(0),
       mNumClientOwnedBuffers(0) {
     ALOGV(""sampleRate: %u, outSampleRate: %u, channelCount: %u"",
","AudioSource.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not initialize certain data, which allows attackers to obtain sensitive information via a crafted application, aka internal bug 27855172."
2301,CVE-2016-2495," 

       mSampleSizeFieldSize(0),
       mDefaultSampleSize(0),
       mNumSampleSizes(0),
      mHasTimeToSample(false),
       mTimeToSampleCount(0),
       mTimeToSample(),
       mSampleTimeEntries(NULL),
 

     return mChunkOffsetOffset >= 0
         && mSampleToChunkOffset >= 0
         && mSampleSizeOffset >= 0
        && mHasTimeToSample;
 }
 
 status_t SampleTable::setChunkOffsetParams(
 

 
 status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (mHasTimeToSample || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 

     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }

    mHasTimeToSample = true;
     return OK;
 }
 
","SampleTable.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to cause a denial of service (device hang or reboot) via a crafted file, aka internal bug 28076789."
2302,CVE-2016-2494," 

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
         if (pathlen < 0) {
             return -1;
         }
","Off-by-one error in sdcard/sdcard.c in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 28085658."
2303,CVE-2016-2487," 

 
         const uint8_t *data = inHeader->pBuffer + inHeader->nOffset;
         const uint32_t size = inHeader->nFilledLen;
        size_t frameSize = kMaxOpusOutputPacketSizeSamples;
        if (frameSize > outHeader->nAllocLen / sizeof(int16_t) / mHeader->channels) {
            frameSize = outHeader->nAllocLen / sizeof(int16_t) / mHeader->channels;
            android_errorWriteLog(0x534e4554, ""27833616"");
        }
 
         int numFrames = opus_multistream_decode(mDecoder,
                                                 data,
                                                 size,
                                                 (int16_t *)outHeader->pBuffer,
                                                frameSize,
                                                 0);
         if (numFrames < 0) {
             ALOGE(""opus_multistream_decode returned %d"", numFrames);
","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27833616."
2304,CVE-2016-2486," 

         mConfig->inputBufferUsedLength = 0;
 
         mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
        if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {
            ALOGE(""input buffer too small: got %lu, expected %u"",
                outHeader->nAllocLen, mConfig->outputFrameSize);
            android_errorWriteLog(0x534e4554, ""27793371"");
            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
            mSignalledError = true;
            return;
        }
 
         mConfig->pOutputBuffer =
             reinterpret_cast<int16_t *>(outHeader->pBuffer);
","mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate the relationship between allocated memory and the frame size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27793371."
2305,CVE-2016-2485," 

             mSignalledError = true;
         }
 
        if (inHeader->nFilledLen * sizeof(int16_t) > outHeader->nAllocLen) {
            ALOGE(""output buffer too small (%d)."", outHeader->nAllocLen);
            android_errorWriteLog(0x534e4554, ""27793163"");

            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

         const uint8_t *inputptr = inHeader->pBuffer + inHeader->nOffset;
 
         if (mIsMLaw) {
","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes for the GSM and G711 codecs, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27793367."
2306,CVE-2016-2483," 

 /*--------------------------------------------------------------------------
Copyright (c) 2010-2016, The Linux Foundation. All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 

         & BITMASK_FLAG(mIndex))
 #define BITMASK_ABSENT(mArray,mIndex) (((mArray)[BITMASK_OFFSET(mIndex)] \
             & BITMASK_FLAG(mIndex)) == 0x0)

 #define MAX_NUM_INPUT_BUFFERS 64
#define MAX_NUM_OUTPUT_BUFFERS 64

 void* message_thread(void *);
 
  
","The mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 mishandles a buffer count, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27662502."
2307,CVE-2016-2482," 

 #define DESC_BUFFER_SIZE (8192 * 16)
 
 #ifdef _ANDROID_
#define MAX_NUM_INPUT_OUTPUT_BUFFERS 64
 #endif
 
 #ifdef _ION_HEAP_MASK_COMPATIBILITY_WA
","The mm-video-v4l2 vdec component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 mishandles a buffer count, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27661749."
2308,CVE-2016-2480," 

  
","The mm-video-v4l2 vidc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate certain OMX parameter data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27532721."
2309,CVE-2016-2478," 

 
     DEBUG_PRINT_LOW(""Set Config Called"");
 
    if (configIndex == OMX_IndexConfigVideoNalSize) {
         struct v4l2_control temp;
         temp.id = V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT;
 
","mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 mishandles pointers, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27475409."
2310,CVE-2016-2476," 

         kPreferSoftwareCodecs    = 1,
         kIgnoreCodecSpecificData = 2,
 
          
          
         kSoftwareCodecsOnly      = 8,
","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
2311,CVE-2016-2464," 

  
 
 #include ""mkvparser.hpp""

 #include <cassert>
#include <climits>
#include <cmath>
 #include <cstring>
 #include <new>
 
 #ifdef _MSC_VER
  
 #pragma warning(disable : 4996)
 #endif
 
namespace mkvparser {
 
IMkvReader::~IMkvReader() {}

template<typename Type> Type* SafeArrayAlloc(unsigned long long num_elements,
                                             unsigned long long element_size) {
  if (num_elements == 0 || element_size == 0)
    return NULL;

  const size_t kMaxAllocSize = 0x80000000;   
  const unsigned long long num_bytes = num_elements * element_size;
  if (element_size > (kMaxAllocSize / num_elements))
    return NULL;

  return new (std::nothrow) Type[num_bytes];
}

void GetVersion(int& major, int& minor, int& build, int& revision) {
   major = 1;
   minor = 0;
   build = 0;
  revision = 30;
 }
 
long long ReadUInt(IMkvReader* pReader, long long pos, long& len) {
  if (!pReader || pos < 0)
    return E_FILE_FORMAT_INVALID;
 
   len = 1;
   unsigned char b;
  int status = pReader->Read(pos, 1, &b);
 
   if (status < 0)   
     return status;
 

     ++len;
   }
 
   long long result = b & (~m);
   ++pos;
 
 

   return result;
 }
 
long long ReadID(IMkvReader* pReader, long long pos, long& len) {
  const long long id = ReadUInt(pReader, pos, len);
  if (id < 0 || len < 1 || len > 4) {
     
     
    return E_FILE_FORMAT_INVALID;
  }
  return id;
}

long long GetUIntLength(IMkvReader* pReader, long long pos, long& len) {
  if (!pReader || pos < 0)
    return E_FILE_FORMAT_INVALID;
 
   long long total, available;
 
   int status = pReader->Length(&total, &available);
  if (status < 0 || (total >= 0 && available > total))
    return E_FILE_FORMAT_INVALID;
 
   len = 1;
 
 

 
   status = pReader->Read(pos, 1, &b);
 
  if (status != 0)
     return status;
 
   if (b == 0)   
     return E_FILE_FORMAT_INVALID;
 
 

 
  
  
long long UnserializeUInt(IMkvReader* pReader, long long pos, long long size) {
  if (!pReader || pos < 0 || (size <= 0) || (size > 8))
     return E_FILE_FORMAT_INVALID;
 
   long long result = 0;
 

   return result;
 }
 
long UnserializeFloat(IMkvReader* pReader, long long pos, long long size_,
                      double& result) {
  if (!pReader || pos < 0 || ((size_ != 4) && (size_ != 8)))
     return E_FILE_FORMAT_INVALID;
 
   const long size = static_cast<long>(size_);
 

 
     result = f;
   } else {
     union {
       double d;
       unsigned long long dd;
 

     result = d;
   }
 
  if (std::isinf(result) || std::isnan(result))
    return E_FILE_FORMAT_INVALID;

   return 0;
 }
 
long UnserializeInt(IMkvReader* pReader, long long pos, long long size,
                    long long& result_ref) {
  if (!pReader || pos < 0 || size < 1 || size > 8)
    return E_FILE_FORMAT_INVALID;
 
  signed char first_byte = 0;
  const long status = pReader->Read(pos, 1, (unsigned char*)&first_byte);
 
  if (status < 0)
    return status;
 
  unsigned long long result = first_byte;
  ++pos;
 
   for (long i = 1; i < size; ++i) {
     unsigned char b;
 

     ++pos;
   }
 
  result_ref = static_cast<long long>(result);
  return 0;
 }
 
long UnserializeString(IMkvReader* pReader, long long pos, long long size,
                       char*& str) {
   delete[] str;
   str = NULL;
 
  if (size >= LONG_MAX || size < 0)
     return E_FILE_FORMAT_INVALID;
 
   
  const long required_size = static_cast<long>(size) + 1;
 
  str = SafeArrayAlloc<char>(1, required_size);
   if (str == NULL)
    return E_FILE_FORMAT_INVALID;
 
   unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
 
 

     return status;
   }
 
  str[required_size - 1] = '\0';
  return 0;
 }
 
long ParseElementHeader(IMkvReader* pReader, long long& pos,
                        long long stop, long long& id,
                        long long& size) {
  if (stop >= 0 && pos >= stop)
     return E_FILE_FORMAT_INVALID;
 
   long len;
 
  id = ReadID(pReader, pos, len);
 
   if (id < 0)
     return E_FILE_FORMAT_INVALID;
 
   pos += len;   
 
  if (stop >= 0 && pos >= stop)
     return E_FILE_FORMAT_INVALID;
 
   size = ReadUInt(pReader, pos, len);
 
  if (size < 0 || len < 1 || len > 8) {
     
     
    return E_FILE_FORMAT_INVALID;
  }

   
  const unsigned long long rollover_check =
      static_cast<unsigned long long>(pos) + len;
  if (rollover_check > LONG_LONG_MAX)
     return E_FILE_FORMAT_INVALID;
 
   pos += len;   
 
    
 
  if (stop >= 0 && pos >= stop)
     return E_FILE_FORMAT_INVALID;
 
   return 0;   
 }
 
bool Match(IMkvReader* pReader, long long& pos, unsigned long expected_id,
           long long& val) {
  if (!pReader || pos < 0)
     return false;
 
  long long total = 0;
  long long available = 0;
 
  const long status = pReader->Length(&total, &available);
  if (status < 0 || (total >= 0 && available > total))
    return false;
 
  long len = 0;

  const long long id = ReadID(pReader, pos, len);
  if (id < 0 || (available - pos) > len)
    return false;

  if (static_cast<unsigned long>(id) != expected_id)
     return false;
 
   pos += len;   
 
   const long long size = ReadUInt(pReader, pos, len);
  if (size < 0 || size > 8 || len < 1 || len > 8 || (available - pos) > len)
    return false;
 
   pos += len;   
 
   val = UnserializeUInt(pReader, pos, size);
  if (val < 0)
    return false;
 
   pos += size;   
 
   return true;
 }
 
bool Match(IMkvReader* pReader, long long& pos, unsigned long expected_id,
           unsigned char*& buf, size_t& buflen) {
  if (!pReader || pos < 0)
     return false;
 
  long long total = 0;
  long long available = 0;
 
  long status = pReader->Length(&total, &available);
  if (status < 0 || (total >= 0 && available > total))
    return false;

  long len = 0;
  const long long id = ReadID(pReader, pos, len);
  if (id < 0 || (available - pos) > len)
    return false;

  if (static_cast<unsigned long>(id) != expected_id)
     return false;
 
   pos += len;   
 
  const long long size = ReadUInt(pReader, pos, len);
  if (size < 0 || len <= 0 || len > 8 || (available - pos) > len)
    return false;

  unsigned long long rollover_check =
      static_cast<unsigned long long>(pos) + len;
  if (rollover_check > LONG_LONG_MAX)
    return false;
 
   pos += len;   
 
  rollover_check = static_cast<unsigned long long>(pos) + size;
  if (rollover_check > LONG_LONG_MAX)
    return false;
 
  if ((pos + size) > available)
    return false;

  if (size >= LONG_MAX)
    return false;

  const long buflen_ = static_cast<long>(size);

  buf = SafeArrayAlloc<unsigned char>(1, buflen_);
  if (!buf)
    return false;
 
   status = pReader->Read(pos, buflen_, buf);
  if (status != 0)
    return false;
 
   buflen = buflen_;
 
  pos += size;   
   return true;
 }
 
 EBMLHeader::EBMLHeader() : m_docType(NULL) { Init(); }
 
 EBMLHeader::~EBMLHeader() { delete[] m_docType; }
 

 }
 
 long long EBMLHeader::Parse(IMkvReader* pReader, long long& pos) {
  if (!pReader)
    return E_FILE_FORMAT_INVALID;
 
   long long total, available;
 
 

   if (result > 0)   
     return result;
 
  if (len < 1 || len > 8)
    return E_FILE_FORMAT_INVALID;
 
   if ((total >= 0) && ((total - pos) < len))
     return E_FILE_FORMAT_INVALID;
 

     pos += size;
   }
 
  if (pos != end)
    return E_FILE_FORMAT_INVALID;

   return 0;
 }
 
 

       m_pTracks(NULL),
       m_pCues(NULL),
       m_pChapters(NULL),
      m_pTags(NULL),
       m_clusters(NULL),
       m_clusterCount(0),
       m_clusterPreloadCount(0),
 

 
   while (i != j) {
     Cluster* const p = *i++;
     delete p;
   }
 
 

   delete m_pInfo;
   delete m_pCues;
   delete m_pChapters;
  delete m_pTags;
   delete m_pSeekHead;
 }
 
 long long Segment::CreateInstance(IMkvReader* pReader, long long pos,
                                   Segment*& pSegment) {
  if (pReader == NULL || pos < 0)
    return E_PARSE_FAILED;
 
   pSegment = NULL;
 
 

       return pos + len;
 
     const long long idpos = pos;
    const long long id = ReadID(pReader, pos, len);
 
    if (id < 0)
      return E_FILE_FORMAT_INVALID;
 
     pos += len;   
 
 

   if (status < 0)   
     return status;
 
  if (total > 0 && available > total)
    return E_FILE_FORMAT_INVALID;
 
   const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

  if ((segment_stop >= 0 && total >= 0 && segment_stop > total) ||
      (segment_stop >= 0 && m_pos > segment_stop)) {
    return E_FILE_FORMAT_INVALID;
  }
 
   for (;;) {
     if ((total >= 0) && (m_pos >= total))
 

     long long pos = m_pos;
     const long long element_start = pos;
 
     
    unsigned long long rollover_check = pos + 1ULL;
    if (rollover_check > LONG_LONG_MAX)
      return E_FILE_FORMAT_INVALID;

     if ((pos + 1) > available)
       return (pos + 1);
 
 

     if (result < 0)   
       return result;
 
    if (result > 0) {
       
       return (pos + 1);
    }
 
     if ((segment_stop >= 0) && ((pos + len) > segment_stop))
       return E_FILE_FORMAT_INVALID;
 

       return pos + len;
 
     const long long idpos = pos;
    const long long id = ReadID(m_pReader, idpos, len);
 
    if (id < 0)
      return E_FILE_FORMAT_INVALID;
 
     if (id == 0x0F43B675)   
       break;
 

     if (result < 0)   
       return result;
 
    if (result > 0) {
       
       return (pos + 1);
    }
 
     if ((segment_stop >= 0) && ((pos + len) > segment_stop))
       return E_FILE_FORMAT_INVALID;
 

 
     const long long size = ReadUInt(m_pReader, pos, len);
 
    if (size < 0 || len < 1 || len > 8) {
       
       
       return size;
    }
 
     pos += len;   
 
     
    rollover_check = static_cast<unsigned long long>(pos) + size;
    if (rollover_check > LONG_LONG_MAX)
      return E_FILE_FORMAT_INVALID;

     const long long element_size = size + pos - element_start;
 
      
 

         if (status)
           return status;
       }
    } else if (id == 0x0254C367) {   
      if (m_pTags == NULL) {
        m_pTags = new (std::nothrow)
            Tags(this, pos, size, element_start, element_size);

        if (m_pTags == NULL)
          return -1;

        const long status = m_pTags->Parse();

        if (status)
          return status;
      }
     }
 
     m_pos = pos + size;   
   }
 
  if (segment_stop >= 0 && m_pos > segment_stop)
    return E_FILE_FORMAT_INVALID;
 
   if (m_pInfo == NULL)   
     return E_FILE_FORMAT_INVALID;
 

   if (status < 0)   
     return status;
 
  if (total >= 0 && avail > total)
    return E_FILE_FORMAT_INVALID;
 
   const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
 
 

       return E_BUFFER_NOT_FULL;
 
     const long long idpos = pos;
    const long long id = ReadID(m_pReader, idpos, len);
 
    if (id < 0)
      return E_FILE_FORMAT_INVALID;
 
     pos += len;   
 
 

 
     const long long unknown_size = (1LL << (7 * len)) - 1;
 
     if ((segment_stop >= 0) && (size != unknown_size) &&
         ((pos + size) > segment_stop)) {
       return E_FILE_FORMAT_INVALID;
     }
 
     if (id == 0x0C53BB6B) {   
       if (size == unknown_size)
         return E_FILE_FORMAT_INVALID;   
 

       if (m_pCues == NULL) {
         const long long element_size = (pos - idpos) + size;
 
        m_pCues = new (std::nothrow) Cues(this, pos, size, idpos, element_size);
        if (m_pCues == NULL)
          return -1;
       }
 
       m_pos = pos + size;   
 

     break;
   }
 
  if (cluster_off < 0) {
     
    return E_FILE_FORMAT_INVALID;
  }
 
   long long pos_;
   long len_;
 

   const long idx = m_clusterCount;
 
   if (m_clusterPreloadCount > 0) {
    if (idx >= m_clusterSize)
      return E_FILE_FORMAT_INVALID;
 
     Cluster* const pCluster = m_clusters[idx];
    if (pCluster == NULL || pCluster->m_index >= 0)
      return E_FILE_FORMAT_INVALID;
 
     const long long off = pCluster->GetPosition();
    if (off < 0)
      return E_FILE_FORMAT_INVALID;
 
     if (off == cluster_off) {   
       if (status == 0)   
 

       --m_clusterPreloadCount;
 
       m_pos = pos;   
      if (segment_stop >= 0 && m_pos > segment_stop)
        return E_FILE_FORMAT_INVALID;
 
       return 0;   
     }
   }
 
   if (status == 0) {   
    if (cluster_size >= 0)
      pos += cluster_size;
 
     if ((total >= 0) && (pos >= total)) {
       m_pos = total;
 

    
 
   Cluster* const pCluster = Cluster::Create(this, idx, cluster_off);
  if (pCluster == NULL)
    return -1;
 
  if (!AppendCluster(pCluster)) {
    delete pCluster;
    return -1;
  }
 
   if (cluster_size >= 0) {
     pos += cluster_size;
 
     m_pos = pos;

    if (segment_stop > 0 && m_pos > segment_stop)
      return E_FILE_FORMAT_INVALID;
 
     return 0;
   }
 

 
   return 0;   
 
   
   
   
 }
 
 long Segment::DoLoadClusterUnknownSize(long long& pos, long& len) {
  if (m_pos >= 0 || m_pUnknownSize == NULL)
    return E_PARSE_FAILED;
 
   const long status = m_pUnknownSize->Parse(pos, len);
 
   if (status < 0)   
 

   if (status == 0)   
     return 2;   
 
   const long long start = m_pUnknownSize->m_element_start;
   const long long size = m_pUnknownSize->GetElementSize();

  if (size < 0)
    return E_FILE_FORMAT_INVALID;
 
   pos = start + size;
   m_pos = pos;
 

   m_pUnknownSize = 0;
 
   return 2;   
 }
 
bool Segment::AppendCluster(Cluster* pCluster) {
  if (pCluster == NULL || pCluster->m_index < 0)
    return false;
 
   const long count = m_clusterCount + m_clusterPreloadCount;
 
   long& size = m_clusterSize;
   const long idx = pCluster->m_index;

  if (size < count || idx != m_clusterCount)
    return false;
 
   if (count >= size) {
     const long n = (size <= 0) ? 2048 : 2 * size;
 
    Cluster** const qq = new (std::nothrow) Cluster*[n];
    if (qq == NULL)
      return false;
 
    Cluster** q = qq;
     Cluster** p = m_clusters;
     Cluster** const pp = p + count;
 
 

   }
 
   if (m_clusterPreloadCount > 0) {
     Cluster** const p = m_clusters + m_clusterCount;
    if (*p == NULL || (*p)->m_index >= 0)
      return false;
 
     Cluster** q = p + m_clusterPreloadCount;
    if (q >= (m_clusters + size))
      return false;
 
     for (;;) {
       Cluster** const qq = q - 1;
      if ((*qq)->m_index >= 0)
        return false;
 
       *q = *qq;
       q = qq;
 

 
   m_clusters[idx] = pCluster;
   ++m_clusterCount;
  return true;
 }
 
bool Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx) {
   assert(pCluster);
   assert(pCluster->m_index < 0);
   assert(idx >= m_clusterCount);
 

   if (count >= size) {
     const long n = (size <= 0) ? 2048 : 2 * size;
 
    Cluster** const qq = new (std::nothrow) Cluster*[n];
    if (qq == NULL)
      return false;
     Cluster** q = qq;
 
     Cluster** p = m_clusters;
 

 
   m_clusters[idx] = pCluster;
   ++m_clusterPreloadCount;
  return true;
 }
 
 long Segment::Load() {
 

   if (header_status > 0)   
     return E_BUFFER_NOT_FULL;
 
  if (m_pInfo == NULL || m_pTracks == NULL)
    return E_FILE_FORMAT_INVALID;
 
   for (;;) {
     const int status = LoadCluster();
 

       ++void_element_count;
 
     pos += size;   

    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   m_entries = new (std::nothrow) Entry[entry_count];
 
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);
   assert(count_ >= 0);
 

   return m_void_elements + idx;
 }
 
 long Segment::ParseCues(long long off, long long& pos, long& len) {
   if (m_pCues)
     return 0;   
 

 
   const long long idpos = pos;
 
  const long long id = ReadID(m_pReader, idpos, len);
 
   if (id != 0x0C53BB6B)   
     return E_FILE_FORMAT_INVALID;
 

 
   m_pCues =
       new (std::nothrow) Cues(this, pos, size, element_start, element_size);
  if (m_pCues == NULL)
    return -1;
 
   return 0;   
 }
 
 bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,
                           Entry* pEntry) {
   if (size_ <= 0)
 

 
    
 
  const long long seekIdId = ReadID(pReader, pos, len);
  if (seekIdId < 0)
    return false;
 
   if (seekIdId != 0x13AB)   
     return false;
 

 
   return true;
 }
 
 Cues::Cues(Segment* pSegment, long long start_, long long size_,
            long long element_start, long long element_size)
 

   return (m_pos >= stop);
 }
 
bool Cues::Init() const {
   if (m_cue_points)
    return true;
 
  if (m_count != 0 || m_preload_count != 0)
    return false;
 
   IMkvReader* const pReader = m_pSegment->m_pReader;
 
 

 
     long len;
 
    const long long id = ReadID(pReader, pos, len);
    if (id < 0 || (pos + len) > stop) {
      return false;
    }
 
     pos += len;   
 
     const long long size = ReadUInt(pReader, pos, len);
    if (size < 0 || (pos + len > stop)) {
      return false;
    }
 
     pos += len;   
    if (pos + size > stop) {
      return false;
    }
 
    if (id == 0x3B) {   
      if (!PreloadCuePoint(cue_points_size, idpos))
        return false;
    }
 
    pos += size;   
   }
  return true;
 }
 
bool Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {
  if (m_count != 0)
    return false;
 
   if (m_preload_count >= cue_points_size) {
     const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;
 
    CuePoint** const qq = new (std::nothrow) CuePoint*[n];
    if (qq == NULL)
      return false;

     CuePoint** q = qq;   
 
     CuePoint** p = m_cue_points;   
 

     cue_points_size = n;
   }
 
  CuePoint* const pCP = new (std::nothrow) CuePoint(m_preload_count, pos);
  if (pCP == NULL)
    return false;

   m_cue_points[m_preload_count++] = pCP;
  return true;
 }
 
 bool Cues::LoadCuePoint() const {
   const long long stop = m_start + m_size;
 
   if (m_pos >= stop)
     return false;   
 
  if (!Init()) {
    m_pos = stop;
    return false;
  }
 
   IMkvReader* const pReader = m_pSegment->m_pReader;
 
 

 
     long len;
 
    const long long id = ReadID(pReader, m_pos, len);
    if (id < 0 || (m_pos + len) > stop)
      return false;
 
     m_pos += len;   
 
     const long long size = ReadUInt(pReader, m_pos, len);
    if (size < 0 || (m_pos + len) > stop)
      return false;
 
     m_pos += len;   
    if ((m_pos + size) > stop)
      return false;
 
     if (id != 0x3B) {   
       m_pos += size;   
      if (m_pos > stop)
        return false;
 
       continue;
     }
 
    if (m_preload_count < 1)
       return false;
 
    CuePoint* const pCP = m_cue_points[m_count];
    if (!pCP || (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos)))
      return false;

    if (!pCP->Load(pReader)) {
      m_pos = stop;
      return false;
    }
     ++m_count;
     --m_preload_count;
 
     m_pos += size;   
    if (m_pos > stop)
      return false;
 
     return true;   
   }
 
   return false;   
 }
 
 bool Cues::Find(long long time_ns, const Track* pTrack, const CuePoint*& pCP,
                 const CuePoint::TrackPosition*& pTP) const {
  if (time_ns < 0 || pTrack == NULL || m_cue_points == NULL || m_count == 0)
     return false;
 
   CuePoint** const ii = m_cue_points;
 

   CuePoint** j = jj;
 
   pCP = *i;
  if (pCP == NULL)
    return false;
 
   if (time_ns <= pCP->GetTime(m_pSegment)) {
     pTP = pCP->Find(pTrack);
 

      
 
     CuePoint** const k = i + (j - i) / 2;
    if (k >= jj)
      return false;
 
     CuePoint* const pCP = *k;
    if (pCP == NULL)
      return false;
 
     const long long t = pCP->GetTime(m_pSegment);
 
 

     else
       j = k;
 
    if (i > j)
      return false;
   }
 
  if (i != j || i > jj || i <= ii)
    return false;
 
   pCP = *--i;

  if (pCP == NULL || pCP->GetTime(m_pSegment) > time_ns)
    return false;
 
    
    
 

   return (pTP != NULL);
 }
 
 const CuePoint* Cues::GetFirst() const {
  if (m_cue_points == NULL || m_count == 0)
     return NULL;
 
   CuePoint* const* const pp = m_cue_points;
  if (pp == NULL)
    return NULL;
 
   CuePoint* const pCP = pp[0];
  if (pCP == NULL || pCP->GetTimeCode() < 0)
    return NULL;
 
   return pCP;
 }
 
 const CuePoint* Cues::GetLast() const {
  if (m_cue_points == NULL || m_count <= 0)
     return NULL;
 
   const long index = m_count - 1;
 
   CuePoint* const* const pp = m_cue_points;
  if (pp == NULL)
    return NULL;
 
   CuePoint* const pCP = pp[index];
  if (pCP == NULL || pCP->GetTimeCode() < 0)
    return NULL;
 
   return pCP;
 }
 
 const CuePoint* Cues::GetNext(const CuePoint* pCurr) const {
  if (pCurr == NULL || pCurr->GetTimeCode() < 0 ||
      m_cue_points == NULL || m_count < 1) {
    return NULL;
  }

  long index = pCurr->m_index;
  if (index >= m_count)
     return NULL;
 
   CuePoint* const* const pp = m_cue_points;
  if (pp == NULL || pp[index] != pCurr)
    return NULL;
 
   ++index;
 
 

     return NULL;
 
   CuePoint* const pNext = pp[index];

  if (pNext == NULL || pNext->GetTimeCode() < 0)
    return NULL;
 
   return pNext;
 }
 
 const BlockEntry* Cues::GetBlock(const CuePoint* pCP,
                                  const CuePoint::TrackPosition* pTP) const {
  if (pCP == NULL || pTP == NULL)
     return NULL;
 
   return m_pSegment->GetBlock(*pCP, *pTP);
 

    
 
   Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos);   
  if (pCluster == NULL)
    return NULL;
 
   const ptrdiff_t idx = i - m_clusters;
 
  if (!PreloadCluster(pCluster, idx)) {
    delete pCluster;
    return NULL;
  }
   assert(m_clusters);
   assert(m_clusterPreloadCount > 0);
   assert(m_clusters[idx] == pCluster);
 

    
 
   Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);
  if (pCluster == NULL)
    return NULL;
 
   const ptrdiff_t idx = i - m_clusters;
 
  if (!PreloadCluster(pCluster, idx)) {
    delete pCluster;
    return NULL;
  }
   assert(m_clusters);
   assert(m_clusterPreloadCount > 0);
   assert(m_clusters[idx] == pCluster);
 

 
 CuePoint::~CuePoint() { delete[] m_track_positions; }
 
bool CuePoint::Load(IMkvReader* pReader) {
    
    
 
   if (m_timecode >= 0)   
    return true;
 
   assert(m_track_positions == NULL);
   assert(m_track_positions_count == 0);
 

   {
     long len;
 
    const long long id = ReadID(pReader, pos_, len);
     if (id != 0x3B)
      return false;
 
     pos_ += len;   
 
 

   while (pos < stop) {
     long len;
 
    const long long id = ReadID(pReader, pos, len);
    if ((id < 0) || (pos + len > stop)) {
      return false;
    }
 
     pos += len;   
 
     const long long size = ReadUInt(pReader, pos, len);
    if ((size < 0) || (pos + len > stop)) {
      return false;
    }
 
     pos += len;   
    if ((pos + size) > stop) {
      return false;
    }
 
     if (id == 0x33)   
       m_timecode = UnserializeUInt(pReader, pos, size);
 

       ++m_track_positions_count;
 
     pos += size;   
   }
 
  if (m_timecode < 0 || m_track_positions_count <= 0) {
    return false;
  }
 
    
    
    
 
  m_track_positions = new (std::nothrow) TrackPosition[m_track_positions_count];
  if (m_track_positions == NULL)
    return false;
 
    
 
 

   while (pos < stop) {
     long len;
 
    const long long id = ReadID(pReader, pos, len);
    if (id < 0 || (pos + len) > stop)
      return false;
 
     pos += len;   
 
 

 
     if (id == 0x37) {   
       TrackPosition& tp = *p++;
      if (!tp.Parse(pReader, pos, size)) {
        return false;
      }
     }
 
     pos += size;   
    if (pos > stop)
      return false;
   }
 
   assert(size_t(p - m_track_positions) == m_track_positions_count);
 
   m_element_start = element_start;
   m_element_size = element_size;

  return true;
 }
 
bool CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,
                                     long long size_) {
   const long long stop = start_ + size_;
   long long pos = start_;
 

   while (pos < stop) {
     long len;
 
    const long long id = ReadID(pReader, pos, len);
    if ((id < 0) || ((pos + len) > stop)) {
      return false;
    }
 
     pos += len;   
 
     const long long size = ReadUInt(pReader, pos, len);
    if ((size < 0) || ((pos + len) > stop)) {
      return false;
    }
 
     pos += len;   
    if ((pos + size) > stop) {
      return false;
    }
 
     if (id == 0x77)   
       m_track = UnserializeUInt(pReader, pos, size);
 

       m_block = UnserializeUInt(pReader, pos, size);
 
     pos += size;   
   }
 
  if ((m_pos < 0) || (m_track <= 0)) {
    return false;
  }

  return true;
 }
 
 const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const {
 

   return time;
 }
 
 bool Segment::DoneParsing() const {
   if (m_size < 0) {
     long long total, avail;
 

 
   return (m_pos >= stop);
 }
 
 const Cluster* Segment::GetFirst() const {
   if ((m_clusters == NULL) || (m_clusterCount <= 0))
 

     if (result != 0)
       return NULL;
 
    const long long id = ReadID(m_pReader, pos, len);
    if (id != 0x0F43B675)   
       return NULL;
 
     pos += len;   
 

 
     const long long idpos = pos;   
 
    const long long id = ReadID(m_pReader, idpos, len);
    if (id < 0)
      return NULL;
 
     pos += len;   
 
 

   assert(i == j);
 
   Cluster* const pNext = Cluster::Create(this, -1, off_next);
  if (pNext == NULL)
    return NULL;
 
   const ptrdiff_t idx_next = i - m_clusters;   
 
  if (!PreloadCluster(pNext, idx_next)) {
    delete pNext;
    return NULL;
  }
   assert(m_clusters);
   assert(idx_next < m_clusterSize);
   assert(m_clusters[idx_next] == pNext);
 

      
 
     pos += size;   
    if (segment_stop >= 0 && pos > segment_stop)
      return E_FILE_FORMAT_INVALID;
 
      
      
 

       const long long element_size = element_stop - element_start;
 
       if (m_pCues == NULL) {
        m_pCues = new (std::nothrow)
            Cues(this, pos, size, element_start, element_size);
        if (m_pCues == NULL)
          return false;
       }
 
       pos += size;   
      if (segment_stop >= 0 && pos > segment_stop)
        return E_FILE_FORMAT_INVALID;
 
       continue;
     }
 

         return E_FILE_FORMAT_INVALID;
 
       pos += size;   
      if (segment_stop >= 0 && pos > segment_stop)
        return E_FILE_FORMAT_INVALID;
 
       continue;
     }
 
      
     off_next = idoff;
 
     if (size != unknown_size)
 

     Cluster* const pNext = Cluster::Create(this,
                                            -1,   
                                            off_next);
    if (pNext == NULL)
      return -1;
 
     const ptrdiff_t idx_next = i - m_clusters;   
 
    if (!PreloadCluster(pNext, idx_next)) {
      delete pNext;
      return -1;
    }
     assert(m_clusters);
     assert(idx_next < m_clusterSize);
     assert(m_clusters[idx_next] == pNext);
 

         return E_FILE_FORMAT_INVALID;
 
       pos += size;   
      if (segment_stop >= 0 && pos > segment_stop)
        return E_FILE_FORMAT_INVALID;
     }   
 
     cluster_size = pos - payload_pos;
 

   }
 
   pos += cluster_size;   
  if (segment_stop >= 0 && pos > segment_stop)
    return E_FILE_FORMAT_INVALID;
 
   return 2;   
 }
 

   return pCluster;
 }
 
 const Tracks* Segment::GetTracks() const { return m_pTracks; }
 const SegmentInfo* Segment::GetInfo() const { return m_pInfo; }
 const Cues* Segment::GetCues() const { return m_pCues; }
 const Chapters* Segment::GetChapters() const { return m_pChapters; }
const Tags* Segment::GetTags() const { return m_pTags; }
 const SeekHead* Segment::GetSeekHead() const { return m_pSeekHead; }
 
 long long Segment::GetDuration() const {
 

     Edition& e = m_editions[--m_editions_count];
     e.Clear();
   }
  delete[] m_editions;
 }
 
 long Chapters::Parse() {
 

     }
 
     pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
   return 0;
 }
 
 

     }
 
     pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
   return 0;
 }
 
 

     }
 
     pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
   return 0;
 }
 
 

     }
 
     pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
  return 0;
}

Tags::Tags(Segment* pSegment, long long payload_start, long long payload_size,
           long long element_start, long long element_size)
    : m_pSegment(pSegment),
      m_start(payload_start),
      m_size(payload_size),
      m_element_start(element_start),
      m_element_size(element_size),
      m_tags(NULL),
      m_tags_size(0),
      m_tags_count(0) {}

Tags::~Tags() {
  while (m_tags_count > 0) {
    Tag& t = m_tags[--m_tags_count];
    t.Clear();
  }
  delete[] m_tags;
}

long Tags::Parse() {
  IMkvReader* const pReader = m_pSegment->m_pReader;

  long long pos = m_start;   
  const long long stop = pos + m_size;   

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)
      return status;

    if (size == 0)   
      continue;

    if (id == 0x3373) {   
      status = ParseTag(pos, size);

      if (status < 0)
        return status;
    }

    pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
  }

  if (pos != stop)
    return E_FILE_FORMAT_INVALID;

  return 0;
}

int Tags::GetTagCount() const { return m_tags_count; }

const Tags::Tag* Tags::GetTag(int idx) const {
  if (idx < 0)
    return NULL;

  if (idx >= m_tags_count)
    return NULL;

  return m_tags + idx;
}

bool Tags::ExpandTagsArray() {
  if (m_tags_size > m_tags_count)
    return true;   

  const int size = (m_tags_size == 0) ? 1 : 2 * m_tags_size;

  Tag* const tags = new (std::nothrow) Tag[size];

  if (tags == NULL)
    return false;

  for (int idx = 0; idx < m_tags_count; ++idx) {
    m_tags[idx].ShallowCopy(tags[idx]);
  }

  delete[] m_tags;
  m_tags = tags;

  m_tags_size = size;
  return true;
}

long Tags::ParseTag(long long pos, long long size) {
  if (!ExpandTagsArray())
    return -1;

  Tag& t = m_tags[m_tags_count++];
  t.Init();

  return t.Parse(m_pSegment->m_pReader, pos, size);
}

Tags::Tag::Tag() {}

Tags::Tag::~Tag() {}

int Tags::Tag::GetSimpleTagCount() const { return m_simple_tags_count; }

const Tags::SimpleTag* Tags::Tag::GetSimpleTag(int index) const {
  if (index < 0)
    return NULL;

  if (index >= m_simple_tags_count)
    return NULL;

  return m_simple_tags + index;
}

void Tags::Tag::Init() {
  m_simple_tags = NULL;
  m_simple_tags_size = 0;
  m_simple_tags_count = 0;
}

void Tags::Tag::ShallowCopy(Tag& rhs) const {
  rhs.m_simple_tags = m_simple_tags;
  rhs.m_simple_tags_size = m_simple_tags_size;
  rhs.m_simple_tags_count = m_simple_tags_count;
}

void Tags::Tag::Clear() {
  while (m_simple_tags_count > 0) {
    SimpleTag& d = m_simple_tags[--m_simple_tags_count];
    d.Clear();
  }

  delete[] m_simple_tags;
  m_simple_tags = NULL;

  m_simple_tags_size = 0;
}

long Tags::Tag::Parse(IMkvReader* pReader, long long pos, long long size) {
  const long long stop = pos + size;

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)
      return status;

    if (size == 0)   
      continue;

    if (id == 0x27C8) {   
      status = ParseSimpleTag(pReader, pos, size);

      if (status < 0)
        return status;
    }

    pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
  }

  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
  return 0;
}

long Tags::Tag::ParseSimpleTag(IMkvReader* pReader, long long pos,
                               long long size) {
  if (!ExpandSimpleTagsArray())
    return -1;

  SimpleTag& st = m_simple_tags[m_simple_tags_count++];
  st.Init();

  return st.Parse(pReader, pos, size);
}

bool Tags::Tag::ExpandSimpleTagsArray() {
  if (m_simple_tags_size > m_simple_tags_count)
    return true;   

  const int size = (m_simple_tags_size == 0) ? 1 : 2 * m_simple_tags_size;

  SimpleTag* const displays = new (std::nothrow) SimpleTag[size];

  if (displays == NULL)
    return false;

  for (int idx = 0; idx < m_simple_tags_count; ++idx) {
    m_simple_tags[idx].ShallowCopy(displays[idx]);
  }

  delete[] m_simple_tags;
  m_simple_tags = displays;

  m_simple_tags_size = size;
  return true;
}

Tags::SimpleTag::SimpleTag() {}

Tags::SimpleTag::~SimpleTag() {}

const char* Tags::SimpleTag::GetTagName() const { return m_tag_name; }

const char* Tags::SimpleTag::GetTagString() const { return m_tag_string; }

void Tags::SimpleTag::Init() {
  m_tag_name = NULL;
  m_tag_string = NULL;
}

void Tags::SimpleTag::ShallowCopy(SimpleTag& rhs) const {
  rhs.m_tag_name = m_tag_name;
  rhs.m_tag_string = m_tag_string;
}

void Tags::SimpleTag::Clear() {
  delete[] m_tag_name;
  m_tag_name = NULL;

  delete[] m_tag_string;
  m_tag_string = NULL;
}

long Tags::SimpleTag::Parse(IMkvReader* pReader, long long pos,
                            long long size) {
  const long long stop = pos + size;

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (size == 0)   
      continue;

    if (id == 0x5A3) {   
      status = UnserializeString(pReader, pos, size, m_tag_name);

      if (status)
        return status;
    } else if (id == 0x487) {   
      status = UnserializeString(pReader, pos, size, m_tag_string);

      if (status)
        return status;
    }

    pos += size;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
  }

  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
   return 0;
 }
 
 

     }
 
     pos += size;

    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  const double rollover_check = m_duration * m_timecodeScale;
  if (rollover_check > LONG_LONG_MAX)
    return E_FILE_FORMAT_INVALID;

  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   return 0;
 }
 

 }
 
 const ContentEncoding::ContentCompression*
    ContentEncoding::GetCompressionByIndex(unsigned long idx) const {
   const ptrdiff_t count = compression_entries_end_ - compression_entries_;
   assert(count >= 0);
 
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
   return 0;
 

       ++encryption_count;
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
   if (compression_count <= 0 && encryption_count <= 0)
 

 
   if (compression_count > 0) {
     compression_entries_ =
        new (std::nothrow) ContentCompression*[compression_count];
     if (!compression_entries_)
       return -1;
     compression_entries_end_ = compression_entries_;
 

 
   if (encryption_count > 0) {
     encryption_entries_ =
        new (std::nothrow) ContentEncryption*[encryption_count];
     if (!encryption_entries_) {
       delete[] compression_entries_;
       return -1;
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
   return 0;
 }
 
 

         return E_FILE_FORMAT_INVALID;
 
       const size_t buflen = static_cast<size_t>(size);
      unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);
       if (buf == NULL)
         return -1;
 
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
    
 

         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x7E2) {
        
      delete[] encryption->key_id;
       encryption->key_id = NULL;
       encryption->key_id_len = 0;
 
 

         return E_FILE_FORMAT_INVALID;
 
       const size_t buflen = static_cast<size_t>(size);
      unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);
       if (buf == NULL)
         return -1;
 
 

       encryption->key_id_len = buflen;
     } else if (id == 0x7E3) {
        
      delete[] encryption->signature;
       encryption->signature = NULL;
       encryption->signature_len = 0;
 
 

         return E_FILE_FORMAT_INVALID;
 
       const size_t buflen = static_cast<size_t>(size);
      unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);
       if (buf == NULL)
         return -1;
 
 

       encryption->signature_len = buflen;
     } else if (id == 0x7E4) {
        
      delete[] encryption->sig_key_id;
       encryption->sig_key_id = NULL;
       encryption->sig_key_id_len = 0;
 
 

         return E_FILE_FORMAT_INVALID;
 
       const size_t buflen = static_cast<size_t>(size);
      unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);
       if (buf == NULL)
         return -1;
 
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
   return 0;
 

 
   const size_t len = strlen(src);
 
  dst = SafeArrayAlloc<char>(1, len + 1);
 
   if (dst == NULL)
     return -1;
 

     if (dst.codecPrivateSize != 0)
       return -1;
 
    dst.codecPrivate = SafeArrayAlloc<unsigned char>(1, codecPrivateSize);
 
     if (dst.codecPrivate == NULL)
       return -1;
 

     }
 
     if (pCluster->EOS()) {
       if (m_pSegment->DoneParsing()) {
         pBlockEntry = GetEOS();
         return 1;
       }
 
       pBlockEntry = 0;
       return E_BUFFER_NOT_FULL;
 

     }
 
     if (pCluster->EOS()) {
       if (m_pSegment->DoneParsing()) {
         pNextEntry = GetEOS();
         return 1;
       }
 
        
        
 

       ++count;
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
   if (count <= 0)
     return -1;
 
  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];
   if (!content_encoding_entries_)
     return -1;
 
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   return 0;
 }
 

 
   long long width = 0;
   long long height = 0;
  long long display_width = 0;
  long long display_height = 0;
  long long display_unit = 0;
  long long stereo_mode = 0;

   double rate = 0.0;
 
   IMkvReader* const pReader = pSegment->m_pReader;
 

 
       if (height <= 0)
         return E_FILE_FORMAT_INVALID;
    } else if (id == 0x14B0) {   
      display_width = UnserializeUInt(pReader, pos, size);

      if (display_width <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x14BA) {   
      display_height = UnserializeUInt(pReader, pos, size);

      if (display_height <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x14B2) {   
      display_unit = UnserializeUInt(pReader, pos, size);

      if (display_unit < 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x13B8) {   
      stereo_mode = UnserializeUInt(pReader, pos, size);

      if (stereo_mode < 0)
        return E_FILE_FORMAT_INVALID;
     } else if (id == 0x0383E3) {   
       const long status = UnserializeFloat(pReader, pos, size, rate);
 
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   VideoTrack* const pTrack =
       new (std::nothrow) VideoTrack(pSegment, element_start, element_size);
 

 
   pTrack->m_width = width;
   pTrack->m_height = height;
  pTrack->m_display_width = display_width;
  pTrack->m_display_height = display_height;
  pTrack->m_display_unit = display_unit;
  pTrack->m_stereo_mode = stereo_mode;
   pTrack->m_rate = rate;
 
   pResult = pTrack;
 

     assert(pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
     pResult = pCluster->GetEntry(this, time_ns);
 
     if ((pResult != 0) && !pResult->EOS())
       return 0;
 

 
 long long VideoTrack::GetHeight() const { return m_height; }
 
long long VideoTrack::GetDisplayWidth() const {
  return m_display_width > 0 ? m_display_width : GetWidth();
}

long long VideoTrack::GetDisplayHeight() const {
  return m_display_height > 0 ? m_display_height : GetHeight();
}

long long VideoTrack::GetDisplayUnit() const { return m_display_unit; }

long long VideoTrack::GetStereoMode() const { return m_stereo_mode; }

 double VideoTrack::GetFrameRate() const { return m_rate; }
 
 AudioTrack::AudioTrack(Segment* pSegment, long long element_start,
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   AudioTrack* const pTrack =
       new (std::nothrow) AudioTrack(pSegment, element_start, element_size);
 

       ++count;
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   if (count <= 0)
     return 0;   
 
  m_trackEntries = new (std::nothrow) Track*[count];
 
   if (m_trackEntries == NULL)
     return -1;
 

     }
 
     pos = payload_stop;
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
 
   return 0;   
 }
 

       const size_t buflen = static_cast<size_t>(size);
 
       if (buflen) {
        unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);
 
         if (buf == NULL)
           return -1;
 

     }
 
     pos += size;   
    if (pos > track_stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != track_stop)
    return E_FILE_FORMAT_INVALID;
 
   if (info.number <= 0)   
     return E_FILE_FORMAT_INVALID;
 

   return m_trackEntries[idx];
 }
 
 long Cluster::Load(long long& pos, long& len) const {
   assert(m_pSegment);
   assert(m_pos >= m_element_start);
 

       cluster_size = size;
   }
 
   
   long long timecode = -1;
   long long new_pos = -1;
   bool bBlock = false;
 

     }
 
     pos += size;   
    if (cluster_stop >= 0 && pos > cluster_stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (cluster_stop >= 0 && pos > cluster_stop)
    return E_FILE_FORMAT_INVALID;
 
   if (timecode < 0)   
     return E_FILE_FORMAT_INVALID;
 

       return this_->ParseSimpleBlock(size, pos, len);
 
     pos += size;   
    if (cluster_stop >= 0 && pos > cluster_stop)
      return E_FILE_FORMAT_INVALID;
   }
 
   assert(m_element_size > 0);
 
   m_pos = pos;
  if (cluster_stop >= 0 && m_pos > cluster_stop)
    return E_FILE_FORMAT_INVALID;
 
   if (m_entries_count > 0) {
     const long idx = m_entries_count - 1;
 

   if (track == 0)
     return E_FILE_FORMAT_INVALID;
 
   pos += len;   
 
   if ((pos + 2) > block_stop)
 

     if (track == 0)
       return E_FILE_FORMAT_INVALID;
 
     pos += len;   
 
     if ((pos + 2) > block_stop)
 

     }
 
     pos = block_stop;   
    if (pos > payload_stop)
      return E_FILE_FORMAT_INVALID;
   }
 
  if (pos != payload_stop)
    return E_FILE_FORMAT_INVALID;
 
   status = CreateBlock(0x20,   
                        payload_start, payload_size, discard_padding);
 

   return E_BUFFER_NOT_FULL;   
 }
 
Cluster* Cluster::Create(Segment* pSegment, long idx, long long off) {
  if (!pSegment || off < 0)
    return NULL;
 
   const long long element_start = pSegment->m_start + off;
 
  Cluster* const pCluster =
      new (std::nothrow) Cluster(pSegment, idx, element_start);
 
   return pCluster;
 }
 

 
 long long Cluster::GetElementSize() const { return m_element_size; }
 
 long Cluster::HasBlockEntries(
     const Segment* pSegment,
     long long off,   
 

       return 1;   
 
     pos += size;   
    if (cluster_stop >= 0 && pos > cluster_stop)
      return E_FILE_FORMAT_INVALID;
   }
 }
 
 

     assert(m_entries_size == 0);
 
     m_entries_size = 1024;
    m_entries = new (std::nothrow) BlockEntry*[m_entries_size];
    if (m_entries == NULL)
      return -1;
 
     m_entries_count = 0;
   } else {
 

     if (m_entries_count >= m_entries_size) {
       const long entries_size = 2 * m_entries_size;
 
      BlockEntry** const entries = new (std::nothrow) BlockEntry*[entries_size];
      if (entries == NULL)
        return -1;
 
       BlockEntry** src = m_entries;
       BlockEntry** const src_end = src + m_entries_count;
 

 
   while (pos < stop) {
     long len;
    const long long id = ReadID(pReader, pos, len);
    if (id < 0 || (pos + len) > stop)
      return E_FILE_FORMAT_INVALID;
 
     pos += len;   
 
 

         bsize = size;
       }
     } else if (id == 0x1B) {   
      if (size > 8)
        return E_FILE_FORMAT_INVALID;
 
       duration = UnserializeUInt(pReader, pos, size);

      if (duration < 0)
        return E_FILE_FORMAT_INVALID;
     } else if (id == 0x7B) {   
      if (size > 8 || size <= 0)
        return E_FILE_FORMAT_INVALID;
       const long size_ = static_cast<long>(size);
 
       long long time;
 

     }
 
     pos += size;   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
   }
  if (bpos < 0)
    return E_FILE_FORMAT_INVALID;
 
  if (pos != stop)
    return E_FILE_FORMAT_INVALID;
   assert(bsize >= 0);
 
   const long idx = m_entries_count;
 

   if (m_pSegment == NULL)   
     return pTrack->GetEOS();
 
   const BlockEntry* pResult = pTrack->GetEOS();
 
   long index = 0;
 

 
     ++index;
   }
 }
 
 const BlockEntry* Cluster::GetEntry(const CuePoint& cp,
                                     const CuePoint::TrackPosition& tp) const {
   assert(m_pSegment);
   const long long tc = cp.GetTimeCode();
 
   if (tp.m_block > 0) {
 

 
     return pEntry;
   }
 }
 
 BlockEntry::BlockEntry(Cluster* p, long idx) : m_pCluster(p), m_index(idx) {}
 BlockEntry::~BlockEntry() {}
 bool BlockEntry::EOS() const { return (GetKind() == kBlockEOS); }
 const Cluster* BlockEntry::GetCluster() const { return m_pCluster; }
 long BlockEntry::GetIndex() const { return m_index; }
 
 SimpleBlock::SimpleBlock(Cluster* pCluster, long idx, long long start,
 

     : BlockEntry(pCluster, idx), m_block(start, size, 0) {}
 
 long SimpleBlock::Parse() { return m_block.Parse(m_pCluster); }
 BlockEntry::Kind SimpleBlock::GetKind() const { return kBlockSimple; }
 const Block* SimpleBlock::GetBlock() const { return &m_block; }
 
 BlockGroup::BlockGroup(Cluster* pCluster, long idx, long long block_start,
 

   return 0;
 }
 
 BlockEntry::Kind BlockGroup::GetKind() const { return kBlockGroup; }
 const Block* BlockGroup::GetBlock() const { return &m_block; }
 long long BlockGroup::GetPrevTimeCode() const { return m_prev; }
 long long BlockGroup::GetNextTimeCode() const { return m_next; }
 long long BlockGroup::GetDurationTimeCode() const { return m_duration; }
 
 Block::Block(long long start, long long size_, long long discard_padding)
 

       return E_FILE_FORMAT_INVALID;
 
     m_frame_count = 1;
    m_frames = new (std::nothrow) Frame[m_frame_count];
    if (m_frames == NULL)
      return -1;
 
     Frame& f = m_frames[0];
     f.pos = pos;
 
     const long long frame_size = stop - pos;
 
    if (frame_size > LONG_MAX || frame_size <= 0)
       return E_FILE_FORMAT_INVALID;
 
     f.len = static_cast<long>(frame_size);
 

     return E_FILE_FORMAT_INVALID;
 
   ++pos;   
  if (pos > stop)
    return E_FILE_FORMAT_INVALID;
 
   m_frame_count = int(biased_count) + 1;
 
  m_frames = new (std::nothrow) Frame[m_frame_count];
  if (m_frames == NULL)
    return -1;

  if (!m_frames)
    return E_FILE_FORMAT_INVALID;
 
   if (lacing == 1) {   
     Frame* pf = m_frames;
     Frame* const pf_end = pf + m_frame_count;
 
    long long size = 0;
     int frame_count = m_frame_count;
 
     while (frame_count > 1) {
 

 
       Frame& f = *pf++;
       assert(pf < pf_end);
      if (pf >= pf_end)
        return E_FILE_FORMAT_INVALID;
 
       f.pos = 0;   
 
      if (frame_size <= 0)
        return E_FILE_FORMAT_INVALID;

       f.len = frame_size;
       size += frame_size;   
 
       --frame_count;
     }
 
    if (pf >= pf_end || pos > stop)
      return E_FILE_FORMAT_INVALID;
 
     {
       Frame& f = *pf++;
 

 
       const long long frame_size = total_size - size;
 
      if (frame_size > LONG_MAX || frame_size <= 0)
         return E_FILE_FORMAT_INVALID;
 
       f.len = static_cast<long>(frame_size);
 

       Frame& f = *pf++;
       assert((pos + f.len) <= stop);
 
      if ((pos + f.len) > stop)
        return E_FILE_FORMAT_INVALID;

       f.pos = pos;
       pos += f.len;
     }
 
     assert(pos == stop);
    if (pos != stop)
      return E_FILE_FORMAT_INVALID;

   } else if (lacing == 2) {   
    if (pos >= stop)
      return E_FILE_FORMAT_INVALID;

     const long long total_size = stop - pos;
 
     if ((total_size % m_frame_count) != 0)
 

 
     const long long frame_size = total_size / m_frame_count;
 
    if (frame_size > LONG_MAX || frame_size <= 0)
       return E_FILE_FORMAT_INVALID;
 
     Frame* pf = m_frames;
 

 
     while (pf != pf_end) {
       assert((pos + frame_size) <= stop);
      if ((pos + frame_size) > stop)
        return E_FILE_FORMAT_INVALID;
 
       Frame& f = *pf++;
 
 

     }
 
     assert(pos == stop);
    if (pos != stop)
      return E_FILE_FORMAT_INVALID;

   } else {
     assert(lacing == 3);   
 
     if (pos >= stop)
       return E_FILE_FORMAT_INVALID;
 
    long long size = 0;
     int frame_count = m_frame_count;
 
     long long frame_size = ReadUInt(pReader, pos, len);
 
    if (frame_size <= 0)
       return E_FILE_FORMAT_INVALID;
 
     if (frame_size > LONG_MAX)
 

         return E_FILE_FORMAT_INVALID;
 
       assert(pf < pf_end);
      if (pf >= pf_end)
        return E_FILE_FORMAT_INVALID;

 
       const Frame& prev = *pf++;
       assert(prev.len == frame_size);
 

         return E_FILE_FORMAT_INVALID;
 
       assert(pf < pf_end);
      if (pf >= pf_end)
        return E_FILE_FORMAT_INVALID;
 
       Frame& curr = *pf;
 
 

         return E_FILE_FORMAT_INVALID;
 
       pos += len;   
      if (pos > stop)
        return E_FILE_FORMAT_INVALID;
 
       const int exp = 7 * len - 1;
       const long long bias = (1LL << exp) - 1LL;
 

 
       frame_size += delta_size;
 
      if (frame_size <= 0)
         return E_FILE_FORMAT_INVALID;
 
       if (frame_size > LONG_MAX)
 

       --frame_count;
     }
 
     
    if (frame_count > 0) {
      if (pos > stop || pf >= pf_end)
        return E_FILE_FORMAT_INVALID;
 
       const Frame& prev = *pf++;
       assert(prev.len == frame_size);
       if (prev.len != frame_size)
         return E_FILE_FORMAT_INVALID;
 
      if (pf >= pf_end)
        return E_FILE_FORMAT_INVALID;
 
       Frame& curr = *pf++;
      if (pf != pf_end)
        return E_FILE_FORMAT_INVALID;
 
       curr.pos = 0;   
 
 

 
       frame_size = total_size - size;
 
      if (frame_size > LONG_MAX || frame_size <= 0)
         return E_FILE_FORMAT_INVALID;
 
       curr.len = static_cast<long>(frame_size);
 

     while (pf != pf_end) {
       Frame& f = *pf++;
       assert((pos + f.len) <= stop);
      if ((pos + f.len) > stop)
        return E_FILE_FORMAT_INVALID;
 
       f.pos = pos;
       pos += f.len;
     }
 
    if (pos != stop)
      return E_FILE_FORMAT_INVALID;
   }
 
   return 0;   
","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
2312,CVE-2016-2463," 

     void H264SwDecTrace(char *);
 
      
    void* H264SwDecMalloc(u32 size, u32 num);
 
      
     void H264SwDecFree(void *ptr);
","Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419."
2313,CVE-2016-2460," 

         }
         case GET_RELEASED_BUFFERS: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
            uint64_t slotMask = 0;
             status_t result = getReleasedBuffers(&slotMask);
             reply->writeInt64(static_cast<int64_t>(slotMask));
             reply->writeInt32(result);
","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not initialize certain data structures, which allows attackers to obtain sensitive information via a crafted application, related to IGraphicBufferConsumer.cpp and IGraphicBufferProducer.cpp, aka internal bug 27555981."
2314,CVE-2016-2452," 

         int32_t numBytesRead;
 
         if (mMode == MODE_NARROW) {
            if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
                ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 

                 return;
             }
         } else {
            if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
                ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"",
                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
                android_errorWriteLog(0x534e4554, ""27662364"");
                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
                mSignalledError = true;
                return;
            }

             int16 mode = ((inputPtr[0] >> 3) & 0x0f);
 
             if (mode >= 10 && mode <= 13) {
","codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673."
2315,CVE-2016-2451," 

         outHeader->nFlags = 0;
         outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;
         outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;
        if (outHeader->nAllocLen >= outHeader->nFilledLen) {
            uint8_t *dst = outHeader->pBuffer;
            const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];
            const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];
            const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];
            size_t srcYStride = mImg->stride[VPX_PLANE_Y];
            size_t srcUStride = mImg->stride[VPX_PLANE_U];
            size_t srcVStride = mImg->stride[VPX_PLANE_V];
            copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);
        } else {
            ALOGE(""b/27597103, buffer too small"");
            android_errorWriteLog(0x534e4554, ""27597103"");
            outHeader->nFilledLen = 0;
        }
 
         mImg = NULL;
         outInfo->mOwnedByUs = false;
","codecs/on2/dec/SoftVPX.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate VPX output buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27597103."
2316,CVE-2016-2450," 

         const uint8_t *source =
             inputBufferHeader->pBuffer + inputBufferHeader->nOffset;
 
        size_t frameSize = mWidth * mHeight * 3 / 2;
         if (mInputDataIsMeta) {
             source = extractGraphicBuffer(
                    mConversionBuffer, frameSize,
                     source, inputBufferHeader->nFilledLen,
                     mWidth, mHeight);
             if (source == NULL) {
 

                 notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
                 return;
             }
        } else {
            if (inputBufferHeader->nFilledLen < frameSize) {
                android_errorWriteLog(0x534e4554, ""27569635"");
                notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
                return;
            } else if (inputBufferHeader->nFilledLen > frameSize) {
                ALOGW(""Input buffer contains too many pixels"");
            }
 
            if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
                ConvertYUV420SemiPlanarToYUV420Planar(
                        source, mConversionBuffer, mWidth, mHeight);

                source = mConversionBuffer;
            }
         }
         vpx_image_t raw_frame;
         vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,
 

                 outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;
                 outputBufferHeader->nFlags = 0;
                 if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)
                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
                 outputBufferHeader->nOffset = 0;
                 outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;
                if (outputBufferHeader->nFilledLen > outputBufferHeader->nAllocLen) {
                    android_errorWriteLog(0x534e4554, ""27569635"");
                    notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
                    return;
                }
                 memcpy(outputBufferHeader->pBuffer,
                        encoded_packet->data.frame.buf,
                        encoded_packet->data.frame.sz);
","codecs/on2/enc/SoftVPXEncoder.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27569635."
2317,CVE-2016-2449," 

 #include <utils/Trace.h>
 #include <utils/Timers.h>
 
#include ""CameraService.h""
 #include ""utils/CameraTraces.h""
 #include ""mediautils/SchedulingPolicyService.h""
 #include ""device3/Camera3Device.h""
 

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);

    if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
        android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, ""26866110"",
                IPCThreadState::self()->getCallingUid(), NULL, 0);
        return BAD_VALUE;
    }

     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
","services/camera/libcameraservice/device3/Camera3Device.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate template IDs, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27568958."
2318,CVE-2016-2448," 

         copy = size;
     }
 
    if (entry->mIndex >= mBuffers.size()) {
        return ERROR_MALFORMED;
    }

    sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
    if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
        return ERROR_MALFORMED;
    }

     memcpy(data,
           (const uint8_t *)mem->pointer()
             + entry->mOffset,
            copy);
 
","media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not properly validate entry data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27533704."
2319,CVE-2016-2440," 

                     << reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
             }
             if (tr.target.ptr) {
                 
                 
                if (reinterpret_cast<RefBase::weakref_type*>(
                        tr.target.ptr)->attemptIncStrong(this)) {
                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
                            &reply, tr.flags);
                    reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                } else {
                    error = UNKNOWN_TRANSACTION;
                }
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
","libs/binder/IPCThreadState.cpp in Binder in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 mishandles object references, which allows attackers to gain privileges via a crafted application, aka internal bug 27252896."
2320,CVE-2016-2439," 

                                uint8_t pin_len, bt_pin_code_t *pin_code)
 {
     BTIF_TRACE_EVENT(""%s: accept=%d"", __FUNCTION__, accept);
    if (pin_code == NULL || pin_len > PIN_CODE_LEN)
         return BT_STATUS_FAIL;
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 
","Buffer overflow in btif/src/btif_dm.c in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows remote attackers to execute arbitrary code via a long PIN value, aka internal bug 27411268."
2321,CVE-2016-2430," 

   }
 }
 
 std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
   return func_name;
 }
 
","libbacktrace/Backtrace.cpp in debuggerd in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows attackers to gain privileges via an application containing a crafted symbol name, aka internal bug 27299236."
2322,CVE-2016-2429," 

 		if (obj->num_comments > 0) {
 			if (0 == (obj->comments = safe_malloc_mul_2op_p(obj->num_comments,  sizeof(FLAC__StreamMetadata_VorbisComment_Entry)))) {
 				decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
				obj->num_comments = 0;
 				return false;
 			}
 			for (i = 0; i < obj->num_comments; i++) {
","libFLAC/stream_decoder.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not prevent free operations on uninitialized memory, which allows remote attackers to execute arbitrary code or cause a denial of service (heap memory corruption) via a crafted media file, aka internal bug 27211885."
2323,CVE-2016-2428," 

  
     int bitsParsed;
 

 
    
 
  if (self->numThreads >= MAX_DRC_THREADS) {
      self->numThreads = MAX_DRC_THREADS - 1;
  }

    
   for (thread = 0; thread < self->numThreads; thread++) {
     CDrcPayload *pThreadBs = &threadBs[thread];
","libAACdec/src/aacdec_drc.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not properly limit the number of threads, which allows remote attackers to execute arbitrary code or cause a denial of service (stack memory corruption) via a crafted media file, aka internal bug 26751339."
2324,CVE-2016-2420," 

   log.current_tid = tid;
   log.crashed_tid = tid;
 
   int fd = -1;
  char* path = find_and_open_tombstone(&fd);
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
","rootdir/init.rc in Android 4.x before 4.4.4 does not ensure that the /data/tombstones directory exists for the Debuggerd component, which allows attackers to gain privileges via a crafted application, aka internal bug 26403620."
2325,CVE-2016-2419," 

 
             Vector<uint8_t> request;
             String8 defaultUrl;
            DrmPlugin::KeyRequestType keyRequestType = DrmPlugin::kKeyRequestType_Unknown;
 
             status_t result = getKeyRequest(sessionId, initData, mimeType,
                     keyType, optionalParameters, request, defaultUrl,
","media/libmedia/IDrm.cpp in mediaserver in Android 6.x before 2016-04-01 does not initialize a certain key-request data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26323455."
2326,CVE-2016-2418," 

             OMX_U32 port_index = data.readInt32();
 
             sp<IGraphicBufferProducer> bufferProducer;
            MetadataBufferType type = kMetadataBufferTypeInvalid;
             status_t err = createInputSurface(node, port_index, &bufferProducer, &type);
 
            if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {
                android_errorWriteLog(0x534e4554, ""26324358"");
            }

             reply->writeInt32(type);
             reply->writeInt32(err);
 
 

             sp<IGraphicBufferConsumer> bufferConsumer =
                     interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());
 
            MetadataBufferType type = kMetadataBufferTypeInvalid;
             status_t err = setInputSurface(node, port_index, bufferConsumer, &type);
 
            if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {
                android_errorWriteLog(0x534e4554, ""26324358"");
            }

             reply->writeInt32(type);
             reply->writeInt32(err);
             return NO_ERROR;
 

             OMX_U32 port_index = data.readInt32();
             OMX_BOOL enable = (OMX_BOOL)data.readInt32();
 
            MetadataBufferType type = kMetadataBufferTypeInvalid;
             status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);

            if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {
                android_errorWriteLog(0x534e4554, ""26324358"");
            }

             reply->writeInt32(type);
             reply->writeInt32(err);
 
","media/libmedia/IOMX.cpp in mediaserver in Android 6.x before 2016-04-01 does not initialize certain metadata buffer pointers, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26324358."
2327,CVE-2016-2417," 

 
             size_t size = data.readInt64();
 
            status_t err = NO_MEMORY;
            void *params = calloc(size, 1);
            if (params) {
                err = data.read(params, size);
                if (err != OK) {
                    android_errorWriteLog(0x534e4554, ""26914474"");
                } else {
                    switch (code) {
                        case GET_PARAMETER:
                            err = getParameter(node, index, params, size);
                            break;
                        case SET_PARAMETER:
                            err = setParameter(node, index, params, size);
                            break;
                        case GET_CONFIG:
                            err = getConfig(node, index, params, size);
                            break;
                        case SET_CONFIG:
                            err = setConfig(node, index, params, size);
                            break;
                        case SET_INTERNAL_OPTION:
                        {
                            InternalOptionType type =
                                (InternalOptionType)data.readInt32();
 
                            err = setInternalOption(node, index, type, params, size);
                            break;
                        }
 
                        default:
                            TRESPASS();
                    }
                 }
             }
 
             reply->writeInt32(err);
","media/libmedia/IOMX.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a parameter data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26914474."
2328,CVE-2016-2416," 

             ""android.permission.DUMP""), pid, uid)) {
         result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                 ""from pid=%d, uid=%d\n"", pid, uid);
        android_errorWriteWithInfoLog(0x534e4554, ""27046057"", uid, NULL, 0);
     } else {
         mCore->dump(result, prefix);
     }
","libs/gui/BufferQueueConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for the android.permission.DUMP permission, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via a dump request, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27046057."
2329,CVE-2016-2414," 

 #define LOG_TAG ""Minikin""
 #include <cutils/log.h>
 
#define LOG_TAG ""Minikin""
#include <cutils/log.h>

 #include <vector>
 using std::vector;
 
 

         uint32_t start = readU16(data, kHeaderSize + 2 * (segCount + i));
         if (end < start) {
              
            android_errorWriteLog(0x534e4554, ""26413177"");
             return false;
         }
         uint32_t rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));
 

     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
     if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
        android_errorWriteLog(0x534e4554, ""25645298"");
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 

         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
         if (end < start) {
              
            android_errorWriteLog(0x534e4554, ""26413177"");
             return false;
         }
         addRange(coverage, start, end + 1);   
","The Minikin library in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider negative size values in font data, which allows remote attackers to cause a denial of service (memory corruption and reboot loop) via a crafted font, aka internal bug 26413177."
2330,CVE-2016-2413," 

         remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply);
 
         status_t err = reply.readInt32();
        if (err == OK && sidebandHandle) {
             *sidebandHandle = (native_handle_t *)reply.readNativeHandle();
         }
         return err;
 

             OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
             OMX_U32 audio_hw_sync = data.readInt32();
 
            native_handle_t *sideband_handle = NULL;
             status_t err = configureVideoTunnelMode(
                     node, port_index, tunneled, audio_hw_sync, &sideband_handle);
             reply->writeInt32(err);
            if(err == OK){
                reply->writeNativeHandle(sideband_handle);
            }
 
             return NO_ERROR;
         }
","media/libmedia/IOMX.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a handle pointer, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26403627."
2331,CVE-2016-2412," 

 #    define SK_CRASH() __debugbreak()
 #  else
 #    if 1    
#      define SK_CRASH() do { SkNO_RETURN_HINT(); abort(); } while (false)
 #    else
 #      define SK_CRASH() do { SkNO_RETURN_HINT(); } while (true)
 #    endif
","include/core/SkPostConfig.h in Skia, as used in System_server in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01, mishandles certain crashes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26593930."
2332,CVE-2016-1621," 

         }
 
         if (mImg != NULL) {
            CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420);
 
             uint32_t width = mImg->d_w;
             uint32_t height = mImg->d_h;
 

             outHeader->nTimeStamp = inHeader->nTimeStamp;
 
             uint8_t *dst = outHeader->pBuffer;
            const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];
            const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];
            const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V];
            size_t srcYStride = mImg->stride[VPX_PLANE_Y];
            size_t srcUStride = mImg->stride[VPX_PLANE_U];
            size_t srcVStride = mImg->stride[VPX_PLANE_V];
             copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);
 
             mImg = NULL;
","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
2333,CVE-2016-1503," 

 
 		if (type)
 			*type = opt->type;
		 
 		if (opt->type == 0 ||
 		    opt->type & (STRING | RFC3442 | RFC5969))
 			return 0;
		 
 		sz = 0;
		if (opt->type & (UINT32 | SINT32 | IPV4))
 			sz = sizeof(uint32_t);
		else if (opt->type & (UINT16 | SINT16))
 			sz = sizeof(uint16_t);
		else if (opt->type & UINT8)
 			sz = sizeof(uint8_t);
		if (opt->type & ARRAY) {
			 
			if (!sz) return -1;
			return (dl % sz == 0) ? 0 : -1;
		}
		return (sz == dl) ? 0 : -1;
 	}
 
 	 
","dhcpcd before 6.10.0, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 and other products, mismanages option lengths, which allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow) via a malformed DHCP response, aka internal bug 26461634."
2334,CVE-2016-0850," 

 #define BTA_AV_RET_TOUT 15
 #endif
 
 #ifndef BTA_AV_CO_CP_SCMS_T
 #define BTA_AV_CO_CP_SCMS_T  FALSE
 #endif
","The PORCHE_PAIRING_CONFLICT feature in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to bypass intended pairing restrictions via a crafted device, aka internal bug 26551752."
2335,CVE-2016-0849," 

  *
  * System utilities.
  */
#include <stdbool.h>
#include <stdint.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
 

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
    if (pMap->ranges == NULL) {
        LOGE(""malloc failed: %s\n"", strerror(errno));
        munmap(memPtr, length);
        return -1;
    }
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 

     char block_dev[PATH_MAX+1];
     size_t size;
     unsigned int blksize;
    size_t blocks;
     unsigned int range_count;
     unsigned int i;
 
 

         LOGW(""failed to parse block map header\n"");
         return -1;
     }
    if (blksize != 0) {
        blocks = ((size-1) / blksize) + 1;
    }
    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {
        LOGE(""invalid data in block map file: size %zu, blksize %u, range_count %u\n"",
             size, blksize, range_count);
        return -1;
    }
 
     pMap->range_count = range_count;
    pMap->ranges = calloc(range_count, sizeof(MappedRange));
    if (pMap->ranges == NULL) {
        LOGE(""calloc(%u, %zu) failed: %s\n"", range_count, sizeof(MappedRange), strerror(errno));
        return -1;
    }
 
      
     unsigned char* reserve;
     reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
     if (reserve == MAP_FAILED) {
         LOGW(""failed to reserve address space: %s\n"", strerror(errno));
        free(pMap->ranges);
         return -1;
     }
 
     int fd = open(block_dev, O_RDONLY);
     if (fd < 0) {
         LOGW(""failed to open block device %s: %s\n"", block_dev, strerror(errno));
        munmap(reserve, blocks * blksize);
        free(pMap->ranges);
         return -1;
     }
 
     unsigned char* next = reserve;
    size_t remaining_size = blocks * blksize;
    bool success = true;
     for (i = 0; i < range_count; ++i) {
        size_t start, end;
        if (fscanf(mapf, ""%zu %zu\n"", &start, &end) != 2) {
             LOGW(""failed to parse range %d in block map\n"", i);
            success = false;
            break;
        }
        size_t length = (end - start) * blksize;
        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {
          LOGE(""unexpected range in block map: %zu %zu\n"", start, end);
          success = false;
          break;
         }
 
        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
         if (addr == MAP_FAILED) {
             LOGW(""failed to map block %d: %s\n"", i, strerror(errno));
            success = false;
            break;
         }
         pMap->ranges[i].addr = addr;
        pMap->ranges[i].length = length;
 
        next += length;
        remaining_size -= length;
    }
    if (success && remaining_size != 0) {
      LOGE(""ranges in block map are invalid: remaining_size = %zu\n"", remaining_size);
      success = false;
    }
    if (!success) {
      close(fd);
      munmap(reserve, blocks * blksize);
      free(pMap->ranges);
      return -1;
     }
 
    close(fd);
     pMap->addr = reserve;
     pMap->length = size;
 
 

 
         if (sysMapBlockFile(mapf, pMap) != 0) {
             LOGW(""Map of '%s' failed\n"", fn);
            fclose(mapf);
             return -1;
         }
 
","Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931."
2336,CVE-2016-0846," 

 #include <sys/mman.h>
 
 #include <binder/IMemory.h>
#include <cutils/log.h>
 #include <utils/KeyedVector.h>
 #include <utils/threads.h>
 #include <utils/Atomic.h>
 

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    size_t heapSize = mHeap->getSize();
                    if (s <= heapSize
                            && o >= 0
                            && (static_cast<size_t>(o) <= heapSize - s)) {
                        mOffset = o;
                        mSize = s;
                    } else {
                         
                        android_errorWriteWithInfoLog(0x534e4554,
                            ""26877992"", -1, NULL, 0);
                        mOffset = 0;
                        mSize = 0;
                    }
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return (mSize > 0) ? mHeap : 0;
 }
 
  
","libs/binder/IMemory.cpp in the IMemory Native Interface in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider the heap size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26877992."
2337,CVE-2016-0842," 

  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
#include ""log/log.h""
#include <cutils/log.h>

 #include ""ih264_typedefs.h""
 #include ""ih264_macros.h""
 #include ""ih264_platform_macros.h""
 

                                      pu4_bitstrm_buf);
                 while(u4_mmco != END_OF_MMCO)
                 {
                    if (j >= MAX_REF_BUFS)
                    {
                        ALOGE(""b/25818142"");
                        android_errorWriteLog(0x534e4554, ""25818142"");
                        ps_dpb_cmds->u1_num_of_commands = 0;
                        return -1;
                    }
                     ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
                     ps_mmc_params->u4_mmco = u4_mmco;
                     switch(u4_mmco)
","The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142."
2338,CVE-2016-0841," 

     const char* extractMetadata(int keyCode);
 
 private:
    static const sp<IMediaPlayerService> getService();
 
     class DeathNotifier: public IBinder::DeathRecipient
     {
","media/libmedia/mediametadataretriever.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 mishandles cleared service binders, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26040840."
2339,CVE-2016-0840," 

     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
     
     
     
    WORD16 ai2_level_arr[19];
    WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
 

     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
     
     
     
    WORD16 ai2_level_arr[19]; 
    WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
 

     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
     
     
     
    WORD16 ai2_level_arr[7]; 
    WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;
","Multiple stack-based buffer underflows in decoder/ih264d_parse_cavlc.c in mediaserver in Android 6.x before 2016-04-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26399350."
2340,CVE-2016-0839," 

     struct listnode *node, *temp_node_next;
     vol_listener_context_t *context = NULL;
     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;
    int status = -EINVAL;
     bool recompute_flag = false;
     int active_stream_count = 0;
    uint32_t session_id;
    uint32_t stream_type;
    effect_uuid_t uuid;

     ALOGV(""%s context %p"", __func__, handle);

    if (recv_contex == NULL) {
        return status;
    }
     pthread_mutex_lock(&vol_listner_init_lock);
    session_id = recv_contex->session_id;
    stream_type = recv_contex->stream_type;
    uuid = recv_contex->desc->uuid;
 
      
     list_for_each_safe(node, temp_node_next, &vol_effect_list) {
         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);
        if ((memcmp(&(context->desc->uuid), &uuid, sizeof(effect_uuid_t)) == 0)
            && (context->session_id == session_id)
            && (context->stream_type == stream_type)) {
             ALOGV(""--- Found something to remove ---"");
            list_remove(node);
             PRINT_STREAM_TYPE(context->stream_type);
             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {
                 recompute_flag = true;
 

 
     if (status != 0) {
         ALOGE(""something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>"");
        pthread_mutex_unlock(&vol_listner_init_lock);
        return status;
     }
 
      
","post_proc/volume_listener.c in mediaserver in Android 6.x before 2016-04-01 mishandles deleted effect context, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25753245."
2341,CVE-2016-0838," 

  * includes
  *------------------------------------
 */
#include ""log/log.h""

 #include ""eas_types.h""
 #include ""eas_math.h""
 #include ""eas_audioconst.h""
 

 
      
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pMixBuffer = pWTIntFrame->pMixBuffer;
     pInputBuffer = pWTIntFrame->pAudioBuffer;
 
 

 
      
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 
     loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;
 

 
      
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 
     phaseInc = pWTIntFrame->frame.phaseIncrement;
 

 
      
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pAudioBuffer = pWTIntFrame->pAudioBuffer;
 
     z1 = pFilter->z1;
 

 
      
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
     phaseInc = pWTIntFrame->frame.phaseIncrement;
 
 

     EAS_I8 *pLoopStart;
 
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pMixBuffer = pWTIntFrame->pMixBuffer;
 
      
","Sonivox in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for a negative number of samples, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to arm-wt-22k/lib_src/eas_wtengine.c and arm-wt-22k/lib_src/eas_wtsynth.c, aka internal bug 26366256."
2342,CVE-2016-0837," 

                     continue;
                 }
 
                if (dstOffset > SIZE_MAX - 4 ||
                        dstOffset + 4 > SIZE_MAX - nalLength ||
                        dstOffset + 4 + nalLength > mBuffer->size()) {
                    ALOGE(""b/27208621 : %zu %zu"", dstOffset, mBuffer->size());
                    android_errorWriteLog(0x534e4554, ""27208621"");
                    mBuffer->release();
                    mBuffer = NULL;
                    return ERROR_MALFORMED;
                }
 
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
","MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (out-of-bounds read and memory corruption) via a crafted media file, aka internal bug 27208621."
2343,CVE-2016-0836," 

                 u4_nz_cols |= 1 << (u4_pos & 0x7);
                 u4_nz_rows |= 1 << (u4_pos >> 0x3);
 
                if (u4_numCoeffs > 64)
                {
                    return IMPEG2D_MB_TEX_DECODE_ERR;
                }
 
             }
             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
         }
         else
         {
 

 
                 u4_nz_cols |= 1 << (u4_pos & 0x7);
                 u4_nz_rows |= 1 << (u4_pos >> 0x3);
                if (u4_numCoeffs > 64)
                {
                    return IMPEG2D_MB_TEX_DECODE_ERR;
                }

             }
 
             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
","Stack-based buffer overflow in decoder/impeg2d_vld.c in mediaserver in Android 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25812590."
2344,CVE-2016-0835," 

  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 #include <string.h>
#include <cutils/log.h>
 
 #include ""iv_datatypedef.h""
 #include ""iv.h""
 

             temp = u4_bits_read & 0xFF;
             i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));
 
            if (1 == ps_dec->i4_num_cores && 0 == ps_dec->u2_num_mbs_left)
            {
                i4_continue_decode = 0;
                android_errorWriteLog(0x534e4554, ""26070014"");
            }

             if(i4_continue_decode)
             {
                  
 

         i4_row -= 1;
 
 
        if(i4_prev_row < i4_row)
         {
              
             if(i4_start_row != -1)
 

              
             i4_start_row = i4_row;
 
        } else if (i4_prev_row > i4_row) {
            android_errorWriteLog(0x534e4554, ""26070014"");
         }
 
 
","decoder/impeg2d_dec_hdr.c in mediaserver in Android 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a certain negative value, aka internal bug 26070014."
2345,CVE-2016-0830," 

 static const char *LEGACY_CONFIG_FILE_PATH = ""/data/misc/bluedroid/bt_config.xml"";
 static const period_ms_t CONFIG_SETTLE_PERIOD_MS = 3000;
 
static void timer_config_save_cb(void *data);
static void btif_config_write(void);
static void btif_config_devcache_cleanup(void);
 
  
  
 

       unlink(LEGACY_CONFIG_FILE_PATH);
   }
 
  btif_config_devcache_cleanup();

    
    
    
 

   assert(alarm_timer != NULL);
   assert(config != NULL);
 
  alarm_set(alarm_timer, CONFIG_SETTLE_PERIOD_MS, timer_config_save_cb, NULL);
 }
 
 void btif_config_flush(void) {
 

 
   alarm_cancel(alarm_timer);
 
  btif_config_write();
 }
 
 int btif_config_clear(void){
 

   return ret;
 }
 
static void timer_config_save_cb(UNUSED_ATTR void *data) {
  btif_config_write();
}

static void btif_config_write(void) {
   assert(config != NULL);
   assert(alarm_timer != NULL);
 
  btif_config_devcache_cleanup();
 
   pthread_mutex_lock(&lock);
   config_save(config, CONFIG_FILE_PATH);
   pthread_mutex_unlock(&lock);
 }

static void btif_config_devcache_cleanup(void) {
  assert(config != NULL);

   
   
   
   
  static const size_t ADDRS_MAX = 512;
  size_t total_addrs = 0;

  pthread_mutex_lock(&lock);
  const config_section_node_t *snode = config_section_begin(config);
  while (snode != config_section_end(config)) {
    const char *section = config_section_name(snode);
    if (string_is_bdaddr(section)) {
      ++total_addrs;

      if ((total_addrs > ADDRS_MAX) &&
          !config_has_key(config, section, ""LinkKey"") &&
          !config_has_key(config, section, ""LE_KEY_PENC"") &&
          !config_has_key(config, section, ""LE_KEY_PID"") &&
          !config_has_key(config, section, ""LE_KEY_PCSRK"") &&
          !config_has_key(config, section, ""LE_KEY_LENC"") &&
          !config_has_key(config, section, ""LE_KEY_LCSRK"")) {
        snode = config_section_next(snode);
        config_remove_section(config, section);
        continue;
      }
    }
    snode = config_section_next(snode);
  }
  pthread_mutex_unlock(&lock);
}
","btif_config.c in Bluetooth in Android 6.x before 2016-03-01 allows remote attackers to cause a denial of service (memory corruption and persistent daemon crash) by triggering a large number of configuration entries, and consequently exceeding the maximum size of a configuration file, aka internal bug 26071376."
2346,CVE-2016-0829," 

             QueueBufferOutput* const output =
                     reinterpret_cast<QueueBufferOutput *>(
                             reply->writeInplace(sizeof(QueueBufferOutput)));
            memset(output, 0, sizeof(QueueBufferOutput));
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
","The BnGraphicBufferProducer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not initialize a certain output data structure, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering a QUEUE_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338109."
2347,CVE-2016-0828," 

             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
             data.read(*buffer.get());
            int slot = -1;
             int result = attachBuffer(&slot, buffer);
             reply->writeInt32(slot);
             reply->writeInt32(result);
","The BnGraphicBufferConsumer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 5.x before 5.1.1 LMY49H and 6.x before 2016-03-01 does not initialize a certain slot variable, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering an ATTACH_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338113."
2348,CVE-2016-0827," 

              
 
             effect_param_t *p = (effect_param_t *)pCmdData;
            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {
                android_errorWriteLog(0x534e4554, ""26347509"");
                return -EINVAL;
            }
             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
                     cmdSize < (sizeof(effect_param_t) + p->psize) ||
                     pReplyData == NULL || replySize == NULL ||
","Multiple integer overflows in libeffects in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, related to EffectBundle.cpp and EffectReverb.cpp, aka internal bug 26347509."
2349,CVE-2016-0826," 

     mClientPid = 0;
 }
 
status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {
     
     
    android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, ""26265403"",
            IPCThreadState::self()->getCallingUid(), NULL, 0);
    return OK;
}

 status_t CameraService::BasicClient::startCameraOps() {
     int32_t res;
 
 

             hasClient = true;
             result = String8::format(""  Device is open. Client instance dump:\n"");
             write(fd, result.string(), result.size());
            client->dumpClient(fd, args);
         }
         if (!hasClient) {
             result = String8::format(""\nNo active camera clients yet.\n"");
","libcameraservice in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not require use of the ICameraService::dump method for a camera service dump, which allows attackers to gain privileges via a crafted application that directly dumps, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26265403."
2350,CVE-2016-0824," 

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
 
        if (ps_stream->u4_offset < ps_stream->u4_max_offset)
        {
            u4_temp             = *(ps_stream->pu4_buf_aligned)++;
            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
        }
     }
     ps_stream->u4_offset          = u4_offset;
 
 

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 

    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
    {
        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
    }
     return;
 }
 /******************************************************************************
","libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591."
2351,CVE-2016-0816," 

                                      (UWORD16)(u1_num_mbs >> u1_mbaff));
         }
         u1_num_mbs++;
 
          
          
 

                                             u1_num_mbs_next, u1_tfr_n_mb,
                                             u1_end_of_row);
             }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
             if(u1_tfr_n_mb)
                 u1_num_mbs = 0;
             u1_mb_idx = u1_num_mbs;
 

                                          (UWORD16)(u1_num_mbs >> u1_mbaff));
             }
             u1_num_mbs++;
 
         }
 
 

                                             u1_num_mbs_next, u1_tfr_n_mb,
                                             u1_end_of_row);
             }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
             if(u1_tfr_n_mb)
                 u1_num_mbs = 0;
             u1_mb_idx = u1_num_mbs;
","mediaserver in Android 6.x before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to decoder/ih264d_parse_islice.c and decoder/ih264d_parse_pslice.c, aka internal bug 25928803."
2352,CVE-2016-0815," 

                     continue;
                 }
 
                if (dstOffset > SIZE_MAX - 4 ||
                        dstOffset + 4 > SIZE_MAX - nalLength ||
                        dstOffset + 4 + nalLength > mBuffer->size()) {
                    ALOGE(""b/26365349 : %zu %zu"", dstOffset, mBuffer->size());
                    android_errorWriteLog(0x534e4554, ""26365349"");
                    mBuffer->release();
                    mBuffer = NULL;
                    return ERROR_MALFORMED;
                }
 
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;
","The MPEG4Source::fragmentedRead function in MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26365349."
2353,CVE-2016-0811," 

 
             if (overflow || sumSubsampleSizes != totalSize) {
                 result = -EINVAL;
            } else if (totalSize > sharedBuffer->size()) {
                result = -EINVAL;
            } else if ((size_t)offset > sharedBuffer->size() - totalSize) {
                 result = -EINVAL;
             } else {
                 result = decrypt(
","Integer overflow in the BnCrypto::onTransact function in media/libmedia/ICrypto.cpp in libmediaplayerservice in Android 6.x before 2016-02-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering an improper size calculation, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25800375."
2354,CVE-2016-0810," 

 
      
     void sampleLoaded(int sampleID);
    sp<Sample> findSample(int sampleID);
 
      
     void done_l(SoundChannel* channel);
 

 private:
     SoundPool() {}  
     bool startThreads();
    sp<Sample> findSample_l(int sampleID);
     SoundChannel* findChannel (int channelID);
     SoundChannel* findNextChannel (int channelID);
     SoundChannel* allocateChannel_l(int priority);
","media/libmedia/SoundPool.cpp in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49G, and 6.x before 2016-02-01 mishandles locking requirements, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25781119."
2355,CVE-2016-0809," 

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
             
            cmd->releaseRef();
         }
     }
 
","Use-after-free vulnerability in the wifi_cleanup function in bcmdhd/wifi_hal/wifi_hal.cpp in Wi-Fi in Android 6.x before 2016-02-01 allows attackers to gain privileges by leveraging access to the local physical environment during execution of a crafted application, aka internal bug 25753768."
2356,CVE-2016-0808," 

 
  
 static uint32_t readU16(const uint8_t* data, size_t offset) {
    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);
 }
 
 static uint32_t readU32(const uint8_t* data, size_t offset) {
    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |
        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);
 }
 
 static void addRange(vector<uint32_t> &coverage, uint32_t start, uint32_t end) {
 

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;   
     
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
","Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298."
2357,CVE-2016-0807," 

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
            
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[160];
          if (nhdr.n_descsz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, desc size value is too large: %u"",
                  nhdr.n_descsz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
","The get_build_id function in elf_utils.cpp in Debuggerd in Android 6.x before 2016-02-01 allows attackers to gain privileges via a crafted application that mishandles a Desc Size element in an ELF Note, aka internal bug 25187394."
2358,CVE-2016-0804," 

             {
                 Mutex::Autolock _l(mDisconnectLock);
                 mDataSource.clear();
                mDrmManagerClient = NULL;
                 mCachedSource.clear();
                 mHttpSource.clear();
             }
","The NuPlayer::GenericSource::notifyPreparedAndCleanup function in media/libmediaplayerservice/nuplayer/GenericSource.cpp in mediaserver in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 improperly manages mDrmManagerClient objects, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25070434."
2359,CVE-2016-0803," 

 
 #include <inttypes.h>
 
#ifndef INT32_MAX
#define INT32_MAX   2147483647
#endif

 namespace android {
 
 template<class T>
 

     if (mColorFormat != OMX_COLOR_FormatYUV420Planar || mInputDataIsMeta) {
          
         free(mInputFrameData);
        mInputFrameData = NULL;
        if (((uint64_t)mWidth * mHeight) > ((uint64_t)INT32_MAX / 3)) {
            ALOGE(""b/25812794, Buffer size is too big."");
            return OMX_ErrorBadParameter;
        }
         mInputFrameData =
             (uint8_t *) malloc((mWidth * mHeight * 3 ) >> 1);
         CHECK(mInputFrameData != NULL);
","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49G, and 6.x before 2016-02-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation in the (1) SoftMPEG4Encoder or (2) SoftVPXEncoder component, aka internal bug 25812794."
2360,CVE-2015-6640," 

 			tmp = end;
 
 		 
		error = prctl_update_vma_anon_name(vma, &prev, start, tmp,
 				(const char __user *)arg);
 		if (error)
 			return error;
","The prctl_set_vma_anon_name function in kernel/sys.c in Android before 5.1.1 LMY49F and 6.0 before 2016-01-01 does not ensure that only one vma is accessed in a certain update action, which allows attackers to gain privileges or cause a denial of service (vma list corruption) via a crafted application, aka internal bug 20017123."
2361,CVE-2017-0823," 

     int data;
     unsigned int qxdm_data[6];
     const char *deactData[1] = {""1""};
     RIL_Dial dialData;
     int hangupData[1] = {1};
     int number;
     char **args;
     RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
    int MAX_DIAL_ADDRESS = 128;
     int sim_id = 0;
 
     RLOGI(""debugCallback for socket %s"", rilSocketIdToString(socket_id));
 

              
             issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
             break;
         case 7:
             RLOGI(""Debug port: Deactivate Data Call"");
             issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
 

         case 8:
             RLOGI(""Debug port: Dial Call"");
             dialData.clir = 0;
            if (strlen(args[1]) > MAX_DIAL_ADDRESS) {
                RLOGE(""Debug port: Error calling Dial"");
                freeDebugCallbackArgs(number, args);
                close(acceptFD);
                return;
            }
             dialData.address = args[1];
             issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
             break;
","An information disclosure vulnerability in the Android system (rild). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-37896655."
2362,CVE-2017-0820," 

                 ALOGE(""moov: depth %d"", depth);
                 return ERROR_MALFORMED;
             }

            if (chunk_type == FOURCC('m', 'o', 'o', 'v') && mInitCheck == OK) {
                ALOGE(""duplicate moov"");
                return ERROR_MALFORMED;
            }

             if (chunk_type == FOURCC('m', 'o', 'o', 'f') && !mMoofFound) {
                  
                 mMoofFound = true;
 

                 if (!mLastTrack->meta->findInt32(kKeyTrackID, &trackId)) {
                     mLastTrack->skipTrack = true;
                 }

                status_t err = verifyTrack(mLastTrack);
                if (err != OK) {
                    mLastTrack->skipTrack = true;
                }

                 if (mLastTrack->skipTrack) {
                     Track *cur = mFirstTrack;
 
 

 
                     return OK;
                 }
             } else if (chunk_type == FOURCC('m', 'o', 'o', 'v')) {
                 mInitCheck = OK;
 
","A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-62187433."
2363,CVE-2017-0819," 

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
","A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63045918."
2364,CVE-2017-0818," 

             }
              
             if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {
                if (mBuf != NULL) {
                    mBuf->release();
                    mBuf = NULL;
                }
                 break;
             }
             curGranulePosition = mCurrentPage.mGranulePosition;
","A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63581671."
2365,CVE-2017-0817," 

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
    PortInfo *port = &mPorts.editItemAt(portIndex);
    if (size < port->mDef.nBufferSize) {
        ALOGE(""b/63522430, Buffer size is too small."");
        android_errorWriteLog(0x534e4554, ""63522430"");
        return OMX_ErrorBadParameter;
    }

     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);
","An information disclosure vulnerability in the Android media framework (libstagefright). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63522430."
2366,CVE-2017-0816," 

             return -EINVAL;
         }
         effect_param_t *cmd = (effect_param_t *) pCmdData;
        if (cmd->psize != sizeof(int32_t)) {
            android_errorWriteLog(0x534e4554, ""63662938"");
            return -EINVAL;
        }
         *(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data,
                 cmd->vsize, cmd->data + sizeof(int32_t));
         break;
","An information disclosure vulnerability in the Android media framework (libeffects). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63662938."
2367,CVE-2017-0814," 

 }
 
 static ogg_uint32_t decpack(long entry,long used_entry,long quantvals,
                            codebook *b,oggpack_buffer *opb,int maptype){
   ogg_uint32_t ret=0;
   int j;
 
 

     if(maptype==1){
        
       for(j=0;j<b->dim;j++){
        ogg_uint32_t off=entry%quantvals;
        entry/=quantvals;
        ret|=((ogg_uint16_t *)(b->q_val))[off]<<(b->q_bits*j);
       }
     }else{
       for(j=0;j<b->dim;j++)
        ret|=oggpack_read(opb,b->q_bits)<<(b->q_bits*j);
     }
     return ret;
 
 

  
 static int _make_words(char *l,long n,ogg_uint32_t *r,long quantvals,
                       codebook *b, oggpack_buffer *opb,int maptype){
   long i,j,count=0;
   long top=0;
   ogg_uint32_t marker[MARKER_SIZE];
 

           ALOGE(""b/23881715"");
           return 1;
         }
        ogg_uint32_t entry=marker[length];
        long chase=0;
        if(count && !entry)return -1;  
 
         
        for(j=0;j<length-1;j++){
          int bit=(entry>>(length-j-1))&1;
          if(chase>=top){
            if (chase < 0 || chase >= n) return 1;
            top++;
            r[chase*2]=top;
            r[chase*2+1]=0;
          }else
            if (chase < 0 || chase >= n || chase*2+bit > n*2+1) return 1;
            if(!r[chase*2+bit])
              r[chase*2+bit]=top;
          chase=r[chase*2+bit];
          if (chase < 0 || chase >= n) return 1;
        }
        {
          int bit=(entry>>(length-j-1))&1;
          if(chase>=top){
            top++;
            r[chase*2+1]=0;
          }
          r[chase*2+bit]= decpack(i,count++,quantvals,b,opb,maptype) |
            0x80000000;
        }
 
         
        for(j=length;j>0;j--){
          if(marker[j]&1){
            marker[j]=marker[j-1]<<1;
            break;
          }
          marker[j]++;
        }
 
         
        for(j=length+1;j<MARKER_SIZE;j++)
          if((marker[j]>>1) == entry){
            entry=marker[j];
            marker[j]=marker[j-1]<<1;
          }else
            break;
       }
     }
   }
 

 }
 
 static int _make_decode_table(codebook *s,char *lengthlist,long quantvals,
                              oggpack_buffer *opb,int maptype){
   int i;
   ogg_uint32_t *work;
 
 

      
     if(_make_words(lengthlist,s->entries,
                   s->dec_table,quantvals,s,opb,maptype))return 1;
 
     return 0;
   }
 

   if (s->used_entries > INT_MAX/(s->dec_leafw+1)) goto error_out;
   if (s->dec_nodeb && s->used_entries * (s->dec_leafw+1) > INT_MAX/s->dec_nodeb) goto error_out;
   s->dec_table=_ogg_malloc((s->used_entries*(s->dec_leafw+1)-2)*
                           s->dec_nodeb);
   if (!s->dec_table) goto error_out;
 
   if(s->dec_leafw==1){
     switch(s->dec_nodeb){
     case 1:
       for(i=0;i<s->used_entries*2-2;i++)
          ((unsigned char *)s->dec_table)[i]=(unsigned char)
            (((work[i] & 0x80000000UL) >> 24) | work[i]);
       break;
     case 2:
       for(i=0;i<s->used_entries*2-2;i++)
          ((ogg_uint16_t *)s->dec_table)[i]=(ogg_uint16_t)
            (((work[i] & 0x80000000UL) >> 16) | work[i]);
       break;
     }
 
 

       unsigned char *out=(unsigned char *)s->dec_table;
 
       for(i=s->used_entries*2-4;i>=0;i-=2){
        if(work[i]&0x80000000UL){
          if(work[i+1]&0x80000000UL){
            top-=4;
            out[top]=(work[i]>>8 & 0x7f)|0x80;
            out[top+1]=(work[i+1]>>8 & 0x7f)|0x80;
            out[top+2]=work[i] & 0xff;
            out[top+3]=work[i+1] & 0xff;
          }else{
            top-=3;
            out[top]=(work[i]>>8 & 0x7f)|0x80;
            out[top+1]=work[work[i+1]*2];
            out[top+2]=work[i] & 0xff;
          }
        }else{
          if(work[i+1]&0x80000000UL){
            top-=3;
            out[top]=work[work[i]*2];
            out[top+1]=(work[i+1]>>8 & 0x7f)|0x80;
            out[top+2]=work[i+1] & 0xff;
          }else{
            top-=2;
            out[top]=work[work[i]*2];
            out[top+1]=work[work[i+1]*2];
          }
        }
        work[i]=top;
       }
     }else{
       ogg_uint16_t *out=(ogg_uint16_t *)s->dec_table;
       for(i=s->used_entries*2-4;i>=0;i-=2){
        if(work[i]&0x80000000UL){
          if(work[i+1]&0x80000000UL){
            top-=4;
            out[top]=(work[i]>>16 & 0x7fff)|0x8000;
            out[top+1]=(work[i+1]>>16 & 0x7fff)|0x8000;
            out[top+2]=work[i] & 0xffff;
            out[top+3]=work[i+1] & 0xffff;
          }else{
            top-=3;
            out[top]=(work[i]>>16 & 0x7fff)|0x8000;
            out[top+1]=work[work[i+1]*2];
            out[top+2]=work[i] & 0xffff;
          }
        }else{
          if(work[i+1]&0x80000000UL){
            top-=3;
            out[top]=work[work[i]*2];
            out[top+1]=(work[i+1]>>16 & 0x7fff)|0x8000;
            out[top+2]=work[i+1] & 0xffff;
          }else{
            top-=2;
            out[top]=work[work[i]*2];
            out[top+1]=work[work[i+1]*2];
          }
        }
        work[i]=top;
       }
     }
   }
 

        
 
       for(i=0;i<s->entries;i++){
        if(oggpack_read(opb,1)){
          long num=oggpack_read(opb,5);
          if(num==-1)goto _eofout;
          lengthlist[i]=(char)(num+1);
          s->used_entries++;
          if(num+1>s->dec_maxlength)s->dec_maxlength=num+1;
        }else
          lengthlist[i]=0;
       }
     }else{
        
       s->used_entries=s->entries;
       for(i=0;i<s->entries;i++){
        long num=oggpack_read(opb,5);
        if(num==-1)goto _eofout;
        lengthlist[i]=(char)(num+1);
        if(num+1>s->dec_maxlength)s->dec_maxlength=num+1;
       }
     }
 
 

       if (!lengthlist) goto _eofout;
 
       for(i=0;i<s->entries;){
        long num=oggpack_read(opb,_ilog(s->entries-i));
        if(num<0)goto _eofout;
        for(j=0;j<num && i<s->entries;j++,i++)
          lengthlist[i]=(char)length;
        s->dec_maxlength=length;
        length++;
       }
     }
     break;
 

 
 
       if(total1<=4 && total1<=total2){
         
 
         
        s->q_val=calloc(sizeof(ogg_uint16_t), quantvals);
        if (!s->q_val) goto _eofout;
        for(i=0;i<quantvals;i++)
          ((ogg_uint16_t *)s->q_val)[i]=(ogg_uint16_t)oggpack_read(opb,s->q_bits);
 
        if(oggpack_eop(opb)){
          goto _eofout;
        }
 
        s->dec_type=1;
        s->dec_nodeb=_determine_node_bytes(s->used_entries,
                                           (s->q_bits*s->dim+8)/8);
        s->dec_leafw=_determine_leaf_words(s->dec_nodeb,
                                           (s->q_bits*s->dim+8)/8);
        if(_make_decode_table(s,lengthlist,quantvals,opb,maptype)){
          goto _errout;
        }
 
        free(s->q_val);
        s->q_val=0;
 
       }else{
         
 
         
        if(s->q_bits<=8){
          s->q_val=_ogg_malloc(quantvals);
          if (!s->q_val) goto _eofout;
          for(i=0;i<quantvals;i++)
            ((unsigned char *)s->q_val)[i]=(unsigned char)oggpack_read(opb,s->q_bits);
        }else{
          s->q_val=_ogg_malloc(quantvals*2);
          if (!s->q_val) goto _eofout;
          for(i=0;i<quantvals;i++)
            ((ogg_uint16_t *)s->q_val)[i]=(ogg_uint16_t)oggpack_read(opb,s->q_bits);
        }
 
        if(oggpack_eop(opb))goto _eofout;
 
        s->q_pack=_ilog(quantvals-1);
        s->dec_type=2;
        s->dec_nodeb=_determine_node_bytes(s->used_entries,
                                           (_ilog(quantvals-1)*s->dim+8)/8);
        s->dec_leafw=_determine_leaf_words(s->dec_nodeb,
                                           (_ilog(quantvals-1)*s->dim+8)/8);
        if(_make_decode_table(s,lengthlist,quantvals,opb,maptype))goto _errout;
 
       }
     }
 

       s->q_val=_ogg_malloc(s->q_pack*s->used_entries);
 
       if(s->q_bits<=8){
        for(i=0;i<s->used_entries*s->dim;i++)
          ((unsigned char *)(s->q_val))[i]=(unsigned char)oggpack_read(opb,s->q_bits);
       }else{
        for(i=0;i<s->used_entries*s->dim;i++)
          ((ogg_uint16_t *)(s->q_val))[i]=(ogg_uint16_t)oggpack_read(opb,s->q_bits);
       }
     }
     break;
 

                                         oggpack_buffer *b);
 #else
 static inline ogg_uint32_t decode_packed_entry_number(codebook *book,
                                                      oggpack_buffer *b){
   ogg_uint32_t chase=0;
   int  read=book->dec_maxlength;
   long lok = oggpack_look(b,read),i;
 

       unsigned char *t=(unsigned char *)book->dec_table;
 
       for(i=0;i<read;i++){
        chase=t[chase*2+((lok>>i)&1)];
        if(chase&0x80UL)break;
       }
       chase&=0x7fUL;
       break;
 

        
       unsigned char *t=(unsigned char *)book->dec_table;
       for(i=0;i<read;i++){
        int bit=(lok>>i)&1;
        int next=t[chase+bit];
        if(next&0x80){
          chase= (next<<8) | t[chase+bit+1+(!bit || t[chase]&0x80)];
          break;
        }
        chase=next;
       }
        
       chase&=~0x8000UL;
 

        
        
       for(i=0;i<read;i++){
        chase=((ogg_uint16_t *)(book->dec_table))[chase*2+((lok>>i)&1)];
        if(chase&0x8000UL)break;
       }
        
       chase&=~0x8000UL;
 

        
       ogg_uint16_t *t=(ogg_uint16_t *)book->dec_table;
       for(i=0;i<read;i++){
        int bit=(lok>>i)&1;
        int next=t[chase+bit];
        if(next&0x8000){
          chase= (next<<16) | t[chase+bit+1+(!bit || t[chase]&0x8000)];
          break;
        }
        chase=next;
       }
        
       chase&=~0x80000000UL;
 

     {
        
       for(i=0;i<read;i++){
        chase=((ogg_uint32_t *)(book->dec_table))[chase*2+((lok>>i)&1)];
        if(chase&0x80000000UL)break;
       }
        
       chase&=~0x80000000UL;
 

     int mask=(1<<s->q_pack)-1;
     for(i=0;i<s->dim;i++){
       if(s->q_bits<=8)
        v[i]=((unsigned char *)(s->q_val))[entry&mask];
       else
        v[i]=((ogg_uint16_t *)(s->q_val))[entry&mask];
       entry>>=s->q_pack;
     }
     break;
 

 
     if(s->q_bits<=8){
       for(i=0;i<s->dim;i++)
        v[i]=((unsigned char *)ptr)[i];
     }else{
       for(i=0;i<s->dim;i++)
        v[i]=((ogg_uint16_t *)ptr)[i];
     }
     break;
   }
 

 
     if(s->q_seq)
       for(i=1;i<s->dim;i++)
        v[i]+=v[i-1];
   }
 
   return 0;
 

 
  
 long vorbis_book_decodevs_add(codebook *book,ogg_int32_t *a,
                              oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
     int step=n/book->dim;
     ogg_int32_t *v = book->dec_buf; 
 

     for (j=0;j<step;j++){
       if(decode_map(book,b,v,point))return -1;
       for(i=0,o=j;i<book->dim;i++,o+=step)
        a[o]+=v[i];
     }
   }
   return 0;
 }
 
 long vorbis_book_decodev_add(codebook *book,ogg_int32_t *a,
                             oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
     ogg_int32_t *v = book->dec_buf; 
     int i,j;
 

     if (!v) return -1;
     for(i=0;i<n;){
       if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim && i < n;j++)
        a[i++]+=v[j];
     }
   }
   return 0;
 }
 
 long vorbis_book_decodev_set(codebook *book,ogg_int32_t *a,
                             oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
     ogg_int32_t *v = book->dec_buf; 
     int i,j;
 

     if (!v) return -1;
     for(i=0;i<n;){
       if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim && i < n;j++)
        a[i++]=v[j];
     }
   }else{
     int i,j;
 
     for(i=0;i<n;){
      for (j=0;j<book->dim && i < n;j++)
        a[i++]=0;
     }
   }
 
 

 
 #ifndef ONLY_C
 long vorbis_book_decodevv_add(codebook *book,ogg_int32_t **a,
                              long offset,int ch,
                              oggpack_buffer *b,int n,int point);
 #else
 long vorbis_book_decodevv_add(codebook *book,ogg_int32_t **a,
                              long offset,int ch,
                              oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
 
     ogg_int32_t *v = book->dec_buf; 
 

     if (!v) return -1;
     for(i=offset;i<offset+n;){
       if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim && i < offset + n;j++){
        a[chptr++][i]+=v[j];
        if(chptr==ch){
          chptr=0;
          i++;
        }
       }
     }
   }
","An information disclosure vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-62800140."
2368,CVE-2017-0813," 

 
     if (mDataSource->readAt(data_offset + 8, mSyncSamples,
             (size_t)allocSize) != (ssize_t)allocSize) {
        delete[] mSyncSamples;
         mSyncSamples = NULL;
         return ERROR_IO;
     }
 

 }
 
 }   
","A denial of service vulnerability in the Android media framework (libstagefright). Product: Android. Versions: 7.0, 7.1.1, 7.1.2. Android ID: A-36531046."
2369,CVE-2017-0812," 

     ssize_t frames_wr = 0;  
     size_t bytes_per_sample = audio_bytes_per_sample(stream->common.get_format(&stream->common));
     void *proc_buf_out = buffer;

      
    if (channel_remapping_needed || has_processing) {
        const size_t src_buffer_size = frames_num * src_frame_size;

        if (in->proc_buf_size < src_buffer_size) {
            in->proc_buf_size = src_buffer_size;
#ifdef PREPROCESSING_ENABLED
             
            in->proc_buf_in = realloc(in->proc_buf_in, src_buffer_size);
            ALOG_ASSERT((in->proc_buf_in != NULL),
                    ""process_frames() failed to reallocate proc_buf_in"");
#endif
            in->proc_buf_out = realloc(in->proc_buf_out, src_buffer_size);
            ALOG_ASSERT((in->proc_buf_out != NULL),
                    ""process_frames() failed to reallocate proc_buf_out"");
        }
        if (channel_remapping_needed) {
            proc_buf_out = in->proc_buf_out;
        }
    }
 
 #ifdef PREPROCESSING_ENABLED
     if (has_processing) {
 

         while (frames_wr < frames_num) {
              
             if (in->proc_buf_frames < (size_t)frames_num) {
                ssize_t frames_rd = read_frames(in,
                        (char *)in->proc_buf_in + in->proc_buf_frames * src_frame_size,
                        frames_num - in->proc_buf_frames);
                if (frames_rd < 0) {
                      
                     frames_wr = frames_rd;
                     break;
 

 
               
            audio_buffer_t in_buf;
            audio_buffer_t out_buf;

             in_buf.frameCount = in->proc_buf_frames;
            in_buf.s16 = in->proc_buf_in;   
             out_buf.frameCount = frames_num - frames_wr;
            out_buf.s16 = (int16_t *)proc_buf_out + frames_wr * src_channels;
 
              
            for (int i = 0; i < in->num_preprocessors; i++) {
                 (*in->preprocessors[i].effect_itfe)->process(in->preprocessors[i].effect_itfe,
                                                    &in_buf,
                                                    &out_buf);
 

 
             if (in->proc_buf_frames) {
                 memcpy(in->proc_buf_in,
                       (char *)in->proc_buf_in + in_buf.frameCount * src_frame_size,
                       in->proc_buf_frames * src_frame_size);
             }
 
              
 

 #endif  
     {
          
         frames_wr = read_frames(in, proc_buf_out, frames_num);
         ALOG_ASSERT(frames_wr <= frames_num, ""read more frames than requested"");
     }
 
     
    if (channel_remapping_needed && frames_wr > 0) {
         size_t ret = adjust_channels(proc_buf_out, src_channels, buffer, dst_channels,
            bytes_per_sample, frames_wr * src_frame_size);
         ALOG_ASSERT(ret == (frames_wr * dst_channels * bytes_per_sample));
     }
 
","An elevation of privilege vulnerability in the Android media framework (audio hal). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-62873231."
2370,CVE-2017-0811," 

     BITS_PARSE(""tiles_enabled_flag"", value, ps_bitstrm, 1);
     ps_pps->i1_tiles_enabled_flag = value;
 
     
    if((ps_pps->i1_tiles_enabled_flag) &&
                    (ps_sps->i1_log2_ctb_size == 4) &&
                    ((ps_sps->i2_pic_width_in_luma_samples >= 4096) ||
                    (ps_sps->i2_pic_height_in_luma_samples >= 4096)))
    {
        return IHEVCD_INVALID_HEADER;
    }

     BITS_PARSE(""entropy_coding_sync_enabled_flag"", value, ps_bitstrm, 1);
     ps_pps->i1_entropy_coding_sync_enabled_flag = value;
 
","A remote code execution vulnerability in the Android media framework (libhevc). Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-37930177."
2371,CVE-2017-0810," 

 
         if(ret)
             return IMPEG2D_MB_TEX_DECODE_ERR;

        if(0 >= ps_dec->u2_num_mbs_left)
        {
            break;
        }

         IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);
 
         u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);
","A remote code execution vulnerability in the Android media framework (libmpeg2). Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-38207066."
2372,CVE-2017-0809," 

         accum = (accum << 6) | value;
 
         if (((i + 1) % 4) == 0) {
            if (j < outLen) { out[j++] = (accum >> 16); }
             if (j < outLen) { out[j++] = (accum >> 8) & 0xff; }
             if (j < outLen) { out[j++] = accum & 0xff; }
 
","A remote code execution vulnerability in the Android media framework (libstagefright). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-62673128."
2373,CVE-2017-0642," 

 {
     IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
     WORD32 value;
    WORD32 i, j;
     WORD32 sps_id;
 
     pps_t *ps_pps;
 

                     ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
                      
                     ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
                    for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
                     {
                         if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
                         {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
                             break;
                         }
                         ps_mv_buf++;
","A remote denial of service vulnerability in libhevc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34819017."
2374,CVE-2017-0637," 

     ps_pps->i1_loop_filter_across_tiles_enabled_flag = 0;
     if(ps_pps->i1_tiles_enabled_flag)
     {
        WORD32 wd = ALIGN64(ps_codec->i4_wd);
        WORD32 ht = ALIGN64(ps_codec->i4_ht);

        WORD32 max_tile_cols = (wd + MIN_TILE_WD - 1) / MIN_TILE_WD;
        WORD32 max_tile_rows = (ht + MIN_TILE_HT - 1) / MIN_TILE_HT;

         UEV_PARSE(""num_tile_columns_minus1"", value, ps_bitstrm);
         ps_pps->i1_num_tile_columns = value + 1;
 
 

         ps_pps->i1_num_tile_rows = value + 1;
 
         if((ps_pps->i1_num_tile_columns < 1) ||
                        (ps_pps->i1_num_tile_columns > max_tile_cols) ||
                         (ps_pps->i1_num_tile_rows < 1) ||
                        (ps_pps->i1_num_tile_rows > max_tile_rows))
             return IHEVCD_INVALID_HEADER;
 
         BITS_PARSE(""uniform_spacing_flag"", value, ps_bitstrm, 1);
","A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process.Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34064500."
2375,CVE-2017-0635," 

 }
 
 status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {
    if (size < 1) {
        ALOGE(""empty NAL b/35467107"");
        return ERROR_MALFORMED;
    }
     uint8_t nalUnitType = (data[0] >> 1) & 0x3f;
     status_t err = OK;
     switch (nalUnitType) {
         case 32:   
            if (size < 2) {
                ALOGE(""invalid NAL/VPS size b/35467107"");
                return ERROR_MALFORMED;
            }
             err = parseVps(data + 2, size - 2);
             break;
         case 33:   
            if (size < 2) {
                ALOGE(""invalid NAL/SPS size b/35467107"");
                return ERROR_MALFORMED;
            }
             err = parseSps(data + 2, size - 2);
             break;
         case 34:   
            if (size < 2) {
                ALOGE(""invalid NAL/PPS size b/35467107"");
                return ERROR_MALFORMED;
            }
             err = parsePps(data + 2, size - 2);
             break;
         case 39:   
","A remote denial of service vulnerability in HevcUtils.cpp in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as Low due to details specific to the vulnerability. Product: Android. Versions: 7.0, 7.1.1, 7.1.2. Android ID: A-35467107."
2376,CVE-2017-0603," 

 
     int64_t seekTimeUs;
     ReadOptions::SeekMode mode;
    if (mOffsetTableLength > 0 && options && options->getSeekTo(&seekTimeUs, &mode)) {
         size_t size;
         int64_t seekFrame = seekTimeUs / 20000ll;   
         mCurrentTimeUs = seekFrame * 20000ll;
","A denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as Moderate because it requires an uncommon device configuration. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35763994."
2377,CVE-2017-0600," 

  * and limitations under the License.
  * -------------------------------------------------------------------
  */

#define LOG_TAG ""m4v_h263""
#include <log/log.h>

  
     c_prev  = prev->yChan;
    if (!c_prev) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }
 
     pred_block = video->mblock->pred_block;
 
 

 
      
      
    c_prev  = prev->yChan;
    if (!c_prev) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }
    c_prev += offset;

      
     cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);
      
","A remote denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35269635."
2378,CVE-2017-0599," 

         }
         else
         {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
            if ((WORD32)IHEVCD_SUCCESS != ret)
            {
                return ret;
            }
 
         }
 
","A remote denial of service vulnerability in libhevc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34672748."
2379,CVE-2017-0596," 

 }
 
 SoftAACEncoder::~SoftAACEncoder() {
    onReset();
 
     if (mEncoderHandle) {
         CHECK_EQ(VO_ERR_NONE, mApiHandle->Uninit(mEncoderHandle));
 

     }
 }
 
void SoftAACEncoder::onReset() {
    delete[] mInputFrame;
    mInputFrame = NULL;
    mInputSize = 0;

    mSentCodecSpecificData = false;
    mInputTimeUs = -1ll;
    mSawInputEOS = false;
    mSignalledError = false;
}

 }   
 
 android::SoftOMXComponent *createSoftOMXComponent(
","An elevation of privilege vulnerability in libstagefright in Mediaserver could enable a local malicious application to execute arbitrary code within the context of a privileged process. This issue is rated as High because it could be used to gain local access to elevated capabilities, which are not normally accessible to a third-party application. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34749392."
2380,CVE-2017-0594," 

 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

        if (outHeader->nOffset + encInfo.confSize > outHeader->nAllocLen) {
            ALOGE(""b/34617444"");
            android_errorWriteLog(0x534e4554,""34617444"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }

         outHeader->nFilledLen = encInfo.confSize;
         outHeader->nFlags = OMX_BUFFERFLAG_CODECCONFIG;
 
","An elevation of privilege vulnerability in codecs/aacenc/SoftAACEncoder2.cpp in libstagefright in Mediaserver could enable a local malicious application to execute arbitrary code within the context of a privileged process. This issue is rated as High because it could be used to gain local access to elevated capabilities, which are not normally accessible to a third-party application. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34617444."
2381,CVE-2017-0592," 

 class FLACParser : public RefBase {
 
 public:
    enum {
        kMaxChannels = 8,
    };

     explicit FLACParser(
         const sp<DataSource> &dataSource,
          
 

      
     size_t mMaxBufferSize;
     MediaBufferGroup *mGroup;
    void (*mCopy)(short *dst, const int * src[kMaxChannels], unsigned nSamples, unsigned nChannels);
 
      
     FLAC__StreamDecoder *mDecoder;
 

     bool mWriteRequested;
     bool mWriteCompleted;
     FLAC__FrameHeader mWriteHeader;
    FLAC__int32 const * mWriteBuffer[kMaxChannels];
 
      
     FLAC__StreamDecoderErrorStatus mErrorStatus;
 

         mWriteRequested = false;
          
         mWriteHeader = frame->header;
        memmove(mWriteBuffer, buffer, sizeof(const FLAC__int32 * const) * getChannels());
         mWriteCompleted = true;
         return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
     } else {
 

 
 static void copyMono8(
         short *dst,
        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 

 
 static void copyStereo8(
         short *dst,
        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 

     }
 }
 
static void copyMultiCh8(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {
 

 
 static void copyMono16(
         short *dst,
        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 

 
 static void copyStereo16(
         short *dst,
        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 

     }
 }
 
static void copyMultiCh16(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {
 

 
 static void copyMono24(
         short *dst,
        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 

 
 static void copyStereo24(
         short *dst,
        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned  ) {
     for (unsigned i = 0; i < nSamples; ++i) {
 

     }
 }
 
static void copyMultiCh24(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {
 

 
 static void copyTrespass(
         short *  ,
        const int *[FLACParser::kMaxChannels]  ,
         unsigned  ,
         unsigned  ) {
     TRESPASS();
 

       mStreamInfoValid(false),
       mWriteRequested(false),
       mWriteCompleted(false),
       mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
 {
     ALOGV(""FLACParser::FLACParser"");
 

     }
     if (mStreamInfoValid) {
          
        if (getChannels() == 0 || getChannels() > kMaxChannels) {
             ALOGE(""unsupported channel count %u"", getChannels());
             return NO_INIT;
         }
 

         static const struct {
             unsigned mChannels;
             unsigned mBitsPerSample;
            void (*mCopy)(short *dst, const int * src[kMaxChannels], unsigned nSamples, unsigned nChannels);
         } table[] = {
             { 1,  8, copyMono8    },
             { 2,  8, copyStereo8  },
","A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788."
2382,CVE-2017-0591," 

 
     ps_cur_slice = ps_dec->ps_cur_slice;
     ps_pic_params = ps_dec->ps_cur_pps;
 
     i4_frame_gaps = 0;
     ps_dpb_mgr = ps_dec->ps_dpb_mgr;
","A remote code execution vulnerability in libavc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34097672."
2383,CVE-2017-0590," 

 
     BITS_PARSE(""sps_extension_flag"", value, ps_bitstrm, 1);
 
    if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
    {
        return IHEVCD_INVALID_PARAMETER;
    }
 
     {
         WORD32 numerator;
","A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35039946."
2384,CVE-2017-0589," 

            pu1_init_ctxt,
            IHEVC_CAB_CTXT_END);
     DEBUG_RANGE_OFST(""init"", ps_cabac->u4_range, ps_cabac->u4_ofst);

     
    if(ps_cabac->u4_ofst >= ps_cabac->u4_range)
    {
        return ((IHEVCD_ERROR_T)IHEVCD_FAIL);
    }

     return ((IHEVCD_ERROR_T)IHEVCD_SUCCESS);
 }
 
","A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34897036."
2385,CVE-2017-0588," 

             flags &= ~1;
         }
 
        if ((flags & 2) && (dataSize >= 2)) {
              
              
 
 

                 mData[writeOffset++] = mData[readOffset++];
             }
              
            if (readOffset <= oldSize) {
                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
            } else {
                ALOGE(""b/34618607 (%zu %zu %zu %zu)"", readOffset, writeOffset, oldSize, mSize);
                android_errorWriteLog(0x534e4554, ""34618607"");
            }
 
         }
        flags &= ~2;
         if (flags != prevFlags || iTunesHack) {
             WriteSyncsafeInteger(&mData[offset + 4], dataSize);
             mData[offset + 8] = flags >> 8;
","A remote code execution vulnerability in id3/ID3.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34618607."
2386,CVE-2017-0587," 

         bytes_remaining -= ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed;
     }
 
    if((1 != ps_dec_state->u2_decode_header) &&
        (((bytes_remaining > 0) && (1 == ps_dec_state->u2_header_done)) || ps_dec_state->u1_flushfrm))
     {
         if(ps_dec_state->u1_flushfrm)
         {
","A remote code execution vulnerability in libmpeg2 in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35219737."
2387,CVE-2017-0557," 

                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
                 
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }

                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
                 u4_level = DecodedValue >> 9;
 

                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
                 
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
","An information disclosure vulnerability in libmpeg2 in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34093073."
2388,CVE-2017-0556," 

 #include ""impeg2d_pic_proc.h""
 
 
 
#define MPEG2_MAX_FRAME_RATE_CODE   8
 
  
      
     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
    if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
    {
        return IMPEG2D_FRM_HDR_DECODE_ERR;
    }
      
      
      
","An information disclosure vulnerability in libmpeg2 in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34093952."
2389,CVE-2017-0555," 

     ps_dec->u2_cur_slice_num = 0;
     ps_dec->cur_dec_mb_num = 0;
     ps_dec->cur_recon_mb_num = 0;
    ps_dec->u4_first_slice_in_pic = 1;
     ps_dec->u1_first_pb_nal_in_pic = 1;
     ps_dec->u1_slice_header_done = 0;
     ps_dec->u1_dangling_field = 0;
","An information disclosure vulnerability in libavc in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33551775."
2390,CVE-2017-0552," 

              
             if(j == -1)
             {
                return ERROR_INV_SLICE_HDR_T;
             }
 
              
","A remote denial of service vulnerability in libavc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34097915."
2391,CVE-2017-0551," 

      
      
      
     
    i1_is_end_of_poc = 1;
    ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;

    if(ps_dec->u4_first_slice_in_pic != 2)
     {
         i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,
                                             &s_tmp_poc, &ps_dec->s_cur_pic_poc,
 

                                             u1_nal_unit_type, u4_idr_pic_id,
                                             u1_field_pic_flag,
                                             u1_bottom_field_flag);
     }
 
      
","A remote denial of service vulnerability in libavc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34097231."
2392,CVE-2017-0550," 

         if(u1_mbaff)
         {
             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
            if(!uc_more_data_flag && (0 == (i2_cur_mb_addr & 1)))
            {
                return ERROR_EOB_FLUSHBITS_T;
            }
         }
          
          
","A remote denial of service vulnerability in libavc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33933140."
2393,CVE-2017-0547," 

         case HDCP_ENCRYPT:
         {
             size_t size = data.readInt32();
             void *inData = NULL;
             
            if (size <= SIZE_MAX / 2) {
                inData = malloc(2 * size);
             }
             if (inData == NULL) {
                 reply->writeInt32(ERROR_OUT_OF_RANGE);
                 return OK;
 

 
             void *outData = (uint8_t *)inData + size;
 
            status_t err = data.read(inData, size);
            if (err != OK) {
                free(inData);
                reply->writeInt32(err);
                return OK;
            }
 
             uint32_t streamCTR = data.readInt32();
             uint64_t inputCTR;
            err = encrypt(inData, size, streamCTR, &inputCTR, outData);
 
             reply->writeInt32(err);
 
","An information disclosure vulnerability in libmedia in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as High because it is a general bypass for operating system protections that isolate application data from other applications. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33861560."
2394,CVE-2017-0543," 

         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;

         {
              
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
","A remote code execution vulnerability in libavc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34097866."
2395,CVE-2017-0542," 

         if(buflen == -1)
             buflen = 0;
          
         
        buflen = MIN(buflen, buf_size - 8);
 
         bytes_consumed = buflen + u4_length_of_start_code;
         ps_dec_op->u4_num_bytes_consumed += bytes_consumed;
","A remote code execution vulnerability in libavc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33934721."
2396,CVE-2017-0541," 

  
 #define SCNST
 
#include ""log/log.h""

 #include ""eas_data.h""
 #include ""eas_host.h""
 #include ""eas_mdls.h""
 

 {
 
      
    if (*pStackPtr >= (CDL_STACK_SIZE - 1)) {
        ALOGE(""b/34031018, stackPtr(%d)"", *pStackPtr);
        android_errorWriteLog(0x534e4554, ""34031018"");
         return EAS_ERROR_FILE_FORMAT;
    }
 
      
     *pStackPtr = *pStackPtr + 1;
","A remote code execution vulnerability in sonivox in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34031018."
2397,CVE-2017-0540," 

     numones = k;
     bin = 1;
     u4_sym = 0;
    while(bin && (numones <= 16))
     {
         IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);
         u4_sym += bin << numones++;
     }
 
     numones -= 1;
 
     if(numones)
     {
","A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33966031."
2398,CVE-2017-0539," 

         UEV_PARSE(""max_dec_pic_buffering"", value, ps_bitstrm);
         ps_sps->ai1_sps_max_dec_pic_buffering[i] = value + 1;
 
        if(ps_sps->ai1_sps_max_dec_pic_buffering[i] > MAX_DPB_SIZE)
        {
            return IHEVCD_INVALID_PARAMETER;
        }

         UEV_PARSE(""num_reorder_pics"", value, ps_bitstrm);
         ps_sps->ai1_sps_max_num_reorder_pics[i] = value;
 
        if(ps_sps->ai1_sps_max_num_reorder_pics[i] > ps_sps->ai1_sps_max_dec_pic_buffering[i])
        {
            return IHEVCD_INVALID_PARAMETER;
        }

         UEV_PARSE(""max_latency_increase"", value, ps_bitstrm);
         ps_sps->ai1_sps_max_latency_increase[i] = value;
     }
","A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33864300."
2399,CVE-2017-0538," 

 
     ps_dec->i4_frametype = -1;
     ps_dec->i4_content_type = -1;

     ps_dec->u4_slice_start_code_found = 0;
 
      
             ret = ih264d_deblock_display(ps_dec);
         }
 
 
 

         }
     }
 
    if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
    {
        ps_dec->u1_top_bottom_decoded = 0;
    }
     
     
     
     
    if(ps_dec->u4_pic_buf_got == 1)
    {
        if(1 == ps_dec->u1_last_pic_not_decoded)
        {
            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);

            if(ret != OK)
                return ret;

            ret = ih264d_end_of_pic(ps_dec);
            if(ret != OK)
                return ret;
        }
        else
        {
            ret = ih264d_end_of_pic(ps_dec);
            if(ret != OK)
                return ret;
        }

    }


      
     DATA_SYNC();
 
","A remote code execution vulnerability in libavc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33641588."
2400,CVE-2017-0402," 

 
     case EQ_PARAM_BAND_LEVEL:
         param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
             break;
         }
         *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
 

 
     case EQ_PARAM_CENTER_FREQ:
         param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
             break;
         }
         *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
 

 
     case EQ_PARAM_BAND_FREQ_RANGE:
         param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
             break;
         }
         EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));
","An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in Audioserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32436341."
2401,CVE-2017-0401," 

 
     case EQ_PARAM_GET_PRESET_NAME:
         param2 = *pParamTemp;
        if ((param2 < 0 && param2 != PRESET_CUSTOM) ||  param2 >= EqualizerGetNumPresets()) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32448258"");
                ALOGE(""\tERROR Equalizer_getParameter() EQ_PARAM_GET_PRESET_NAME preset %d"",
                        param2);
            }
             break;
         }
         name = (char *)pValue;
 

         band =  *pParamTemp;
         level = (int32_t)(*(int16_t *)pValue);
          
        if (band < 0 || band >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (band < 0) {
                android_errorWriteLog(0x534e4554, ""32095626"");
                ALOGE(""\tERROR Equalizer_setParameter() EQ_PARAM_BAND_LEVEL band %d"", band);
            }
             break;
         }
         EqualizerSetBandLevel(pContext, band, level);
","An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in the Qualcomm audio post processor could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32588016."
2402,CVE-2017-0400," 

 
     case EQ_PARAM_BAND_LEVEL:
         param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
             break;
         }
         *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);
 

 
     case EQ_PARAM_CENTER_FREQ:
         param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
             break;
         }
         *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);
 

 
     case EQ_PARAM_BAND_FREQ_RANGE:
         param2 = *pParamTemp;
        if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
             break;
         }
         EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));
","An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in Audioserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32584034."
2403,CVE-2017-0397," 

     }
 }
 
 
static size_t StringSize(const uint8_t *start, size_t limit, uint8_t encoding) {

     if (encoding == 0x00 || encoding == 0x03) {
          
        return strnlen((const char *)start, limit) + 1;
     }
 
      
     size_t n = 0;
    while ((n+1 < limit) && (start[n] != '\0' || start[n + 1] != '\0')) {
         n += 2;
     }
    n += 2;
    return n;
 }
 
 const void *
 

 
         if (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) {
             uint8_t encoding = data[0];
            size_t consumed = 1;

             
            size_t mimeLen = StringSize(&data[consumed], size - consumed, 0x00);
            if (mimeLen > size - consumed) {
                ALOGW(""bogus album art size: mime"");
                return NULL;
            }
            mime->setTo((const char *)&data[consumed]);
            consumed += mimeLen;
 
 #if 0
            uint8_t picType = data[consumed];
             if (picType != 0x03) {
                  
                 it.next();
 

             }
 #endif
 
            consumed++;
            if (consumed >= size) {
                ALOGW(""bogus album art size: pic type"");
                 return NULL;
             }
 
            size_t descLen = StringSize(&data[consumed], size - consumed, encoding);
            consumed += descLen;

            if (consumed >= size) {
                ALOGW(""bogus album art size: description"");
                return NULL;
            }

            *length = size - consumed;

            return &data[consumed];
         } else {
             uint8_t encoding = data[0];
 
            if (size <= 5) {
                return NULL;
            }

             if (!memcmp(&data[1], ""PNG"", 3)) {
                 mime->setTo(""image/png"");
             } else if (!memcmp(&data[1], ""JPG"", 3)) {
 

             }
 #endif
 
            size_t descLen = StringSize(&data[5], size - 5, encoding);
            if (descLen > size - 5) {
                return NULL;
            }
 
             *length = size - 5 - descLen;
 
","An information disclosure vulnerability in id3/ID3.cpp in libstagefright in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32377688."
2404,CVE-2017-0396," 

 
 #define DISCARD_MEASUREMENTS_TIME_MS 2000  
 
#define MAX_LATENCY_MS 3000  

  
 #define MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS 25  
 
 

             break;
         }
         switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE: {
            const uint32_t captureSize = *((uint32_t *)p->data + 1);
            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
                android_errorWriteLog(0x534e4554, ""31781965"");
                *(int32_t *)pReplyData = -EINVAL;
                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
            } else {
                pContext->mCaptureSize = captureSize;
                ALOGV(""set mCaptureSize = %u"", captureSize);
            }
            } break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
        case VISUALIZER_PARAM_LATENCY: {
            uint32_t latency = *((uint32_t *)p->data + 1);
            if (latency > MAX_LATENCY_MS) {
                latency = MAX_LATENCY_MS;  
            }
            pContext->mLatency = latency;
            ALOGV(""set mLatency = %u"", latency);
            } break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
 

                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
                uint32_t deltaSmpl = captureSize
                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
 
                 
                 
                if (deltaSmpl > CAPTURE_BUF_SIZE) {
                    android_errorWriteLog(0x534e4554, ""31781965"");
                    deltaSmpl = CAPTURE_BUF_SIZE;
                }

                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
                 
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {
","An information disclosure vulnerability in visualizer/EffectVisualizer.cpp in libeffects in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-31781965."
2405,CVE-2017-0393," 

     }
 
 #if CONFIG_MULTITHREAD
   
  if (pbi->decoding_thread_count > num_token_partitions - 1) {
    pbi->decoding_thread_count = num_token_partitions - 1;
  }
  if (pbi->decoding_thread_count > pbi->common.mb_rows - 1) {
    pbi->decoding_thread_count = pbi->common.mb_rows - 1;
  }
 #endif
 }
 
","A denial of service vulnerability in libvpx in Mediaserver could enable a remote attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-30436808."
2406,CVE-2017-0392," 

          scale,
          entrySize);
 
    if (entrySize > 4) {
        ALOGE(""invalid VBRI entry size: %zu"", entrySize);
        return NULL;
    }

    sp<VBRISeeker> seeker = new (std::nothrow) VBRISeeker;
    if (seeker == NULL) {
        ALOGW(""Couldn't allocate VBRISeeker"");
        return NULL;
    }

     size_t totalEntrySize = numEntries * entrySize;
    uint8_t *buffer = new (std::nothrow) uint8_t[totalEntrySize];
    if (!buffer) {
        ALOGW(""Couldn't allocate %zu bytes"", totalEntrySize);
        return NULL;
    }
 
     n = source->readAt(pos + sizeof(vbriHeader), buffer, totalEntrySize);
     if (n < (ssize_t)totalEntrySize) {
 

         return NULL;
     }
 
     seeker->mBasePos = post_id3_pos + frameSize;
      
      
","A denial of service vulnerability in VBRISeeker.cpp in libstagefright in Mediaserver could enable a remote attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32577290."
2407,CVE-2017-0391," 

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
","A denial of service vulnerability in decoder/ihevcd_decode.c in libhevc in Mediaserver could enable a remote attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32322258."
2408,CVE-2017-0381," 

 
          
         for( i = 1; i < L; i++ )
            NLSF_Q15[i] = silk_max_int( NLSF_Q15[i], silk_ADD_SAT16( NLSF_Q15[i-1], NDeltaMin_Q15[i] ) );
 
          
         NLSF_Q15[L-1] = silk_min_int( NLSF_Q15[L-1], (1<<15) - NDeltaMin_Q15[L] );
","An information disclosure vulnerability in silk/NLSF_stabilize.c in libopus in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-31607432."
2409,CVE-2015-1529," 

     SET_CAPTURE_STATE,
 };
 
#define MAX_ITEMS_PER_LIST 1024

 class BpSoundTriggerHwService: public BpInterface<ISoundTriggerHwService>
 {
 public:
 

         case LIST_MODULES: {
             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);
             unsigned int numModulesReq = data.readInt32();
            if (numModulesReq > MAX_ITEMS_PER_LIST) {
                numModulesReq = MAX_ITEMS_PER_LIST;
            }
             unsigned int numModules = numModulesReq;
             struct sound_trigger_module_descriptor *modules =
                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,
                                                    sizeof(struct sound_trigger_module_descriptor));
            if (modules == NULL) {
                reply->writeInt32(NO_MEMORY);
                reply->writeInt32(0);
                return NO_ERROR;
            }
             status_t status = listModules(modules, &numModules);
             reply->writeInt32(status);
             reply->writeInt32(numModules);
",Integer overflow in soundtrigger/ISoundTriggerHwService.cpp in Android allows attacks to cause a denial of service via unspecified vectors.
2410,CVE-2018-9511," 

     }
 
     int optval;
    socklen_t optlen = sizeof(optval);
     netdutils::Status status =
         getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);
     if (status != netdutils::status::ok) {
","In ipSecSetEncapSocketOwner of XfrmController.cpp, there is a possible failure to initialize a security feature due to uninitialized data. This could lead to local denial of service of IPsec on sockets with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-111650288"
2411,CVE-2018-9510," 

   uint8_t* p = p_data->p_data;
 
   SMP_TRACE_DEBUG(""%s"", __func__);

  if (smp_command_has_invalid_parameters(p_cb)) {
    tSMP_INT_DATA smp_int_data;
    smp_int_data.status = SMP_INVALID_PARAMETERS;
    android_errorWriteLog(0x534e4554, ""111937065"");
    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);
    return;
  }

   STREAM_TO_ARRAY(p_cb->ltk, p, BT_OCTET16_LEN);
 
   smp_key_distribution(p_cb, NULL);
 

 }
 
  
 void smp_proc_id_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
   uint8_t* p = p_data->p_data;
 
   SMP_TRACE_DEBUG(""%s"", __func__);

  if (smp_command_has_invalid_parameters(p_cb)) {
    tSMP_INT_DATA smp_int_data;
    smp_int_data.status = SMP_INVALID_PARAMETERS;
    android_errorWriteLog(0x534e4554, ""111937065"");
    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);
    return;
  }

   STREAM_TO_ARRAY(p_cb->tk, p, BT_OCTET16_LEN);  
   smp_key_distribution_by_transport(p_cb, NULL);
 }
","In smp_proc_enc_info of smp_act.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111937065"
2412,CVE-2018-9509," 

   tBTM_LE_PENC_KEYS le_key;
 
   SMP_TRACE_DEBUG(""%s"", __func__);

  if (p_cb->rcvd_cmd_len < 11) {   
    android_errorWriteLog(0x534e4554, ""111937027"");
    SMP_TRACE_ERROR(""%s: Invalid command length: %d, should be at least 11"",
                    __func__, p_cb->rcvd_cmd_len);
    return;
  }

   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);
 
   STREAM_TO_UINT16(le_key.ediv, p);
","In smp_proc_master_id of smp_act.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111937027"
2413,CVE-2018-9508," 

   uint8_t reason = SMP_INVALID_PARAMETERS;
 
   SMP_TRACE_DEBUG(""%s"", __func__);
 
   if (smp_command_has_invalid_parameters(p_cb)) {
    if (p_cb->rcvd_cmd_len < 2) {   
      android_errorWriteLog(0x534e4554, ""111936834"");
    }
     smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);
     return;
   }
 
  p_cb->status = *(uint8_t*)p_data;

   if (p != NULL) {
     STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);
   } else {
","In smp_process_keypress_notification of smp_act.cc, there is a possible out of bounds read due to an incorrect bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-111936834"
2414,CVE-2018-9507," 

 #include ""bta_av_api.h""
 #include ""bta_av_int.h""
 #include ""l2c_api.h""
#include ""log/log.h""
 #include ""osi/include/list.h""
 #include ""osi/include/log.h""
 #include ""osi/include/osi.h""
 

       case AVRC_PDU_GET_CAPABILITIES:
          
         evt = 0;
        if (p_vendor->vendor_len != 5) {
          android_errorWriteLog(0x534e4554, ""111893951"");
          p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
          break;
        }
         u8 = *(p_vendor->p_vendor_data + 4);
         p = p_vendor->p_vendor_data + 2;
         p_rc_rsp->get_caps.capability_id = u8;
         BE_STREAM_TO_UINT16(u16, p);
        if (u16 != 1) {
           p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
         } else {
           p_rc_rsp->get_caps.status = AVRC_STS_NO_ERROR;
","In bta_av_proc_meta_cmd of bta_av_act.cc, there is a possible out of bounds read due to an incorrect bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111893951"
2415,CVE-2018-9506," 

 #include <base/logging.h>
 #include <string.h>
 
#include <log/log.h>

 #include ""avrc_api.h""
 #include ""avrc_int.h""
 #include ""bt_common.h""
 

     msg.browse.browse_len = p_pkt->len;
     msg.browse.p_browse_pkt = p_pkt;
   } else {
    if (p_pkt->len < AVRC_AVC_HDR_SIZE) {
      android_errorWriteLog(0x534e4554, ""111803925"");
      AVRC_TRACE_WARNING(""%s: message length %d too short: must be at least %d"",
                         __func__, p_pkt->len, AVRC_AVC_HDR_SIZE);
      osi_free(p_pkt);
      return;
    }
     msg.hdr.ctype = p_data[0] & AVRC_CTYPE_MASK;
     AVRC_TRACE_DEBUG(""%s handle:%d, ctype:%d, offset:%d, len: %d"", __func__,
                      handle, msg.hdr.ctype, p_pkt->offset, p_pkt->len);
 

           p_drop_msg = ""auto respond"";
         } else {
            
          if (p_pkt->len < AVRC_OP_UNIT_INFO_RSP_LEN) {
            AVRC_TRACE_WARNING(
                ""%s: message length %d too short: must be at least %d"",
                __func__, p_pkt->len, AVRC_OP_UNIT_INFO_RSP_LEN);
            android_errorWriteLog(0x534e4554, ""79883824"");
            drop = true;
            p_drop_msg = ""UNIT_INFO_RSP too short"";
            break;
          }
           p_data += 4;  
           msg.unit.unit_type =
               (*p_data & AVRC_SUBTYPE_MASK) >> AVRC_SUBTYPE_SHIFT;
 

           p_drop_msg = ""auto responded"";
         } else {
            
          if (p_pkt->len < AVRC_OP_SUB_UNIT_INFO_RSP_LEN) {
            AVRC_TRACE_WARNING(
                ""%s: message length %d too short: must be at least %d"",
                __func__, p_pkt->len, AVRC_OP_SUB_UNIT_INFO_RSP_LEN);
            android_errorWriteLog(0x534e4554, ""79883824"");
            drop = true;
            p_drop_msg = ""SUB_UNIT_INFO_RSP too short"";
            break;
          }
           p_data += AVRC_AVC_HDR_SIZE;  
           msg.sub.page =
               (*p_data++ >> AVRC_SUB_PAGE_SHIFT) & AVRC_SUB_PAGE_MASK;
","In avrc_msg_cback of avrc_api.cc, there is a possible out-of-bound read due to a missing bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111803925"
2416,CVE-2018-9505," 

  *  Functions.
  *
  ******************************************************************************/
#include <log/log.h>
 #include <string.h>
 #include ""bt_common.h""
 #include ""bt_target.h""
 

   p_rx_msg = (tMCA_CCB_MSG*)p_pkt;
   p = (uint8_t*)(p_pkt + 1) + p_pkt->offset;
   evt_data.hdr.op_code = *p++;
   reject_opcode = evt_data.hdr.op_code + 1;
 
  if (p_pkt->len >= 3) {
    BE_STREAM_TO_UINT16(evt_data.hdr.mdl_id, p);
  } else {
    android_errorWriteLog(0x534e4554, ""110791536"");
    evt_data.hdr.mdl_id = 0;
  }

   MCA_TRACE_DEBUG(""received mdl id: %d "", evt_data.hdr.mdl_id);
   if (p_ccb->status == MCA_CCB_STAT_PENDING) {
     MCA_TRACE_DEBUG(""received req inpending state"");
","In mca_ccb_hdl_req of mca_cact.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-110791536"
2417,CVE-2018-9504," 

     p = &p_ccb->rsp_list[0];
 
     if (offset) {
      cpy_len -= 1;
       type = *p++;
      uint8_t* old_p = p;
       p = sdpu_get_len_from_type(p, type, &list_len);
      if ((int)cpy_len < (p - old_p)) {
        SDP_TRACE_WARNING(""%s: no bytes left for data"", __func__);
        return;
      }
      cpy_len -= (p - old_p);
     }
     if (list_len < cpy_len) {
       cpy_len = list_len;
","In sdp_copy_raw_data of sdp_discovery.cc, there is a possible out of bounds write due to an incorrect bounds check. This could lead to remote code execution over bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-110216176"
2418,CVE-2018-9503," 

   uint8_t ea, cr, mx_len;
   bool is_command;
 
  if (length < 2) {
    RFCOMM_TRACE_ERROR(
        ""%s: Illegal MX Frame len when reading EA, C/R. len:%d < 2"", __func__,
        length);
    android_errorWriteLog(0x534e4554, ""111937065"");
    osi_free(p_buf);
    return;
  }
   p_rx_frame->ea = *p_data & RFCOMM_EA;
   p_rx_frame->cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;
   p_rx_frame->type = *p_data++ & ~(RFCOMM_CR_MASK | RFCOMM_EA_MASK);
 

   length--;
 
   if (!ea) {
    if (length < 1) {
      RFCOMM_TRACE_ERROR(""%s: Illegal MX Frame when EA = 0. len:%d < 1"",
                         __func__, length);
      android_errorWriteLog(0x534e4554, ""111937065"");
      osi_free(p_buf);
      return;
    }
     mx_len += *p_data++ << RFCOMM_SHIFT_LENGTH2;
     length--;
   }
 

       return;
 
     case RFCOMM_MX_MSC:
      if (length != RFCOMM_MX_MSC_LEN_WITH_BREAK &&
          length != RFCOMM_MX_MSC_LEN_NO_BREAK) {
        RFCOMM_TRACE_ERROR(""%s: Illegal MX MSC Frame len:%d"", __func__, length);
        android_errorWriteLog(0x534e4554, ""111937065"");
        osi_free(p_buf);
        return;
      }
       ea = *p_data & RFCOMM_EA;
       cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;
       p_rx_frame->dlci = *p_data++ >> RFCOMM_SHIFT_DLCI;
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-80432928"
2419,CVE-2018-9502," 

   uint8_t ea, cr, mx_len;
   bool is_command;
 
  if (length < 2) {
    RFCOMM_TRACE_ERROR(
        ""%s: Illegal MX Frame len when reading EA, C/R. len:%d < 2"", __func__,
        length);
    android_errorWriteLog(0x534e4554, ""111937065"");
    osi_free(p_buf);
    return;
  }
   p_rx_frame->ea = *p_data & RFCOMM_EA;
   p_rx_frame->cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;
   p_rx_frame->type = *p_data++ & ~(RFCOMM_CR_MASK | RFCOMM_EA_MASK);
 

   length--;
 
   if (!ea) {
    if (length < 1) {
      RFCOMM_TRACE_ERROR(""%s: Illegal MX Frame when EA = 0. len:%d < 1"",
                         __func__, length);
      android_errorWriteLog(0x534e4554, ""111937065"");
      osi_free(p_buf);
      return;
    }
     mx_len += *p_data++ << RFCOMM_SHIFT_LENGTH2;
     length--;
   }
 

       return;
 
     case RFCOMM_MX_MSC:
      if (length != RFCOMM_MX_MSC_LEN_WITH_BREAK &&
          length != RFCOMM_MX_MSC_LEN_NO_BREAK) {
        RFCOMM_TRACE_ERROR(""%s: Illegal MX MSC Frame len:%d"", __func__, length);
        android_errorWriteLog(0x534e4554, ""111937065"");
        osi_free(p_buf);
        return;
      }
       ea = *p_data & RFCOMM_EA;
       cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;
       p_rx_frame->dlci = *p_data++ >> RFCOMM_SHIFT_DLCI;
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out-of-bounds read due to a missing bounds check. This could lead to remote information disclosure in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111936792"
2420,CVE-2018-9499," 

 
 void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
    if (vector.insertAt((size_t)0, size) < 0) {
        vector.clear();
    }
    if (data.read(vector.editArray(), size) != NO_ERROR) {
        vector.clear();
        android_errorWriteWithInfoLog(0x534e4554, ""62872384"", -1, NULL, 0);
    }
 }
 
 void BnCrypto::writeVector(Parcel *reply, Vector<uint8_t> const &vector) const {
","In readVector of iCrypto.cpp, there is a possible invalid read due to uninitialized data. This could lead to local information disclosure from the DRM server with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-79218474"
2421,CVE-2018-9498," 

 #define SK_MaxU32   0xFFFFFFFF
 #define SK_MinU32   0
 #define SK_NaN32    ((int) (1U << 31))
#define SK_MaxSizeT SIZE_MAX
 
  
","In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855"
2422,CVE-2018-9497," 

              
             ps_dec->u2_horizontal_size = u2_width;
             ps_dec->u2_vertical_size = u2_height;
         }
         else
         {
 

 
                 return e_error;
             }
            else if((ps_dec->u2_horizontal_size < MIN_WIDTH)
                            || (ps_dec->u2_vertical_size < MIN_HEIGHT))
            {
                return IMPEG2D_UNSUPPORTED_DIMENSIONS;
            }
             else
             {
                  
 

         return e_error;
     }
 
    if((ps_dec->u2_horizontal_size < MIN_WIDTH)
                    || (ps_dec->u2_vertical_size < MIN_HEIGHT))
    {
        return IMPEG2D_UNSUPPORTED_DIMENSIONS;
    }
 
      
      
",In impeg2_fmt_conv_yuv420p_to_yuv420sp_uv_av8 of impeg2_format_conv.s there is a possible out of bounds write due to missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-74078669
2423,CVE-2018-9496," 

                               WORD32 index) {
   int i;
   WORD32 l1, l2, h2, fft_jmp;
  WORD64 xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
  WORD64 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
   WORD32 x_0, x_1, x_l1_0, x_l1_1, x_l2_0, x_l2_1;
   WORD32 x_h2_0, x_h2_1;
   WORD32 si10, si20, si30, co10, co20, co30;
 

       x_l1_0 = x[l1];
       x_l2_0 = x[l2];
 
      xh0_0 = (WORD64)x_0 + (WORD64)x_l1_0;
      xl0_0 = (WORD64)x_0 - (WORD64)x_l1_0;
 
      xh20_0 = (WORD64)x_h2_0 + (WORD64)x_l2_0;
      xl20_0 = (WORD64)x_h2_0 - (WORD64)x_l2_0;
 
      x[0] = (WORD32)ixheaacd_add64_sat(xh0_0, xh20_0);
      xt0_0 = (WORD64)xh0_0 - (WORD64)xh20_0;
 
       x_1 = x[1];
       x_h2_1 = x[h2 + 1];
       x_l1_1 = x[l1 + 1];
       x_l2_1 = x[l2 + 1];
 
      xh1_0 = (WORD64)x_1 + (WORD64)x_l1_1;
      xl1_0 = (WORD64)x_1 - (WORD64)x_l1_1;
 
      xh21_0 = (WORD64)x_h2_1 + (WORD64)x_l2_1;
      xl21_0 = (WORD64)x_h2_1 - (WORD64)x_l2_1;
 
      x[1] = (WORD32)ixheaacd_add64_sat(xh1_0, xh21_0);
      yt0_0 = (WORD64)xh1_0 - (WORD64)xh21_0;
 
      xt1_0 = (WORD64)xl0_0 + (WORD64)xl21_0;
      xt2_0 = (WORD64)xl0_0 - (WORD64)xl21_0;
 
      yt2_0 = (WORD64)xl1_0 + (WORD64)xl20_0;
      yt1_0 = (WORD64)xl1_0 - (WORD64)xl20_0;
 
       mul_11 = ixheaacd_mult64(xt2_0, co30);
       mul_3 = ixheaacd_mult64(yt2_0, si30);
 

   WORD32 x_0, x_1, x_2, x_3;
   WORD32 x_4, x_5, x_6, x_7;
   WORD32 x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;
   WORD32 n0, j0;
   WORD32 *x2, *x0;
   WORD32 *y0, *y1, *y2, *y3;
 

       x_6 = *x0++;
       x_7 = *x0++;
 
      y0[h2] = ixheaacd_add32_sat(x_0, x_2);
      y0[h2 + 1] = ixheaacd_add32_sat(x_1, x_3);
      y1[h2] = ixheaacd_add32_sat(x_4, x_6);
      y1[h2 + 1] = ixheaacd_add32_sat(x_5, x_7);
      y2[h2] = ixheaacd_sub32_sat(x_0, x_2);
      y2[h2 + 1] = ixheaacd_sub32_sat(x_1, x_3);
      y3[h2] = ixheaacd_sub32_sat(x_4, x_6);
      y3[h2 + 1] = ixheaacd_sub32_sat(x_5, x_7);
 
       x_8 = *x2++;
       x_9 = *x2++;
 

       x_e = *x2++;
       x_f = *x2++;
 
      y0[h2 + 2] = ixheaacd_add32_sat(x_8, x_a);
      y0[h2 + 3] = ixheaacd_add32_sat(x_9, x_b);
      y1[h2 + 2] = ixheaacd_add32_sat(x_c, x_e);
      y1[h2 + 3] = ixheaacd_add32_sat(x_d, x_f);
      y2[h2 + 2] = ixheaacd_sub32_sat(x_8, x_a);
      y2[h2 + 3] = ixheaacd_sub32_sat(x_9, x_b);
      y3[h2 + 2] = ixheaacd_sub32_sat(x_c, x_e);
      y3[h2 + 3] = ixheaacd_sub32_sat(x_d, x_f);
     }
     x0 += (WORD32)npoints >> 1;
     x2 += (WORD32)npoints >> 1;
 

     r1 = *qmf_real++;
     i1 = *qmf_imag++;
 
    timag = ixheaacd_add32_sat(i1, r1);
     timag = (ixheaacd_shl32_sat(timag, shift));
     filter_states_rev[j] = timag;
 
    treal = ixheaacd_sub32_sat(i2, r2);
     treal = (ixheaacd_shl32_sat(treal, shift));
     filter_states[j] = treal;
 
    treal = ixheaacd_sub32_sat(i1, r1);
     treal = (ixheaacd_shl32_sat(treal, shift));
     *filter_states++ = treal;
 
    timag = ixheaacd_add32_sat(i2, r2);
     timag = (ixheaacd_shl32_sat(timag, shift));
     *filter_states_rev++ = timag;
   }
",In ixheaacd_real_synth_fft_p3 of ixheaacd_esbr_fft.c there is a possible out of bounds write due to a missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-110769924
2424,CVE-2018-9491," 

         size_t *encryptedbytes) {
 
      
    size_t cryptosize;
     
    if (__builtin_mul_overflow(sizeof(size_t) * 2, numsubsamples, &cryptosize) ||
            __builtin_add_overflow(cryptosize, sizeof(AMediaCodecCryptoInfo), &cryptosize)) {
        ALOGE(""crypto size overflow"");
        return NULL;
    }
     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);
     if (!ret) {
         ALOGE(""couldn't allocate %zu bytes"", cryptosize);
","In AMediaCodecCryptoInfo_new of NdkMediaCodec.cpp, there is a possible out-of-bounds write due to an integer overflow. This could lead to remote code execution in external apps with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111603051"
2425,CVE-2018-9490," 

   return Just<int64_t>(-1);
 }
 
 
 
 
class InternalElementsAccessor : public ElementsAccessor {
 public:
  explicit InternalElementsAccessor(const char* name)
      : ElementsAccessor(name) {}

  virtual uint32_t GetEntryForIndex(Isolate* isolate, JSObject* holder,
                                    FixedArrayBase* backing_store,
                                    uint32_t index) = 0;

  virtual PropertyDetails GetDetails(JSObject* holder, uint32_t entry) = 0;
};

  
  
  
 

  
  
 template <typename Subclass, typename ElementsTraitsParam>
class ElementsAccessorBase : public InternalElementsAccessor {
  public:
   explicit ElementsAccessorBase(const char* name)
      : InternalElementsAccessor(name) {}
 
   typedef ElementsTraitsParam ElementsTraits;
   typedef typename ElementsTraitsParam::BackingStore BackingStore;
 

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    int count = 0;
    int i = 0;
    Handle<Map> original_map(object->map(), isolate);

    for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
      Handle<Object> value;
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->map() != *original_map) break;
    }

     
    for (; i < keys->length(); i++) {
      Handle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!key->ToUint32(&index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        uint32_t entry = accessor->GetEntryForIndex(isolate, *object,
                                                    object->elements(), index);
        if (entry == kMaxUInt32) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
       }

      Handle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
       values_or_entries->set(count++, *value);
     }
 
 

         return result;
       }
     }
    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
      
      
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         if (search_for_hole) return Just(true);
 

                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
 
    Handle<Map> original_map(receiver->map(), isolate);
     Handle<SeededNumberDictionary> dictionary(
         SeededNumberDictionary::cast(receiver->elements()), isolate);
      
      
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->map(), *original_map);
       int entry = dictionary->FindEntry(isolate, k);
       if (entry == SeededNumberDictionary::kNotFound) {
         continue;
 

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
      DCHECK_EQ(object->map(), *original_map);
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
","In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046"
2426,CVE-2018-9476," 

           memcpy(p_msg_dest->vendor.p_vendor_data,
                  p_msg_src->vendor.p_vendor_data, p_msg_src->vendor.vendor_len);
         }
        if ((p_msg_src->hdr.opcode == AVRC_OP_BROWSE) &&
            p_msg_src->browse.p_browse_data && p_msg_src->browse.browse_len) {
          p_msg_dest->browse.p_browse_data =
              (uint8_t*)osi_calloc(p_msg_src->browse.browse_len);
          memcpy(p_msg_dest->browse.p_browse_data,
                 p_msg_src->browse.p_browse_data, p_msg_src->browse.browse_len);
          android_errorWriteLog(0x534e4554, ""109699112"");
        }
       }
       break;
 
 

         if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_VENDOR) {
           osi_free(av->meta_msg.p_msg->vendor.p_vendor_data);
         }
        if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_BROWSE) {
          osi_free(av->meta_msg.p_msg->browse.p_browse_data);
        }
         osi_free_and_reset((void**)&av->meta_msg.p_msg);
       }
     } break;
","In avrc_pars_browsing_cmd of avrc_pars_tg.cc, there is a possible use-after-free due to improper locking. This could lead to remote escalation of privilege in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-8.0 Android-8.1 Android ID: A-109699112"
2427,CVE-2018-9473," 

 
             case SEI_USER_DATA_REGISTERED_ITU_T_T35:
                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;
                if(ps_parse->s_sei_params.i4_sei_user_data_cnt >= USER_DATA_MAX)
                {
                    for(i = 0; i < u4_payload_size / 4; i++)
                    {
                        ihevcd_bits_flush(ps_bitstrm, 4 * 8);
                    }

                    ihevcd_bits_flush(ps_bitstrm, (u4_payload_size - i * 4) * 8);
                }
                else
                {
                    ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,
                                                                u4_payload_size);
                }
                 break;
 
             default:
 

         {
             case SEI_USER_DATA_REGISTERED_ITU_T_T35:
                 ps_parse->s_sei_params.i1_sei_parameters_present_flag = 1;
                if(ps_parse->s_sei_params.i4_sei_user_data_cnt >= USER_DATA_MAX)
                {
                    for(i = 0; i < u4_payload_size / 4; i++)
                    {
                        ihevcd_bits_flush(ps_bitstrm, 4 * 8);
                    }

                    ihevcd_bits_flush(ps_bitstrm, (u4_payload_size - i * 4) * 8);
                }
                else
                {
                    ihevcd_parse_user_data_registered_itu_t_t35(ps_codec,
                                                                u4_payload_size);
                }
                 break;
 
             default:
","In ihevcd_parse_sei_payload of ihevcd_parse_headers.c, there is a possible out-of-bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-8.0 Android ID: A-65484460"
2428,CVE-2017-13205," 

 
     if(ps_dec->u2_is_mpeg2 == 0)
     {
        if (ps_dec->u2_forw_f_code < 1 || ps_dec->u2_forw_f_code > 7 ||
                        ps_dec->u2_back_f_code < 1 || ps_dec->u2_back_f_code > 7)
        {
            return IMPEG2D_UNKNOWN_ERROR;
        }
         ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
         ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
     }
","An information disclosure vulnerability in the Android media framework (libmpeg2). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-64550583."
2429,CVE-2017-13204," 

 {
     UWORD8 i;
     dec_seq_params_t *ps_seq = NULL;
    UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id, u1_mb_aff_flag = 0;
     UWORD16 i2_max_frm_num;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 

     COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm);
 
     if(!u1_frm)
        u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm);

    if((ps_dec->i4_header_decoded & 1)
                    && (ps_seq->u1_mb_aff_flag != u1_mb_aff_flag))
    {
        ps_dec->u1_res_changed = 1;
        return IVD_RES_CHANGED;
    }

    if(!u1_frm)
     {
         u2_pic_ht <<= 1;
        ps_seq->u1_mb_aff_flag = u1_mb_aff_flag;
         COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"",
                         ps_seq->u1_mb_aff_flag);
 
","An information disclosure vulnerability in the Android media framework (libavc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-64380237."
2430,CVE-2017-13203," 

             void *pv_buf;
             void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
             size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128,
                                              size + EXTRA_BS_OFFSET);
             RETURN_IF((NULL == pv_buf), IV_FAIL);
             ps_dec->pu1_bits_buf_dynamic = pv_buf;
             ps_dec->u4_dynamic_bits_buf_size = size;
","An information disclosure vulnerability in the Android media framework (libavc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-63122634."
2431,CVE-2017-13200," 

                     --mSize;
                     --dataSize;
                 }
                if (i + 1 < dataSize) {
                     
                     
                     
                    mData[writeOffset++] = mData[readOffset++];
                }
             }
              
             if (readOffset <= oldSize) {
","An information disclosure vulnerability in the Android media framework (av) related to id3 unsynchronization. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-63100526."
2432,CVE-2017-13198," 

                 cmap = frame.ImageDesc.ColorMap;
             }
 
             
            if (cmap) {
                const unsigned char* src = (unsigned char*)frame.RasterBits;
                Color8888* dst = outputPtr + frame.ImageDesc.Left +
                        frame.ImageDesc.Top * outputPixelStride;
                GifWord copyWidth, copyHeight;
                getCopySize(frame.ImageDesc, width, height, copyWidth, copyHeight);
                for (; copyHeight > 0; copyHeight--) {
                    copyLine(dst, src, cmap, gcb.TransparentColor, copyWidth);
                    src += frame.ImageDesc.Width;
                    dst += outputPixelStride;
                }
             }
         }
     }
","A vulnerability in the Android media framework (ex) related to composition of frames lacking a color map. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-68399117."
2433,CVE-2017-13194," 

     default: ycs = 0; break;
   }
 
   
  w = d_w;
  h = d_h;
   s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
   s = (s + stride_align - 1) & ~(stride_align - 1);
   stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;
 

   img->img_data = img_data;
 
   if (!img_data) {
    uint64_t alloc_size;
     
    align = (1 << xcs) - 1;
    w = (d_w + align) & ~align;
    align = (1 << ycs) - 1;
    h = (d_h + align) & ~align;

    s = (fmt & VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
    s = (s + stride_align - 1) & ~(stride_align - 1);
    stride_in_bytes = (fmt & VPX_IMG_FMT_HIGHBITDEPTH) ? s * 2 : s;
    alloc_size = (fmt & VPX_IMG_FMT_PLANAR) ? (uint64_t)h * s * bps / 8
                                            : (uint64_t)h * s;
 
     if (alloc_size != (size_t)alloc_size) goto fail;
 
","A vulnerability in the Android media framework (libvpx) related to odd frame width. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-64710201."
2434,CVE-2017-13190," 

                            void *pv_api_ip,
                            void *pv_api_op)
 {
    ihevcd_cxa_create_ip_t *ps_create_ip;
     ihevcd_cxa_create_op_t *ps_create_op;
 
     WORD32 ret;
     codec_t *ps_codec;
    ps_create_ip = (ihevcd_cxa_create_ip_t *)pv_api_ip;
     ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;
 
     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
    ps_codec_obj = NULL;
     ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);
 
      
    if(IV_FAIL == ret)
     {
        if(NULL != ps_codec_obj)
        {
            if(ps_codec_obj->pv_codec_handle)
            {
                ihevcd_free_static_bufs(ps_codec_obj);
            }
            else
            {
                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
                void *pv_mem_ctxt;

                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;
                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;
                pf_aligned_free(pv_mem_ctxt, ps_codec_obj);
            }
        }
         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;
         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;
 
","A vulnerability in the Android media framework (libhevc) related to handling ps_codec_obj memory allocation failures. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-68299873."
2435,CVE-2017-13189," 

  
 WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
    ih264d_create_ip_t *ps_create_ip;
     ih264d_create_op_t *ps_create_op;
 
     WORD32 ret;
 
    ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;
     ps_create_op = (ih264d_create_op_t *)pv_api_op;
 
     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
    dec_hdl = NULL;
     ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);
 
      
    if(IV_FAIL == ret)
     {
        if(dec_hdl)
        {
            if(dec_hdl->pv_codec_handle)
            {
                ih264d_free_static_bufs(dec_hdl);
            }
            else
            {
                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
                void *pv_mem_ctxt;

                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;
                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;
                pf_aligned_free(pv_mem_ctxt, dec_hdl);
            }
        }
         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;
         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;
 
","A vulnerability in the Android media framework (libavc) related to handling dec_hdl memory allocation failures. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-68300072."
2436,CVE-2017-13188," 

   }
 
    
  FDKmemclear(bwIndex, MAX_NUM_PATCHES*sizeof(INT));
 
    
      while (hiBand >= pSettings->bwBorders[bwIndex[patch]] && bwIndex[patch] < MAX_NUM_PATCHES-1) {
         bwIndex[patch]++;
      }
 
       /*
         Filter Step 2: add the left slope with the current filter to the buffer
 

   for(i = 0 ; i < noNoiseBands; i++){
     pSettings->bwBorders[i] = noiseBandTable[i+1];
   }
  for (;i < MAX_NUM_NOISE_VALUES; i++) {
    pSettings->bwBorders[i] = 255;
  }

 
   /*
    * Choose whitening factors
","An information disclosure vulnerability in the Android media framework (aac). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65280786."
2437,CVE-2017-13187," 

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
    WORD32 prev_slice_incomplete_flag = 0;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;
 

             {
                 if(ps_codec->i4_pic_present)
                 {
                    prev_slice_incomplete_flag = 1;
                 }
                 else
                 {
 

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
        prev_slice_incomplete_flag = 1;
        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;
 

         }
     }
 
    if(prev_slice_incomplete_flag)
    {
        ps_codec->i4_slice_error = 1;
        ps_codec->s_parse.i4_cur_slice_idx--;
        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
            ps_codec->s_parse.i4_cur_slice_idx = 0;
    }

     return ret;
 }
","An information disclosure vulnerability in the Android media framework (libhevc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65034175."
2438,CVE-2017-13186," 

 WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
 {
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
    dpb_commands_t *ps_dpb_cmds = &(ps_dec->s_dpb_cmds_scratch);
     dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     WORD32 j;
     UWORD8 u1_buf_mode;
","A vulnerability in the Android media framework (libavc) related to incorrect use of mmco parameters. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65735716."
2439,CVE-2017-13185," 

  *******************************************************************************
  *
  * @brief
 *  Set ctb skip
 *
 * @par Description:
 *  During error, sets tu and pu params of a ctb as skip.
 *
 * @param[in] ps_codec
 *  Pointer to codec context
 *
 * @returns  None
 *
 * @remarks
 *
 *
 *******************************************************************************
 */
void ihevcd_set_ctb_skip(codec_t *ps_codec)
{
    tu_t *ps_tu;
    pu_t *ps_pu;
    sps_t *ps_sps = ps_codec->s_parse.ps_sps;
    WORD32 ctb_size = 1 << ps_sps->i1_log2_ctb_size;
    WORD32 ctb_skip_wd, ctb_skip_ht;
    WORD32 rows_remaining, cols_remaining;
    WORD32 tu_abs_x, tu_abs_y;
    WORD32 numbytes_row =  (ps_sps->i2_pic_width_in_luma_samples + 63) / 64;
    UWORD8 *pu1_pic_intra_flag;
    UWORD32 u4_mask;
    WORD32 pu_x,pu_y;

     
    rows_remaining = ps_sps->i2_pic_height_in_luma_samples
                    - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size);
    ctb_skip_ht = MIN(ctb_size, rows_remaining);

    cols_remaining = ps_sps->i2_pic_width_in_luma_samples
                    - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size);
    ctb_skip_wd = MIN(ctb_size, cols_remaining);

    ps_codec->s_parse.s_cu.i4_pred_mode = PRED_MODE_SKIP;
    ps_codec->s_parse.s_cu.i4_part_mode = PART_2Nx2N;

    for (pu_y = 0; pu_y < ctb_skip_ht ; pu_y += MIN_CU_SIZE)
    {
        for (pu_x = 0; pu_x < ctb_skip_wd ; pu_x += MIN_CU_SIZE)
        {
            ps_tu = ps_codec->s_parse.ps_tu;
            ps_tu->b1_cb_cbf = 0;
            ps_tu->b1_cr_cbf = 0;
            ps_tu->b1_y_cbf = 0;
            ps_tu->b4_pos_x = pu_x >> 2;
            ps_tu->b4_pos_y = pu_y >> 2;
            ps_tu->b1_transquant_bypass = 0;
            ps_tu->b3_size = 1;
            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
            ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
            ps_tu->b6_luma_intra_mode   = INTRA_PRED_NONE;
            ps_tu->b1_first_tu_in_cu = 1;

            ps_codec->s_parse.ps_tu++;
            ps_codec->s_parse.s_cu.i4_tu_cnt++;
            ps_codec->s_parse.i4_pic_tu_idx++;

            tu_abs_x = (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size) + pu_x;
            tu_abs_y = (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size) + pu_y;
            pu1_pic_intra_flag = ps_codec->s_parse.pu1_pic_intra_flag;
            pu1_pic_intra_flag += (tu_abs_y >> 3) * numbytes_row;
            pu1_pic_intra_flag += (tu_abs_x >> 6);
            u4_mask = (LSB_ONES((MIN_CU_SIZE >> 3)) << (((tu_abs_x) / 8) % 8));
            u4_mask = ~u4_mask;
            *pu1_pic_intra_flag &= u4_mask;

            ps_pu = ps_codec->s_parse.ps_pu;
            ps_pu->b2_part_idx = 0;
            ps_pu->b4_pos_x = pu_x >> 2;
            ps_pu->b4_pos_y = pu_y >> 2;
            ps_pu->b4_wd = 1;
            ps_pu->b4_ht = 1;
            ps_pu->b1_intra_flag = 0;
            ps_pu->b3_part_mode = ps_codec->s_parse.s_cu.i4_part_mode;
            ps_pu->b1_merge_flag = 1;
            ps_pu->b3_merge_idx = 0;

            ps_codec->s_parse.ps_pu++;
            ps_codec->s_parse.i4_pic_pu_idx++;
        }
    }
}

 
                 WORD32 tu_coeff_data_reset_size;
 
                 ps_codec->s_parse.ps_tu = ps_tu;
                 ps_codec->s_parse.s_cu.i4_tu_cnt = i4_tu_cnt;
                 ps_codec->s_parse.i4_pic_tu_idx = i4_pic_tu_idx;
 

                 ps_codec->s_parse.ps_pu = ps_pu;
                 ps_codec->s_parse.i4_pic_pu_idx = i4_pic_pu_idx;
 
                 tu_coeff_data_reset_size = (UWORD8 *)ps_codec->s_parse.pv_tu_coeff_data - pu1_tu_coeff_data;
                 memset(pu1_tu_coeff_data, 0, tu_coeff_data_reset_size);
                 ps_codec->s_parse.pv_tu_coeff_data = (void *)pu1_tu_coeff_data;
 
                ihevcd_set_ctb_skip(ps_codec);
 
                  
            ihevcd_set_ctb_skip(ps_codec);
         }
 
         if(0 == ps_codec->i4_slice_error)
","An information disclosure vulnerability in the Android media framework (libhevc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-65123471."
2440,CVE-2017-7376," 

 #include ""libxml.h""
 
 #include <string.h>
#include <limits.h>
 
 #include <libxml/xmlmemory.h>
 #include <libxml/uri.h>
 

 	    cur++;
 	}
 	if (uri != NULL)
	    uri->port = port & USHRT_MAX;  
 	*str = cur;
 	return(0);
     }
",Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects.
2441,CVE-2017-7375," 

 	    if (xmlPushInput(ctxt, input) < 0)
 		return;
 	} else {
	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
	        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
	        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
	        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
	        (ctxt->replaceEntities == 0) &&
	        (ctxt->validate == 0))
	        return;
 	    /*
 	     * TODO !!!
 	     * handle the extra spaces added before and after
","A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes). Depending on the context, this may expose a higher-risk attack surface in libxml2 not usually reachable with default parser flags, and expose content from local files, HTTP, or FTP servers (which might be otherwise unreachable)."
2442,CVE-2015-3849," 

         return NULL;
     }
     SkRegion* region = new SkRegion;
    size_t actualSize = region->readFromMemory(regionData, size);

    if (size != actualSize) {
        delete region;
        return NULL;
    }
 
     return reinterpret_cast<jlong>(region);
 }
","The Region_createFromParcel function in core/jni/android/graphics/Region.cpp in Region in Android before 5.1.1 LMY48M does not check the return values of certain read operations, which allows attackers to execute arbitrary code via an application that sends a crafted message to a service, aka internal bug 21585255."
2443,CVE-2015-3835," 

     Mutex::Autolock autoLock(mLock);
 
     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     
     
    if (rangeOffset > header->nAllocLen
            || rangeLength > header->nAllocLen - rangeOffset) {
        return BAD_VALUE;
    }
     header->nFilledLen = rangeLength;
     header->nOffset = rangeOffset;
 
","Buffer overflow in the OMXNodeInstance::emptyBuffer function in omx/OMXNodeInstance.cpp in libstagefright in Android before 5.1.1 LMY48I allows attackers to execute arbitrary code via a crafted application, aka internal bug 20634516."
2444,CVE-2015-1528," 

 #include <cutils/log.h>
 #include <cutils/native_handle.h>
 
static const int kMaxNativeFds = 1024;
static const int kMaxNativeInts = 1024;

 native_handle_t* native_handle_create(int numFds, int numInts)
 {
    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {
        return NULL;
    }
 
    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));
    native_handle_t* h = malloc(mallocSize);
     if (h) {
         h->version = sizeof(native_handle_t);
         h->numFds = numFds;
","Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482."
2445,CVE-2016-6720," 

 #include ""OMX.h""
 
 #include <utils/RefBase.h>
#include <utils/SortedVector.h>
 #include <utils/threads.h>
 
 namespace android {
 

     OMX_HANDLETYPE mHandle;
     sp<IOMXObserver> mObserver;
     bool mDying;
    bool mSailed;   
    bool mQueriedProhibitedExtensions;
    SortedVector<OMX_INDEXTYPE> mProhibitedExtensions;
     bool mIsSecure;
 
      
 

     OMX::buffer_id findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader);
     void invalidateBufferID(OMX::buffer_id buffer);
 
    bool isProhibitedIndex_l(OMX_INDEXTYPE index);

     status_t useGraphicBuffer2_l(
             OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
             OMX::buffer_id *buffer);
","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
2446,CVE-2016-6720," 

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
 
     *buffer = makeBufferID(header);
 
","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
2447,CVE-2016-6720," 

                 params, portIndex, false  , false  , data);
     } else {
         buffer_meta = new BufferMeta(
                params, portIndex, false  , false  , NULL);
     }
 
     OMX_BUFFERHEADERTYPE *header;
 

     }
 
     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);
     
     sp<ABuffer> data = bufferMeta->getBuffer(
             header, false  , false  );
     bufferMeta->setNativeHandle(nativeHandle);
 

     }
     BufferMeta *buffer_meta =
         static_cast<BufferMeta *>(header->pAppPrivate);
 
     
     
    if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource) {
        header->nFilledLen = rangeLength ? sizeof(VideoGrallocMetadata) : 0;
         header->nOffset = 0;
     } else {
          
","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
2448,CVE-2016-3909," 

             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
             if ((outHeader->nAllocLen < yFrameSize) ||
                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
                ALOGE(""Too small output buffer for reference frame: %lu bytes"",
                        (unsigned long)outHeader->nAllocLen);
                 android_errorWriteLog(0x534e4554, ""30033990"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
","The SoftMPEG4 component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30033990."
2449,CVE-2016-3900," 

 static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = ""add"";

    if (uid >= AID_APP) {
        return 0;  
    }

     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
 }
 
","cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260."
2450,CVE-2016-3890," 

 #endif
 ADB_MUTEX(basename_lock)
 ADB_MUTEX(dirname_lock)
 ADB_MUTEX(transport_lock)
 #if ADB_HOST
 ADB_MUTEX(local_transports_lock)
","The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842."
2451,CVE-2016-3872," 

         outHeader->nFlags = 0;
         outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;
         outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv;
        if (outputBufferSafe(outHeader)) {
             uint8_t *dst = outHeader->pBuffer;
             const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y];
             const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U];
 

             size_t srcVStride = mImg->stride[VPX_PLANE_V];
             copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);
         } else {
             outHeader->nFilledLen = 0;
         }
 
 

     return true;
 }
 
bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) {
    uint32_t width = outputBufferWidth();
    uint32_t height = outputBufferHeight();
    uint64_t nFilledLen = width;
    nFilledLen *= height;
    if (nFilledLen > UINT32_MAX / 3) {
        ALOGE(""b/29421675, nFilledLen overflow %llu w %u h %u"", nFilledLen, width, height);
        android_errorWriteLog(0x534e4554, ""29421675"");
        return false;
    } else if (outHeader->nAllocLen < outHeader->nFilledLen) {
        ALOGE(""b/27597103, buffer too small"");
        android_errorWriteLog(0x534e4554, ""27597103"");
        return false;
    }

    return true;
}

 void SoftVPX::onQueueFilled(OMX_U32  ) {
     if (mOutputPortSettingsChange != NONE || mEOSStatus == OUTPUT_FRAMES_FLUSHED) {
         return;
","Buffer overflow in codecs/on2/dec/SoftVPX.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allows attackers to gain privileges via a crafted application, aka internal bug 29421675."
2452,CVE-2016-3871," 

 
 void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %u, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
","Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022."
2453,CVE-2016-3871," 

 
 void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
","Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022."
2454,CVE-2016-3861," 

        return NO_ERROR;
     }
 
     
    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size) + 1;
    if (utf8Size < 1) {
         return BAD_VALUE;
     }
      
     
     str->resize(utf8Size);
    utf16_to_utf8(src, utf16Size, &((*str)[0]), utf8Size);
    str->resize(utf8Size - 1);
     return NO_ERROR;
 }
 
","LibUtils in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 mishandles conversions between Unicode character encodings with different encoding widths, which allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow) via a crafted file, aka internal bug 29250543."
2455,CVE-2016-3861," 

              
             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?
                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;
            utf16_to_utf8(tags.string(), tagSize, attributes->tags,
                    sizeof(attributes->tags) / sizeof(attributes->tags[0]));
         }
     } else {
         ALOGE(""unmarshallAudioAttributes() received unflattened tags, ignoring tag values"");
","LibUtils in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 mishandles conversions between Unicode character encodings with different encoding widths, which allows remote attackers to execute arbitrary code or cause a denial of service (heap-based buffer overflow) via a crafted file, aka internal bug 29250543."
2456,CVE-2016-3760," 

     return JNI_TRUE;
 }
 
static jboolean enableNative(JNIEnv* env, jobject obj, jboolean isGuest) {
     ALOGV(""%s:"",__FUNCTION__);
 
     jboolean result = JNI_FALSE;
     if (!sBluetoothInterface) return result;
    int ret = sBluetoothInterface->enable(isGuest == JNI_TRUE ? 1 : 0);
     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
     return result;
 }
 

     {""classInitNative"", ""()V"", (void *) classInitNative},
     {""initNative"", ""()Z"", (void *) initNative},
     {""cleanupNative"", ""()V"", (void*) cleanupNative},
    {""enableNative"", ""(Z)Z"",  (void*) enableNative},
     {""disableNative"", ""()Z"",  (void*) disableNative},
     {""setAdapterPropertyNative"", ""(I[B)Z"", (void*) setAdapterPropertyNative},
     {""getAdapterPropertiesNative"", ""()Z"", (void*) getAdapterPropertiesNative},
","Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683."
2457,CVE-2016-3760," 

     int (*init)(bt_callbacks_t* callbacks );
 
      
    int (*enable)(bool guest_mode);
 
      
     int (*disable)(void);
","Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683."
2458,CVE-2016-3754," 

     }
     if (psshsize > 0 && psshsize <= UINT32_MAX) {
         char *buf = (char*)malloc(psshsize);
        if (!buf) {
            ALOGE(""b/28471206"");
            return NO_MEMORY;
        }
         char *ptr = buf;
         for (size_t i = 0; i < mPssh.size(); i++) {
             memcpy(ptr, mPssh[i].uuid, 20);  
 

 
             sp<ABuffer> buffer = new ABuffer(chunk_data_size);
 
            if (buffer->data() == NULL) {
                ALOGE(""b/28471206"");
                return NO_MEMORY;
            }

             if (mDataSource->readAt(
                         data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                 return ERROR_IO;
 

         {
             sp<ABuffer> buffer = new ABuffer(chunk_data_size);
 
            if (buffer->data() == NULL) {
                ALOGE(""b/28471206"");
                return NO_MEMORY;
            }

             if (mDataSource->readAt(
                         data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                 return ERROR_IO;
 

                     return ERROR_MALFORMED;
                 }
                 sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);
                if (buffer->data() == NULL) {
                    ALOGE(""b/28471206"");
                    return NO_MEMORY;
                }
                 if (mDataSource->readAt(
                     data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
                     return ERROR_IO;
","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not limit process-memory usage, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28615448."
2459,CVE-2016-3741," 

 
     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

    {
        UWORD32 u4_size;
        u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size;
    }

     ps_dec->pv_dec_out = ps_dec_op;
     if(ps_dec->init_done != 1)
     {
","The H.264 decoder in mediaserver in Android 6.x before 2016-07-01 does not initialize certain slice data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28165661."
2460,CVE-2016-2508," 

 
 status_t NuPlayer::GenericSource::setBuffers(
         bool audio, Vector<MediaBuffer *> &buffers) {
    if (mIsSecure && !audio && mVideoTrack.mSource != NULL) {
         return mVideoTrack.mSource->setBuffers(buffers);
     }
     return INVALID_OPERATION;
","media/libmediaplayerservice/nuplayer/GenericSource.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate certain track data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28799341."
2461,CVE-2016-2496," 

 };
 
 enum {

     
    AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED = 0x2,

      
     AMOTION_EVENT_FLAG_TAINTED = 0x80000000,
 };
","The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796."
2462,CVE-2016-2495," 

 #define DATA_SOURCE_H_
 
 #include <sys/types.h>
#include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/MediaErrors.h>
 #include <utils/Errors.h>
 #include <utils/KeyedVector.h>
 

     bool getUInt32(off64_t offset, uint32_t *x);
     bool getUInt64(off64_t offset, uint64_t *x);
 
     
     
     
     
     
     
     
     
     
     
    template <typename T>
    bool getVector(off64_t offset, Vector<T>* x, size_t count,
                   size_t chunkSize = (4095 / sizeof(T)) + 1);

      
     virtual status_t getSize(off64_t *size);
 
 

     DataSource &operator=(const DataSource &);
 };
 
template <typename T>
bool DataSource::getVector(off64_t offset, Vector<T>* x, size_t count,
                           size_t chunkSize)
{
    x->clear();
    if (chunkSize == 0) {
        return false;
    }
    if (count == 0) {
        return true;
    }

    T tmp[chunkSize];
    ssize_t numBytesRead;
    size_t numBytesPerChunk = chunkSize * sizeof(T);
    size_t i;

    for (i = 0; i + chunkSize < count; i += chunkSize) {
         
         
        numBytesRead = this->readAt(offset, (void*)&tmp, numBytesPerChunk);
        if (numBytesRead == -1) {  
            return false;
        }
        if (numBytesRead < numBytesPerChunk) {
             
             
            x->appendArray(tmp, (size_t)numBytesRead / sizeof(T));
            return false;
        }
        x->appendArray(tmp, chunkSize);
        offset += numBytesPerChunk;
    }

     
     
     
    numBytesRead = this->readAt(offset, (void*)&tmp, (count - i) * sizeof(T));
    if (numBytesRead == -1) {
        return false;
    }
    x->appendArray(tmp, (size_t)numBytesRead / sizeof(T));
    return x->size() == count;
}

 }   
 
 #endif   
","SampleTable.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to cause a denial of service (device hang or reboot) via a crafted file, aka internal bug 28076789."
2463,CVE-2016-2487," 

         int32_t bufferSize = inHeader->nFilledLen;
         int32_t tmp = bufferSize;
 
        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;
        if (outHeader->nAllocLen < frameSize) {
            android_errorWriteLog(0x534e4554, ""27833616"");
            ALOGE(""Insufficient output buffer size"");
            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
            mSignalledError = true;
            return;
        }
          
          
          
 

         ++mInputBufferCount;
 
         outHeader->nOffset = 0;
        outHeader->nFilledLen = frameSize;
 
         List<BufferInfo *>::iterator it = outQueue.begin();
         while ((*it)->mHeader != outHeader) {
","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27833616."
2464,CVE-2016-2487," 

     resetPlugin();
 }
 
bool SoftAVC::setDecodeArgs(
         ivd_video_decode_ip_t *ps_dec_ip,
         ivd_video_decode_op_t *ps_dec_op,
         OMX_BUFFERHEADERTYPE *inHeader,
 

         size_t timeStampIx) {
     size_t sizeY = outputBufferWidth() * outputBufferHeight();
     size_t sizeUV;
 
     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);
     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
 

         ps_dec_ip->u4_num_Bytes = 0;
     }
 
     sizeUV = sizeY / 4;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;
 
    uint8_t *pBuf;
    if (outHeader) {
        if (outHeader->nAllocLen < sizeY + (sizeUV * 2)) {
            android_errorWriteLog(0x534e4554, ""27569635"");
            return false;
        }
        pBuf = outHeader->pBuffer;
    } else {
         
        pBuf = mFlushOutBuffer;
    }

     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;
     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;
     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;
     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;
    return true;
 }
 void SoftAVC::onPortFlushCompleted(OMX_U32 portIndex) {
      
 

             WORD32 timeDelay, timeTaken;
             size_t sizeY, sizeUV;
 
            if (!setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx)) {
                ALOGE(""Decoder arg setup failed"");
                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                mSignalledError = true;
                return;
            }
              
             DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);
 
","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27833616."
2465,CVE-2016-2476," 

 #define LOG_TAG ""IOMX""
 #include <utils/Log.h>
 
#include <sys/mman.h>

 #include <binder/IMemory.h>
 #include <binder/Parcel.h>
 #include <media/IOMX.h>
 

 
             size_t size = data.readInt64();
 
            status_t err = NOT_ENOUGH_DATA;
            void *params = NULL;
            size_t pageSize = 0;
            size_t allocSize = 0;
            if (code != SET_INTERNAL_OPTION && size < 8) {
                 
                 
                ALOGE(""b/27207275 (%zu)"", size);
                android_errorWriteLog(0x534e4554, ""27207275"");
            } else {
                err = NO_MEMORY;
                pageSize = (size_t) sysconf(_SC_PAGE_SIZE);
                if (size > SIZE_MAX - (pageSize * 2)) {
                    ALOGE(""requested param size too big"");
                 } else {
                    allocSize = (size + pageSize * 2) & ~(pageSize - 1);
                    params = mmap(NULL, allocSize, PROT_READ | PROT_WRITE,
                            MAP_PRIVATE | MAP_ANONYMOUS, -1  , 0  );
                }
                if (params != MAP_FAILED) {
                    err = data.read(params, size);
                    if (err != OK) {
                        android_errorWriteLog(0x534e4554, ""26914474"");
                    } else {
                        err = NOT_ENOUGH_DATA;
                        OMX_U32 declaredSize = *(OMX_U32*)params;
                        if (code != SET_INTERNAL_OPTION && declaredSize > size) {
                             
                            ALOGE(""b/27207275 (%u/%zu)"", declaredSize, size);
                            android_errorWriteLog(0x534e4554, ""27207275"");
                        } else {
                             
                             
                             
                            mprotect((char*)params + allocSize - pageSize, pageSize, PROT_NONE);
                            switch (code) {
                                case GET_PARAMETER:
                                    err = getParameter(node, index, params, size);
                                    break;
                                case SET_PARAMETER:
                                    err = setParameter(node, index, params, size);
                                    break;
                                case GET_CONFIG:
                                    err = getConfig(node, index, params, size);
                                    break;
                                case SET_CONFIG:
                                    err = setConfig(node, index, params, size);
                                    break;
                                case SET_INTERNAL_OPTION:
                                {
                                    InternalOptionType type =
                                        (InternalOptionType)data.readInt32();
 
                                    err = setInternalOption(node, index, type, params, size);
                                    break;
                                }

                                default:
                                    TRESPASS();
                            }
                         }
                     }
                } else {
                    ALOGE(""couldn't map: %s"", strerror(errno));
                 }
             }
 
 

                 reply->write(params, size);
             }
 
            if (params) {
                munmap(params, allocSize);
            }
             params = NULL;
 
             return NO_ERROR;
","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
2466,CVE-2016-2476," 

             void *params = NULL;
             size_t pageSize = 0;
             size_t allocSize = 0;
            bool isUsageBits = (index == (OMX_INDEXTYPE) OMX_IndexParamConsumerUsageBits);
            if ((isUsageBits && size < 4) ||
                    (!isUsageBits && code != SET_INTERNAL_OPTION && size < 8)) {
                  
                  
                ALOGE(""b/27207275 (%zu) (%d/%d)"", size, int(index), int(code));
                 android_errorWriteLog(0x534e4554, ""27207275"");
             } else {
                 err = NO_MEMORY;
","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
2467,CVE-2016-2476," 

             : OMX_AUDIO_AACStreamFormatMP4FF;
 
     OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;
    InitOMXParams(&presentation);
     presentation.nMaxOutputChannels = maxOutputChannelCount;
     presentation.nDrcCut = drc.drcCut;
     presentation.nDrcBoost = drc.drcBoost;
","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
2468,CVE-2016-2464," 

 
    
 
  if (stop >= 0 && pos > stop)
     return E_FILE_FORMAT_INVALID;
 
   return 0;   
","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
2469,CVE-2016-2452," 

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 

             return;
         }
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         if (inHeader->nOffset == 0) {
             mAnchorTimeUs = inHeader->nTimeStamp;
             mNumSamplesOutput = 0;
","codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673."
2470,CVE-2016-2452," 

         BufferInfo *inInfo = *inQueue.begin();
         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;
 
        if (inHeader->nFilledLen == 0) {
            inInfo->mOwnedByUs = false;
            inQueue.erase(inQueue.begin());
            notifyEmptyBufferDone(inHeader);
            continue;
        }

         BufferInfo *outInfo = *outQueue.begin();
         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
 
 

                 return;
             }
 
            int16 mode = ((inputPtr[0] >> 3) & 0x0f);
             
            size_t frameSize = WmfDecBytesPerFrame[mode] + 1;

            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }

             numBytesRead =
                 AMRDecode(mState,
                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
 

             }
 
             size_t frameSize = getFrameSize(mode);
            if (inHeader->nFilledLen < frameSize) {
                ALOGE(""b/27662364: expected %zu bytes vs %u"", frameSize, inHeader->nFilledLen);
                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                mSignalledError = true;
                return;
            }
 
             int16_t *outPtr = (int16_t *)outHeader->pBuffer;
 
","codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673."
2471,CVE-2016-2416," 

 #include <gui/IConsumerListener.h>
 #include <gui/IProducerListener.h>
 
#include <binder/IPCThreadState.h>
#include <binder/PermissionCache.h>
#include <private/android_filesystem_config.h>

 namespace android {
 
 BufferQueueConsumer::BufferQueueConsumer(const sp<BufferQueueCore>& core) :
 

 }
 
 void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    const IPCThreadState* ipc = IPCThreadState::self();
    const pid_t pid = ipc->getCallingPid();
    const uid_t uid = ipc->getCallingUid();
    if ((uid != AID_SHELL)
            && !PermissionCache::checkPermission(String16(
            ""android.permission.DUMP""), pid, uid)) {
        result.appendFormat(""Permission Denial: can't dump BufferQueueConsumer ""
                ""from pid=%d, uid=%d\n"", pid, uid);
    } else {
        mCore->dump(result, prefix);
    }
 }
 
 }  
","libs/gui/BufferQueueConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for the android.permission.DUMP permission, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via a dump request, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27046057."
2472,CVE-2016-2414," 

     }
 }
 
 
 static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
     const size_t kSegCountOffset = 6;
     const size_t kEndCountOffset = 14;
 

         return false;
     }
     for (size_t i = 0; i < segCount; i++) {
        uint32_t end = readU16(data, kEndCountOffset + 2 * i);
        uint32_t start = readU16(data, kHeaderSize + 2 * (segCount + i));
        if (end < start) {
             
            return false;
        }
        uint32_t rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));
         if (rangeOffset == 0) {
            uint32_t delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));
             if (((end + delta) & 0xffff) > end - start) {
                 addRange(coverage, start, end + 1);
             } else {
                for (uint32_t j = start; j < end + 1; j++) {
                     if (((j + delta) & 0xffff) != 0) {
                         addRange(coverage, j, j + 1);
                     }
                 }
             }
         } else {
            for (uint32_t j = start; j < end + 1; j++) {
                 uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +
                     (i + j - start) * 2;
                 if (actualRangeOffset + 2 > size) {
                     return false;
                 }
                uint32_t glyphId = readU16(data, actualRangeOffset);
                 if (glyphId != 0) {
                     addRange(coverage, j, j + 1);
                 }
 

         uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
         uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
         uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        if (end < start) {
             
            return false;
        }
         addRange(coverage, start, end + 1);   
     }
     return true;
 

     const size_t kPlatformIdOffset = 0;
     const size_t kEncodingIdOffset = 2;
     const size_t kOffsetOffset = 4;
    const uint16_t kMicrosoftPlatformId = 3;
    const uint16_t kUnicodeBmpEncodingId = 1;
    const uint16_t kUnicodeUcs4EncodingId = 10;
    const uint32_t kNoTable = UINT32_MAX;
     if (kHeaderSize > cmap_size) {
         return false;
     }
    uint32_t numTables = readU16(cmap_data, kNumTablesOffset);
     if (kHeaderSize + numTables * kTableSize > cmap_size) {
         return false;
     }
    uint32_t bestTable = kNoTable;
    for (uint32_t i = 0; i < numTables; i++) {
         uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset);
         uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset);
         if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) {
 

 #ifdef PRINTF_DEBUG
     printf(""best table = %d\n"", bestTable);
 #endif
    if (bestTable == kNoTable) {
         return false;
     }
     uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset);
    if (offset > cmap_size - 2) {
         return false;
     }
     uint16_t format = readU16(cmap_data, offset);
","The Minikin library in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider negative size values in font data, which allows remote attackers to cause a denial of service (memory corruption and reboot loop) via a crafted font, aka internal bug 26413177."
2473,CVE-2016-1621," 

 #include <new>
 #include <climits>
 
#ifdef _MSC_VER
 
#pragma warning(disable : 4996)
#endif

mkvparser::IMkvReader::~IMkvReader() {}

void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision) {
  major = 1;
  minor = 0;
  build = 0;
  revision = 28;
 }
 
long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {
  assert(pReader);
  assert(pos >= 0);
 
  int status;
 
   
   
   
   
   
   
   
   
 
  len = 1;
 
  unsigned char b;
 
  status = pReader->Read(pos, 1, &b);
 
  if (status < 0)   
    return status;

  if (status > 0)   
    return E_BUFFER_NOT_FULL;

  if (b == 0)   
    return E_FILE_FORMAT_INVALID;

  unsigned char m = 0x80;

  while (!(b & m)) {
    m >>= 1;
    ++len;
  }

   
   
   

  long long result = b & (~m);
  ++pos;

  for (int i = 1; i < len; ++i) {
     status = pReader->Read(pos, 1, &b);
 
    if (status < 0) {
      len = 1;
      return status;
     }
 
    if (status > 0) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }
 
    result <<= 8;
    result |= b;

     ++pos;
  }
 
  return result;
 }
 
long long mkvparser::GetUIntLength(IMkvReader* pReader, long long pos,
                                   long& len) {
  assert(pReader);
  assert(pos >= 0);
 
  long long total, available;
 
  int status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
 
  len = 1;
 
  if (pos >= available)
    return pos;   
 
  unsigned char b;

  status = pReader->Read(pos, 1, &b);

  if (status < 0)
    return status;

  assert(status == 0);

  if (b == 0)   
    return E_FILE_FORMAT_INVALID;

  unsigned char m = 0x80;

  while (!(b & m)) {
    m >>= 1;
    ++len;
  }

  return 0;   
}

 
 
long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,
                                     long long size) {
  assert(pReader);
  assert(pos >= 0);

  if ((size <= 0) || (size > 8))
    return E_FILE_FORMAT_INVALID;

  long long result = 0;

  for (long long i = 0; i < size; ++i) {
     unsigned char b;
 
    const long status = pReader->Read(pos, 1, &b);
 
     if (status < 0)
      return status;
 
    result <<= 8;
    result |= b;
 
    ++pos;
  }
 
  return result;
 }
 
long mkvparser::UnserializeFloat(IMkvReader* pReader, long long pos,
                                 long long size_, double& result) {
  assert(pReader);
  assert(pos >= 0);
 
  if ((size_ != 4) && (size_ != 8))
    return E_FILE_FORMAT_INVALID;
 
  const long size = static_cast<long>(size_);
 
  unsigned char buf[8];
 
  const int status = pReader->Read(pos, size, buf);
 
  if (status < 0)   
    return status;
 
  if (size == 4) {
    union {
      float f;
      unsigned long ff;
    };
 
    ff = 0;
 
    for (int i = 0;;) {
      ff |= buf[i];

      if (++i >= 4)
        break;

      ff <<= 8;
     }
 
    result = f;
  } else {
    assert(size == 8);

    union {
      double d;
      unsigned long long dd;
    };

    dd = 0;

    for (int i = 0;;) {
      dd |= buf[i];

      if (++i >= 8)
        break;

      dd <<= 8;
    }

    result = d;
  }

  return 0;
 }
 
long mkvparser::UnserializeInt(IMkvReader* pReader, long long pos, long size,
                               long long& result) {
  assert(pReader);
  assert(pos >= 0);
  assert(size > 0);
  assert(size <= 8);
 
  {
    signed char b;
 
    const long status = pReader->Read(pos, 1, (unsigned char*)&b);
 
    if (status < 0)
      return status;
 
    result = b;
 
    ++pos;
  }
 
  for (long i = 1; i < size; ++i) {
    unsigned char b;
 
    const long status = pReader->Read(pos, 1, &b);
 
    if (status < 0)
      return status;
 
    result <<= 8;
    result |= b;
 
    ++pos;
  }
 
  return 0;   
 }
 
long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,
                                  long long size_, char*& str) {
  delete[] str;
  str = NULL;
 
  if (size_ >= LONG_MAX)   
    return E_FILE_FORMAT_INVALID;
 
  const long size = static_cast<long>(size_);
 
  str = new (std::nothrow) char[size + 1];
 
  if (str == NULL)
    return -1;
 
  unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
 
  const long status = pReader->Read(pos, size, buf);
 
  if (status) {
     delete[] str;
     str = NULL;
 
    return status;
  }
 
  str[size] = '\0';
 
  return 0;   
 }
 
long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,
                                   long long stop, long long& id,
                                   long long& size) {
  if ((stop >= 0) && (pos >= stop))
    return E_FILE_FORMAT_INVALID;
 
  long len;
 
  id = ReadUInt(pReader, pos, len);
 
  if (id < 0)
    return E_FILE_FORMAT_INVALID;
 
  pos += len;   
 
  if ((stop >= 0) && (pos >= stop))
    return E_FILE_FORMAT_INVALID;
 
  size = ReadUInt(pReader, pos, len);
 
  if (size < 0)
    return E_FILE_FORMAT_INVALID;
 
  pos += len;   
 
   
 
  if ((stop >= 0) && ((pos + size) > stop))
    return E_FILE_FORMAT_INVALID;
 
  return 0;   
 }
 
bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,
                      long long& val) {
  assert(pReader);
  assert(pos >= 0);
 
  long long total, available;
 
  const long status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
    return false;
 
  long len;
 
  const long long id = ReadUInt(pReader, pos, len);
  assert(id >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
  if ((unsigned long)id != id_)
    return false;
 
  pos += len;   
 
  const long long size = ReadUInt(pReader, pos, len);
  assert(size >= 0);
  assert(size <= 8);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
  pos += len;   
 
  val = UnserializeUInt(pReader, pos, size);
  assert(val >= 0);
 
  pos += size;   
 
  return true;
 }
 
bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,
                      unsigned char*& buf, size_t& buflen) {
  assert(pReader);
  assert(pos >= 0);
 
  long long total, available;
 
  long status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
    return false;
 
  long len;
  const long long id = ReadUInt(pReader, pos, len);
  assert(id >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
  if ((unsigned long)id != id_)
    return false;
 
  pos += len;   
 
  const long long size_ = ReadUInt(pReader, pos, len);
  assert(size_ >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
  pos += len;   
  assert((pos + size_) <= available);
 
  const long buflen_ = static_cast<long>(size_);
 
  buf = new (std::nothrow) unsigned char[buflen_];
  assert(buf);   
 
  status = pReader->Read(pos, buflen_, buf);
  assert(status == 0);   
 
  buflen = buflen_;
 
  pos += size_;   
  return true;
 }
 
namespace mkvparser {
 
EBMLHeader::EBMLHeader() : m_docType(NULL) { Init(); }
 
EBMLHeader::~EBMLHeader() { delete[] m_docType; }
 
void EBMLHeader::Init() {
  m_version = 1;
  m_readVersion = 1;
  m_maxIdLength = 4;
  m_maxSizeLength = 8;

  if (m_docType) {
     delete[] m_docType;
    m_docType = NULL;
  }

  m_docTypeVersion = 1;
  m_docTypeReadVersion = 1;
 }
 
long long EBMLHeader::Parse(IMkvReader* pReader, long long& pos) {
  assert(pReader);
 
  long long total, available;
 
  long status = pReader->Length(&total, &available);
 
  if (status < 0)   
    return status;
 
  pos = 0;
  long long end = (available >= 1024) ? 1024 : available;
 
  for (;;) {
    unsigned char b = 0;
 
    while (pos < end) {
      status = pReader->Read(pos, 1, &b);

      if (status < 0)   
         return status;
 
      if (b == 0x1A)
        break;
 
      ++pos;
     }
 
    if (b != 0x1A) {
      if (pos >= 1024)
        return E_FILE_FORMAT_INVALID;   
 
      if ((total >= 0) && ((total - available) < 5))
        return E_FILE_FORMAT_INVALID;
 
      return available + 5;   
    }

    if ((total >= 0) && ((total - pos) < 5))
      return E_FILE_FORMAT_INVALID;

    if ((available - pos) < 5)
      return pos + 5;   

    long len;

    const long long result = ReadUInt(pReader, pos, len);

    if (result < 0)   
      return result;

    if (result == 0x0A45DFA3) {   
      pos += len;   
      break;
    }

    ++pos;   
  }

   

   

  long len;
  long long result = GetUIntLength(pReader, pos, len);

  if (result < 0)   
    return result;

  if (result > 0)   
    return result;

  assert(len > 0);
  assert(len <= 8);

  if ((total >= 0) && ((total - pos) < len))
    return E_FILE_FORMAT_INVALID;

  if ((available - pos) < len)
    return pos + len;   

   

  result = ReadUInt(pReader, pos, len);

  if (result < 0)   
    return result;

  pos += len;   

   

  if ((total >= 0) && ((total - pos) < result))
    return E_FILE_FORMAT_INVALID;

  if ((available - pos) < result)
    return pos + result;

  end = pos + result;

  Init();

  while (pos < end) {
    long long id, size;

    status = ParseElementHeader(pReader, pos, end, id, size);

    if (status < 0)   
      return status;

    if (size == 0)   
      return E_FILE_FORMAT_INVALID;

    if (id == 0x0286) {   
      m_version = UnserializeUInt(pReader, pos, size);

      if (m_version <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x02F7) {   
      m_readVersion = UnserializeUInt(pReader, pos, size);

      if (m_readVersion <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x02F2) {   
      m_maxIdLength = UnserializeUInt(pReader, pos, size);

      if (m_maxIdLength <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x02F3) {   
      m_maxSizeLength = UnserializeUInt(pReader, pos, size);

      if (m_maxSizeLength <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x0282) {   
      if (m_docType)
        return E_FILE_FORMAT_INVALID;

      status = UnserializeString(pReader, pos, size, m_docType);

      if (status)   
        return status;
    } else if (id == 0x0287) {   
      m_docTypeVersion = UnserializeUInt(pReader, pos, size);

      if (m_docTypeVersion <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x0285) {   
      m_docTypeReadVersion = UnserializeUInt(pReader, pos, size);

      if (m_docTypeReadVersion <= 0)
        return E_FILE_FORMAT_INVALID;
    }

    pos += size;
  }

  assert(pos == end);
  return 0;
}

Segment::Segment(IMkvReader* pReader, long long elem_start,
                  
                 long long start, long long size)
    : m_pReader(pReader),
      m_element_start(elem_start),
       
      m_start(start),
      m_size(size),
      m_pos(start),
      m_pUnknownSize(0),
      m_pSeekHead(NULL),
      m_pInfo(NULL),
      m_pTracks(NULL),
      m_pCues(NULL),
      m_pChapters(NULL),
      m_clusters(NULL),
      m_clusterCount(0),
      m_clusterPreloadCount(0),
      m_clusterSize(0) {}

Segment::~Segment() {
  const long count = m_clusterCount + m_clusterPreloadCount;

  Cluster** i = m_clusters;
  Cluster** j = m_clusters + count;

  while (i != j) {
    Cluster* const p = *i++;
    assert(p);

    delete p;
  }

  delete[] m_clusters;

  delete m_pTracks;
  delete m_pInfo;
  delete m_pCues;
  delete m_pChapters;
  delete m_pSeekHead;
}

long long Segment::CreateInstance(IMkvReader* pReader, long long pos,
                                  Segment*& pSegment) {
  assert(pReader);
  assert(pos >= 0);

  pSegment = NULL;

  long long total, available;

  const long status = pReader->Length(&total, &available);

  if (status < 0)   
    return status;

  if (available < 0)
    return -1;

  if ((total >= 0) && (available > total))
    return -1;

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

  for (;;) {
    if ((total >= 0) && (pos >= total))
      return E_FILE_FORMAT_INVALID;

     
     long len;
     long long result = GetUIntLength(pReader, pos, len);
 
    if (result)   
      return result;
 
    if ((total >= 0) && ((pos + len) > total))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > available)
      return pos + len;
 
    const long long idpos = pos;
    const long long id = ReadUInt(pReader, pos, len);
 
    if (id < 0)   
      return id;
 
    pos += len;   
 
     
 
    result = GetUIntLength(pReader, pos, len);
 
    if (result)   
      return result;
 
    if ((total >= 0) && ((pos + len) > total))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > available)
      return pos + len;
 
    long long size = ReadUInt(pReader, pos, len);
 
    if (size < 0)   
      return size;
 
    pos += len;   
 
     
 
     
    const long long unknown_size = (1LL << (7 * len)) - 1;
 
    if (id == 0x08538067) {   
      if (size == unknown_size)
        size = -1;
 
      else if (total < 0)
        size = -1;
 
      else if ((pos + size) > total)
        size = -1;
 
      pSegment = new (std::nothrow) Segment(pReader, idpos,
                                             
                                            pos, size);
 
      if (pSegment == 0)
        return -1;   
 
      return 0;   
     }
 
    if (size == unknown_size)
      return E_FILE_FORMAT_INVALID;

    if ((total >= 0) && ((pos + size) > total))
      return E_FILE_FORMAT_INVALID;

    if ((pos + size) > available)
      return pos + size;

    pos += size;   
  }
 }
 
long long Segment::ParseHeaders() {
   
   
   
  long long total, available;
 
  const int status = m_pReader->Length(&total, &available);
 
  if (status < 0)   
    return status;
 
  assert((total < 0) || (available <= total));
 
  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));
  assert((segment_stop < 0) || (m_pos <= segment_stop));
 
  for (;;) {
    if ((total >= 0) && (m_pos >= total))
      break;
 
    if ((segment_stop >= 0) && (m_pos >= segment_stop))
      break;
 
    long long pos = m_pos;
    const long long element_start = pos;
 
    if ((pos + 1) > available)
      return (pos + 1);
 
    long len;
    long long result = GetUIntLength(m_pReader, pos, len);
 
    if (result < 0)   
      return result;
 
    if (result > 0)   
      return (pos + 1);
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > available)
      return pos + len;
 
    const long long idpos = pos;
    const long long id = ReadUInt(m_pReader, idpos, len);
 
    if (id < 0)   
      return id;

    if (id == 0x0F43B675)   
      break;

    pos += len;   

    if ((pos + 1) > available)
      return (pos + 1);

     
    result = GetUIntLength(m_pReader, pos, len);

    if (result < 0)   
      return result;

    if (result > 0)   
      return (pos + 1);

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > available)
      return pos + len;

    const long long size = ReadUInt(m_pReader, pos, len);

    if (size < 0)   
      return size;

    pos += len;   

    const long long element_size = size + pos - element_start;

     

    if ((segment_stop >= 0) && ((pos + size) > segment_stop))
      return E_FILE_FORMAT_INVALID;

     

    if ((pos + size) > available)
      return pos + size;

    if (id == 0x0549A966) {   
      if (m_pInfo)
        return E_FILE_FORMAT_INVALID;

      m_pInfo = new (std::nothrow)
          SegmentInfo(this, pos, size, element_start, element_size);

      if (m_pInfo == NULL)
         return -1;
 
      const long status = m_pInfo->Parse();

      if (status)
        return status;
    } else if (id == 0x0654AE6B) {   
      if (m_pTracks)
        return E_FILE_FORMAT_INVALID;

      m_pTracks = new (std::nothrow)
          Tracks(this, pos, size, element_start, element_size);

      if (m_pTracks == NULL)
         return -1;
 
      const long status = m_pTracks->Parse();
 
      if (status)
         return status;
    } else if (id == 0x0C53BB6B) {   
      if (m_pCues == NULL) {
        m_pCues = new (std::nothrow)
            Cues(this, pos, size, element_start, element_size);
 
        if (m_pCues == NULL)
          return -1;
      }
    } else if (id == 0x014D9B74) {   
      if (m_pSeekHead == NULL) {
        m_pSeekHead = new (std::nothrow)
            SeekHead(this, pos, size, element_start, element_size);
 
        if (m_pSeekHead == NULL)
          return -1;
 
        const long status = m_pSeekHead->Parse();
 
        if (status)
          return status;
      }
    } else if (id == 0x0043A770) {   
      if (m_pChapters == NULL) {
        m_pChapters = new (std::nothrow)
            Chapters(this, pos, size, element_start, element_size);
 
        if (m_pChapters == NULL)
          return -1;
 
        const long status = m_pChapters->Parse();
 
        if (status)
          return status;
      }
     }
 
    m_pos = pos + size;   
  }
 
  assert((segment_stop < 0) || (m_pos <= segment_stop));
 
  if (m_pInfo == NULL)   
    return E_FILE_FORMAT_INVALID;
 
  if (m_pTracks == NULL)
    return E_FILE_FORMAT_INVALID;

  return 0;   
 }
 
long Segment::LoadCluster(long long& pos, long& len) {
  for (;;) {
    const long result = DoLoadCluster(pos, len);
 
    if (result <= 1)
      return result;
  }
}
 
long Segment::DoLoadCluster(long long& pos, long& len) {
  if (m_pos < 0)
    return DoLoadClusterUnknownSize(pos, len);

  long long total, avail;

  long status = m_pReader->Length(&total, &avail);

  if (status < 0)   
    return status;

  assert((total < 0) || (avail <= total));

  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

  long long cluster_off = -1;   
  long long cluster_size = -1;   

  for (;;) {
    if ((total >= 0) && (m_pos >= total))
      return 1;   

    if ((segment_stop >= 0) && (m_pos >= segment_stop))
      return 1;   

    pos = m_pos;

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }
 
    long long result = GetUIntLength(m_pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long idpos = pos;
    const long long id = ReadUInt(m_pReader, idpos, len);
 
    if (id < 0)   
      return static_cast<long>(id);
 
    pos += len;   
 
     
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }
 
    result = GetUIntLength(m_pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long size = ReadUInt(m_pReader, pos, len);
 
    if (size < 0)   
      return static_cast<long>(size);
 
    pos += len;   
 
     
 
    if (size == 0) {   
      m_pos = pos;
      continue;
    }
 
    const long long unknown_size = (1LL << (7 * len)) - 1;
 
#if 0   
         if (size == unknown_size)
             return E_FILE_FORMAT_INVALID;   
 #endif
 
    if ((segment_stop >= 0) && (size != unknown_size) &&
        ((pos + size) > segment_stop)) {
      return E_FILE_FORMAT_INVALID;
    }
 
#if 0   
         len = static_cast<long>(size);
 
         if ((pos + size) > avail)
             return E_BUFFER_NOT_FULL;
 #endif
 
    if (id == 0x0C53BB6B) {   
      if (size == unknown_size)
        return E_FILE_FORMAT_INVALID;   
 
      if (m_pCues == NULL) {
        const long long element_size = (pos - idpos) + size;
 
        m_pCues = new Cues(this, pos, size, idpos, element_size);
        assert(m_pCues);   
      }
 
      m_pos = pos + size;   
      continue;
     }
 
    if (id != 0x0F43B675) {   
      if (size == unknown_size)
        return E_FILE_FORMAT_INVALID;   
 
      m_pos = pos + size;   
      continue;
     }
 
     
 
    cluster_off = idpos - m_start;   
 
    if (size != unknown_size)
      cluster_size = size;
 
    break;
  }
 
  assert(cluster_off >= 0);   
 
  long long pos_;
  long len_;
 
  status = Cluster::HasBlockEntries(this, cluster_off, pos_, len_);
 
  if (status < 0) {   
    pos = pos_;
    len = len_;
 
    return status;
  }
 
   
   
 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 
  const long idx = m_clusterCount;
 
  if (m_clusterPreloadCount > 0) {
     assert(idx < m_clusterSize);
 
    Cluster* const pCluster = m_clusters[idx];
    assert(pCluster);
    assert(pCluster->m_index < 0);

    const long long off = pCluster->GetPosition();
    assert(off >= 0);

    if (off == cluster_off) {   
      if (status == 0)   
        return E_FILE_FORMAT_INVALID;

      if (cluster_size >= 0)
         pos += cluster_size;
      else {
        const long long element_size = pCluster->GetElementSize();
 
        if (element_size <= 0)
          return E_FILE_FORMAT_INVALID;   
 
        pos = pCluster->m_element_start + element_size;
      }

      pCluster->m_index = idx;   
      ++m_clusterCount;
      --m_clusterPreloadCount;

      m_pos = pos;   
      assert((segment_stop < 0) || (m_pos <= segment_stop));

      return 0;   
    }
  }

  if (status == 0) {   
    if (cluster_size < 0)
      return E_FILE_FORMAT_INVALID;   

    pos += cluster_size;

    if ((total >= 0) && (pos >= total)) {
      m_pos = total;
      return 1;   
     }
 
    if ((segment_stop >= 0) && (pos >= segment_stop)) {
      m_pos = segment_stop;
      return 1;   
    }
 
    m_pos = pos;
    return 2;   
  }
 
   
 
  Cluster* const pCluster = Cluster::Create(this, idx, cluster_off);
   
  assert(pCluster);

  AppendCluster(pCluster);
  assert(m_clusters);
  assert(idx < m_clusterSize);
  assert(m_clusters[idx] == pCluster);

  if (cluster_size >= 0) {
    pos += cluster_size;

    m_pos = pos;
    assert((segment_stop < 0) || (m_pos <= segment_stop));

    return 0;
  }

  m_pUnknownSize = pCluster;
  m_pos = -pos;

  return 0;   

 

 
 
 
 #if 0
 
    if (cluster_size < 0) {   
         const long long payload_pos = pos;   
 
        for (;;) {   
             if ((total >= 0) && (pos >= total))
                 break;
 
 

     return 2;      
 
 #endif
 }
 
long Segment::DoLoadClusterUnknownSize(long long& pos, long& len) {
  assert(m_pos < 0);
  assert(m_pUnknownSize);
 
 #if 0
     assert(m_pUnknownSize->GetElementSize() < 0);   
 

 
     long long element_size = -1;
 
    for (;;) {   
         if ((total >= 0) && (pos >= total))
         {
             element_size = total - element_start;
 

          
          
 
        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {   
             element_size = pos - element_start;
             assert(element_size > 0);
 
 

 
     return 2;   
 #else
  const long status = m_pUnknownSize->Parse(pos, len);
 
  if (status < 0)   
    return status;
 
  if (status == 0)   
    return 2;   
 
  assert(status > 0);   
 
  const long long start = m_pUnknownSize->m_element_start;
 
  const long long size = m_pUnknownSize->GetElementSize();
  assert(size >= 0);
 
  pos = start + size;
  m_pos = pos;
 
  m_pUnknownSize = 0;
 
  return 2;   
 #endif
 }
 
void Segment::AppendCluster(Cluster* pCluster) {
  assert(pCluster);
  assert(pCluster->m_index >= 0);
 
  const long count = m_clusterCount + m_clusterPreloadCount;
 
  long& size = m_clusterSize;
  assert(size >= count);
 
  const long idx = pCluster->m_index;
  assert(idx == m_clusterCount);
 
  if (count >= size) {
    const long n = (size <= 0) ? 2048 : 2 * size;
 
    Cluster** const qq = new Cluster* [n];
    Cluster** q = qq;
 
    Cluster** p = m_clusters;
    Cluster** const pp = p + count;
 
    while (p != pp)
      *q++ = *p++;
 
    delete[] m_clusters;
 
    m_clusters = qq;
    size = n;
  }
 
  if (m_clusterPreloadCount > 0) {
     assert(m_clusters);
 
    Cluster** const p = m_clusters + m_clusterCount;
    assert(*p);
    assert((*p)->m_index < 0);
 
    Cluster** q = p + m_clusterPreloadCount;
     assert(q < (m_clusters + size));
 
    for (;;) {
      Cluster** const qq = q - 1;
      assert((*qq)->m_index < 0);
 
      *q = *qq;
      q = qq;

      if (q == p)
        break;
     }
  }
 
  m_clusters[idx] = pCluster;
  ++m_clusterCount;
 }
 
void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx) {
  assert(pCluster);
  assert(pCluster->m_index < 0);
  assert(idx >= m_clusterCount);
 
  const long count = m_clusterCount + m_clusterPreloadCount;
 
  long& size = m_clusterSize;
  assert(size >= count);
 
  if (count >= size) {
    const long n = (size <= 0) ? 2048 : 2 * size;
 
    Cluster** const qq = new Cluster* [n];
    Cluster** q = qq;
 
    Cluster** p = m_clusters;
    Cluster** const pp = p + count;
 
    while (p != pp)
      *q++ = *p++;
 
    delete[] m_clusters;
 
    m_clusters = qq;
    size = n;
  }
 
  assert(m_clusters);

  Cluster** const p = m_clusters + idx;

  Cluster** q = m_clusters + count;
  assert(q >= p);
  assert(q < (m_clusters + size));

  while (q > p) {
    Cluster** const qq = q - 1;
    assert((*qq)->m_index < 0);

    *q = *qq;
    q = qq;
  }

  m_clusters[idx] = pCluster;
  ++m_clusterPreloadCount;
 }
 
long Segment::Load() {
  assert(m_clusters == NULL);
  assert(m_clusterSize == 0);
  assert(m_clusterCount == 0);
   
 
   
   
   

  const long long header_status = ParseHeaders();

  if (header_status < 0)   
    return static_cast<long>(header_status);

  if (header_status > 0)   
    return E_BUFFER_NOT_FULL;

  assert(m_pInfo);
  assert(m_pTracks);

  for (;;) {
    const int status = LoadCluster();

    if (status < 0)   
      return status;

    if (status >= 1)   
      return 0;
  }
 }
 
SeekHead::SeekHead(Segment* pSegment, long long start, long long size_,
                   long long element_start, long long element_size)
    : m_pSegment(pSegment),
      m_start(start),
      m_size(size_),
      m_element_start(element_start),
      m_element_size(element_size),
      m_entries(0),
      m_entry_count(0),
      m_void_elements(0),
      m_void_element_count(0) {}
 
SeekHead::~SeekHead() {
  delete[] m_entries;
  delete[] m_void_elements;
 }
 
long SeekHead::Parse() {
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long pos = m_start;
  const long long stop = m_start + m_size;
 
   
 
  int entry_count = 0;
  int void_element_count = 0;
 
  while (pos < stop) {
    long long id, size;
 
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
    if (status < 0)   
      return status;
 
    if (id == 0x0DBB)   
      ++entry_count;
    else if (id == 0x6C)   
      ++void_element_count;
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(pos == stop);

  m_entries = new (std::nothrow) Entry[entry_count];

  if (m_entries == NULL)
    return -1;

  m_void_elements = new (std::nothrow) VoidElement[void_element_count];

  if (m_void_elements == NULL)
    return -1;

   

  Entry* pEntry = m_entries;
  VoidElement* pVoidElement = m_void_elements;

  pos = m_start;

  while (pos < stop) {
    const long long idpos = pos;

    long long id, size;

    const long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (id == 0x0DBB) {   
      if (ParseEntry(pReader, pos, size, pEntry)) {
        Entry& e = *pEntry++;

        e.element_start = idpos;
        e.element_size = (pos + size) - idpos;
      }
    } else if (id == 0x6C) {   
      VoidElement& e = *pVoidElement++;

      e.element_start = idpos;
      e.element_size = (pos + size) - idpos;
     }
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(pos == stop);
 
  ptrdiff_t count_ = ptrdiff_t(pEntry - m_entries);
  assert(count_ >= 0);
  assert(count_ <= entry_count);
 
  m_entry_count = static_cast<int>(count_);
 
  count_ = ptrdiff_t(pVoidElement - m_void_elements);
  assert(count_ >= 0);
  assert(count_ <= void_element_count);
 
  m_void_element_count = static_cast<int>(count_);
 
  return 0;
}
 
int SeekHead::GetCount() const { return m_entry_count; }
 
const SeekHead::Entry* SeekHead::GetEntry(int idx) const {
  if (idx < 0)
     return 0;

  if (idx >= m_entry_count)
    return 0;

  return m_entries + idx;
 }
 
int SeekHead::GetVoidElementCount() const { return m_void_element_count; }
 
const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const {
  if (idx < 0)
    return 0;

  if (idx >= m_void_element_count)
    return 0;

  return m_void_elements + idx;
 }
 
 #if 0
 void Segment::ParseCues(long long off)
 {
 

      
 }
 #else
long Segment::ParseCues(long long off, long long& pos, long& len) {
  if (m_pCues)
    return 0;   
 
  if (off < 0)
    return -1;
 
  long long total, avail;
 
  const int status = m_pReader->Length(&total, &avail);
 
  if (status < 0)   
    return status;
 
  assert((total < 0) || (avail <= total));
 
  pos = m_start + off;
 
  if ((total < 0) || (pos >= total))
    return 1;   
 
  const long long element_start = pos;
  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
 
  if ((pos + 1) > avail) {
    len = 1;
    return E_BUFFER_NOT_FULL;
  }
 
  long long result = GetUIntLength(m_pReader, pos, len);
 
  if (result < 0)   
    return static_cast<long>(result);
 
  if (result > 0)   
  {
    len = 1;
    return E_BUFFER_NOT_FULL;
  }
 
  if ((segment_stop >= 0) && ((pos + len) > segment_stop))
    return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > avail)
    return E_BUFFER_NOT_FULL;
 
  const long long idpos = pos;
 
  const long long id = ReadUInt(m_pReader, idpos, len);
 
  if (id != 0x0C53BB6B)   
    return E_FILE_FORMAT_INVALID;
 
  pos += len;   
  assert((segment_stop < 0) || (pos <= segment_stop));
 
   
 
  if ((pos + 1) > avail) {
    len = 1;
    return E_BUFFER_NOT_FULL;
  }
 
  result = GetUIntLength(m_pReader, pos, len);
 
  if (result < 0)   
    return static_cast<long>(result);
 
  if (result > 0)   
  {
    len = 1;
    return E_BUFFER_NOT_FULL;
  }
 
  if ((segment_stop >= 0) && ((pos + len) > segment_stop))
    return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > avail)
    return E_BUFFER_NOT_FULL;
 
  const long long size = ReadUInt(m_pReader, pos, len);
 
  if (size < 0)   
    return static_cast<long>(size);
 
  if (size == 0)   
    return 1;   
 
  pos += len;   
  assert((segment_stop < 0) || (pos <= segment_stop));
 
   
 
  const long long element_stop = pos + size;
 
  if ((segment_stop >= 0) && (element_stop > segment_stop))
    return E_FILE_FORMAT_INVALID;
 
  if ((total >= 0) && (element_stop > total))
    return 1;   
 
  len = static_cast<long>(size);
 
  if (element_stop > avail)
    return E_BUFFER_NOT_FULL;
 
  const long long element_size = element_stop - element_start;
 
  m_pCues =
      new (std::nothrow) Cues(this, pos, size, element_start, element_size);
  assert(m_pCues);   
 
  return 0;   
 }
 #endif
 
 #if 0
 void Segment::ParseSeekEntry(
     long long start,
 

         ParseCues(seekOff);
 }
 #else
bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,
                          Entry* pEntry) {
  if (size_ <= 0)
    return false;
 
  long long pos = start;
  const long long stop = start + size_;
 
  long len;
 
   
 
  const long long seekIdId = ReadUInt(pReader, pos, len);
   
 
  if (seekIdId != 0x13AB)   
    return false;
 
  if ((pos + len) > stop)
    return false;
 
  pos += len;   
 
  const long long seekIdSize = ReadUInt(pReader, pos, len);
 
  if (seekIdSize <= 0)
    return false;
 
  if ((pos + len) > stop)
    return false;
 
  pos += len;   
 
  if ((pos + seekIdSize) > stop)
    return false;
 
   
   
   
   
   
   
   
   
   
   
 
  pEntry->id = ReadUInt(pReader, pos, len);   
 
  if (pEntry->id <= 0)
    return false;
 
  if (len != seekIdSize)
    return false;
 
  pos += seekIdSize;   
 
  const long long seekPosId = ReadUInt(pReader, pos, len);
 
  if (seekPosId != 0x13AC)   
    return false;
 
  if ((pos + len) > stop)
    return false;
 
  pos += len;   
 
  const long long seekPosSize = ReadUInt(pReader, pos, len);
 
  if (seekPosSize <= 0)
    return false;
 
  if ((pos + len) > stop)
    return false;
 
  pos += len;   
 
  if ((pos + seekPosSize) > stop)
    return false;
 
  pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);
 
  if (pEntry->pos < 0)
    return false;
 
  pos += seekPosSize;   
 
  if (pos != stop)
    return false;
 
  return true;
 }
 #endif
 
Cues::Cues(Segment* pSegment, long long start_, long long size_,
           long long element_start, long long element_size)
    : m_pSegment(pSegment),
      m_start(start_),
      m_size(size_),
      m_element_start(element_start),
      m_element_size(element_size),
      m_cue_points(NULL),
      m_count(0),
      m_preload_count(0),
      m_pos(start_) {}
 
Cues::~Cues() {
  const long n = m_count + m_preload_count;

  CuePoint** p = m_cue_points;
  CuePoint** const q = p + n;

  while (p != q) {
    CuePoint* const pCP = *p++;
    assert(pCP);

    delete pCP;
  }

  delete[] m_cue_points;
 }
 
long Cues::GetCount() const {
  if (m_cue_points == NULL)
    return -1;
 
  return m_count;   
}
 
bool Cues::DoneParsing() const {
  const long long stop = m_start + m_size;
  return (m_pos >= stop);
}
 
void Cues::Init() const {
  if (m_cue_points)
    return;
 
  assert(m_count == 0);
  assert(m_preload_count == 0);

  IMkvReader* const pReader = m_pSegment->m_pReader;

  const long long stop = m_start + m_size;
  long long pos = m_start;

  long cue_points_size = 0;

  while (pos < stop) {
    const long long idpos = pos;

    long len;

    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);   
    assert((pos + len) <= stop);

    pos += len;   

    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);

    pos += len;   
    assert((pos + size) <= stop);

    if (id == 0x3B)   
      PreloadCuePoint(cue_points_size, idpos);

    pos += size;   
    assert(pos <= stop);
  }
}

void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {
  assert(m_count == 0);

  if (m_preload_count >= cue_points_size) {
    const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;

    CuePoint** const qq = new CuePoint* [n];
    CuePoint** q = qq;   

    CuePoint** p = m_cue_points;   
    CuePoint** const pp = p + m_preload_count;   

    while (p != pp)
      *q++ = *p++;
 
     delete[] m_cue_points;

    m_cue_points = qq;
    cue_points_size = n;
  }

  CuePoint* const pCP = new CuePoint(m_preload_count, pos);
  m_cue_points[m_preload_count++] = pCP;
 }
 
bool Cues::LoadCuePoint() const {
   
   
 
  const long long stop = m_start + m_size;
 
  if (m_pos >= stop)
    return false;   
 
  Init();
 
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  while (m_pos < stop) {
    const long long idpos = m_pos;
 
    long len;
 
    const long long id = ReadUInt(pReader, m_pos, len);
    assert(id >= 0);   
    assert((m_pos + len) <= stop);
 
    m_pos += len;   
 
    const long long size = ReadUInt(pReader, m_pos, len);
    assert(size >= 0);
    assert((m_pos + len) <= stop);
 
    m_pos += len;   
    assert((m_pos + size) <= stop);
 
    if (id != 0x3B) {   
      m_pos += size;   
      assert(m_pos <= stop);
 
      continue;
     }
 
    assert(m_preload_count > 0);

    CuePoint* const pCP = m_cue_points[m_count];
    assert(pCP);
    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
      return false;

    pCP->Load(pReader);
    ++m_count;
    --m_preload_count;

    m_pos += size;   
    assert(m_pos <= stop);

    return true;   
  }

   
  return false;   
 }
 
bool Cues::Find(long long time_ns, const Track* pTrack, const CuePoint*& pCP,
                const CuePoint::TrackPosition*& pTP) const {
  assert(time_ns >= 0);
  assert(pTrack);
 
 #if 0
     LoadCuePoint();   
 

     assert(pCP);
     assert(pCP->GetTime(m_pSegment) <= time_ns);
 #else
  if (m_cue_points == NULL)
    return false;
 
  if (m_count == 0)
    return false;
 
  CuePoint** const ii = m_cue_points;
  CuePoint** i = ii;
 
  CuePoint** const jj = ii + m_count;
  CuePoint** j = jj;
 
  pCP = *i;
  assert(pCP);
 
  if (time_ns <= pCP->GetTime(m_pSegment)) {
     pTP = pCP->Find(pTrack);
     return (pTP != NULL);
  }
 
  while (i < j) {
     
     
     
     

    CuePoint** const k = i + (j - i) / 2;
    assert(k < jj);

    CuePoint* const pCP = *k;
    assert(pCP);

    const long long t = pCP->GetTime(m_pSegment);

    if (t <= time_ns)
      i = k + 1;
    else
      j = k;

    assert(i <= j);
  }

  assert(i == j);
  assert(i <= jj);
  assert(i > ii);

  pCP = *--i;
  assert(pCP);
  assert(pCP->GetTime(m_pSegment) <= time_ns);
#endif

   
   
   
   
   
   
   

  pTP = pCP->Find(pTrack);
  return (pTP != NULL);
}
 
 #if 0
 bool Cues::FindNext(
 

 }
 #endif
 
const CuePoint* Cues::GetFirst() const {
  if (m_cue_points == NULL)
    return NULL;
 
  if (m_count == 0)
    return NULL;
 
 #if 0
     LoadCuePoint();   
 

         return NULL;
 #endif
 
  CuePoint* const* const pp = m_cue_points;
  assert(pp);
 
  CuePoint* const pCP = pp[0];
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
 
  return pCP;
 }
 
const CuePoint* Cues::GetLast() const {
  if (m_cue_points == NULL)
    return NULL;
 
  if (m_count <= 0)
    return NULL;
 
 #if 0
     LoadCuePoint();   
 

     pCP->Load(m_pSegment->m_pReader);
     assert(pCP->GetTimeCode() >= 0);
 #else
  const long index = m_count - 1;
 
  CuePoint* const* const pp = m_cue_points;
  assert(pp);
 
  CuePoint* const pCP = pp[index];
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
 #endif
 
  return pCP;
 }
 
const CuePoint* Cues::GetNext(const CuePoint* pCurr) const {
  if (pCurr == NULL)
    return NULL;
 
  assert(pCurr->GetTimeCode() >= 0);
  assert(m_cue_points);
  assert(m_count >= 1);
 
 #if 0
     const size_t count = m_count + m_preload_count;
 

 
     pNext->Load(m_pSegment->m_pReader);
 #else
  long index = pCurr->m_index;
  assert(index < m_count);
 
  CuePoint* const* const pp = m_cue_points;
  assert(pp);
  assert(pp[index] == pCurr);
 
  ++index;
 
  if (index >= m_count)
    return NULL;
 
  CuePoint* const pNext = pp[index];
  assert(pNext);
  assert(pNext->GetTimeCode() >= 0);
 #endif
 
  return pNext;
 }
 
const BlockEntry* Cues::GetBlock(const CuePoint* pCP,
                                 const CuePoint::TrackPosition* pTP) const {
  if (pCP == NULL)
    return NULL;
 
  if (pTP == NULL)
    return NULL;
 
  return m_pSegment->GetBlock(*pCP, *pTP);
 }
 
const BlockEntry* Segment::GetBlock(const CuePoint& cp,
                                    const CuePoint::TrackPosition& tp) {
  Cluster** const ii = m_clusters;
  Cluster** i = ii;
 
  const long count = m_clusterCount + m_clusterPreloadCount;
 
  Cluster** const jj = ii + count;
  Cluster** j = jj;
 
  while (i < j) {
     
     
     
     
 
    Cluster** const k = i + (j - i) / 2;
    assert(k < jj);
 
    Cluster* const pCluster = *k;
     assert(pCluster);
 
     
     
     
 
    const long long pos = pCluster->GetPosition();
    assert(pos >= 0);
 
    if (pos < tp.m_pos)
      i = k + 1;
    else if (pos > tp.m_pos)
      j = k;
    else
      return pCluster->GetEntry(cp, tp);
  }

  assert(i == j);
   

  Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos);   
  assert(pCluster);

  const ptrdiff_t idx = i - m_clusters;

  PreloadCluster(pCluster, idx);
  assert(m_clusters);
  assert(m_clusterPreloadCount > 0);
  assert(m_clusters[idx] == pCluster);

  return pCluster->GetEntry(cp, tp);
 }
 
const Cluster* Segment::FindOrPreloadCluster(long long requested_pos) {
  if (requested_pos < 0)
    return 0;
 
  Cluster** const ii = m_clusters;
  Cluster** i = ii;
 
  const long count = m_clusterCount + m_clusterPreloadCount;
 
  Cluster** const jj = ii + count;
  Cluster** j = jj;
 
  while (i < j) {
     
     
     
     
 
    Cluster** const k = i + (j - i) / 2;
    assert(k < jj);
 
    Cluster* const pCluster = *k;
     assert(pCluster);
 
     
     
     
 
    const long long pos = pCluster->GetPosition();
    assert(pos >= 0);
 
    if (pos < requested_pos)
      i = k + 1;
    else if (pos > requested_pos)
      j = k;
    else
      return pCluster;
  }

  assert(i == j);
   

  Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);
   
  assert(pCluster);

  const ptrdiff_t idx = i - m_clusters;

  PreloadCluster(pCluster, idx);
  assert(m_clusters);
  assert(m_clusterPreloadCount > 0);
  assert(m_clusters[idx] == pCluster);

  return pCluster;
 }
 
CuePoint::CuePoint(long idx, long long pos)
    : m_element_start(0),
      m_element_size(0),
      m_index(idx),
      m_timecode(-1 * pos),
      m_track_positions(NULL),
      m_track_positions_count(0) {
  assert(pos > 0);
 }
 
CuePoint::~CuePoint() { delete[] m_track_positions; }
 
void CuePoint::Load(IMkvReader* pReader) {
   
   
 
  if (m_timecode >= 0)   
    return;
 
  assert(m_track_positions == NULL);
  assert(m_track_positions_count == 0);
 
  long long pos_ = -m_timecode;
  const long long element_start = pos_;
 
  long long stop;
 
  {
    long len;
 
    const long long id = ReadUInt(pReader, pos_, len);
    assert(id == 0x3B);   
    if (id != 0x3B)
      return;
 
    pos_ += len;   
 
    const long long size = ReadUInt(pReader, pos_, len);
    assert(size >= 0);
 
    pos_ += len;   
     
 
    stop = pos_ + size;
  }
 
  const long long element_size = stop - element_start;
 
  long long pos = pos_;

   

  while (pos < stop) {
    long len;

    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);   
    assert((pos + len) <= stop);

    pos += len;   

    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);

    pos += len;   
    assert((pos + size) <= stop);

    if (id == 0x33)   
      m_timecode = UnserializeUInt(pReader, pos, size);

    else if (id == 0x37)   
      ++m_track_positions_count;

    pos += size;   
    assert(pos <= stop);
  }

  assert(m_timecode >= 0);
  assert(m_track_positions_count > 0);

   
   
   

  m_track_positions = new TrackPosition[m_track_positions_count];

   

  TrackPosition* p = m_track_positions;
  pos = pos_;

  while (pos < stop) {
    long len;

    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);   
    assert((pos + len) <= stop);

    pos += len;   

    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);

    pos += len;   
    assert((pos + size) <= stop);

    if (id == 0x37) {   
      TrackPosition& tp = *p++;
      tp.Parse(pReader, pos, size);
     }
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(size_t(p - m_track_positions) == m_track_positions_count);
 
  m_element_start = element_start;
  m_element_size = element_size;
 }
 
void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,
                                    long long size_) {
  const long long stop = start_ + size_;
  long long pos = start_;
 
  m_track = -1;
  m_pos = -1;
  m_block = 1;   
 
  while (pos < stop) {
    long len;
 
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);   
    assert((pos + len) <= stop);
 
    pos += len;   
 
    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);
 
    pos += len;   
    assert((pos + size) <= stop);
 
    if (id == 0x77)   
      m_track = UnserializeUInt(pReader, pos, size);
 
    else if (id == 0x71)   
      m_pos = UnserializeUInt(pReader, pos, size);
 
    else if (id == 0x1378)   
      m_block = UnserializeUInt(pReader, pos, size);
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(m_pos >= 0);
  assert(m_track > 0);
   
 }
 
const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const {
  assert(pTrack);
 
  const long long n = pTrack->GetNumber();
 
  const TrackPosition* i = m_track_positions;
  const TrackPosition* const j = i + m_track_positions_count;
 
  while (i != j) {
    const TrackPosition& p = *i++;
 
    if (p.m_track == n)
      return &p;
  }
 
  return NULL;   
 }
 
long long CuePoint::GetTimeCode() const { return m_timecode; }
 
long long CuePoint::GetTime(const Segment* pSegment) const {
  assert(pSegment);
  assert(m_timecode >= 0);

  const SegmentInfo* const pInfo = pSegment->GetInfo();
  assert(pInfo);

  const long long scale = pInfo->GetTimeCodeScale();
  assert(scale >= 1);

  const long long time = scale * m_timecode;

  return time;
 }
 
 #if 0
 long long Segment::Unparsed() const
 {
 

     return result;
 }
 #else
bool Segment::DoneParsing() const {
  if (m_size < 0) {
    long long total, avail;
 
    const int status = m_pReader->Length(&total, &avail);
 
    if (status < 0)   
      return true;   
 
    if (total < 0)
      return false;   
 
    return (m_pos >= total);
  }
 
  const long long stop = m_start + m_size;
 
  return (m_pos >= stop);
 }
 #endif
 
const Cluster* Segment::GetFirst() const {
  if ((m_clusters == NULL) || (m_clusterCount <= 0))
    return &m_eos;
 
  Cluster* const pCluster = m_clusters[0];
  assert(pCluster);
 
  return pCluster;
 }
 
const Cluster* Segment::GetLast() const {
  if ((m_clusters == NULL) || (m_clusterCount <= 0))
    return &m_eos;
 
  const long idx = m_clusterCount - 1;
 
  Cluster* const pCluster = m_clusters[idx];
  assert(pCluster);
 
  return pCluster;
 }
 
unsigned long Segment::GetCount() const { return m_clusterCount; }
 
const Cluster* Segment::GetNext(const Cluster* pCurr) {
  assert(pCurr);
  assert(pCurr != &m_eos);
  assert(m_clusters);
 
  long idx = pCurr->m_index;
 
  if (idx >= 0) {
    assert(m_clusterCount > 0);
    assert(idx < m_clusterCount);
    assert(pCurr == m_clusters[idx]);
 
    ++idx;
 
    if (idx >= m_clusterCount)
      return &m_eos;   
 
    Cluster* const pNext = m_clusters[idx];
     assert(pNext);
    assert(pNext->m_index >= 0);
    assert(pNext->m_index == idx);
 
     return pNext;
  }
 
  assert(m_clusterPreloadCount > 0);
 
  long long pos = pCurr->m_element_start;
 
  assert(m_size >= 0);   
  const long long stop = m_start + m_size;   
 
  {
    long len;
 
    long long result = GetUIntLength(m_pReader, pos, len);
    assert(result == 0);
    assert((pos + len) <= stop);   
    if (result != 0)
      return NULL;
 
    const long long id = ReadUInt(m_pReader, pos, len);
    assert(id == 0x0F43B675);   
    if (id != 0x0F43B675)
      return NULL;
 
    pos += len;   
 
     
    result = GetUIntLength(m_pReader, pos, len);
    assert(result == 0);   
    assert((pos + len) <= stop);   
 
    const long long size = ReadUInt(m_pReader, pos, len);
    assert(size > 0);   
     
 
    pos += len;   
    assert((pos + size) <= stop);   
 
     

    pos += size;   
  }

  long long off_next = 0;

  while (pos < stop) {
    long len;

    long long result = GetUIntLength(m_pReader, pos, len);
    assert(result == 0);
    assert((pos + len) <= stop);   
    if (result != 0)
      return NULL;

    const long long idpos = pos;   

    const long long id = ReadUInt(m_pReader, idpos, len);
    assert(id > 0);   

    pos += len;   

     
    result = GetUIntLength(m_pReader, pos, len);
    assert(result == 0);   
    assert((pos + len) <= stop);   

    const long long size = ReadUInt(m_pReader, pos, len);
    assert(size >= 0);   

    pos += len;   
    assert((pos + size) <= stop);   

     

    if (size == 0)   
      continue;

    if (id == 0x0F43B675) {   
      const long long off_next_ = idpos - m_start;

      long long pos_;
      long len_;

      const long status = Cluster::HasBlockEntries(this, off_next_, pos_, len_);

      assert(status >= 0);

      if (status > 0) {
        off_next = off_next_;
        break;
      }
     }
 
    pos += size;   
  }
 
  if (off_next <= 0)
    return 0;
 
  Cluster** const ii = m_clusters + m_clusterCount;
  Cluster** i = ii;
 
  Cluster** const jj = ii + m_clusterPreloadCount;
  Cluster** j = jj;
 
  while (i < j) {
     
     
     
     
 
    Cluster** const k = i + (j - i) / 2;
    assert(k < jj);
 
    Cluster* const pNext = *k;
    assert(pNext);
    assert(pNext->m_index < 0);
 
     
     
     
 
    pos = pNext->GetPosition();

    if (pos < off_next)
      i = k + 1;
    else if (pos > off_next)
      j = k;
     else
      return pNext;
  }
 
  assert(i == j);
 
  Cluster* const pNext = Cluster::Create(this, -1, off_next);
  assert(pNext);
 
  const ptrdiff_t idx_next = i - m_clusters;   
 
  PreloadCluster(pNext, idx_next);
  assert(m_clusters);
  assert(idx_next < m_clusterSize);
  assert(m_clusters[idx_next] == pNext);
 
  return pNext;
 }
 
long Segment::ParseNext(const Cluster* pCurr, const Cluster*& pResult,
                        long long& pos, long& len) {
  assert(pCurr);
  assert(!pCurr->EOS());
  assert(m_clusters);
 
  pResult = 0;
 
  if (pCurr->m_index >= 0) {   
    assert(m_clusters[pCurr->m_index] == pCurr);
 
    const long next_idx = pCurr->m_index + 1;
 
    if (next_idx < m_clusterCount) {
      pResult = m_clusters[next_idx];
      return 0;   
    }
 
     
 
    const long result = LoadCluster(pos, len);
 
    if (result < 0)   
      return result;
 
    if (result > 0)   
     {
       
      return 1;
    }
 
    pResult = GetLast();
    return 0;   
  }
 
  assert(m_pos > 0);
 
  long long total, avail;
 
  long status = m_pReader->Length(&total, &avail);
 
  if (status < 0)   
    return status;
 
  assert((total < 0) || (avail <= total));
 
  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
 
   
 
  pos = pCurr->m_element_start;
 
  if (pCurr->m_element_size >= 0)
    pos += pCurr->m_element_size;
  else {
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }
 
    long long result = GetUIntLength(m_pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long id = ReadUInt(m_pReader, pos, len);
 
    if (id != 0x0F43B675)   
      return -1;
 
    pos += len;   
 
     
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }
 
    result = GetUIntLength(m_pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long size = ReadUInt(m_pReader, pos, len);
 
    if (size < 0)   
      return static_cast<long>(size);
 
    pos += len;   
 
    const long long unknown_size = (1LL << (7 * len)) - 1;
 
    if (size == unknown_size)   
      return E_FILE_FORMAT_INVALID;   
 
     
 
    if ((segment_stop >= 0) && ((pos + size) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
     
 
    pos += size;   
    assert((segment_stop < 0) || (pos <= segment_stop));
 
     
     
     
     
     
     
  }
 
   
 
  for (;;) {
    const long status = DoParseNext(pResult, pos, len);

    if (status <= 1)
      return status;
  }
}

long Segment::DoParseNext(const Cluster*& pResult, long long& pos, long& len) {
  long long total, avail;

  long status = m_pReader->Length(&total, &avail);

  if (status < 0)   
    return status;

  assert((total < 0) || (avail <= total));

  const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

   
   
   

  long long off_next = 0;
  long long cluster_size = -1;

  for (;;) {
    if ((total >= 0) && (pos >= total))
      return 1;   

    if ((segment_stop >= 0) && (pos >= segment_stop))
      return 1;   

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    long long result = GetUIntLength(m_pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long idpos = pos;   
    const long long idoff = pos - m_start;   

    const long long id = ReadUInt(m_pReader, idpos, len);   

    if (id < 0)   
      return static_cast<long>(id);

    if (id == 0)   
      return -1;   

    pos += len;   

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    result = GetUIntLength(m_pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(m_pReader, pos, len);

    if (size < 0)   
      return static_cast<long>(size);

    pos += len;   

     

    if (size == 0)   
      continue;

    const long long unknown_size = (1LL << (7 * len)) - 1;

    if ((segment_stop >= 0) && (size != unknown_size) &&
        ((pos + size) > segment_stop)) {
      return E_FILE_FORMAT_INVALID;
    }

    if (id == 0x0C53BB6B) {   
      if (size == unknown_size)
        return E_FILE_FORMAT_INVALID;

      const long long element_stop = pos + size;

      if ((segment_stop >= 0) && (element_stop > segment_stop))
        return E_FILE_FORMAT_INVALID;

      const long long element_start = idpos;
      const long long element_size = element_stop - element_start;

      if (m_pCues == NULL) {
        m_pCues = new Cues(this, pos, size, element_start, element_size);
        assert(m_pCues);   
      }

      pos += size;   
      assert((segment_stop < 0) || (pos <= segment_stop));

      continue;
    }

    if (id != 0x0F43B675) {   
      if (size == unknown_size)
        return E_FILE_FORMAT_INVALID;

      pos += size;   
      assert((segment_stop < 0) || (pos <= segment_stop));

      continue;
    }

#if 0   
         len = static_cast<long>(size);
 
         if (element_stop > avail)
             return E_BUFFER_NOT_FULL;
 #endif
 
     
 
    off_next = idoff;
 
    if (size != unknown_size)
      cluster_size = size;
 
    break;
  }

  assert(off_next > 0);   

   
   
   
   
   

  Cluster** const ii = m_clusters + m_clusterCount;
  Cluster** i = ii;

  Cluster** const jj = ii + m_clusterPreloadCount;
  Cluster** j = jj;

  while (i < j) {
     
     
     
     

    Cluster** const k = i + (j - i) / 2;
    assert(k < jj);

    const Cluster* const pNext = *k;
    assert(pNext);
    assert(pNext->m_index < 0);

    pos = pNext->GetPosition();
    assert(pos >= 0);

    if (pos < off_next)
      i = k + 1;
    else if (pos > off_next)
      j = k;
    else {
      pResult = pNext;
      return 0;   
    }
  }

  assert(i == j);

  long long pos_;
  long len_;

  status = Cluster::HasBlockEntries(this, off_next, pos_, len_);

  if (status < 0) {   
    pos = pos_;
    len = len_;

    return status;
  }

  if (status > 0) {   
    Cluster* const pNext = Cluster::Create(this,
                                           -1,   
                                           off_next);
     
    assert(pNext);

    const ptrdiff_t idx_next = i - m_clusters;   

    PreloadCluster(pNext, idx_next);
    assert(m_clusters);
    assert(idx_next < m_clusterSize);
    assert(m_clusters[idx_next] == pNext);

    pResult = pNext;
    return 0;   
  }

   

  if (cluster_size < 0) {   
    const long long payload_pos = pos;   

    for (;;) {   
      if ((total >= 0) && (pos >= total))
         break;
 
      if ((segment_stop >= 0) && (pos >= segment_stop))
        break;   
 
       
 
      if ((pos + 1) > avail) {
        len = 1;
        return E_BUFFER_NOT_FULL;
      }
 
      long long result = GetUIntLength(m_pReader, pos, len);
 
      if (result < 0)   
        return static_cast<long>(result);
 
      if (result > 0)   
        return E_BUFFER_NOT_FULL;
 
      if ((segment_stop >= 0) && ((pos + len) > segment_stop))
        return E_FILE_FORMAT_INVALID;
 
      if ((pos + len) > avail)
        return E_BUFFER_NOT_FULL;
 
      const long long idpos = pos;
      const long long id = ReadUInt(m_pReader, idpos, len);
 
      if (id < 0)   
        return static_cast<long>(id);
 
       
       
       
 
      if (id == 0x0F43B675)   
        break;
 
      if (id == 0x0C53BB6B)   
        break;
 
      pos += len;   
 
       
 
      if ((pos + 1) > avail) {
        len = 1;
        return E_BUFFER_NOT_FULL;
      }
 
      result = GetUIntLength(m_pReader, pos, len);
 
      if (result < 0)   
        return static_cast<long>(result);
 
      if (result > 0)   
        return E_BUFFER_NOT_FULL;
 
      if ((segment_stop >= 0) && ((pos + len) > segment_stop))
        return E_FILE_FORMAT_INVALID;
 
      if ((pos + len) > avail)
        return E_BUFFER_NOT_FULL;
 
      const long long size = ReadUInt(m_pReader, pos, len);
 
      if (size < 0)   
        return static_cast<long>(size);
 
      pos += len;   
 
       
 
      if (size == 0)   
        continue;
 
      const long long unknown_size = (1LL << (7 * len)) - 1;
 
      if (size == unknown_size)
        return E_FILE_FORMAT_INVALID;   
 
      if ((segment_stop >= 0) && ((pos + size) > segment_stop))   
        return E_FILE_FORMAT_INVALID;
 
      pos += size;   
      assert((segment_stop < 0) || (pos <= segment_stop));
    }   
 
    cluster_size = pos - payload_pos;
    assert(cluster_size >= 0);   
 
    pos = payload_pos;   
  }
 
  pos += cluster_size;   
  assert((segment_stop < 0) || (pos <= segment_stop));
 
  return 2;   
 }
 
const Cluster* Segment::FindCluster(long long time_ns) const {
  if ((m_clusters == NULL) || (m_clusterCount <= 0))
    return &m_eos;
 
  {
    Cluster* const pCluster = m_clusters[0];
    assert(pCluster);
    assert(pCluster->m_index == 0);
 
    if (time_ns <= pCluster->GetTime())
      return pCluster;
  }
 
   
 
  long i = 0;
  long j = m_clusterCount;
 
  while (i < j) {
     
     
     
     
 
    const long k = i + (j - i) / 2;
    assert(k < m_clusterCount);
 
     Cluster* const pCluster = m_clusters[k];
     assert(pCluster);
     assert(pCluster->m_index == k);
 
    const long long t = pCluster->GetTime();

    if (t <= time_ns)
      i = k + 1;
    else
      j = k;

    assert(i <= j);
  }

  assert(i == j);
  assert(i > 0);
  assert(i <= m_clusterCount);

  const long k = i - 1;

  Cluster* const pCluster = m_clusters[k];
  assert(pCluster);
  assert(pCluster->m_index == k);
  assert(pCluster->GetTime() <= time_ns);

  return pCluster;
 }
 
 #if 0
 const BlockEntry* Segment::Seek(
     long long time_ns,
 

 
     Cluster** const j = i + m_clusterCount;
 
    if (pTrack->GetType() == 2) {   
          
          
          
 

 }
 #endif
 
 #if 0
 bool Segment::SearchCues(
     long long time_ns,
 

 }
 #endif
 
const Tracks* Segment::GetTracks() const { return m_pTracks; }
 
const SegmentInfo* Segment::GetInfo() const { return m_pInfo; }

const Cues* Segment::GetCues() const { return m_pCues; }

const Chapters* Segment::GetChapters() const { return m_pChapters; }

const SeekHead* Segment::GetSeekHead() const { return m_pSeekHead; }

long long Segment::GetDuration() const {
  assert(m_pInfo);
  return m_pInfo->GetDuration();
 }
 
Chapters::Chapters(Segment* pSegment, long long payload_start,
                   long long payload_size, long long element_start,
                   long long element_size)
    : m_pSegment(pSegment),
      m_start(payload_start),
      m_size(payload_size),
      m_element_start(element_start),
      m_element_size(element_size),
      m_editions(NULL),
      m_editions_size(0),
      m_editions_count(0) {}
 
Chapters::~Chapters() {
  while (m_editions_count > 0) {
    Edition& e = m_editions[--m_editions_count];
    e.Clear();
  }
 }
 
long Chapters::Parse() {
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long pos = m_start;   
  const long long stop = pos + m_size;   
 
  while (pos < stop) {
    long long id, size;
 
    long status = ParseElementHeader(pReader, pos, stop, id, size);
 
    if (status < 0)   
      return status;
 
    if (size == 0)   
      continue;
 
    if (id == 0x05B9) {   
      status = ParseEdition(pos, size);
 
      if (status < 0)   
        return status;
     }
 
    pos += size;
    assert(pos <= stop);
  }

  assert(pos == stop);
  return 0;
 }
 
int Chapters::GetEditionCount() const { return m_editions_count; }
 
const Chapters::Edition* Chapters::GetEdition(int idx) const {
  if (idx < 0)
    return NULL;

  if (idx >= m_editions_count)
    return NULL;

  return m_editions + idx;
 }
 
bool Chapters::ExpandEditionsArray() {
  if (m_editions_size > m_editions_count)
    return true;   
 
  const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;
 
  Edition* const editions = new (std::nothrow) Edition[size];
 
  if (editions == NULL)
    return false;

  for (int idx = 0; idx < m_editions_count; ++idx) {
    m_editions[idx].ShallowCopy(editions[idx]);
  }

  delete[] m_editions;
  m_editions = editions;

  m_editions_size = size;
  return true;
 }
 
long Chapters::ParseEdition(long long pos, long long size) {
  if (!ExpandEditionsArray())
    return -1;
 
  Edition& e = m_editions[m_editions_count++];
  e.Init();
 
  return e.Parse(m_pSegment->m_pReader, pos, size);
}
 
Chapters::Edition::Edition() {}
 
Chapters::Edition::~Edition() {}
 
int Chapters::Edition::GetAtomCount() const { return m_atoms_count; }

const Chapters::Atom* Chapters::Edition::GetAtom(int index) const {
  if (index < 0)
    return NULL;

  if (index >= m_atoms_count)
    return NULL;

  return m_atoms + index;
}

void Chapters::Edition::Init() {
  m_atoms = NULL;
  m_atoms_size = 0;
  m_atoms_count = 0;
}

void Chapters::Edition::ShallowCopy(Edition& rhs) const {
  rhs.m_atoms = m_atoms;
  rhs.m_atoms_size = m_atoms_size;
  rhs.m_atoms_count = m_atoms_count;
}

void Chapters::Edition::Clear() {
  while (m_atoms_count > 0) {
    Atom& a = m_atoms[--m_atoms_count];
    a.Clear();
  }

  delete[] m_atoms;
  m_atoms = NULL;

  m_atoms_size = 0;
}

long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,
                              long long size) {
  const long long stop = pos + size;

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (size == 0)   
      continue;

    if (id == 0x36) {   
      status = ParseAtom(pReader, pos, size);

      if (status < 0)   
        return status;
     }
 
    pos += size;
    assert(pos <= stop);
  }
 
  assert(pos == stop);
  return 0;
 }
 
long Chapters::Edition::ParseAtom(IMkvReader* pReader, long long pos,
                                  long long size) {
  if (!ExpandAtomsArray())
    return -1;
 
  Atom& a = m_atoms[m_atoms_count++];
  a.Init();
 
  return a.Parse(pReader, pos, size);
 }
 
bool Chapters::Edition::ExpandAtomsArray() {
  if (m_atoms_size > m_atoms_count)
    return true;   
 
  const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;

  Atom* const atoms = new (std::nothrow) Atom[size];

  if (atoms == NULL)
    return false;

  for (int idx = 0; idx < m_atoms_count; ++idx) {
    m_atoms[idx].ShallowCopy(atoms[idx]);
  }

  delete[] m_atoms;
  m_atoms = atoms;

  m_atoms_size = size;
  return true;
 }
 
Chapters::Atom::Atom() {}
 
Chapters::Atom::~Atom() {}

unsigned long long Chapters::Atom::GetUID() const { return m_uid; }

const char* Chapters::Atom::GetStringUID() const { return m_string_uid; }

long long Chapters::Atom::GetStartTimecode() const { return m_start_timecode; }

long long Chapters::Atom::GetStopTimecode() const { return m_stop_timecode; }

long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const {
  return GetTime(pChapters, m_start_timecode);
 }
 
long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const {
  return GetTime(pChapters, m_stop_timecode);
 }
 
int Chapters::Atom::GetDisplayCount() const { return m_displays_count; }
 
const Chapters::Display* Chapters::Atom::GetDisplay(int index) const {
  if (index < 0)
    return NULL;
 
  if (index >= m_displays_count)
    return NULL;
 
  return m_displays + index;
 }
 
void Chapters::Atom::Init() {
  m_string_uid = NULL;
  m_uid = 0;
  m_start_timecode = -1;
  m_stop_timecode = -1;
 
  m_displays = NULL;
  m_displays_size = 0;
  m_displays_count = 0;
 }
 
void Chapters::Atom::ShallowCopy(Atom& rhs) const {
  rhs.m_string_uid = m_string_uid;
  rhs.m_uid = m_uid;
  rhs.m_start_timecode = m_start_timecode;
  rhs.m_stop_timecode = m_stop_timecode;
 
  rhs.m_displays = m_displays;
  rhs.m_displays_size = m_displays_size;
  rhs.m_displays_count = m_displays_count;
 }
 
void Chapters::Atom::Clear() {
  delete[] m_string_uid;
  m_string_uid = NULL;
 
  while (m_displays_count > 0) {
    Display& d = m_displays[--m_displays_count];
    d.Clear();
  }

  delete[] m_displays;
  m_displays = NULL;

  m_displays_size = 0;
}

long Chapters::Atom::Parse(IMkvReader* pReader, long long pos, long long size) {
  const long long stop = pos + size;

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (size == 0)   
      continue;

    if (id == 0x00) {   
      status = ParseDisplay(pReader, pos, size);

      if (status < 0)   
        return status;
    } else if (id == 0x1654) {   
      status = UnserializeString(pReader, pos, size, m_string_uid);

      if (status < 0)   
        return status;
    } else if (id == 0x33C4) {   
      long long val;
      status = UnserializeInt(pReader, pos, size, val);

      if (val < 0)   
        return status;

      m_uid = static_cast<unsigned long long>(val);
    } else if (id == 0x11) {   
      const long long val = UnserializeUInt(pReader, pos, size);

      if (val < 0)   
        return static_cast<long>(val);

      m_start_timecode = val;
    } else if (id == 0x12) {   
      const long long val = UnserializeUInt(pReader, pos, size);

      if (val < 0)   
        return static_cast<long>(val);

      m_stop_timecode = val;
     }
 
    pos += size;
    assert(pos <= stop);
  }
 
  assert(pos == stop);
  return 0;
 }
 
long long Chapters::Atom::GetTime(const Chapters* pChapters,
                                  long long timecode) {
  if (pChapters == NULL)
    return -1;
 
  Segment* const pSegment = pChapters->m_pSegment;
 
  if (pSegment == NULL)   
    return -1;
 
  const SegmentInfo* const pInfo = pSegment->GetInfo();
 
  if (pInfo == NULL)
    return -1;
 
  const long long timecode_scale = pInfo->GetTimeCodeScale();
 
  if (timecode_scale < 1)   
    return -1;
 
  if (timecode < 0)
    return -1;
 
  const long long result = timecode_scale * timecode;

  return result;
}

long Chapters::Atom::ParseDisplay(IMkvReader* pReader, long long pos,
                                  long long size) {
  if (!ExpandDisplaysArray())
    return -1;

  Display& d = m_displays[m_displays_count++];
  d.Init();

  return d.Parse(pReader, pos, size);
}

bool Chapters::Atom::ExpandDisplaysArray() {
  if (m_displays_size > m_displays_count)
    return true;   

  const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;

  Display* const displays = new (std::nothrow) Display[size];

  if (displays == NULL)
    return false;

  for (int idx = 0; idx < m_displays_count; ++idx) {
    m_displays[idx].ShallowCopy(displays[idx]);
  }

  delete[] m_displays;
  m_displays = displays;

  m_displays_size = size;
  return true;
}

Chapters::Display::Display() {}

Chapters::Display::~Display() {}

const char* Chapters::Display::GetString() const { return m_string; }

const char* Chapters::Display::GetLanguage() const { return m_language; }

const char* Chapters::Display::GetCountry() const { return m_country; }

void Chapters::Display::Init() {
  m_string = NULL;
  m_language = NULL;
  m_country = NULL;
}

void Chapters::Display::ShallowCopy(Display& rhs) const {
  rhs.m_string = m_string;
  rhs.m_language = m_language;
  rhs.m_country = m_country;
}

void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;

  delete[] m_language;
  m_language = NULL;

  delete[] m_country;
  m_country = NULL;
}

long Chapters::Display::Parse(IMkvReader* pReader, long long pos,
                              long long size) {
  const long long stop = pos + size;

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (size == 0)   
      continue;

    if (id == 0x05) {   
      status = UnserializeString(pReader, pos, size, m_string);

      if (status)
        return status;
    } else if (id == 0x037C) {   
      status = UnserializeString(pReader, pos, size, m_language);

      if (status)
        return status;
    } else if (id == 0x037E) {   
      status = UnserializeString(pReader, pos, size, m_country);

      if (status)
        return status;
     }
 
    pos += size;
    assert(pos <= stop);
  }

  assert(pos == stop);
  return 0;
 }
 
SegmentInfo::SegmentInfo(Segment* pSegment, long long start, long long size_,
                         long long element_start, long long element_size)
    : m_pSegment(pSegment),
      m_start(start),
      m_size(size_),
      m_element_start(element_start),
      m_element_size(element_size),
      m_pMuxingAppAsUTF8(NULL),
      m_pWritingAppAsUTF8(NULL),
      m_pTitleAsUTF8(NULL) {}
 
SegmentInfo::~SegmentInfo() {
  delete[] m_pMuxingAppAsUTF8;
  m_pMuxingAppAsUTF8 = NULL;
 
  delete[] m_pWritingAppAsUTF8;
  m_pWritingAppAsUTF8 = NULL;
 
  delete[] m_pTitleAsUTF8;
  m_pTitleAsUTF8 = NULL;
 }
 
long SegmentInfo::Parse() {
  assert(m_pMuxingAppAsUTF8 == NULL);
  assert(m_pWritingAppAsUTF8 == NULL);
  assert(m_pTitleAsUTF8 == NULL);
 
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long pos = m_start;
  const long long stop = m_start + m_size;
 
  m_timecodeScale = 1000000;
  m_duration = -1;
 
  while (pos < stop) {
    long long id, size;
 
    const long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (id == 0x0AD7B1) {   
      m_timecodeScale = UnserializeUInt(pReader, pos, size);

      if (m_timecodeScale <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x0489) {   
      const long status = UnserializeFloat(pReader, pos, size, m_duration);

      if (status < 0)
        return status;

      if (m_duration < 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x0D80) {   
      const long status =
          UnserializeString(pReader, pos, size, m_pMuxingAppAsUTF8);

      if (status)
        return status;
    } else if (id == 0x1741) {   
      const long status =
          UnserializeString(pReader, pos, size, m_pWritingAppAsUTF8);

      if (status)
        return status;
    } else if (id == 0x3BA9) {   
      const long status = UnserializeString(pReader, pos, size, m_pTitleAsUTF8);

      if (status)
        return status;
     }
 
    pos += size;
    assert(pos <= stop);
  }
 
  assert(pos == stop);

  return 0;
 }
 
long long SegmentInfo::GetTimeCodeScale() const { return m_timecodeScale; }
 
long long SegmentInfo::GetDuration() const {
  if (m_duration < 0)
    return -1;

  assert(m_timecodeScale >= 1);

  const double dd = double(m_duration) * double(m_timecodeScale);
  const long long d = static_cast<long long>(dd);

  return d;
 }
 
const char* SegmentInfo::GetMuxingAppAsUTF8() const {
  return m_pMuxingAppAsUTF8;
 }
 
const char* SegmentInfo::GetWritingAppAsUTF8() const {
  return m_pWritingAppAsUTF8;
 }
 
const char* SegmentInfo::GetTitleAsUTF8() const { return m_pTitleAsUTF8; }
 
  
  
 ContentEncoding::ContentCompression::ContentCompression()
    : algo(0), settings(NULL), settings_len(0) {}
 
 ContentEncoding::ContentCompression::~ContentCompression() {
  delete[] settings;
 }
 
 ContentEncoding::ContentEncryption::ContentEncryption()
 

       sig_key_id(NULL),
       sig_key_id_len(0),
       sig_algo(0),
      sig_hash_algo(0) {}
 
 ContentEncoding::ContentEncryption::~ContentEncryption() {
  delete[] key_id;
  delete[] signature;
  delete[] sig_key_id;
 }
 
 ContentEncoding::ContentEncoding()
 

       encryption_entries_end_(NULL),
       encoding_order_(0),
       encoding_scope_(1),
      encoding_type_(0) {}
 
 ContentEncoding::~ContentEncoding() {
   ContentCompression** comp_i = compression_entries_;
 

     delete comp;
   }
 
  delete[] compression_entries_;
 
   ContentEncryption** enc_i = encryption_entries_;
   ContentEncryption** const enc_j = encryption_entries_end_;
 

     delete enc;
   }
 
  delete[] encryption_entries_;
 }
 
 const ContentEncoding::ContentCompression*
 ContentEncoding::GetCompressionByIndex(unsigned long idx) const {
   const ptrdiff_t count = compression_entries_end_ - compression_entries_;
 

   return static_cast<unsigned long>(count);
 }
 
const ContentEncoding::ContentEncryption* ContentEncoding::GetEncryptionByIndex(
    unsigned long idx) const {
   const ptrdiff_t count = encryption_entries_end_ - encryption_entries_;
   assert(count >= 0);
 
 

 }
 
 long ContentEncoding::ParseContentEncAESSettingsEntry(
    long long start, long long size, IMkvReader* pReader,
     ContentEncAESSettings* aes) {
   assert(pReader);
   assert(aes);
 

 
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     if (id == 0x7E8) {
 

         return E_FILE_FORMAT_INVALID;
     }
 
    pos += size;   
     assert(pos <= stop);
   }
 
   return 0;
 }
 
long ContentEncoding::ParseContentEncodingEntry(long long start, long long size,
                                                 IMkvReader* pReader) {
   assert(pReader);
 
 

 
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     if (id == 0x1034)   
 

     if (id == 0x1035)   
       ++encryption_count;
 
    pos += size;   
     assert(pos <= stop);
   }
 
 

 
   if (compression_count > 0) {
     compression_entries_ =
        new (std::nothrow) ContentCompression* [compression_count];
     if (!compression_entries_)
       return -1;
     compression_entries_end_ = compression_entries_;
 

 
   if (encryption_count > 0) {
     encryption_entries_ =
        new (std::nothrow) ContentEncryption* [encryption_count];
     if (!encryption_entries_) {
      delete[] compression_entries_;
       return -1;
     }
     encryption_entries_end_ = encryption_entries_;
 

   pos = start;
   while (pos < stop) {
     long long id, size;
    long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     if (id == 0x1031) {
 

     } else if (id == 0x1034) {
        
       ContentCompression* const compression =
          new (std::nothrow) ContentCompression();
       if (!compression)
         return -1;
 
 

       *encryption_entries_end_++ = encryption;
     }
 
    pos += size;   
     assert(pos <= stop);
   }
 
 

   return 0;
 }
 
long ContentEncoding::ParseCompressionEntry(long long start, long long size,
                                            IMkvReader* pReader,
                                            ContentCompression* compression) {
   assert(pReader);
   assert(compression);
 
 

 
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     if (id == 0x254) {
 

       if (buf == NULL)
         return -1;
 
      const int read_status =
          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
        delete[] buf;
         return status;
       }
 
 

       compression->settings_len = buflen;
     }
 
    pos += size;   
     assert(pos <= stop);
   }
 
 

   return 0;
 }
 
long ContentEncoding::ParseEncryptionEntry(long long start, long long size,
                                           IMkvReader* pReader,
                                           ContentEncryption* encryption) {
   assert(pReader);
   assert(encryption);
 
 

 
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     if (id == 0x7E1) {
 

         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x7E2) {
        
      delete[] encryption -> key_id;
       encryption->key_id = NULL;
       encryption->key_id_len = 0;
 
 

       if (buf == NULL)
         return -1;
 
      const int read_status =
          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
        delete[] buf;
         return status;
       }
 
 

       encryption->key_id_len = buflen;
     } else if (id == 0x7E3) {
        
      delete[] encryption -> signature;
       encryption->signature = NULL;
       encryption->signature_len = 0;
 
 

       if (buf == NULL)
         return -1;
 
      const int read_status =
          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
        delete[] buf;
         return status;
       }
 
 

       encryption->signature_len = buflen;
     } else if (id == 0x7E4) {
        
      delete[] encryption -> sig_key_id;
       encryption->sig_key_id = NULL;
       encryption->sig_key_id_len = 0;
 
 

       if (buf == NULL)
         return -1;
 
      const int read_status =
          pReader->Read(pos, static_cast<long>(buflen), buf);
       if (read_status) {
        delete[] buf;
         return status;
       }
 
 

     } else if (id == 0x7E7) {
        
       const long status = ParseContentEncAESSettingsEntry(
          pos, size, pReader, &encryption->aes_settings);
       if (status)
         return status;
     }
 
    pos += size;   
     assert(pos <= stop);
   }
 
   return 0;
 }
 
Track::Track(Segment* pSegment, long long element_start, long long element_size)
    : m_pSegment(pSegment),
      m_element_start(element_start),
      m_element_size(element_size),
      content_encoding_entries_(NULL),
      content_encoding_entries_end_(NULL) {}

Track::~Track() {
  Info& info = const_cast<Info&>(m_info);
  info.Clear();

  ContentEncoding** i = content_encoding_entries_;
  ContentEncoding** const j = content_encoding_entries_end_;

  while (i != j) {
    ContentEncoding* const encoding = *i++;
    delete encoding;
  }

  delete[] content_encoding_entries_;
 }
 
long Track::Create(Segment* pSegment, const Info& info, long long element_start,
                   long long element_size, Track*& pResult) {
  if (pResult)
    return -1;
 
  Track* const pTrack =
      new (std::nothrow) Track(pSegment, element_start, element_size);
 
  if (pTrack == NULL)
    return -1;   
 
  const int status = info.Copy(pTrack->m_info);

  if (status) {   
    delete pTrack;
    return status;
  }

  pResult = pTrack;
  return 0;   
 }
 
Track::Info::Info()
    : uid(0),
      defaultDuration(0),
      codecDelay(0),
      seekPreRoll(0),
      nameAsUTF8(NULL),
      language(NULL),
      codecId(NULL),
      codecNameAsUTF8(NULL),
      codecPrivate(NULL),
      codecPrivateSize(0),
      lacing(false) {}
 
Track::Info::~Info() { Clear(); }
 
void Track::Info::Clear() {
  delete[] nameAsUTF8;
  nameAsUTF8 = NULL;
 
  delete[] language;
  language = NULL;
 
  delete[] codecId;
  codecId = NULL;
 
  delete[] codecPrivate;
  codecPrivate = NULL;
  codecPrivateSize = 0;

  delete[] codecNameAsUTF8;
  codecNameAsUTF8 = NULL;
 }
 
int Track::Info::CopyStr(char* Info::*str, Info& dst_) const {
  if (str == static_cast<char * Info::*>(NULL))
    return -1;
 
  char*& dst = dst_.*str;
 
  if (dst)   
    return -1;
 
  const char* const src = this->*str;
 
  if (src == NULL)
     return 0;

  const size_t len = strlen(src);

  dst = new (std::nothrow) char[len + 1];

  if (dst == NULL)
    return -1;

  strcpy(dst, src);

  return 0;
 }
 
int Track::Info::Copy(Info& dst) const {
  if (&dst == this)
    return 0;
 
  dst.type = type;
  dst.number = number;
  dst.defaultDuration = defaultDuration;
  dst.codecDelay = codecDelay;
  dst.seekPreRoll = seekPreRoll;
  dst.uid = uid;
  dst.lacing = lacing;
  dst.settings = settings;
 
   
   
   
   
   
 
  if (int status = CopyStr(&Info::nameAsUTF8, dst))
    return status;
 
  if (int status = CopyStr(&Info::language, dst))
    return status;
 
  if (int status = CopyStr(&Info::codecId, dst))
    return status;
 
  if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
    return status;
 
  if (codecPrivateSize > 0) {
    if (codecPrivate == NULL)
      return -1;
 
    if (dst.codecPrivate)
      return -1;
 
    if (dst.codecPrivateSize != 0)
      return -1;
 
    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
 
    if (dst.codecPrivate == NULL)
      return -1;
 
    memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
    dst.codecPrivateSize = codecPrivateSize;
  }
 
  return 0;
}

const BlockEntry* Track::GetEOS() const { return &m_eos; }

long Track::GetType() const { return m_info.type; }

long Track::GetNumber() const { return m_info.number; }

unsigned long long Track::GetUid() const { return m_info.uid; }

const char* Track::GetNameAsUTF8() const { return m_info.nameAsUTF8; }

const char* Track::GetLanguage() const { return m_info.language; }

const char* Track::GetCodecNameAsUTF8() const { return m_info.codecNameAsUTF8; }

const char* Track::GetCodecId() const { return m_info.codecId; }

const unsigned char* Track::GetCodecPrivate(size_t& size) const {
  size = m_info.codecPrivateSize;
  return m_info.codecPrivate;
}

bool Track::GetLacing() const { return m_info.lacing; }

unsigned long long Track::GetDefaultDuration() const {
  return m_info.defaultDuration;
}

unsigned long long Track::GetCodecDelay() const { return m_info.codecDelay; }

unsigned long long Track::GetSeekPreRoll() const { return m_info.seekPreRoll; }

long Track::GetFirst(const BlockEntry*& pBlockEntry) const {
  const Cluster* pCluster = m_pSegment->GetFirst();

  for (int i = 0;;) {
    if (pCluster == NULL) {
      pBlockEntry = GetEOS();
      return 1;
     }
 
    if (pCluster->EOS()) {
 #if 0
            if (m_pSegment->Unparsed() <= 0) {   
                 pBlockEntry = GetEOS();
                 return 1;
             }
 #else
      if (m_pSegment->DoneParsing()) {
        pBlockEntry = GetEOS();
        return 1;
      }
 #endif
 
      pBlockEntry = 0;
      return E_BUFFER_NOT_FULL;
     }
 
    long status = pCluster->GetFirst(pBlockEntry);
 
    if (status < 0)   
      return status;
 
    if (pBlockEntry == 0) {   
      pCluster = m_pSegment->GetNext(pCluster);
      continue;
    }
 
    for (;;) {
      const Block* const pBlock = pBlockEntry->GetBlock();
      assert(pBlock);
 
      const long long tn = pBlock->GetTrackNumber();
 
      if ((tn == m_info.number) && VetEntry(pBlockEntry))
        return 0;
 
      const BlockEntry* pNextEntry;
 
      status = pCluster->GetNext(pBlockEntry, pNextEntry);

      if (status < 0)   
         return status;
 
      if (pNextEntry == 0)
        break;
 
      pBlockEntry = pNextEntry;
    }
 
    ++i;
 
    if (i >= 100)
      break;
 
    pCluster = m_pSegment->GetNext(pCluster);
  }
 
   
   
   
 
  pBlockEntry = GetEOS();   
  return 1;
}
 
long Track::GetNext(const BlockEntry* pCurrEntry,
                    const BlockEntry*& pNextEntry) const {
  assert(pCurrEntry);
  assert(!pCurrEntry->EOS());   

  const Block* const pCurrBlock = pCurrEntry->GetBlock();
  assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
  if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
    return -1;

  const Cluster* pCluster = pCurrEntry->GetCluster();
  assert(pCluster);
  assert(!pCluster->EOS());

  long status = pCluster->GetNext(pCurrEntry, pNextEntry);

  if (status < 0)   
    return status;

  for (int i = 0;;) {
    while (pNextEntry) {
      const Block* const pNextBlock = pNextEntry->GetBlock();
      assert(pNextBlock);

      if (pNextBlock->GetTrackNumber() == m_info.number)
        return 0;

      pCurrEntry = pNextEntry;

      status = pCluster->GetNext(pCurrEntry, pNextEntry);

      if (status < 0)   
        return status;
    }

    pCluster = m_pSegment->GetNext(pCluster);

    if (pCluster == NULL) {
      pNextEntry = GetEOS();
      return 1;
    }

    if (pCluster->EOS()) {
 #if 0
             if (m_pSegment->Unparsed() <= 0)    
             {
 

                 return 1;
             }
 #else
      if (m_pSegment->DoneParsing()) {
        pNextEntry = GetEOS();
        return 1;
      }
 #endif
 
       
       
       
       
       
       
       
       
       
       
       
 
      pNextEntry = NULL;
      return E_BUFFER_NOT_FULL;
     }
 
    status = pCluster->GetFirst(pNextEntry);
 
    if (status < 0)   
      return status;

    if (pNextEntry == NULL)   
      continue;

    ++i;

    if (i >= 100)
      break;
  }

   
   
   

  pNextEntry = GetEOS();   
  return 1;
 }
 
bool Track::VetEntry(const BlockEntry* pBlockEntry) const {
  assert(pBlockEntry);
  const Block* const pBlock = pBlockEntry->GetBlock();
  assert(pBlock);
  assert(pBlock->GetTrackNumber() == m_info.number);
  if (!pBlock || pBlock->GetTrackNumber() != m_info.number)
    return false;
 
   
   
   
   
   
 
  return true;
 }
 
long Track::Seek(long long time_ns, const BlockEntry*& pResult) const {
  const long status = GetFirst(pResult);
 
  if (status < 0)   
    return status;
 
  assert(pResult);
 
  if (pResult->EOS())
    return 0;
 
  const Cluster* pCluster = pResult->GetCluster();
  assert(pCluster);
  assert(pCluster->GetIndex() >= 0);

  if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
    return 0;

  Cluster** const clusters = m_pSegment->m_clusters;
  assert(clusters);

  const long count = m_pSegment->GetCount();   
  assert(count > 0);

  Cluster** const i = clusters + pCluster->GetIndex();
  assert(i);
  assert(*i == pCluster);
  assert(pCluster->GetTime() <= time_ns);

  Cluster** const j = clusters + count;

  Cluster** lo = i;
  Cluster** hi = j;

  while (lo < hi) {
     
     
     
     

    Cluster** const mid = lo + (hi - lo) / 2;
    assert(mid < hi);

    pCluster = *mid;
     assert(pCluster);
     assert(pCluster->GetIndex() >= 0);
    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
 
    const long long t = pCluster->GetTime();
 
    if (t <= time_ns)
      lo = mid + 1;
    else
      hi = mid;
 
    assert(lo <= hi);
  }
 
  assert(lo == hi);
  assert(lo > i);
  assert(lo <= j);

  while (lo > i) {
    pCluster = *--lo;
    assert(pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
    pResult = pCluster->GetEntry(this);
 
    if ((pResult != 0) && !pResult->EOS())
      return 0;
 
     
  }
 
  pResult = GetEOS();   
  return 0;
 }
 
const ContentEncoding* Track::GetContentEncodingByIndex(
    unsigned long idx) const {
   const ptrdiff_t count =
       content_encoding_entries_end_ - content_encoding_entries_;
   assert(count >= 0);
 

   int count = 0;
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     
     if (id == 0x2240)   
       ++count;
 
    pos += size;   
     assert(pos <= stop);
   }
 
   if (count <= 0)
     return -1;
 
  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];
   if (!content_encoding_entries_)
     return -1;
 
 

   pos = start;
   while (pos < stop) {
     long long id, size;
    long status = ParseElementHeader(pReader, pos, stop, id, size);
    if (status < 0)   
       return status;
 
     
    if (id == 0x2240) {   
       ContentEncoding* const content_encoding =
           new (std::nothrow) ContentEncoding();
       if (!content_encoding)
         return -1;
 
      status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);
       if (status) {
         delete content_encoding;
         return status;
 

       *content_encoding_entries_end_++ = content_encoding;
     }
 
    pos += size;   
     assert(pos <= stop);
   }
 
 

   return 0;
 }
 
Track::EOSBlock::EOSBlock() : BlockEntry(NULL, LONG_MIN) {}
 
BlockEntry::Kind Track::EOSBlock::GetKind() const { return kBlockEOS; }
 
const Block* Track::EOSBlock::GetBlock() const { return NULL; }
 
VideoTrack::VideoTrack(Segment* pSegment, long long element_start,
                       long long element_size)
    : Track(pSegment, element_start, element_size) {}
 
long VideoTrack::Parse(Segment* pSegment, const Info& info,
                       long long element_start, long long element_size,
                       VideoTrack*& pResult) {
  if (pResult)
    return -1;
 
  if (info.type != Track::kVideo)
    return -1;
 
  long long width = 0;
  long long height = 0;
  double rate = 0.0;
 
  IMkvReader* const pReader = pSegment->m_pReader;
 
  const Settings& s = info.settings;
  assert(s.start >= 0);
  assert(s.size >= 0);
 
  long long pos = s.start;
  assert(pos >= 0);
 
  const long long stop = pos + s.size;
 
  while (pos < stop) {
    long long id, size;
 
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
    if (status < 0)   
      return status;
 
    if (id == 0x30) {   
      width = UnserializeUInt(pReader, pos, size);
 
      if (width <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x3A) {   
      height = UnserializeUInt(pReader, pos, size);
 
      if (height <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x0383E3) {   
      const long status = UnserializeFloat(pReader, pos, size, rate);
 
      if (status < 0)
         return status;
 
      if (rate <= 0)
        return E_FILE_FORMAT_INVALID;
    }
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(pos == stop);

  VideoTrack* const pTrack =
      new (std::nothrow) VideoTrack(pSegment, element_start, element_size);

  if (pTrack == NULL)
    return -1;   

  const int status = info.Copy(pTrack->m_info);

  if (status) {   
    delete pTrack;
    return status;
  }

  pTrack->m_width = width;
  pTrack->m_height = height;
  pTrack->m_rate = rate;

  pResult = pTrack;
  return 0;   
}

bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const {
  return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();
}

long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {
  const long status = GetFirst(pResult);

  if (status < 0)   
    return status;

  assert(pResult);

  if (pResult->EOS())
    return 0;

  const Cluster* pCluster = pResult->GetCluster();
  assert(pCluster);
  assert(pCluster->GetIndex() >= 0);

  if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
    return 0;

  Cluster** const clusters = m_pSegment->m_clusters;
  assert(clusters);

  const long count = m_pSegment->GetCount();   
  assert(count > 0);

  Cluster** const i = clusters + pCluster->GetIndex();
  assert(i);
  assert(*i == pCluster);
  assert(pCluster->GetTime() <= time_ns);

  Cluster** const j = clusters + count;

  Cluster** lo = i;
  Cluster** hi = j;

  while (lo < hi) {
     
     
     
     

    Cluster** const mid = lo + (hi - lo) / 2;
    assert(mid < hi);

    pCluster = *mid;
     assert(pCluster);
     assert(pCluster->GetIndex() >= 0);
    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
 
    const long long t = pCluster->GetTime();
 
    if (t <= time_ns)
      lo = mid + 1;
    else
      hi = mid;
 
    assert(lo <= hi);
  }
 
  assert(lo == hi);
  assert(lo > i);
  assert(lo <= j);
 
  pCluster = *--lo;
  assert(pCluster);
  assert(pCluster->GetTime() <= time_ns);
 
  pResult = pCluster->GetEntry(this, time_ns);
 
  if ((pResult != 0) && !pResult->EOS())   
    return 0;
 
  while (lo != i) {
     pCluster = *--lo;
     assert(pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
 #if 0
          
          
 

          
         pResult = pCluster->GetMaxKey(this);
 #else
    pResult = pCluster->GetEntry(this, time_ns);
 #endif
 
    if ((pResult != 0) && !pResult->EOS())
      return 0;
  }

   
   

  pResult = GetEOS();
  return 0;
}

long long VideoTrack::GetWidth() const { return m_width; }

long long VideoTrack::GetHeight() const { return m_height; }

double VideoTrack::GetFrameRate() const { return m_rate; }

AudioTrack::AudioTrack(Segment* pSegment, long long element_start,
                       long long element_size)
    : Track(pSegment, element_start, element_size) {}

long AudioTrack::Parse(Segment* pSegment, const Info& info,
                       long long element_start, long long element_size,
                       AudioTrack*& pResult) {
  if (pResult)
    return -1;

  if (info.type != Track::kAudio)
    return -1;

  IMkvReader* const pReader = pSegment->m_pReader;

  const Settings& s = info.settings;
  assert(s.start >= 0);
  assert(s.size >= 0);

  long long pos = s.start;
  assert(pos >= 0);

  const long long stop = pos + s.size;

  double rate = 8000.0;   
  long long channels = 1;
  long long bit_depth = 0;

  while (pos < stop) {
    long long id, size;

    long status = ParseElementHeader(pReader, pos, stop, id, size);

    if (status < 0)   
      return status;

    if (id == 0x35) {   
      status = UnserializeFloat(pReader, pos, size, rate);

      if (status < 0)
        return status;

      if (rate <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x1F) {   
      channels = UnserializeUInt(pReader, pos, size);

      if (channels <= 0)
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x2264) {   
      bit_depth = UnserializeUInt(pReader, pos, size);

      if (bit_depth <= 0)
        return E_FILE_FORMAT_INVALID;
     }
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(pos == stop);

  AudioTrack* const pTrack =
      new (std::nothrow) AudioTrack(pSegment, element_start, element_size);

  if (pTrack == NULL)
    return -1;   

  const int status = info.Copy(pTrack->m_info);

  if (status) {
    delete pTrack;
    return status;
  }

  pTrack->m_rate = rate;
  pTrack->m_channels = channels;
  pTrack->m_bitDepth = bit_depth;

  pResult = pTrack;
  return 0;   
 }
 
double AudioTrack::GetSamplingRate() const { return m_rate; }
 
long long AudioTrack::GetChannels() const { return m_channels; }
 
long long AudioTrack::GetBitDepth() const { return m_bitDepth; }
 
Tracks::Tracks(Segment* pSegment, long long start, long long size_,
               long long element_start, long long element_size)
    : m_pSegment(pSegment),
      m_start(start),
      m_size(size_),
      m_element_start(element_start),
      m_element_size(element_size),
      m_trackEntries(NULL),
      m_trackEntriesEnd(NULL) {}
 
long Tracks::Parse() {
  assert(m_trackEntries == NULL);
  assert(m_trackEntriesEnd == NULL);
 
  const long long stop = m_start + m_size;
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  int count = 0;
  long long pos = m_start;
 
  while (pos < stop) {
    long long id, size;
 
    const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
    if (status < 0)   
      return status;
 
    if (size == 0)   
      continue;
 
    if (id == 0x2E)   
      ++count;
 
    pos += size;   
    assert(pos <= stop);
  }
 
  assert(pos == stop);
 
  if (count <= 0)
    return 0;   
 
  m_trackEntries = new (std::nothrow) Track* [count];
 
  if (m_trackEntries == NULL)
    return -1;
 
  m_trackEntriesEnd = m_trackEntries;
 
  pos = m_start;
 
  while (pos < stop) {
    const long long element_start = pos;
 
    long long id, payload_size;
 
    const long status =
        ParseElementHeader(pReader, pos, stop, id, payload_size);
 
    if (status < 0)   
      return status;
 
    if (payload_size == 0)   
      continue;
 
    const long long payload_stop = pos + payload_size;
    assert(payload_stop <= stop);   

    const long long element_size = payload_stop - element_start;

    if (id == 0x2E) {   
      Track*& pTrack = *m_trackEntriesEnd;
      pTrack = NULL;

      const long status = ParseTrackEntry(pos, payload_size, element_start,
                                          element_size, pTrack);

      if (status)
        return status;

      if (pTrack)
        ++m_trackEntriesEnd;
     }
 
    pos = payload_stop;
    assert(pos <= stop);
  }
 
  assert(pos == stop);
 
  return 0;   
}
 
unsigned long Tracks::GetTracksCount() const {
  const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;
  assert(result >= 0);

  return static_cast<unsigned long>(result);
}

long Tracks::ParseTrackEntry(long long track_start, long long track_size,
                             long long element_start, long long element_size,
                             Track*& pResult) const {
  if (pResult)
    return -1;

  IMkvReader* const pReader = m_pSegment->m_pReader;

  long long pos = track_start;
  const long long track_stop = track_start + track_size;

  Track::Info info;

  info.type = 0;
  info.number = 0;
  info.uid = 0;
  info.defaultDuration = 0;

  Track::Settings v;
  v.start = -1;
  v.size = -1;

  Track::Settings a;
  a.start = -1;
  a.size = -1;

  Track::Settings e;   
  e.start = -1;
  e.size = -1;

  long long lacing = 1;   

  while (pos < track_stop) {
    long long id, size;

    const long status = ParseElementHeader(pReader, pos, track_stop, id, size);

    if (status < 0)   
      return status;

    if (size < 0)
      return E_FILE_FORMAT_INVALID;

    const long long start = pos;

    if (id == 0x60) {   
      v.start = start;
      v.size = size;
    } else if (id == 0x61) {   
      a.start = start;
      a.size = size;
    } else if (id == 0x2D80) {   
      e.start = start;
      e.size = size;
    } else if (id == 0x33C5) {   
      if (size > 8)
        return E_FILE_FORMAT_INVALID;

      info.uid = 0;

      long long pos_ = start;
      const long long pos_end = start + size;

      while (pos_ != pos_end) {
        unsigned char b;

        const int status = pReader->Read(pos_, 1, &b);

        if (status)
          return status;

        info.uid <<= 8;
        info.uid |= b;

        ++pos_;
      }
    } else if (id == 0x57) {   
      const long long num = UnserializeUInt(pReader, pos, size);

      if ((num <= 0) || (num > 127))
        return E_FILE_FORMAT_INVALID;

      info.number = static_cast<long>(num);
    } else if (id == 0x03) {   
      const long long type = UnserializeUInt(pReader, pos, size);

      if ((type <= 0) || (type > 254))
        return E_FILE_FORMAT_INVALID;

      info.type = static_cast<long>(type);
    } else if (id == 0x136E) {   
      const long status =
          UnserializeString(pReader, pos, size, info.nameAsUTF8);

      if (status)
        return status;
    } else if (id == 0x02B59C) {   
      const long status = UnserializeString(pReader, pos, size, info.language);

      if (status)
        return status;
    } else if (id == 0x03E383) {   
      const long long duration = UnserializeUInt(pReader, pos, size);

      if (duration < 0)
        return E_FILE_FORMAT_INVALID;

      info.defaultDuration = static_cast<unsigned long long>(duration);
    } else if (id == 0x06) {   
      const long status = UnserializeString(pReader, pos, size, info.codecId);

      if (status)
        return status;
    } else if (id == 0x1C) {   
      lacing = UnserializeUInt(pReader, pos, size);

      if ((lacing < 0) || (lacing > 1))
        return E_FILE_FORMAT_INVALID;
    } else if (id == 0x23A2) {   
      delete[] info.codecPrivate;
      info.codecPrivate = NULL;
      info.codecPrivateSize = 0;

      const size_t buflen = static_cast<size_t>(size);

      if (buflen) {
        typedef unsigned char* buf_t;

        const buf_t buf = new (std::nothrow) unsigned char[buflen];

        if (buf == NULL)
          return -1;

        const int status = pReader->Read(pos, static_cast<long>(buflen), buf);

        if (status) {
          delete[] buf;
          return status;
        }

        info.codecPrivate = buf;
        info.codecPrivateSize = buflen;
      }
    } else if (id == 0x058688) {   
      const long status =
          UnserializeString(pReader, pos, size, info.codecNameAsUTF8);

      if (status)
        return status;
    } else if (id == 0x16AA) {   
      info.codecDelay = UnserializeUInt(pReader, pos, size);
    } else if (id == 0x16BB) {   
      info.seekPreRoll = UnserializeUInt(pReader, pos, size);
    }

    pos += size;   
    assert(pos <= track_stop);
  }

  assert(pos == track_stop);

  if (info.number <= 0)   
    return E_FILE_FORMAT_INVALID;

  if (GetTrackByNumber(info.number))
    return E_FILE_FORMAT_INVALID;

  if (info.type <= 0)   
    return E_FILE_FORMAT_INVALID;

  info.lacing = (lacing > 0) ? true : false;

  if (info.type == Track::kVideo) {
    if (v.start < 0)
      return E_FILE_FORMAT_INVALID;

    if (a.start >= 0)
      return E_FILE_FORMAT_INVALID;

    info.settings = v;

    VideoTrack* pTrack = NULL;

    const long status = VideoTrack::Parse(m_pSegment, info, element_start,
                                          element_size, pTrack);
 
     if (status)
      return status;
 
     pResult = pTrack;
    assert(pResult);

    if (e.start >= 0)
      pResult->ParseContentEncodingsEntry(e.start, e.size);
  } else if (info.type == Track::kAudio) {
    if (a.start < 0)
      return E_FILE_FORMAT_INVALID;

    if (v.start >= 0)
      return E_FILE_FORMAT_INVALID;

    info.settings = a;

    AudioTrack* pTrack = NULL;

    const long status = AudioTrack::Parse(m_pSegment, info, element_start,
                                          element_size, pTrack);

    if (status)
      return status;

    pResult = pTrack;
    assert(pResult);

    if (e.start >= 0)
      pResult->ParseContentEncodingsEntry(e.start, e.size);
  } else {
     

    if (a.start >= 0)
      return E_FILE_FORMAT_INVALID;

    if (v.start >= 0)
      return E_FILE_FORMAT_INVALID;

    if (e.start >= 0)
      return E_FILE_FORMAT_INVALID;

    info.settings.start = -1;
    info.settings.size = 0;

    Track* pTrack = NULL;

    const long status =
        Track::Create(m_pSegment, info, element_start, element_size, pTrack);

    if (status)
      return status;

    pResult = pTrack;
    assert(pResult);
  }

  return 0;   
 }
 
Tracks::~Tracks() {
  Track** i = m_trackEntries;
  Track** const j = m_trackEntriesEnd;
 
  while (i != j) {
    Track* const pTrack = *i++;
    delete pTrack;
  }

  delete[] m_trackEntries;
 }
 
const Track* Tracks::GetTrackByNumber(long tn) const {
  if (tn < 0)
    return NULL;
 
  Track** i = m_trackEntries;
  Track** const j = m_trackEntriesEnd;

  while (i != j) {
    Track* const pTrack = *i++;

    if (pTrack == NULL)
      continue;

    if (tn == pTrack->GetNumber())
      return pTrack;
  }

  return NULL;   
 }
 
const Track* Tracks::GetTrackByIndex(unsigned long idx) const {
  const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;
 
  if (idx >= static_cast<unsigned long>(count))
    return NULL;
 
  return m_trackEntries[idx];
 }
 
 #if 0
 

 }
 #endif
 
long Cluster::Load(long long& pos, long& len) const {
  assert(m_pSegment);
  assert(m_pos >= m_element_start);
 
  if (m_timecode >= 0)   
    return 0;
 
  assert(m_pos == m_element_start);
  assert(m_element_size < 0);
 
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long total, avail;
 
  const int status = pReader->Length(&total, &avail);
 
  if (status < 0)   
    return status;
 
  assert((total < 0) || (avail <= total));
  assert((total < 0) || (m_pos <= total));   
 
  pos = m_pos;
 
  long long cluster_size = -1;
 
  {
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }
 
    long long result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

     
     

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long id_ = ReadUInt(pReader, pos, len);

    if (id_ < 0)   
      return static_cast<long>(id_);

    if (id_ != 0x0F43B675)   
      return E_FILE_FORMAT_INVALID;

    pos += len;   

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

     
     

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(pReader, pos, len);

    if (size < 0)   
      return static_cast<long>(cluster_size);

    if (size == 0)
      return E_FILE_FORMAT_INVALID;   

    pos += len;   

    const long long unknown_size = (1LL << (7 * len)) - 1;

    if (size != unknown_size)
      cluster_size = size;
  }

 
 
 #if 0
     len = static_cast<long>(size_);
 

         return E_BUFFER_NOT_FULL;
 #endif
 
  long long timecode = -1;
  long long new_pos = -1;
  bool bBlock = false;
 
  long long cluster_stop = (cluster_size < 0) ? -1 : pos + cluster_size;
 
  for (;;) {
    if ((cluster_stop >= 0) && (pos >= cluster_stop))
      break;
 
     
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }
 
     long long result = GetUIntLength(pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
      return E_FILE_FORMAT_INVALID;
 
     if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long id = ReadUInt(pReader, pos, len);

    if (id < 0)   
      return static_cast<long>(id);

    if (id == 0)
      return E_FILE_FORMAT_INVALID;

     
     
     

    if (id == 0x0F43B675)   
      break;

    if (id == 0x0C53BB6B)   
      break;

    pos += len;   

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(pReader, pos, len);

    if (size < 0)   
      return static_cast<long>(size);

    const long long unknown_size = (1LL << (7 * len)) - 1;

    if (size == unknown_size)
      return E_FILE_FORMAT_INVALID;

    pos += len;   

    if ((cluster_stop >= 0) && (pos > cluster_stop))
      return E_FILE_FORMAT_INVALID;

     

    if (size == 0)   
      continue;

    if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if (id == 0x67) {   
      len = static_cast<long>(size);

      if ((pos + size) > avail)
         return E_BUFFER_NOT_FULL;
 
      timecode = UnserializeUInt(pReader, pos, size);
 
      if (timecode < 0)   
        return static_cast<long>(timecode);
 
      new_pos = pos + size;

      if (bBlock)
        break;
    } else if (id == 0x20) {   
      bBlock = true;
      break;
    } else if (id == 0x23) {   
      bBlock = true;
      break;
    }

    pos += size;   
    assert((cluster_stop < 0) || (pos <= cluster_stop));
  }

  assert((cluster_stop < 0) || (pos <= cluster_stop));

  if (timecode < 0)   
    return E_FILE_FORMAT_INVALID;

  if (!bBlock)
    return E_FILE_FORMAT_INVALID;

  m_pos = new_pos;   
  m_timecode = timecode;   

  if (cluster_size >= 0)
    m_element_size = cluster_stop - m_element_start;

  return 0;
}

long Cluster::Parse(long long& pos, long& len) const {
  long status = Load(pos, len);

  if (status < 0)
    return status;

  assert(m_pos >= m_element_start);
  assert(m_timecode >= 0);
   
   

  const long long cluster_stop =
      (m_element_size < 0) ? -1 : m_element_start + m_element_size;

  if ((cluster_stop >= 0) && (m_pos >= cluster_stop))
    return 1;   

  IMkvReader* const pReader = m_pSegment->m_pReader;

  long long total, avail;

  status = pReader->Length(&total, &avail);

  if (status < 0)   
    return status;

  assert((total < 0) || (avail <= total));

  pos = m_pos;

  for (;;) {
    if ((cluster_stop >= 0) && (pos >= cluster_stop))
      break;

    if ((total >= 0) && (pos >= total)) {
      if (m_element_size < 0)
        m_element_size = pos - m_element_start;

      break;
    }

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    long long result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long id = ReadUInt(pReader, pos, len);

    if (id < 0)   
      return static_cast<long>(id);

    if (id == 0)   
      return E_FILE_FORMAT_INVALID;

     
     
     

    if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) {   
      if (m_element_size < 0)
        m_element_size = pos - m_element_start;

      break;
    }

    pos += len;   

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(pReader, pos, len);

    if (size < 0)   
      return static_cast<long>(size);

    const long long unknown_size = (1LL << (7 * len)) - 1;

    if (size == unknown_size)
      return E_FILE_FORMAT_INVALID;

    pos += len;   

    if ((cluster_stop >= 0) && (pos > cluster_stop))
      return E_FILE_FORMAT_INVALID;

     

    if (size == 0)   
      continue;

     
    const long long block_stop = pos + size;

    if (cluster_stop >= 0) {
      if (block_stop > cluster_stop) {
        if ((id == 0x20) || (id == 0x23))
          return E_FILE_FORMAT_INVALID;

        pos = cluster_stop;
        break;
      }
    } else if ((total >= 0) && (block_stop > total)) {
      m_element_size = total - m_element_start;
      pos = total;
      break;
    } else if (block_stop > avail) {
      len = static_cast<long>(size);
      return E_BUFFER_NOT_FULL;
    }

    Cluster* const this_ = const_cast<Cluster*>(this);

    if (id == 0x20)   
      return this_->ParseBlockGroup(size, pos, len);

    if (id == 0x23)   
      return this_->ParseSimpleBlock(size, pos, len);

    pos += size;   
    assert((cluster_stop < 0) || (pos <= cluster_stop));
  }

  assert(m_element_size > 0);

  m_pos = pos;
  assert((cluster_stop < 0) || (m_pos <= cluster_stop));

  if (m_entries_count > 0) {
    const long idx = m_entries_count - 1;

    const BlockEntry* const pLast = m_entries[idx];
    assert(pLast);

    const Block* const pBlock = pLast->GetBlock();
    assert(pBlock);

    const long long start = pBlock->m_start;

    if ((total >= 0) && (start > total))
      return -1;   

    const long long size = pBlock->m_size;

    const long long stop = start + size;
    assert((cluster_stop < 0) || (stop <= cluster_stop));

    if ((total >= 0) && (stop > total))
      return -1;   
  }

  return 1;   
}

long Cluster::ParseSimpleBlock(long long block_size, long long& pos,
                               long& len) {
  const long long block_start = pos;
  const long long block_stop = pos + block_size;

  IMkvReader* const pReader = m_pSegment->m_pReader;

  long long total, avail;

  long status = pReader->Length(&total, &avail);

  if (status < 0)   
    return status;

  assert((total < 0) || (avail <= total));

   

  if ((pos + 1) > avail) {
    len = 1;
    return E_BUFFER_NOT_FULL;
  }

  long long result = GetUIntLength(pReader, pos, len);

  if (result < 0)   
    return static_cast<long>(result);

  if (result > 0)   
    return E_BUFFER_NOT_FULL;

  if ((pos + len) > block_stop)
    return E_FILE_FORMAT_INVALID;

  if ((pos + len) > avail)
    return E_BUFFER_NOT_FULL;

  const long long track = ReadUInt(pReader, pos, len);

  if (track < 0)   
    return static_cast<long>(track);

  if (track == 0)
    return E_FILE_FORMAT_INVALID;
 
 #if 0
      
 

         return E_FILE_FORMAT_INVALID;
 #endif
 
  pos += len;   
 
  if ((pos + 2) > block_stop)
    return E_FILE_FORMAT_INVALID;
 
  if ((pos + 2) > avail) {
    len = 2;
    return E_BUFFER_NOT_FULL;
  }
 
  pos += 2;   
 
  if ((pos + 1) > block_stop)
    return E_FILE_FORMAT_INVALID;
 
  if ((pos + 1) > avail) {
    len = 1;
    return E_BUFFER_NOT_FULL;
  }
 
  unsigned char flags;
 
  status = pReader->Read(pos, 1, &flags);
 
  if (status < 0) {   
    len = 1;
    return status;
  }
 
  ++pos;   
  assert(pos <= avail);
 
  if (pos >= block_stop)
    return E_FILE_FORMAT_INVALID;
 
  const int lacing = int(flags & 0x06) >> 1;
 
  if ((lacing != 0) && (block_stop > avail)) {
    len = static_cast<long>(block_stop - pos);
    return E_BUFFER_NOT_FULL;
  }
 
  status = CreateBlock(0x23,   
                       block_start, block_size,
                       0);   
 
  if (status != 0)
    return status;
 
  m_pos = block_stop;
 
  return 0;   
 }
 
long Cluster::ParseBlockGroup(long long payload_size, long long& pos,
                              long& len) {
  const long long payload_start = pos;
  const long long payload_stop = pos + payload_size;
 
  IMkvReader* const pReader = m_pSegment->m_pReader;
 
  long long total, avail;
 
  long status = pReader->Length(&total, &avail);
 
  if (status < 0)   
    return status;
 
  assert((total < 0) || (avail <= total));
 
  if ((total >= 0) && (payload_stop > total))
    return E_FILE_FORMAT_INVALID;
 
  if (payload_stop > avail) {
    len = static_cast<long>(payload_size);
    return E_BUFFER_NOT_FULL;
  }
 
  long long discard_padding = 0;

  while (pos < payload_stop) {
     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }
 
    long long result = GetUIntLength(pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((pos + len) > payload_stop)
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long id = ReadUInt(pReader, pos, len);
 
    if (id < 0)   
      return static_cast<long>(id);
 
    if (id == 0)   
      return E_FILE_FORMAT_INVALID;
 
    pos += len;   
 
     
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }
 
    result = GetUIntLength(pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((pos + len) > payload_stop)
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long size = ReadUInt(pReader, pos, len);
 
    if (size < 0)   
      return static_cast<long>(size);
 
    pos += len;   
 
     
 
    if (pos > payload_stop)
      return E_FILE_FORMAT_INVALID;
 
    if (size == 0)   
      continue;
 
    const long long unknown_size = (1LL << (7 * len)) - 1;
 
    if (size == unknown_size)
      return E_FILE_FORMAT_INVALID;
 
    if (id == 0x35A2) {   
      status = UnserializeInt(pReader, pos, size, discard_padding);
 
      if (status < 0)   
        return status;
    }
 
    if (id != 0x21) {   
      pos += size;   
 
      if (pos > payload_stop)
        return E_FILE_FORMAT_INVALID;
 
      continue;
    }
 
    const long long block_stop = pos + size;
 
    if (block_stop > payload_stop)
      return E_FILE_FORMAT_INVALID;
 
     
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }
 
    result = GetUIntLength(pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((pos + len) > block_stop)
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long track = ReadUInt(pReader, pos, len);
 
    if (track < 0)   
      return static_cast<long>(track);
 
    if (track == 0)
      return E_FILE_FORMAT_INVALID;
 
 #if 0
          
 

             return E_FILE_FORMAT_INVALID;
 #endif
 
    pos += len;   
 
    if ((pos + 2) > block_stop)
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + 2) > avail) {
      len = 2;
      return E_BUFFER_NOT_FULL;
     }
 
    pos += 2;   
 
    if ((pos + 1) > block_stop)
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }
 
    unsigned char flags;
 
    status = pReader->Read(pos, 1, &flags);
 
    if (status < 0) {   
      len = 1;
      return status;
     }
 
    ++pos;   
    assert(pos <= avail);

    if (pos >= block_stop)
      return E_FILE_FORMAT_INVALID;

    const int lacing = int(flags & 0x06) >> 1;

    if ((lacing != 0) && (block_stop > avail)) {
      len = static_cast<long>(block_stop - pos);
      return E_BUFFER_NOT_FULL;
    }

    pos = block_stop;   
    assert(pos <= payload_stop);
  }

  assert(pos == payload_stop);

  status = CreateBlock(0x20,   
                       payload_start, payload_size, discard_padding);
  if (status != 0)
    return status;

  m_pos = payload_stop;

  return 0;   
 }
 
long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const {
  assert(m_pos >= m_element_start);
 
  pEntry = NULL;

  if (index < 0)
    return -1;   

  if (m_entries_count < 0)
    return E_BUFFER_NOT_FULL;

  assert(m_entries);
  assert(m_entries_size > 0);
  assert(m_entries_count <= m_entries_size);

  if (index < m_entries_count) {
    pEntry = m_entries[index];
    assert(pEntry);

    return 1;   
  }

  if (m_element_size < 0)   
    return E_BUFFER_NOT_FULL;   

  const long long element_stop = m_element_start + m_element_size;

  if (m_pos >= element_stop)
    return 0;   

  return E_BUFFER_NOT_FULL;   
}

Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)
 
 {
  assert(pSegment);
  assert(off >= 0);

  const long long element_start = pSegment->m_start + off;

  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);
   
  assert(pCluster);

  return pCluster;
 }
 
Cluster::Cluster()
    : m_pSegment(NULL),
      m_element_start(0),
      m_index(0),
      m_pos(0),
      m_element_size(0),
      m_timecode(0),
      m_entries(NULL),
      m_entries_size(0),
      m_entries_count(0)   
{}
 
Cluster::Cluster(Segment* pSegment, long idx, long long element_start
                  )
    : m_pSegment(pSegment),
      m_element_start(element_start),
      m_index(idx),
      m_pos(element_start),
      m_element_size(-1  ),
      m_timecode(-1),
      m_entries(NULL),
      m_entries_size(0),
      m_entries_count(-1)   
{}

Cluster::~Cluster() {
  if (m_entries_count <= 0)
    return;

  BlockEntry** i = m_entries;
  BlockEntry** const j = m_entries + m_entries_count;

  while (i != j) {
    BlockEntry* p = *i++;
    assert(p);

    delete p;
  }

  delete[] m_entries;
 }
 
bool Cluster::EOS() const { return (m_pSegment == NULL); }
 
long Cluster::GetIndex() const { return m_index; }
 
long long Cluster::GetPosition() const {
  const long long pos = m_element_start - m_pSegment->m_start;
  assert(pos >= 0);

  return pos;
 }
 
long long Cluster::GetElementSize() const { return m_element_size; }
 
 #if 0
 bool Cluster::HasBlockEntries(
     const Segment* pSegment,
    long long off) {
     assert(pSegment);
    assert(off >= 0);   
 
     IMkvReader* const pReader = pSegment->m_pReader;
 
 

 }
 #endif
 
 long Cluster::HasBlockEntries(
     const Segment* pSegment,
    long long off,   
    long long& pos, long& len) {
  assert(pSegment);
  assert(off >= 0);   
 
  IMkvReader* const pReader = pSegment->m_pReader;
 
  long long total, avail;
 
  long status = pReader->Length(&total, &avail);
 
  if (status < 0)   
    return status;
 
  assert((total < 0) || (avail <= total));
 
  pos = pSegment->m_start + off;   
 
  if ((total >= 0) && (pos >= total))
    return 0;   
 
  const long long segment_stop =
      (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;
 
  long long cluster_stop = -1;   
 
  {
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }
 
    long long result = GetUIntLength(pReader, pos, len);
 
    if (result < 0)   
      return static_cast<long>(result);
 
    if (result > 0)   
      return E_BUFFER_NOT_FULL;
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((total >= 0) && ((pos + len) > total))
      return 0;
 
    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;
 
    const long long id = ReadUInt(pReader, pos, len);
 
    if (id < 0)   
      return static_cast<long>(id);
 
    if (id != 0x0F43B675)   
      return -1;   
 
    pos += len;   
 
     
 
    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
     }

    result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;

    if ((total >= 0) && ((pos + len) > total))
      return 0;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(pReader, pos, len);

    if (size < 0)   
      return static_cast<long>(size);

    if (size == 0)
      return 0;   

    pos += len;   

     

    const long long unknown_size = (1LL << (7 * len)) - 1;

    if (size != unknown_size) {
      cluster_stop = pos + size;
      assert(cluster_stop >= 0);

      if ((segment_stop >= 0) && (cluster_stop > segment_stop))
        return E_FILE_FORMAT_INVALID;

      if ((total >= 0) && (cluster_stop > total))
         
        return 0;   
    }
  }

  for (;;) {
    if ((cluster_stop >= 0) && (pos >= cluster_stop))
      return 0;   

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    long long result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long id = ReadUInt(pReader, pos, len);

    if (id < 0)   
      return static_cast<long>(id);

     
     
     

    if (id == 0x0F43B675)   
      return 0;   

    if (id == 0x0C53BB6B)   
      return 0;   

    pos += len;   

    if ((cluster_stop >= 0) && (pos >= cluster_stop))
      return E_FILE_FORMAT_INVALID;

     

    if ((pos + 1) > avail) {
      len = 1;
      return E_BUFFER_NOT_FULL;
    }

    result = GetUIntLength(pReader, pos, len);

    if (result < 0)   
      return static_cast<long>(result);

    if (result > 0)   
      return E_BUFFER_NOT_FULL;

    if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > avail)
      return E_BUFFER_NOT_FULL;

    const long long size = ReadUInt(pReader, pos, len);

    if (size < 0)   
      return static_cast<long>(size);

    pos += len;   

     

    if ((cluster_stop >= 0) && (pos > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if (size == 0)   
      continue;

    const long long unknown_size = (1LL << (7 * len)) - 1;

    if (size == unknown_size)
      return E_FILE_FORMAT_INVALID;   

    if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
      return E_FILE_FORMAT_INVALID;

    if (id == 0x20)   
      return 1;   

    if (id == 0x23)   
      return 1;   

    pos += size;   
    assert((cluster_stop < 0) || (pos <= cluster_stop));
  }
 }
 
long long Cluster::GetTimeCode() const {
  long long pos;
  long len;
 
  const long status = Load(pos, len);

  if (status < 0)   
    return status;

  return m_timecode;
}

long long Cluster::GetTime() const {
  const long long tc = GetTimeCode();

  if (tc < 0)
    return tc;

  const SegmentInfo* const pInfo = m_pSegment->GetInfo();
  assert(pInfo);

  const long long scale = pInfo->GetTimeCodeScale();
  assert(scale >= 1);

  const long long t = m_timecode * scale;

  return t;
}

long long Cluster::GetFirstTime() const {
  const BlockEntry* pEntry;

  const long status = GetFirst(pEntry);

  if (status < 0)   
    return status;

  if (pEntry == NULL)   
    return GetTime();

  const Block* const pBlock = pEntry->GetBlock();
  assert(pBlock);

  return pBlock->GetTime(this);
}

long long Cluster::GetLastTime() const {
  const BlockEntry* pEntry;

  const long status = GetLast(pEntry);

  if (status < 0)   
    return status;

  if (pEntry == NULL)   
    return GetTime();

  const Block* const pBlock = pEntry->GetBlock();
  assert(pBlock);

  return pBlock->GetTime(this);
}

long Cluster::CreateBlock(long long id,
                          long long pos,   
                          long long size, long long discard_padding) {
  assert((id == 0x20) || (id == 0x23));   

  if (m_entries_count < 0) {   
    assert(m_entries == NULL);
    assert(m_entries_size == 0);

    m_entries_size = 1024;
    m_entries = new BlockEntry* [m_entries_size];

    m_entries_count = 0;
  } else {
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count <= m_entries_size);

    if (m_entries_count >= m_entries_size) {
      const long entries_size = 2 * m_entries_size;

      BlockEntry** const entries = new BlockEntry* [entries_size];
      assert(entries);

      BlockEntry** src = m_entries;
      BlockEntry** const src_end = src + m_entries_count;

      BlockEntry** dst = entries;

      while (src != src_end)
        *dst++ = *src++;

      delete[] m_entries;

      m_entries = entries;
      m_entries_size = entries_size;
    }
  }

  if (id == 0x20)   
    return CreateBlockGroup(pos, size, discard_padding);
  else   
    return CreateSimpleBlock(pos, size);
}

long Cluster::CreateBlockGroup(long long start_offset, long long size,
                               long long discard_padding) {
  assert(m_entries);
  assert(m_entries_size > 0);
  assert(m_entries_count >= 0);
  assert(m_entries_count < m_entries_size);

  IMkvReader* const pReader = m_pSegment->m_pReader;

  long long pos = start_offset;
  const long long stop = start_offset + size;

   
   
   
   
   

  long long prev = 1;   
  long long next = 0;   
  long long duration = -1;   

  long long bpos = -1;
  long long bsize = -1;

  while (pos < stop) {
    long len;
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);   
    assert((pos + len) <= stop);

    pos += len;   

    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);   
    assert((pos + len) <= stop);

    pos += len;   

    if (id == 0x21) {   
      if (bpos < 0) {   
        bpos = pos;
        bsize = size;
      }
    } else if (id == 0x1B) {   
      assert(size <= 8);

      duration = UnserializeUInt(pReader, pos, size);
      assert(duration >= 0);   
    } else if (id == 0x7B) {   
      assert(size <= 8);
      const long size_ = static_cast<long>(size);

      long long time;

      long status = UnserializeInt(pReader, pos, size_, time);
      assert(status == 0);
      if (status != 0)
        return -1;

      if (time <= 0)   
        prev = time;
      else   
        next = time;
    }

    pos += size;   
    assert(pos <= stop);
  }

  assert(pos == stop);
  assert(bpos >= 0);
  assert(bsize >= 0);

  const long idx = m_entries_count;

  BlockEntry** const ppEntry = m_entries + idx;
  BlockEntry*& pEntry = *ppEntry;

  pEntry = new (std::nothrow)
      BlockGroup(this, idx, bpos, bsize, prev, next, duration, discard_padding);

  if (pEntry == NULL)
    return -1;   

  BlockGroup* const p = static_cast<BlockGroup*>(pEntry);

  const long status = p->Parse();

  if (status == 0) {   
    ++m_entries_count;
    return 0;
  }

  delete pEntry;
  pEntry = 0;

  return status;
}

long Cluster::CreateSimpleBlock(long long st, long long sz) {
  assert(m_entries);
  assert(m_entries_size > 0);
  assert(m_entries_count >= 0);
  assert(m_entries_count < m_entries_size);

  const long idx = m_entries_count;

  BlockEntry** const ppEntry = m_entries + idx;
  BlockEntry*& pEntry = *ppEntry;

  pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);

  if (pEntry == NULL)
    return -1;   

  SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);

  const long status = p->Parse();

  if (status == 0) {
    ++m_entries_count;
    return 0;
  }

  delete pEntry;
  pEntry = 0;

  return status;
}

long Cluster::GetFirst(const BlockEntry*& pFirst) const {
  if (m_entries_count <= 0) {
     long long pos;
     long len;
 
    const long status = Parse(pos, len);
 
    if (status < 0) {   
      pFirst = NULL;
      return status;
     }
 
    if (m_entries_count <= 0) {   
      pFirst = NULL;
      return 0;
    }
  }

  assert(m_entries);

  pFirst = m_entries[0];
  assert(pFirst);

  return 0;   
 }
 
long Cluster::GetLast(const BlockEntry*& pLast) const {
  for (;;) {
    long long pos;
    long len;
 
    const long status = Parse(pos, len);
 
    if (status < 0) {   
      pLast = NULL;
      return status;
     }
 
    if (status > 0)   
      break;
  }
 
  if (m_entries_count <= 0) {
    pLast = NULL;
     return 0;
  }

  assert(m_entries);

  const long idx = m_entries_count - 1;

  pLast = m_entries[idx];
  assert(pLast);

  return 0;
 }
 
long Cluster::GetNext(const BlockEntry* pCurr, const BlockEntry*& pNext) const {
  assert(pCurr);
  assert(m_entries);
  assert(m_entries_count > 0);
 
  size_t idx = pCurr->GetIndex();
  assert(idx < size_t(m_entries_count));
  assert(m_entries[idx] == pCurr);

  ++idx;

  if (idx >= size_t(m_entries_count)) {
    long long pos;
    long len;

    const long status = Parse(pos, len);

    if (status < 0) {   
      pNext = NULL;
      return status;
    }

    if (status > 0) {
      pNext = NULL;
      return 0;
    }

     assert(m_entries);
     assert(m_entries_count > 0);
     assert(idx < size_t(m_entries_count));
  }
 
  pNext = m_entries[idx];
  assert(pNext);
 
  return 0;
 }
 
long Cluster::GetEntryCount() const { return m_entries_count; }
 
const BlockEntry* Cluster::GetEntry(const Track* pTrack,
                                    long long time_ns) const {
  assert(pTrack);
 
  if (m_pSegment == NULL)   
    return pTrack->GetEOS();
 
 #if 0
 
 

 
 #else
 
  const BlockEntry* pResult = pTrack->GetEOS();
 
  long index = 0;
 
  for (;;) {
    if (index >= m_entries_count) {
      long long pos;
      long len;
 
      const long status = Parse(pos, len);
      assert(status >= 0);
 
      if (status > 0)   
        return pResult;
 
      if (status < 0)   
        return 0;
 
      assert(m_entries);
      assert(index < m_entries_count);
     }
 
    const BlockEntry* const pEntry = m_entries[index];
    assert(pEntry);
    assert(!pEntry->EOS());

    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);

    if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {
      ++index;
      continue;
    }

    if (pTrack->VetEntry(pEntry)) {
      if (time_ns < 0)   
        return pEntry;

      const long long ns = pBlock->GetTime(this);

      if (ns > time_ns)
        return pResult;

      pResult = pEntry;   
    } else if (time_ns >= 0) {
      const long long ns = pBlock->GetTime(this);

      if (ns > time_ns)
        return pResult;
    }

    ++index;
  }

 #endif
 }
 
const BlockEntry* Cluster::GetEntry(const CuePoint& cp,
                                    const CuePoint::TrackPosition& tp) const {
  assert(m_pSegment);
 
 #if 0
 
 

 
 #else
 
  const long long tc = cp.GetTimeCode();
 
  if (tp.m_block > 0) {
    const long block = static_cast<long>(tp.m_block);
    const long index = block - 1;
 
    while (index >= m_entries_count) {
      long long pos;
      long len;
 
      const long status = Parse(pos, len);
 
      if (status < 0)   
        return NULL;
 
      if (status > 0)   
        return NULL;
     }
 
    const BlockEntry* const pEntry = m_entries[index];
    assert(pEntry);
    assert(!pEntry->EOS());
 
    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);
 
    if ((pBlock->GetTrackNumber() == tp.m_track) &&
        (pBlock->GetTimeCode(this) == tc)) {
      return pEntry;
     }
  }

  long index = 0;

  for (;;) {
    if (index >= m_entries_count) {
      long long pos;
      long len;

      const long status = Parse(pos, len);

      if (status < 0)   
        return NULL;

      if (status > 0)   
        return NULL;

      assert(m_entries);
      assert(index < m_entries_count);
    }

    const BlockEntry* const pEntry = m_entries[index];
    assert(pEntry);
    assert(!pEntry->EOS());

    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);

    if (pBlock->GetTrackNumber() != tp.m_track) {
      ++index;
      continue;
    }

    const long long tc_ = pBlock->GetTimeCode(this);

    if (tc_ < tc) {
      ++index;
      continue;
    }

    if (tc_ > tc)
      return NULL;

    const Tracks* const pTracks = m_pSegment->GetTracks();
    assert(pTracks);

    const long tn = static_cast<long>(tp.m_track);
    const Track* const pTrack = pTracks->GetTrackByNumber(tn);

    if (pTrack == NULL)
      return NULL;

    const long long type = pTrack->GetType();

    if (type == 2)   
      return pEntry;

    if (type != 1)   
      return NULL;

    if (!pBlock->IsKey())
      return NULL;

    return pEntry;
  }
 
 #endif
 }
 
 #if 0
 const BlockEntry* Cluster::GetMaxKey(const VideoTrack* pTrack) const
 {
 

 }
 #endif
 
BlockEntry::BlockEntry(Cluster* p, long idx) : m_pCluster(p), m_index(idx) {}
 
BlockEntry::~BlockEntry() {}

bool BlockEntry::EOS() const { return (GetKind() == kBlockEOS); }

const Cluster* BlockEntry::GetCluster() const { return m_pCluster; }

long BlockEntry::GetIndex() const { return m_index; }

SimpleBlock::SimpleBlock(Cluster* pCluster, long idx, long long start,
                         long long size)
    : BlockEntry(pCluster, idx), m_block(start, size, 0) {}

long SimpleBlock::Parse() { return m_block.Parse(m_pCluster); }

BlockEntry::Kind SimpleBlock::GetKind() const { return kBlockSimple; }

const Block* SimpleBlock::GetBlock() const { return &m_block; }

BlockGroup::BlockGroup(Cluster* pCluster, long idx, long long block_start,
                       long long block_size, long long prev, long long next,
                       long long duration, long long discard_padding)
    : BlockEntry(pCluster, idx),
      m_block(block_start, block_size, discard_padding),
      m_prev(prev),
      m_next(next),
      m_duration(duration) {}

long BlockGroup::Parse() {
  const long status = m_block.Parse(m_pCluster);

  if (status)
    return status;

  m_block.SetKey((m_prev > 0) && (m_next <= 0));

  return 0;
 }
 
 #if 0
 void BlockGroup::ParseBlock(long long start, long long size)
 {
 

 }
 #endif
 
BlockEntry::Kind BlockGroup::GetKind() const { return kBlockGroup; }
 
const Block* BlockGroup::GetBlock() const { return &m_block; }
 
long long BlockGroup::GetPrevTimeCode() const { return m_prev; }
 
long long BlockGroup::GetNextTimeCode() const { return m_next; }
 
long long BlockGroup::GetDurationTimeCode() const { return m_duration; }
 
Block::Block(long long start, long long size_, long long discard_padding)
    : m_start(start),
      m_size(size_),
      m_track(0),
      m_timecode(-1),
      m_flags(0),
      m_frames(NULL),
      m_frame_count(-1),
      m_discard_padding(discard_padding) {}
 
Block::~Block() { delete[] m_frames; }
 
long Block::Parse(const Cluster* pCluster) {
  if (pCluster == NULL)
    return -1;
 
  if (pCluster->m_pSegment == NULL)
    return -1;
 
  assert(m_start >= 0);
  assert(m_size >= 0);
  assert(m_track <= 0);
  assert(m_frames == NULL);
  assert(m_frame_count <= 0);
 
  long long pos = m_start;
  const long long stop = m_start + m_size;
 
  long len;
 
  IMkvReader* const pReader = pCluster->m_pSegment->m_pReader;
 
  m_track = ReadUInt(pReader, pos, len);
 
  if (m_track <= 0)
    return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > stop)
    return E_FILE_FORMAT_INVALID;
 
  pos += len;   
 
  if ((stop - pos) < 2)
    return E_FILE_FORMAT_INVALID;
 
  long status;
  long long value;
 
  status = UnserializeInt(pReader, pos, 2, value);
 
  if (status)
    return E_FILE_FORMAT_INVALID;
 
  if (value < SHRT_MIN)
    return E_FILE_FORMAT_INVALID;
 
  if (value > SHRT_MAX)
    return E_FILE_FORMAT_INVALID;
 
  m_timecode = static_cast<short>(value);
 
  pos += 2;
 
  if ((stop - pos) <= 0)
    return E_FILE_FORMAT_INVALID;
 
  status = pReader->Read(pos, 1, &m_flags);
 
  if (status)
    return E_FILE_FORMAT_INVALID;
 
  const int lacing = int(m_flags & 0x06) >> 1;
 
  ++pos;   
 
  if (lacing == 0) {   
    if (pos > stop)
      return E_FILE_FORMAT_INVALID;
 
    m_frame_count = 1;
     m_frames = new Frame[m_frame_count];
 
    Frame& f = m_frames[0];
    f.pos = pos;
 
    const long long frame_size = stop - pos;
 
    if (frame_size > LONG_MAX)
      return E_FILE_FORMAT_INVALID;
 
    f.len = static_cast<long>(frame_size);
 
    return 0;   
  }
 
  if (pos >= stop)
    return E_FILE_FORMAT_INVALID;
 
  unsigned char biased_count;
 
  status = pReader->Read(pos, 1, &biased_count);
 
  if (status)
    return E_FILE_FORMAT_INVALID;
 
  ++pos;   
  assert(pos <= stop);
 
  m_frame_count = int(biased_count) + 1;
 
  m_frames = new Frame[m_frame_count];
  assert(m_frames);
 
  if (lacing == 1) {   
    Frame* pf = m_frames;
    Frame* const pf_end = pf + m_frame_count;
 
    long size = 0;
    int frame_count = m_frame_count;
 
    while (frame_count > 1) {
      long frame_size = 0;
 
      for (;;) {
        unsigned char val;
 
         if (pos >= stop)
          return E_FILE_FORMAT_INVALID;
 
        status = pReader->Read(pos, 1, &val);
 
        if (status)
          return E_FILE_FORMAT_INVALID;
 
        ++pos;   
 
        frame_size += val;
 
        if (val < 255)
          break;
      }
 
      Frame& f = *pf++;
      assert(pf < pf_end);
 
      f.pos = 0;   
 
      f.len = frame_size;
      size += frame_size;   
 
      --frame_count;
     }
 
    assert(pf < pf_end);
    assert(pos <= stop);

    {
      Frame& f = *pf++;

      if (pf != pf_end)
        return E_FILE_FORMAT_INVALID;

      f.pos = 0;   

      const long long total_size = stop - pos;

      if (total_size < size)
        return E_FILE_FORMAT_INVALID;

      const long long frame_size = total_size - size;

      if (frame_size > LONG_MAX)
        return E_FILE_FORMAT_INVALID;

      f.len = static_cast<long>(frame_size);
    }

    pf = m_frames;
    while (pf != pf_end) {
      Frame& f = *pf++;
      assert((pos + f.len) <= stop);

      f.pos = pos;
      pos += f.len;
    }

    assert(pos == stop);
  } else if (lacing == 2) {   
    const long long total_size = stop - pos;

    if ((total_size % m_frame_count) != 0)
      return E_FILE_FORMAT_INVALID;

    const long long frame_size = total_size / m_frame_count;

    if (frame_size > LONG_MAX)
      return E_FILE_FORMAT_INVALID;

    Frame* pf = m_frames;
    Frame* const pf_end = pf + m_frame_count;

    while (pf != pf_end) {
      assert((pos + frame_size) <= stop);

      Frame& f = *pf++;

      f.pos = pos;
      f.len = static_cast<long>(frame_size);

      pos += frame_size;
    }

    assert(pos == stop);
  } else {
    assert(lacing == 3);   

    if (pos >= stop)
      return E_FILE_FORMAT_INVALID;

    long size = 0;
    int frame_count = m_frame_count;

    long long frame_size = ReadUInt(pReader, pos, len);

    if (frame_size < 0)
      return E_FILE_FORMAT_INVALID;

    if (frame_size > LONG_MAX)
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > stop)
      return E_FILE_FORMAT_INVALID;

    pos += len;   

    if ((pos + frame_size) > stop)
      return E_FILE_FORMAT_INVALID;

    Frame* pf = m_frames;
    Frame* const pf_end = pf + m_frame_count;

    {
      Frame& curr = *pf;

      curr.pos = 0;   

      curr.len = static_cast<long>(frame_size);
      size += curr.len;   
    }

    --frame_count;

    while (frame_count > 1) {
      if (pos >= stop)
        return E_FILE_FORMAT_INVALID;

      assert(pf < pf_end);

      const Frame& prev = *pf++;
      assert(prev.len == frame_size);
      if (prev.len != frame_size)
        return E_FILE_FORMAT_INVALID;

      assert(pf < pf_end);

      Frame& curr = *pf;

      curr.pos = 0;   

      const long long delta_size_ = ReadUInt(pReader, pos, len);

      if (delta_size_ < 0)
        return E_FILE_FORMAT_INVALID;

      if ((pos + len) > stop)
        return E_FILE_FORMAT_INVALID;

      pos += len;   
      assert(pos <= stop);

      const int exp = 7 * len - 1;
      const long long bias = (1LL << exp) - 1LL;
      const long long delta_size = delta_size_ - bias;

      frame_size += delta_size;

      if (frame_size < 0)
        return E_FILE_FORMAT_INVALID;

      if (frame_size > LONG_MAX)
        return E_FILE_FORMAT_INVALID;

      curr.len = static_cast<long>(frame_size);
      size += curr.len;   

      --frame_count;
    }

    {
      assert(pos <= stop);
      assert(pf < pf_end);

      const Frame& prev = *pf++;
      assert(prev.len == frame_size);
      if (prev.len != frame_size)
        return E_FILE_FORMAT_INVALID;

      assert(pf < pf_end);

      Frame& curr = *pf++;
      assert(pf == pf_end);

      curr.pos = 0;   

      const long long total_size = stop - pos;

      if (total_size < size)
        return E_FILE_FORMAT_INVALID;

      frame_size = total_size - size;

      if (frame_size > LONG_MAX)
        return E_FILE_FORMAT_INVALID;

      curr.len = static_cast<long>(frame_size);
    }

    pf = m_frames;
    while (pf != pf_end) {
      Frame& f = *pf++;
      assert((pos + f.len) <= stop);

      f.pos = pos;
      pos += f.len;
    }

    assert(pos == stop);
  }

  return 0;   
 }
 
long long Block::GetTimeCode(const Cluster* pCluster) const {
  if (pCluster == 0)
    return m_timecode;
 
  const long long tc0 = pCluster->GetTimeCode();
  assert(tc0 >= 0);
 
  const long long tc = tc0 + m_timecode;
 
  return tc;   
 }
 
long long Block::GetTime(const Cluster* pCluster) const {
  assert(pCluster);
 
  const long long tc = GetTimeCode(pCluster);
 
  const Segment* const pSegment = pCluster->m_pSegment;
  const SegmentInfo* const pInfo = pSegment->GetInfo();
  assert(pInfo);
 
  const long long scale = pInfo->GetTimeCodeScale();
  assert(scale >= 1);
 
  const long long ns = tc * scale;
 
  return ns;
 }
 
long long Block::GetTrackNumber() const { return m_track; }
 
bool Block::IsKey() const {
  return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);
 }
 
void Block::SetKey(bool bKey) {
  if (bKey)
    m_flags |= static_cast<unsigned char>(1 << 7);
  else
    m_flags &= 0x7F;
 }
 
bool Block::IsInvisible() const { return bool(int(m_flags & 0x08) != 0); }
 
Block::Lacing Block::GetLacing() const {
  const int value = int(m_flags & 0x06) >> 1;
  return static_cast<Lacing>(value);
 }
 
int Block::GetFrameCount() const { return m_frame_count; }
 
const Block::Frame& Block::GetFrame(int idx) const {
  assert(idx >= 0);
  assert(idx < m_frame_count);

  const Frame& f = m_frames[idx];
  assert(f.pos > 0);
  assert(f.len > 0);

  return f;
 }
 
long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const {
  assert(pReader);
  assert(buf);
 
  const long status = pReader->Read(pos, len, buf);
  return status;
 }
 
long long Block::GetDiscardPadding() const { return m_discard_padding; }
 
}   
","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
2474,CVE-2016-0838," 

  *------------------------------------
 */
 #include ""log/log.h""
#include <cutils/log.h>
 
 #include ""eas_types.h""
 #include ""eas_math.h""
 

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
        android_errorWriteLog(0x534e4554, ""26366256"");
         return;
     }
     pMixBuffer = pWTIntFrame->pMixBuffer;
 

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
        android_errorWriteLog(0x534e4554, ""26366256"");
         return;
     }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
        android_errorWriteLog(0x534e4554, ""26366256"");
         return;
     }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
        android_errorWriteLog(0x534e4554, ""26366256"");
         return;
     }
     pAudioBuffer = pWTIntFrame->pAudioBuffer;
 

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
        android_errorWriteLog(0x534e4554, ""26366256"");
         return;
     }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 

     numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
        android_errorWriteLog(0x534e4554, ""26366256"");
         return;
     }
     pMixBuffer = pWTIntFrame->pMixBuffer;
","Sonivox in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for a negative number of samples, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to arm-wt-22k/lib_src/eas_wtengine.c and arm-wt-22k/lib_src/eas_wtsynth.c, aka internal bug 26366256."
2475,CVE-2016-0835," 

 *
 *  Values Returned : None
 *******************************************************************************/
WORD32  impeg2d_dec_p_mb_params(dec_state_t *ps_dec)
 {
     stream_t *ps_stream = &ps_dec->s_bit_stream;
     UWORD16 u2_mb_addr_incr;
 

         ps_dec->e_mb_pred         = (e_pred_direction_t)refPic;
         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];
         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
        if(NULL == ps_dec_mb_params->pf_func_mb_params)
            return -1;
         ps_dec_mb_params->pf_func_mb_params(ps_dec);
 
     }
 

             ps_dec->u2_cbp  = 0;
         }
     }
    return 0;
 }
 
 
 

 *
 *  Values Returned : None
 *******************************************************************************/
WORD32 impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)
 {
     stream_t *ps_stream = &ps_dec->s_bit_stream;
     UWORD16 u2_mb_addr_incr;
 

         ps_dec->e_mb_pred         = BIDIRECT;
         ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];
         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
        if(NULL == ps_dec_mb_params->pf_func_mb_params)
            return -1;
         ps_dec_mb_params->pf_func_mb_params(ps_dec);
     }
     else if(u2_mb_type & MB_FORW_OR_BACK)
 

         ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;
         ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];
         ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
        if(NULL == ps_dec_mb_params->pf_func_mb_params)
            return -1;
         ps_dec_mb_params->pf_func_mb_params(ps_dec);
 
     }
 

             ps_dec->u2_cbp  = 0;
         }
     }
    return 0;
 }
 
 /*******************************************************************************
 

     do
     {
         UWORD32 u4_x_offset, u4_y_offset;
        WORD32 ret;
 
 
         UWORD32 u4_x_dst_offset = 0;
 

 
 
         if(ps_dec->e_pic_type == B_PIC)
            ret = impeg2d_dec_pnb_mb_params(ps_dec);
         else
            ret = impeg2d_dec_p_mb_params(ps_dec);
 
        if(ret)
            return IMPEG2D_MB_TEX_DECODE_ERR;
         IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);
 
         u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);
","decoder/impeg2d_dec_hdr.c in mediaserver in Android 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a certain negative value, aka internal bug 26070014."
2476,CVE-2017-0551," 

 
     ps_dec->i4_frametype = -1;
     ps_dec->i4_content_type = -1;

     ps_dec->u4_slice_start_code_found = 0;
 
      
             ret = ih264d_deblock_display(ps_dec);
         }
 
 
 

         }
     }
 
    if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
    {
        ps_dec->u1_top_bottom_decoded = 0;
    }
     
     
     
     
    if(ps_dec->u4_pic_buf_got == 1)
    {
        if(1 == ps_dec->u1_last_pic_not_decoded)
        {
            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);

            if(ret != OK)
                return ret;

            ret = ih264d_end_of_pic(ps_dec);
            if(ret != OK)
                return ret;
        }
        else
        {
            ret = ih264d_end_of_pic(ps_dec);
            if(ret != OK)
                return ret;
        }

    }


      
     DATA_SYNC();
 
","A remote denial of service vulnerability in libavc in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34097231."
2477,CVE-2017-0402," 

     case EQ_PARAM_BAND_LEVEL:
 	ALOGV(""%s: EQ_PARAM_BAND_LEVEL"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32438598"");
                ALOGW(""\tERROR EQ_PARAM_BAND_LEVEL band %d"", param2);
            }
             break;
         }
         *(int16_t *)value = (int16_t)equalizer_get_band_level(eq_ctxt, param2);
 

     case EQ_PARAM_CENTER_FREQ:
 	ALOGV(""%s: EQ_PARAM_CENTER_FREQ"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
            p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32436341"");
                ALOGW(""\tERROR EQ_PARAM_CENTER_FREQ band %d"", param2);
            }
             break;
         }
         *(int32_t *)value = equalizer_get_center_frequency(eq_ctxt, param2);
 

     case EQ_PARAM_BAND_FREQ_RANGE:
 	ALOGV(""%s: EQ_PARAM_BAND_FREQ_RANGE"", __func__);
         param2 = *param_tmp;
        if (param2 < 0 || param2 >= NUM_EQ_BANDS) {
             p->status = -EINVAL;
            if (param2 < 0) {
                android_errorWriteLog(0x534e4554, ""32247948"");
                ALOGW(""\tERROR EQ_PARAM_BAND_FREQ_RANGE band %d"", param2);
            }
            break;
         }
        equalizer_get_band_freq_range(eq_ctxt, param2, (uint32_t *)value,
","An information disclosure vulnerability in lvm/wrapper/Bundle/EffectBundle.cpp in libeffects in Audioserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32436341."
2478,CVE-2018-9503," 

   uint8_t ea, cr, mx_len;
   bool is_command;
 
  if (length < 2) {
    RFCOMM_TRACE_ERROR(
        ""%s: Illegal MX Frame len when reading EA, C/R. len:%d < 2"", __func__,
        length);
    android_errorWriteLog(0x534e4554, ""111937065"");
    osi_free(p_buf);
    return;
  }
   p_rx_frame->ea = *p_data & RFCOMM_EA;
   p_rx_frame->cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;
   p_rx_frame->type = *p_data++ & ~(RFCOMM_CR_MASK | RFCOMM_EA_MASK);
 

   length--;
 
   if (!ea) {
    if (length < 1) {
      RFCOMM_TRACE_ERROR(""%s: Illegal MX Frame when EA = 0. len:%d < 1"",
                         __func__, length);
      android_errorWriteLog(0x534e4554, ""111937065"");
      osi_free(p_buf);
      return;
    }
     mx_len += *p_data++ << RFCOMM_SHIFT_LENGTH2;
     length--;
   }
 

       return;
 
     case RFCOMM_MX_MSC:
      if (length != RFCOMM_MX_MSC_LEN_WITH_BREAK &&
          length != RFCOMM_MX_MSC_LEN_NO_BREAK) {
        RFCOMM_TRACE_ERROR(""%s: Illegal MX MSC Frame len:%d"", __func__, length);
        android_errorWriteLog(0x534e4554, ""111937065"");
        osi_free(p_buf);
        return;
      }
       ea = *p_data & RFCOMM_EA;
       cr = (*p_data & RFCOMM_CR_MASK) >> RFCOMM_SHIFT_CR;
       p_rx_frame->dlci = *p_data++ >> RFCOMM_SHIFT_DLCI;
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-80432928"
2479,CVE-2018-9503," 

     (pf) = (*(p_data)++ & RFCOMM_PF_MASK) >> RFCOMM_PF_OFFSET; \
   }
 
 #define RFCOMM_FRAME_IS_CMD(initiator, cr) \
   (((initiator) && !(cr)) || (!(initiator) && (cr)))
 
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-80432928"
2480,CVE-2018-9503," 

 
   eal = *(p_data)&RFCOMM_EA;
   len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;
  if (eal == 0 && p_buf->len > RFCOMM_CTRL_FRAME_LEN) {
     len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);
   } else if (eal == 0) {
     RFCOMM_TRACE_ERROR(""Bad Length when EAL = 0: %d"", p_buf->len);
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-80432928"
2481,CVE-2018-9503," 

 
   eal = *(p_data)&RFCOMM_EA;
   len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;
  if (eal == 0 && p_buf->len > RFCOMM_CTRL_FRAME_LEN) {
     len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);
   } else if (eal == 0) {
     RFCOMM_TRACE_ERROR(""Bad Length when EAL = 0: %d"", p_buf->len);
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-80432928"
2482,CVE-2018-9502," 

     (pf) = (*(p_data)++ & RFCOMM_PF_MASK) >> RFCOMM_PF_OFFSET; \
   }
 
 #define RFCOMM_FRAME_IS_CMD(initiator, cr) \
   (((initiator) && !(cr)) || (!(initiator) && (cr)))
 
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out-of-bounds read due to a missing bounds check. This could lead to remote information disclosure in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111936792"
2483,CVE-2018-9502," 

 
   eal = *(p_data)&RFCOMM_EA;
   len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1;
  if (eal == 0 && p_buf->len > RFCOMM_CTRL_FRAME_LEN) {
     len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2);
   } else if (eal == 0) {
     RFCOMM_TRACE_ERROR(""Bad Length when EAL = 0: %d"", p_buf->len);
","In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out-of-bounds read due to a missing bounds check. This could lead to remote information disclosure in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111936792"
2484,,"  const wchar_t kDocRoot[] = L""chrome/test/data"";
 class SessionHistoryTest : public UITest {
  protected:
   SessionHistoryTest() : UITest() {
   }
 
   virtual void SetUp() {
  class SessionHistoryTest : public UITest {
   }
 
  protected:
   scoped_refptr<BrowserProxy> window_;
   scoped_refptr<TabProxy> tab_;
 };
  TEST_F(SessionHistoryTest, HistorySearchXSS) {
   EXPECT_EQ(L""History"", GetTabTitle());
 }
 
TEST_F(SessionHistoryTest, LocationChangeInSubframe) {
  scoped_refptr<HTTPTestServer> server =
      HTTPTestServer::CreateServer(kDocRoot, NULL);
  ASSERT_TRUE(server.get());

  ASSERT_TRUE(tab_->NavigateToURL(server->TestServerPage(
      ""files/session_history/location_redirect.html"")));
  EXPECT_EQ(L""Default Title"", GetTabTitle());

  ASSERT_TRUE(tab_->NavigateToURL(GURL(
      ""javascript:void(frames[0].navigate())"")));
  EXPECT_EQ(L""foo"", GetTabTitle());

  ASSERT_TRUE(tab_->GoBack());
  EXPECT_EQ(L""Default Title"", GetTabTitle());
}

 }   ",
2485,," 
 #include ""chrome/browser/webdata/autofill_profile_syncable_service.h""
 #include ""chrome/browser/webdata/web_data_service.h""
 #include ""chrome/common/chrome_switches.h""
#include ""chrome/common/chrome_version_info.h""
 #include ""chrome/common/pref_names.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""sync/api/syncable_service.h""
  void ProfileSyncComponentsFactoryImpl::RegisterDesktopDataTypes(
 
    
    
  chrome::VersionInfo::Channel channel = chrome::VersionInfo::GetChannel();
  if (!command_line_->HasSwitch(switches::kDisableSyncSyncedNotifications)) {
    if (channel == chrome::VersionInfo::CHANNEL_UNKNOWN ||
        channel == chrome::VersionInfo::CHANNEL_CANARY ||
        channel == chrome::VersionInfo::CHANNEL_DEV) {
      pss->RegisterDataTypeController(
          new UIDataTypeController(
              syncer::SYNCED_NOTIFICATIONS, this, profile_, pss));
    }
   }
 
 #if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_CHROMEOS)",
2486,,"  TEST(Snippets, UTF8) {
             UTF16ToUTF8(BuildSnippet(kSampleDocument, ""relationship"")));
 }
 
TEST(Snippets, ThaiUTF8) {
    
    
    
    
    
    
   ASSERT_EQ("" ... ""
            ""\xE0\xB8\xA3\xE0\xB8\xA7\xE0\xB8\x9A\xE0\xB8\xA3\xE0\xB8\xA7""
            ""\xE0\xB8\xA1 \xE0\xB8\x82\xE0\xB9\x89\xE0\xB8\xAD\xE0\xB8""
            ""\xA1\xE0\xB8\xB9\xE0\xB8\xA5\xE0\xB8\xAA\xE0\xB9\x88\xE0\xB8""
            ""\xA7\xE0\xB8\x99\xE0\xB8\x9A\xE0\xB8\xB8\xE0\xB8\x84\xE0\xB8""
            ""\x84\xE0\xB8\xA5 \xE0\xB9\x80\xE0\xB8\xA1\xE0\xB8\xB7\xE0""
            ""\xB9\x88\xE0\xB8\xAD\xE0\xB8\x84\xE0\xB8\xB8\xE0\xB8\x93\xE0""
            ""\xB8\xA5\xE0\xB8\x87\xE0\xB8\x97\xE0\xB8\xB0\xE0\xB9\x80\xE0""
            ""\xB8\x9A\xE0\xB8\xB5\xE0\xB8\xA2\xE0\xB8\x99\xE0\xB9\x80\xE0""
            ""\xB8\x9E\xE0\xB8\xB7\xE0\xB9\x88\xE0\xB8\xAD\xE0\xB9\x83\xE0""
            ""\xB8\x8A\xE0\xB9\x89\xE0\xB8\x9A\xE0\xB8\xA3\xE0\xB8\xB4\xE0""
            ""\xB8\x81\xE0\xB8\xB2\xE0\xB8\xA3\xE0\xB8\x82\xE0\xB8\xAD\xE0""
            ""\xB8\x87 Google \xE0\xB8\xAB\xE0\xB8\xA3\xE0\xB8\xB7\xE0\xB8""
            ""\xAD**\xE0\xB9\x83\xE0\xB8\xAB\xE0\xB9\x89**\xE0\xB8\x82\xE0""
            ""\xB9\x89\xE0\xB8\xAD\xE0\xB8\xA1\xE0\xB8\xB9\xE0\xB8\xA5\xE0""
            ""\xB8\x94\xE0\xB8\xB1\xE0\xB8\x87\xE0\xB8\x81\xE0\xB8\xA5\xE0""
            ""\xB9\x88\xE0\xB8\xB2\xE0\xB8\xA7\xE0\xB9\x82\xE0\xB8\x94\xE0""
            ""\xB8\xA2\xE0\xB8\xAA\xE0\xB8\xA1\xE0\xB8\xB1\xE0\xB8\x84\xE0""
            ""\xB8\xA3\xE0\xB9\x83\xE0\xB8\x88 \xE0\xB9\x80\xE0\xB8\xA3""
            ""\xE0\xB8\xB2\xE0\xB8\xAD\xE0\xB8\xB2\xE0\xB8\x88\xE0\xB8\xA3""
            ""\xE0\xB8\xA7\xE0\xB8\xA1\xE0\xB8\x82\xE0\xB9\x89\xE0\xB8\xAD""
            ""\xE0\xB8\xA1\xE0\xB8\xB9\xE0\xB8\xA5\xE0\xB8\xAA\xE0\xB9\x88""
            ""\xE0\xB8\xA7\xE0\xB8\x99\xE0\xB8\x9A\xE0\xB8\xB8\xE0\xB8\x84""
            ""\xE0\xB8\x84\xE0\xB8\xA5\xE0\xB8\x97\xE0\xB8\xB5\xE0\xB9\x88""
            ""\xE0\xB9\x80\xE0\xB8\x81\xE0\xB9\x87\xE0\xB8\x9A\xE0\xB8\xA3""
            ""\xE0\xB8\xA7\xE0\xB8\x9A\xE0\xB8\xA3\xE0\xB8\xA7\xE0\xB8\xA1""
             ""\xE0\xB8\x88\xE0\xB8\xB2\xE0\xB8\x81\xE0\xB8\x84\xE0\xB8\xB8""
             ""\xE0\xB8\x93\xE0\xB9\x80\xE0\xB8\x82\xE0\xB9\x89\xE0\xB8\xB2""
            ""\xE0\xB8\x81\xE0\xB8\xB1\xE0\xB8\x9A ...  ... \xE0\xB8\x82""
            ""\xE0\xB9\x89\xE0\xB8\xAD\xE0\xB8\xA1\xE0\xB8\xB9\xE0\xB8\xA5""
            ""\xE0\xB8\x88\xE0\xB8\xB2\xE0\xB8\x81\xE0\xB8\x9A\xE0\xB8\xA3""
            ""\xE0\xB8\xB4\xE0\xB8\x81\xE0\xB8\xB2\xE0\xB8\xA3\xE0\xB8\xAD""
            ""\xE0\xB8\xB7\xE0\xB9\x88\xE0\xB8\x99\xE0\xB8\x82\xE0\xB8\xAD""
            ""\xE0\xB8\x87 Google \xE0\xB8\xAB\xE0\xB8\xA3\xE0\xB8\xB7\xE0""
            ""\xB8\xAD\xE0\xB8\x9A\xE0\xB8\xB8\xE0\xB8\x84\xE0\xB8\x84\xE0""
            ""\xB8\xA5\xE0\xB8\x97\xE0\xB8\xB5\xE0\xB9\x88\xE0\xB8\xAA\xE0""
            ""\xB8\xB2\xE0\xB8\xA1 \xE0\xB9\x80\xE0\xB8\x9E\xE0\xB8\xB7""
            ""\xE0\xB9\x88\xE0\xB8\xAD**\xE0\xB9\x83\xE0\xB8\xAB\xE0\xB9""
            ""\x89**\xE0\xB8\x9C\xE0\xB8\xB9\xE0\xB9\x89\xE0\xB9\x83\xE0""
            ""\xB8\x8A\xE0\xB9\x89\xE0\xB9\x84\xE0\xB8\x94\xE0\xB9\x89\xE0""
            ""\xB8\xA3\xE0\xB8\xB1\xE0\xB8\x9A\xE0\xB8\x9B\xE0\xB8\xA3\xE0""
            ""\xB8\xB0\xE0\xB8\xAA\xE0\xB8\x9A\xE0\xB8\x81\xE0\xB8\xB2\xE0""
            ""\xB8\xA3\xE0\xB8\x93\xE0\xB9\x8C\xE0\xB8\x97\xE0\xB8\xB5\xE0""
            ""\xB9\x88\xE0\xB8\x94\xE0\xB8\xB5\xE0\xB8\x82\xE0\xB8\xB6\xE0""
            ""\xB9\x89\xE0\xB8\x99 \xE0\xB8\xA3\xE0\xB8\xA7\xE0\xB8\xA1""
            ""\xE0\xB8\x97\xE0\xB8\xB1\xE0\xB9\x89\xE0\xB8\x87\xE0\xB8\x9B""
            ""\xE0\xB8\xA3\xE0\xB8\xB1\xE0\xB8\x9A\xE0\xB9\x81\xE0\xB8\x95""
            ""\xE0\xB9\x88\xE0\xB8\x87\xE0\xB9\x80\xE0\xB8\x99\xE0\xB8\xB7""
            ""\xE0\xB9\x89\xE0\xB8\xAD\xE0\xB8\xAB\xE0\xB8\xB2"",
             UTF16ToUTF8(BuildSnippet(kThaiSample,
                                      ""\xE0\xB9\x83\xE0\xB8\xAB\xE0\xB9\x89"")));
 }",
2487,,"  void PageClickTracker::RemoveListener(PageClickListener* listener) {
 void PageClickTracker::handleEvent(const WebDOMEvent& event) {
   last_node_clicked_.reset();
 
  if (!event.isMouseEvent())
    return;

   const WebDOMMouseEvent mouse_event = event.toConst<WebDOMMouseEvent>();
   DCHECK(mouse_event.buttonDown());
   if (mouse_event.button() != 0)",
2488,,"  void AutoFillManager::FormSubmitted(const FormData& form) {
   if (tab_contents_->profile()->IsOffTheRecord())
     return;
 
   
  if (!form.user_submitted)
    return;

    
   upload_form_structure_.reset(new FormStructure(form));
 ",
2489,,"  TEST_F(AutocompleteHistoryManagerTest, CreditCardNumberValue) {
   form.method = ASCIIToUTF16(""POST"");
   form.origin = GURL(""http://myform.com/form.html"");
   form.action = GURL(""http://myform.com/submit.html"");
  form.user_submitted = true;
 
    
   webkit_glue::FormField valid_cc(ASCIIToUTF16(""Credit Card""),
  TEST_F(AutocompleteHistoryManagerTest, NonCreditCardNumberValue) {
   form.method = ASCIIToUTF16(""POST"");
   form.origin = GURL(""http://myform.com/form.html"");
   form.action = GURL(""http://myform.com/submit.html"");
  form.user_submitted = true;
 
    
   webkit_glue::FormField invalid_cc(ASCIIToUTF16(""Credit Card""),
  TEST_F(AutocompleteHistoryManagerTest, SSNValue) {
   form.method = ASCIIToUTF16(""POST"");
   form.origin = GURL(""http://myform.com/form.html"");
   form.action = GURL(""http://myform.com/submit.html"");
  form.user_submitted = true;
 
   webkit_glue::FormField ssn(ASCIIToUTF16(""Social Security Number""),
                              ASCIIToUTF16(""ssn""),",
2490,,"  void AutoFillHelper::FrameWillClose(WebFrame* frame) {
   form_manager_.ResetFrame(frame);
 }
 
void AutoFillHelper::FrameDetached(WebFrame* frame) {
  form_manager_.ResetFrame(frame);
}

 void AutoFillHelper::QueryAutoFillFormData(const WebNode& node,
                                            const WebString& value,
                                            const WebString& label,",
2491,,"  AutoFillCCInfoBarDelegate::AutoFillCCInfoBarDelegate(TabContents* tab_contents,
                                                      AutoFillManager* host)
     : ConfirmInfoBarDelegate(tab_contents),
       host_(host) {
 }
 
 AutoFillCCInfoBarDelegate::~AutoFillCCInfoBarDelegate() {
  void AutoFillCCInfoBarDelegate::InfoBarClosed() {
     host_->OnInfoBarClosed(false);
     host_ = NULL;
   }
  delete this;
 }
 
 string16 AutoFillCCInfoBarDelegate::GetMessageText() const {",
2492,,"  void WebSocketExperimentRunner::InitConfig() {
 void WebSocketExperimentRunner::DoLoop() {
   if (next_state_ == STATE_NONE) {
     if (task_.get()) {
      AddRef();   
       task_->Cancel();
     }
     return;
  void WebSocketExperimentRunner::DoLoop() {
 }
 
 void WebSocketExperimentRunner::OnTaskCompleted(int result) {
  if (next_state_ == STATE_NONE) {
     task_.reset();
      
     DLOG(INFO) << ""WebSocketExperiment Task is canceled."";",
2493,,"  int ChromeMain(int argc, char** argv) {
       if (process_type == switches::kRendererProcess ||
           process_type == switches::kExtensionProcess) {
         rv = RendererMain(main_params);
#if !defined(DISABLE_NACL)
       } else if (process_type == switches::kNaClLoaderProcess) {
         rv = NaClMain(main_params);
 #endif
      } else if (process_type == switches::kWorkerProcess) {
        rv = WorkerMain(main_params);
       } else {
        NOTREACHED() << ""Unknown process type: "" << process_type;
       }
     } else {
       rv = 0;",
2494,,"  class EnvironmentImpl : public base::Environment {
   bool SetVarImpl(const char* variable_name, const std::string& new_value) {
 #if defined(OS_POSIX)
      
    return !setenv(variable_name, new_value.c_str(), 1);
 #elif defined(OS_WIN)
     
    return !!SetEnvironmentVariable(UTF8ToWide(variable_name).c_str(),
                                    UTF8ToWide(new_value).c_str());
 #endif
   }
 
   bool UnSetVarImpl(const char* variable_name) {
 #if defined(OS_POSIX)
      
    return !unsetenv(variable_name);
 #elif defined(OS_WIN)
     
    return !!SetEnvironmentVariable(UTF8ToWide(variable_name).c_str(), NULL);
 #endif
   }
 };",
2495,,"  gfx::Point ImageView::ComputeImageOrigin(const gfx::Size& image_size) const {
 void ImageView::Paint(gfx::Canvas* canvas) {
   View::Paint(canvas);
 
  if (image_.empty())
    return;

   gfx::Rect image_bounds(GetImageBounds());
   if (image_bounds.IsEmpty())
     return;",
2496,,"  TEST_F(ManifestTest, AppWebPaths) {
                          errors::kInvalidWebPath, ""0""));
 }
 
TEST_F(ManifestTest, AppLaunchContainer) {
   scoped_ptr<Extension> extension;
 
   extension.reset(LoadAndExpectSuccess(""launch_tab.json""));",
2497,,"  TEST_F(SearchProviderTest, QueryKeywordProvider) {
 TEST_F(SearchProviderTest, DontSendPrivateDataToSuggest) {
    
    
  const char* inputs[] = {
     ""username:password"",
     ""http://username:password"",
     ""https://username:password"",",
2498,,"  const LanguageMultipleChoicePreference<int> kChewingHsuSelKeyType = {
  
 const char kHangulSectionName[] = ""engine/Hangul"";
 const char kHangulKeyboardConfigName[] = ""HangulKeyboard"";
const char kHangulHanjaKeysConfigName[] = ""HanjaKeys"";
 
 
 
 
const char kHangulHanjaKeys[] = ""F9,Hangul_Hanja,Control+Alt+9"";
 
 const struct HangulKeyboardNameIDPair {
   int message_id;",
2499,," 
 namespace o3d {
 namespace gpu2d {
 
 
 
 
 
 
 
 
  
  
  
  class Interval {
       return false;
     if (high < this->low())
       return false;
     return true;
   }
 
  class IntervalTree : public RedBlackTree<Interval<T, UserData> > {
      
     IntervalNode* left = node->left();
     if (left != NULL &&
         
         
        !(left->data().max_high() < interval.low())) {
       SearchForOverlapsFrom(left, interval, res);
     }
 
  class IntervalTree : public RedBlackTree<Interval<T, UserData> > {
     }
 
      
     
     
    if (!(interval.high() < node->data().low())) {
       SearchForOverlapsFrom(node->right(), interval, res);
     }
   }",
2500,,"  bool AeroPeekManager::GetTabPreview(int tab_id, SkBitmap* preview) {
    
    
   skia::PlatformCanvas canvas;
  if (!backing_store->CopyFromBackingStore(gfx::Rect(backing_store->size()),
                                            &canvas))
     return false;
 ",
2501,," 
  
  
 
 

 #include ""chrome/browser/extensions/extension_cookies_api.h""
 
 #include ""chrome/browser/browser_list.h""
 
 #include ""chrome/common/net/url_request_context_getter.h""
 #include ""net/base/cookie_monster.h""
 
 namespace keys = extension_cookies_api_constants;
 
bool CookiesFunction::ParseUrl(const DictionaryValue* details, GURL* url,
                               bool check_host_permissions) {
   DCHECK(details && url);
   std::string url_string;
   
   EXTENSION_FUNCTION_VALIDATE(details->GetString(keys::kUrlKey, &url_string));
   *url = GURL(url_string);
   if (!url->is_valid()) {
     error_ = ExtensionErrorUtils::FormatErrorMessage(
         keys::kInvalidUrlError, url_string);
     return false;
   }
   
  if (check_host_permissions &&
      !GetExtension()->HasHostPermission(*url)) {
    error_ = ExtensionErrorUtils::FormatErrorMessage(
        keys::kNoHostPermissionsError, url->spec());
    return false;
  }
   return true;
 }
 
  bool CookiesFunction::ParseCookieStore(const DictionaryValue* details,
   DCHECK(details && (store || store_id));
   Profile* store_profile = NULL;
   if (details->HasKey(keys::kStoreIdKey)) {
     
     
     std::string store_id_value;
     
     EXTENSION_FUNCTION_VALIDATE(
         details->GetString(keys::kStoreIdKey, &store_id_value));
    store_profile = extension_cookies_helpers::ChooseProfileFromStoreId(
         store_id_value, profile(), include_incognito());
     if (!store_profile) {
       error_ = ExtensionErrorUtils::FormatErrorMessage(
           keys::kInvalidStoreIdError, store_id_value);
       return false;
     }
   } else {
     
     
      
     Browser* current_browser = GetCurrentBrowser();
     if (!current_browser) {
  bool CookiesFunction::ParseCookieStore(const DictionaryValue* details,
   if (store)
     *store = store_profile->GetRequestContext()->GetCookieStore();
   if (store_id)
    *store_id =
        extension_cookies_helpers::GetStoreIdFromProfile(store_profile);
   return true;
 }
 
 bool GetCookieFunction::RunImpl() {
   
   DictionaryValue* details;
   EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(0, &details));
   DCHECK(details);
 
    
   GURL url;
  if (!ParseUrl(details, &url, true))
     return false;
 
   std::string name;
   
   EXTENSION_FUNCTION_VALIDATE(details->GetString(keys::kNameKey, &name));
 
   net::CookieStore* cookie_store;
  bool GetCookieFunction::RunImpl() {
     return false;
   DCHECK(cookie_store && !store_id.empty());
 
  net::CookieMonster::CookieList cookie_list =
      extension_cookies_helpers::GetCookieListFromStore(cookie_store, url);
   net::CookieMonster::CookieList::iterator it;
   for (it = cookie_list.begin(); it != cookie_list.end(); ++it) {
     
      
     const net::CookieMonster::CanonicalCookie& cookie = it->second;
     if (cookie.Name() == name) {
      result_.reset(
          extension_cookies_helpers::CreateCookieValue(*it, store_id));
       return true;
     }
   }
  bool GetCookieFunction::RunImpl() {
 }
 
 bool GetAllCookiesFunction::RunImpl() {
   
   DictionaryValue* details;
   EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(0, &details));
  DCHECK(details);
 
    
   GURL url;
  if (details->HasKey(keys::kUrlKey) && !ParseUrl(details, &url, false))
     return false;
 
   net::CookieStore* cookie_store;
  bool GetAllCookiesFunction::RunImpl() {
   DCHECK(cookie_store);
 
   ListValue* matching_list = new ListValue();
  extension_cookies_helpers::AppendMatchingCookiesToList(
      cookie_store, store_id, url, details, GetExtension(), matching_list);
   result_.reset(matching_list);
   return true;
 }
 
 bool SetCookieFunction::RunImpl() {
   
   DictionaryValue* details;
   EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(0, &details));
  DCHECK(details);
 
    
   GURL url;
  if (!ParseUrl(details, &url, true))
       return false;
   
   std::string name;
   if (details->HasKey(keys::kNameKey)) {
     EXTENSION_FUNCTION_VALIDATE(details->GetString(keys::kNameKey, &name));
  bool SetCookieFunction::RunImpl() {
   DCHECK(cookie_store);
 
   if (!cookie_store->GetCookieMonster()->SetCookieWithDetails(
          url, name, value, domain, path, expiration_time, secure,
          http_only)) {
     error_ = ExtensionErrorUtils::FormatErrorMessage(
         keys::kCookieSetFailedError, name);
     return false;
  bool SetCookieFunction::RunImpl() {
 }
 
 bool RemoveCookieFunction::RunImpl() {
   
   DictionaryValue* details;
   EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(0, &details));
  DCHECK(details);
 
    
   GURL url;
  if (!ParseUrl(details, &url, true))
     return false;
 
   std::string name;
   
   EXTENSION_FUNCTION_VALIDATE(details->GetString(keys::kNameKey, &name));
 
   net::CookieStore* cookie_store;
  bool GetAllCookieStoresFunction::RunImpl() {
     if (incognito_profile)
       incognito_tab_ids.reset(new ListValue());
   }
   
   
   
   for (BrowserList::const_iterator iter = BrowserList::begin();
        iter != BrowserList::end(); ++iter) {
     Browser* browser = *iter;
     if (browser->profile() == original_profile) {
      extension_cookies_helpers::AppendToTabIdList(browser,
                                                   original_tab_ids.get());
     } else if (incognito_tab_ids.get() &&
                browser->profile() == incognito_profile) {
      extension_cookies_helpers::AppendToTabIdList(browser,
                                                   incognito_tab_ids.get());
     }
   }
   
   ListValue* cookie_store_list = new ListValue();
   if (original_tab_ids->GetSize() > 0) {
    cookie_store_list->Append(
        extension_cookies_helpers::CreateCookieStoreValue(
            original_profile, original_tab_ids.release()));
   }
   if (incognito_tab_ids.get() && incognito_tab_ids->GetSize() > 0) {
    cookie_store_list->Append(
        extension_cookies_helpers::CreateCookieStoreValue(
            incognito_profile, incognito_tab_ids.release()));
   }
   result_.reset(cookie_store_list);
   return true;",
2502,,"  net::WebSocket* WebSocketExperimentTask::Context::CreateWebSocket(
                                   config.ws_protocol,
                                   config.ws_origin,
                                   config.ws_location,
                                  net::WebSocket::DRAFT75,
                                   getter->GetURLRequestContext()));
   return new net::WebSocket(request, delegate);
 }",
2503,,"  void USBMountObserver::MountChanged(chromeos::MountLibrary* obj,
   } else if (evt == chromeos::DISK_CHANGED) {
     BrowserIterator iter = FindBrowserForPath(path);
     LOG(INFO) << ""Got changed mount:"" << path;
    if (iter == browsers_.end()) {
        
        
       const chromeos::MountLibrary::DiskVector& disks = obj->disks();",
2504,,"  GtkWidget* PageInfoWindowGtk::CreateSection(
   label = gtk_label_new(UTF16ToUTF8(section.description).c_str());
   gtk_misc_set_alignment(GTK_MISC(label), 0, 0);
   gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);
   
   
  gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);
   gtk_box_pack_start(GTK_BOX(text_box), label, FALSE, FALSE, 0);
   gtk_widget_set_size_request(label, 400, -1);
 ",
2505,,"  ResourceDispatcherHost::~ResourceDispatcherHost() {
   STLDeleteValues(&pending_requests_);
 
   user_script_listener_->ShutdownMainThread();
 }
 
 void ResourceDispatcherHost::Initialize() {
  void ResourceDispatcherHost::OnShutdown() {
    
    
   update_load_states_timer_.Stop();

   
   
   
   
  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
     
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
 }
 
 bool ResourceDispatcherHost::HandleExternalProtocol(int request_id,",
2506,," 
 #include <gtk/gtkpagesetupunixdialog.h>
 
 #include ""base/file_util.h""
#include ""base/lazy_instance.h""
#include ""base/lock.h""
 #include ""base/logging.h""
 #include ""chrome/browser/browser_list.h""
 #include ""chrome/browser/browser_window.h""
 
 
 namespace {
 
PrintDialogGtk* g_print_dialog = NULL;

 
Lock& DialogLock() {
  static base::LazyInstance<Lock> dialog_lock(base::LINKER_INITIALIZED);
  return dialog_lock.Get();
}

  
  
 class PdfUnsupportedInfoBarDelegate : public LinkInfoBarDelegate {
  void PrintDialogGtk::CreatePrintDialogForPdf(const FilePath& path) {
       NewRunnableFunction(&PrintDialogGtk::CreateDialogImpl, path));
 }
 
 
bool PrintDialogGtk::DialogShowing() {
  AutoLock lock(DialogLock());
  return !!g_print_dialog;
}

  
 void PrintDialogGtk::CreateDialogImpl(const FilePath& path) {
   
   
   
   
  AutoLock lock(DialogLock());
  if (g_print_dialog)
    return;

  g_print_dialog = new PrintDialogGtk(path);
 }
 
 PrintDialogGtk::PrintDialogGtk(const FilePath& path_to_pdf)
  PrintDialogGtk::PrintDialogGtk(const FilePath& path_to_pdf)
 }
 
 PrintDialogGtk::~PrintDialogGtk() {
  AutoLock lock(DialogLock());
  DCHECK_EQ(this, g_print_dialog);
  g_print_dialog = NULL;
 }
 
 void PrintDialogGtk::OnResponse(gint response_id) {",
2507,,"  void PrintJobWorker::SetNewOwner(PrintJobWorkerOwner* new_owner) {
 }
 
 void PrintJobWorker::GetSettings(bool ask_user_for_settings,
                                 gfx::NativeView parent_view,
                                  int document_page_count,
                                  bool has_selection,
                                  bool use_overlays) {
  void PrintJobWorker::GetSettings(bool ask_user_for_settings,
     ChromeThread::PostTask(
         ChromeThread::UI, FROM_HERE,
         NewRunnableMethod(this, &PrintJobWorker::GetSettingsWithUI,
                          parent_view, document_page_count,
                           has_selection));
 #else
     PrintingContext::Result result = printing_context_.AskUserForSettings(
        parent_view, document_page_count, has_selection);
     GetSettingsDone(result);
 #endif
   } else {
  void PrintJobWorker::GetSettingsDone(PrintingContext::Result result) {
 }
 
 #if defined(OS_MACOSX)
void PrintJobWorker::GetSettingsWithUI(gfx::NativeView parent_view,
                                        int document_page_count,
                                        bool has_selection) {
   DCHECK(ChromeThread::CurrentlyOn(ChromeThread::UI));
 
   PrintingContext::Result result = printing_context_.AskUserForSettings(
      parent_view, document_page_count, has_selection);
   message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
       this, &PrintJobWorker::GetSettingsDone, result));
 }",
2508,," 
 
  
  
 
 
 #include ""webkit/glue/form_field.h""
 #include ""webkit/glue/form_field_values.h""
 
namespace {

 const char* kFormMethodPost = ""post"";
 
 
 const char* const kAttributeClientVersion = ""clientversion"";
 const char* const kAttributeAutoFillUsed = ""autofillused"";
 const char* const kAttributeSignature = ""signature"";
  const char* const kXMLElementForm = ""form"";
 const char* const kXMLElementField = ""field"";
 const char* const kAttributeAutoFillType = ""autofilltype"";
 
 
const char* const kControlTypeText = ""text"";

 
const size_t kRequiredFillableFields = 3;
 
 static std::string Hash64Bit(const std::string& str) {
   std::string hash_bin = base::SHA1HashString(str);
  FormStructure::FormStructure(const webkit_glue::FormFieldValues& values)
   std::vector<webkit_glue::FormField>::const_iterator field;
   for (field = values.elements.begin();
        field != values.elements.end(); field++) {
     
     
    if (!LowerCaseEqualsASCII(field->form_control_type(), kControlTypeText))
      continue;

      
     string16 unique_name = field->name() + IntToString16(fields_.size() + 1);
     fields_.push_back(new AutoFillField(*field, unique_name));
  std::string FormStructure::FormSignature() const {
 }
 
 bool FormStructure::IsAutoFillable() const {
  if (field_count() < kRequiredFillableFields)
     return false;
 
    
  bool FormStructure::IsAutoFillable() const {
   if (target_url_.path() == ""/search"")
     return false;
 
   if (method_ == GET)
     return false;
 ",
2509,," 
 
 #include ""chrome/browser/renderer_host/render_sandbox_host_linux.h""
 
#include <fcntl.h>
 #include <stdint.h>
 #include <unistd.h>
 #include <sys/uio.h>
#include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/poll.h>
 #include <time.h>
  class SandboxIPCProcess  {
     char control_buffer[CMSG_SPACE(sizeof(int))];
 
     if (reply_fd != -1) {
      struct stat st;
      if (fstat(reply_fd, &st) == 0 && S_ISDIR(st.st_mode)) {
        LOG(FATAL) << ""Tried to send a directory descriptor over sandbox IPC"";
         
         
         
      }
 
      struct cmsghdr *cmsg;
       msg.msg_control = control_buffer;
       msg.msg_controllen = sizeof(control_buffer);
       cmsg = CMSG_FIRSTHDR(&msg);",
2510,,"  void ResourceMessageFilter::OnClipboardWriteObjectsAsync(
    
   Clipboard::ObjectMap* long_living_objects = new Clipboard::ObjectMap(objects);
 
   
   
  long_living_objects->erase(Clipboard::CBF_SMBITMAP);

   ChromeThread::PostTask(
       ChromeThread::UI,
       FROM_HERE,",
2511,,"  namespace {
 const int kDownloadItemCodeMask = gtk_dnd_util::TEXT_URI_LIST |
                                   gtk_dnd_util::CHROME_NAMED_URL;
 const GdkDragAction kDownloadItemDragAction = GDK_ACTION_COPY;
const GdkDragAction kBookmarkDragAction =
    static_cast<GdkDragAction>(GDK_ACTION_COPY | GDK_ACTION_MOVE);
 
 void OnDragDataGetForDownloadItem(GtkSelectionData* selection_data,
                                   guint target_type,",
2512,," 
 
  
  
 
 
 #include ""base/string_util.h""
 #include ""chrome/browser/google_util.h""
 #include ""googleurl/src/gurl.h""
#include ""googleurl/src/url_util.h""
 #include ""net/base/escape.h""
 #include ""unicode/locid.h""
 
  std::string GetListName(int list_id) {
   return (list_id == PHISH) ? kPhishingList : std::string();
 }
 
std::string Unescape(const std::string& url) {
  std::string unescaped_str(url);
  std::string old_unescaped_str;
  const int kMaxLoopIterations = 1024;
  int loop_var = 0;
  do {
    old_unescaped_str = unescaped_str;
    unescaped_str = UnescapeURLComponent(old_unescaped_str,
        UnescapeRule::CONTROL_CHARS | UnescapeRule::SPACES |
        UnescapeRule::URL_SPECIAL_CHARS);
  } while (unescaped_str != old_unescaped_str && ++loop_var <=
           kMaxLoopIterations);

  return unescaped_str;
}

std::string Escape(const std::string& url) {
  std::string escaped_str;
  const char* kHexString = ""0123456789ABCDEF"";
  for (size_t i = 0; i < url.length(); i++) {
    unsigned char c = static_cast<unsigned char>(url[i]);
    if (c <= ' ' || c > '~' || c == '#' || c == '%') {
      escaped_str.push_back('%');
      escaped_str.push_back(kHexString[c >> 4]);
      escaped_str.push_back(kHexString[c & 0xf]);
    } else {
      escaped_str.push_back(c);
    }
  }

  return escaped_str;
}

std::string RemoveConsecutiveChars(const std::string& str, const char c) {
  std::string output(str);
  std::string string_to_find;
  std::string::size_type loc = 0;
  string_to_find.append(2, c);
  while ((loc = output.find(string_to_find, loc)) != std::string::npos) {
    output.erase(loc, 1);
  }

  return output;
}

 
 
 
void CanonicalizeUrl(const GURL& url,
                     std::string* canonicalized_hostname,
                     std::string* canonicalized_path,
                     std::string* canonicalized_query) {
   
   
   
   
   
   
   

   
   
  GURL url_without_fragment;
  GURL::Replacements f_replacements;
  f_replacements.ClearRef();
  f_replacements.ClearUsername();
  f_replacements.ClearPassword();
  url_without_fragment = url.ReplaceComponents(f_replacements);

   
  std::string url_unescaped_str(Unescape(url_without_fragment.spec()));
  url_parse::Parsed parsed;
  url_parse::ParseStandardURL(url_unescaped_str.data(),
      url_unescaped_str.length(), &parsed);

   
  const std::string host = (parsed.host.len > 0) ? url_unescaped_str.substr(
      parsed.host.begin, parsed.host.len) : """";
  const char kCharsToTrim[] = ""."";
  std::string host_without_end_dots;
  TrimString(host, kCharsToTrim, &host_without_end_dots);

   
  std::string host_without_consecutive_dots(RemoveConsecutiveChars(
      host_without_end_dots, '.'));

   
  std::string path = (parsed.path.len > 0) ? url_unescaped_str.substr(
       parsed.path.begin, parsed.path.len): """";
  std::string path_without_consecutive_slash(RemoveConsecutiveChars(
      path, '/'));

  url_canon::Replacements<char> hp_replacements;
  hp_replacements.SetHost(host_without_consecutive_dots.data(),
  url_parse::Component(0, host_without_consecutive_dots.length()));
  hp_replacements.SetPath(path_without_consecutive_slash.data(),
  url_parse::Component(0, path_without_consecutive_slash.length()));

  std::string url_unescaped_with_can_hostpath;
  url_canon::StdStringCanonOutput output(&url_unescaped_with_can_hostpath);
  url_parse::Parsed temp_parsed;
  url_util::ReplaceComponents(url_unescaped_str.data(),
                              url_unescaped_str.length(), parsed,
                              hp_replacements, NULL, &output, &temp_parsed);
  output.Complete();

   
  url_unescaped_with_can_hostpath = Unescape(url_unescaped_with_can_hostpath);

   
   
  std::string escaped_canon_url_str(Escape(url_unescaped_with_can_hostpath));
  url_parse::Parsed final_parsed;
  url_parse::ParseStandardURL(escaped_canon_url_str.data(),
                              escaped_canon_url_str.length(), &final_parsed);

  if (canonicalized_hostname && final_parsed.host.len > 0) {
    *canonicalized_hostname =
        escaped_canon_url_str.substr(final_parsed.host.begin,
                                     final_parsed.host.len);
  }
  if (canonicalized_path && final_parsed.path.len > 0) {
    *canonicalized_path = escaped_canon_url_str.substr(final_parsed.path.begin,
                                                       final_parsed.path.len);
  }
  if (canonicalized_query && final_parsed.query.len > 0) {
    *canonicalized_query = escaped_canon_url_str.substr(
        final_parsed.query.begin, final_parsed.query.len);
  }
}

 void GenerateHostsToCheck(const GURL& url, std::vector<std::string>* hosts) {
   hosts->clear();

  std::string canon_host;
  CanonicalizeUrl(url, &canon_host, NULL, NULL);

  const std::string host = canon_host;   
   if (host.empty())
     return;
 
  void GenerateHostsToCheck(const GURL& url, std::vector<std::string>* hosts) {
 
 void GeneratePathsToCheck(const GURL& url, std::vector<std::string>* paths) {
   paths->clear();

  std::string canon_path;
  std::string canon_query;
  CanonicalizeUrl(url, NULL, &canon_path, &canon_query);

  const std::string path = canon_path;    
  const std::string query = canon_query;
   if (path.empty())
     return;
 
  void GeneratePathsToCheck(const GURL& url, std::vector<std::string>* paths) {
   if (paths->back() != path)
     paths->push_back(path);
 
  if (!query.empty())
    paths->push_back(path + ""?"" + query);
 }
 
 int CompareFullHashes(const GURL& url,",
2513,,"  void InterstitialPage::Observe(NotificationType type,
        
        
       Disable();
       TakeActionOnResourceDispatcher(CANCEL);
       break;
     case NotificationType::RENDER_WIDGET_HOST_DESTROYED:",
2514,,"  struct PluginMsg_Init_Params {
 };
 
 struct PluginHostMsg_URLRequest_Params {
  std::string url;
   std::string method;
   std::string target;
   std::vector<char> buffer;
  int notify_id;
   bool popups_allowed;
 };
 
 struct PluginMsg_DidReceiveResponseParams {
   unsigned long id;
   std::string mime_type;
  template <>
 struct ParamTraits<PluginHostMsg_URLRequest_Params> {
   typedef PluginHostMsg_URLRequest_Params param_type;
   static void Write(Message* m, const param_type& p) {
    WriteParam(m, p.url);
     WriteParam(m, p.method);
     WriteParam(m, p.target);
     WriteParam(m, p.buffer);
    WriteParam(m, p.notify_id);
     WriteParam(m, p.popups_allowed);
   }
   static bool Read(const Message* m, void** iter, param_type* p) {
     return
      ReadParam(m, iter, &p->url) &&
       ReadParam(m, iter, &p->method) &&
       ReadParam(m, iter, &p->target) &&
       ReadParam(m, iter, &p->buffer) &&
      ReadParam(m, iter, &p->notify_id) &&
       ReadParam(m, iter, &p->popups_allowed);
   }
   static void Log(const param_type& p, std::wstring* l) {
     l->append(L""("");
    LogParam(p.url, l);
     l->append(L"", "");
    LogParam(p.method, l);
     l->append(L"", "");
     LogParam(p.target, l);
     l->append(L"", "");
     LogParam(p.buffer, l);
     l->append(L"", "");
    LogParam(p.notify_id, l);
     l->append(L"", "");
     LogParam(p.popups_allowed, l);
     l->append(L"")"");
   }
 };
 
 template <>
 struct ParamTraits<PluginMsg_DidReceiveResponseParams> {
   typedef PluginMsg_DidReceiveResponseParams param_type;",
2515,,"  void NotificationService::RemoveObserver(NotificationObserver* observer,
                                          NotificationType type,
                                          const NotificationSource& source) {
   DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);

   
   
   
   
   
   
  CHECK(HasKey(observers_[type.value], source));
 
   NotificationObserverList* observer_list =
       observers_[type.value][source.map_key()];",
2516,,"  const struct {
    ""http://www.goodguy.com/evil.exe"",
    ""application/rss+xml"",
    L""evil.download""},

   
  {""filename=evil.exe "",
   ""http://www.goodguy.com/evil.exe "",
   ""binary/octet-stream"",
   L""evil.exe""},

  {""filename=evil.exe."",
   ""http://www.goodguy.com/evil.exe."",
   ""binary/octet-stream"",
   L""evil.exe""},

  {""filename=evil.exe.  .  ."",
   ""http://www.goodguy.com/evil.exe.  .  ."",
   ""binary/octet-stream"",
   L""evil.exe""},

  {""filename=evil."",
   ""http://www.goodguy.com/evil."",
   ""binary/octet-stream"",
   L""evil""},

  {""filename=. . . . ."",
   ""http://www.goodguy.com/. . . . ."",
   ""binary/octet-stream"",
   L""download""},

 #endif   
 
   {""filename=utils.js"",",
2517,,"  BrowserActionsContainer::BrowserActionsContainer(
       toolbar_(toolbar),
       popup_(NULL),
       popup_button_(NULL),
       resize_gripper_(NULL),
       chevron_(NULL),
       suppress_chevron_(false),
       resize_amount_(0),
       animation_target_size_(0),
       ALLOW_THIS_IN_INITIALIZER_LIST(task_factory_(this)) {
   ExtensionsService* extension_service = profile->GetExtensionsService();
   if (!extension_service)   
     return;
 
  registrar_.Add(this, NotificationType::EXTENSION_LOADED,
                 Source<Profile>(profile_));
  registrar_.Add(this, NotificationType::EXTENSION_UNLOADED,
                 Source<Profile>(profile_));
  registrar_.Add(this, NotificationType::EXTENSION_UNLOADED_DISABLED,
                 Source<Profile>(profile_));
   registrar_.Add(this, NotificationType::EXTENSION_HOST_VIEW_SHOULD_CLOSE,
                  Source<Profile>(profile_));
 
   resize_animation_.reset(new SlideAnimation(this));

   resize_gripper_ = new views::ResizeGripper(this);
   resize_gripper_->SetVisible(false);
   AddChildView(resize_gripper_);
  BrowserActionsContainer::BrowserActionsContainer(
   int predefined_width =
       profile_->GetPrefs()->GetInteger(prefs::kBrowserActionContainerWidth);
   container_size_ = gfx::Size(predefined_width, kButtonSize);

  SetID(VIEW_ID_BROWSER_ACTION_TOOLBAR);
 }
 
 BrowserActionsContainer::~BrowserActionsContainer() {
  void BrowserActionsContainer::RefreshBrowserActionViews() {
     browser_action_views_[i]->button()->UpdateState();
 }
 
void BrowserActionsContainer::AddBrowserAction(Extension* extension) {
#if defined(DEBUG)
  for (size_t i = 0; i < browser_action_views_.size(); ++i) {
    DCHECK(browser_action_views_[i]->button()->extension() != extension) <<
           ""Asked to add a browser action view for an extension that already ""
           ""exists."";
  }
#endif
  if (!extension->browser_action())
    return;

   
  size_t visible_actions = 0;
  for (size_t i = 0; i < browser_action_views_.size(); ++i) {
    if (browser_action_views_[i]->IsVisible())
      ++visible_actions;
  }

   
  BrowserActionView* view = new BrowserActionView(extension, this);
  browser_action_views_.push_back(view);
  AddChildView(view);

   
   

   
   
   
  if (visible_actions < browser_action_views_.size() - 1) {
     
    OnBrowserActionVisibilityChanged();
  } else {
     
    animation_target_size_ = IconCountToWidth(visible_actions + 1);

     
     
    suppress_chevron_ = !chevron_->IsVisible();

     
    resize_animation_->Reset();
    resize_animation_->SetTweenType(SlideAnimation::NONE);
    resize_animation_->Show();
  }
}

void BrowserActionsContainer::RemoveBrowserAction(Extension* extension) {
  if (!extension->browser_action())
    return;

  if (popup_ && popup_->host()->extension() == extension) {
    HidePopup();
  }

   
  int visible_actions = 0;
  for (size_t i = 0; i < browser_action_views_.size(); ++i) {
    if (browser_action_views_[i]->IsVisible())
      ++visible_actions;
  }

  for (std::vector<BrowserActionView*>::iterator iter =
       browser_action_views_.begin(); iter != browser_action_views_.end();
       ++iter) {
    if ((*iter)->button()->extension() == extension) {
      RemoveChildView(*iter);
      delete *iter;
      browser_action_views_.erase(iter);

       
       

       
       
       
       
       
      animation_target_size_ =
          ClampToNearestIconCount(IconCountToWidth(visible_actions));

       
      resize_animation_->Reset();
      resize_animation_->SetTweenType(SlideAnimation::EASE_OUT);
      resize_animation_->Show();
      return;
    }
  }
}

 void BrowserActionsContainer::DeleteBrowserActionViews() {
   if (!browser_action_views_.empty()) {
     for (size_t i = 0; i < browser_action_views_.size(); ++i)
  void BrowserActionsContainer::Paint(gfx::Canvas* canvas) {
 void BrowserActionsContainer::ViewHierarchyChanged(bool is_add,
                                                    views::View* parent,
                                                    views::View* child) {
   if (is_add && child == this) {
      
      
      
    ExtensionsService* extension_service = profile_->GetExtensionsService();
    if (!extension_service)
      return;   
    for (size_t i = 0; i < extension_service->extensions()->size(); ++i)
      AddBrowserAction(extension_service->extensions()->at(i));
   }
 }
 
 void BrowserActionsContainer::Observe(NotificationType type,
                                       const NotificationSource& source,
                                       const NotificationDetails& details) {
   switch (type.value) {
    case NotificationType::EXTENSION_LOADED:
      AddBrowserAction(Details<Extension>(details).ptr());
      OnBrowserActionVisibilityChanged();
      break;

    case NotificationType::EXTENSION_UNLOADED:
    case NotificationType::EXTENSION_UNLOADED_DISABLED:
      RemoveBrowserAction(Details<Extension>(details).ptr());
      OnBrowserActionVisibilityChanged();
      break;

     case NotificationType::EXTENSION_HOST_VIEW_SHOULD_CLOSE:
        
       if (!popup_ || Details<ExtensionHost>(popup_->host()) != details)
  int BrowserActionsContainer::ClampToNearestIconCount(int pixelWidth) const {
   return returning;
 }
 
 int BrowserActionsContainer::WidthOfNonIconArea() const {
   int chevron_size = (chevron_->IsVisible()) ?
                      chevron_->GetPreferredSize().width() : 0;",
2518,,"  File* DataObjectItem::GetAsFile() const {
     SkPixmap pixmap;
     bitmap.peekPixels(&pixmap);
 
     
     SkPngEncoder::Options options;
    options.fZLibLevel = 1;
    options.fFilterFlags = SkPngEncoder::FilterFlag::kNone;

    Vector<uint8_t> png_data;
     if (!ImageEncoder::Encode(&png_data, pixmap, options))
       return nullptr;
 ",
2519,,"  bool BrowserInit::LaunchWithProfile::OpenApplicationURL(Profile* profile) {
   if (!command_line_.HasSwitch(switches::kApp))
     return false;
 
  std::string url_string(command_line_.GetSwitchValueASCII(switches::kApp));
#if defined(OS_WIN)   
  ReplaceSubstringsAfterOffset(&url_string, 0, ""\\x"", ""%"");
#endif
  GURL url(url_string);

   if (!url.is_empty() && url.is_valid()) {
     Browser::OpenApplicationWindow(profile, url);
     return true;",
2520,,"  class NetworkLibraryImpl : public NetworkLibrary  {
     for (size_t i = 0; i < cellular_networks_.size(); i++) {
       if (cellular_networks_[i]->connecting_or_connected()) {
         cellular_ = cellular_networks_[i];
         
         if (cellular_networks_[i]->service_path() !=
                 prev_cellular_service_path) {
          RefreshCellularDataPlans(cellular_);
         }
         break;   
       }",
2521,,"  void BrowserRenderProcessHost::PropogateBrowserCommandLineToRenderer(
     switches::kEnableDatabases,
     switches::kDisableByteRangeSupport,
     switches::kEnableWebSockets,
    switches::kEnableDesktopNotifications,
 #if defined(OS_MACOSX)
      
     switches::kEnableSandboxLogging,",
2522,,"  bool ChildProcessSecurityPolicy::CanRequestURL(
     if (url.SchemeIs(chrome::kViewSourceScheme) ||
         url.SchemeIs(chrome::kPrintScheme)) {
        
       
      GURL child_url(url.path());
      if (child_url.SchemeIs(chrome::kPrintScheme) ||
          (child_url.SchemeIs(chrome::kViewSourceScheme) &&
           url.SchemeIs(chrome::kViewSourceScheme)))
          return false;

      return CanRequestURL(renderer_id, child_url);
     }
 
     if (LowerCaseEqualsASCII(url.spec(), chrome::kAboutBlankURL))",
2523,,"  MenuCreateMaterial g_favicon_menu[] = {
   { MENU_NORMAL, IDC_RELOAD, IDS_APP_MENU_RELOAD, 0, NULL,
     GDK_R, GDK_CONTROL_MASK, true },
   { MENU_SEPARATOR },
  { MENU_NORMAL, IDC_RESTORE_TAB, IDS_RESTORE_TAB, 0, NULL,
     GDK_T, GDK_CONTROL_MASK | GDK_SHIFT_MASK, true },
   { MENU_NORMAL, IDC_DUPLICATE_TAB, IDS_APP_MENU_DUPLICATE_APP_WINDOW },
   { MENU_NORMAL, IDC_COPY_URL, IDS_APP_MENU_COPY_URL },",
2524,,"  constexpr int kMoleculeOrder[] = {0, 2, 3, 1};
 
 }   
 
class VoiceInteractionIcon : public ui::Layer {
  public:
   VoiceInteractionIcon() : Layer(ui::LAYER_NOT_DRAWN) {
     set_name(""VoiceInteractionOverlay:ICON_LAYER"");
  class VoiceInteractionIcon : public ui::Layer,
   }
 
   void StartAnimation() {
    animation_timer_.Start(FROM_HERE,
                           base::TimeDelta::FromMilliseconds(
                               base::TimeTicks::kMillisecondsPerSecond /
                               gfx::LinearAnimation::kDefaultFrameRate),
                           this, &VoiceInteractionIcon::AnimationProgressed);
   }
 
  void StopAnimation() { animation_timer_.Stop(); }
 
  private:
   enum Dot {
  class VoiceInteractionIcon : public ui::Layer,
     return ""UNKNOWN"";
   }
 
  void AnimationProgressed() {
    gfx::Transform transform;

    uint64_t now =
        (base::TimeTicks::Now() - base::TimeTicks()).InMilliseconds();
    for (int i = 0; i < DOT_COUNT; ++i) {
      float normalizedTime =
          ((now - kMoleculeAnimationOffset * kMoleculeOrder[i]) %
           kMoleculeAnimationDurationMs) /
          static_cast<float>(kMoleculeAnimationDurationMs);

      transform.MakeIdentity();
      transform.Translate(0,
                          kMoleculeAmplitude * sin(normalizedTime * 2 * M_PI));

      dot_layers_[i]->SetTransform(transform);
    }
  }

   /**
    * Convenience method to place dots to Molecule shape used by Molecule
    * animations.
  class VoiceInteractionIcon : public ui::Layer,
   std::unique_ptr<ui::Layer> dot_layers_[DOT_COUNT];
   std::unique_ptr<views::CircleLayerDelegate> dot_layer_delegates_[DOT_COUNT];
 
  base::RepeatingTimer animation_timer_;

   DISALLOW_COPY_AND_ASSIGN(VoiceInteractionIcon);
 };
 ",
2525,,"  class ActualCallParams : public CrossCallParams {
     param_info_[0].offset_ = parameters_ - reinterpret_cast<char*>(this);
   }
 
   
   
  ActualCallParams(uint32 tag, uint32 number_params)
      : CrossCallParams(tag, number_params) {
    param_info_[0].offset_ = parameters_ - reinterpret_cast<char*>(this);
  }

    
    
   bool CopyParamIn(size_t index, const void* parameter_address, size_t size,",
2526,CVE-2011-3907,"  NavigateParams::NavigateParams(
       source_contents(NULL),
       disposition(CURRENT_TAB),
       transition(a_transition),
      is_renderer_initiated(false),
       tabstrip_index(-1),
       tabstrip_add_types(TabStripModel::ADD_ACTIVE),
       window_action(NO_ACTION),
  NavigateParams::NavigateParams(Browser* a_browser,
       source_contents(NULL),
       disposition(CURRENT_TAB),
       transition(content::PAGE_TRANSITION_LINK),
      is_renderer_initiated(false),
       tabstrip_index(-1),
       tabstrip_add_types(TabStripModel::ADD_ACTIVE),
       window_action(NO_ACTION),",The view-source feature in Google Chrome before 16.0.912.63 allows remote attackers to spoof the URL bar via unspecified vectors.
2527,CVE-2011-3911,"  class ChromeMainDelegate : public content::ContentMainDelegate {
 #if defined(OS_MACOSX)
   void InitMacCrashReporter(const CommandLine& command_line,
                             const std::string& process_type) {
      
      
      
  class ChromeMainDelegate : public content::ContentMainDelegate {
        
       SetMacProcessName(process_type);
 #endif   
    }
 
 #if defined(USE_LINUX_BREAKPAD)
     
     
     
    if (!process_type.empty() && process_type != switches::kZygoteProcess)
      InitCrashReporter();
 #endif
 
 #if defined(OS_CHROMEOS)
      ","Google Chrome before 16.0.912.63 does not properly handle PDF documents, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2528,,"  int MapHttpResponseCode(int code) {
   return 0;
 }
 
void CheckDoesNotHaveEmbededNulls(const std::string& str) {
   
   
   
  CHECK(str.find('\0') == std::string::npos);
}

 }   
 
 struct HttpResponseHeaders::ParsedHeader {
  void HttpResponseHeaders::RemoveHeader(const std::string& name) {
 }
 
 void HttpResponseHeaders::AddHeader(const std::string& header) {
  CheckDoesNotHaveEmbededNulls(header);
   DCHECK_EQ('\0', raw_headers_[raw_headers_.size() - 2]);
   DCHECK_EQ('\0', raw_headers_[raw_headers_.size() - 1]);
    
  void HttpResponseHeaders::AddHeader(const std::string& header) {
 }
 
 void HttpResponseHeaders::ReplaceStatusLine(const std::string& new_status) {
  CheckDoesNotHaveEmbededNulls(new_status);
    
   std::string new_raw_headers(new_status);
   new_raw_headers.push_back('\0');",
2529,,"  bool ParseTimeFromValue(const double& ms_since_epoch, base::Time* time) {
 
  
  
bool DataRemovalRequested(base::DictionaryValue* dict, const std::string& key) {
   bool value = false;
   if (!dict->GetBoolean(key, &value))
     return false;",
2530,,"  class QuotaManager::UsageAndQuotaDispatcherTask : public QuotaTask {
   DISALLOW_COPY_AND_ASSIGN(UsageAndQuotaDispatcherTask);
 };
 
class QuotaManager::GetUsageInfoTask : public QuotaTask {
 private:
  typedef QuotaManager::GetUsageInfoTask self_type;

 public:
  GetUsageInfoTask(
      QuotaManager* manager,
      GetUsageInfoCallback* callback)
      : QuotaTask(manager),
        callback_(callback),
        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {
  }
 protected:
  virtual void Run() OVERRIDE {
    remaining_trackers_ = 2;
     
    manager()->GetUsageTracker(kStorageTypeTemporary)->GetGlobalUsage(
        callback_factory_.NewCallback(&GetUsageInfoTask::DidGetGlobalUsage));
    manager()->GetUsageTracker(kStorageTypePersistent)->GetGlobalUsage(
        callback_factory_.NewCallback(&GetUsageInfoTask::DidGetGlobalUsage));
  }

  virtual void Completed() OVERRIDE {
    callback_->Run(entries_);
    DeleteSoon();
  }

  virtual void Aborted() OVERRIDE {
    callback_->Run(UsageInfoEntries());
    DeleteSoon();
  }

 private:
  void AddEntries(StorageType type, UsageTracker* tracker) {
    std::map<std::string, int64> host_usage;
    tracker->GetCachedHostsUsage(&host_usage);
    for (std::map<std::string, int64>::const_iterator iter = host_usage.begin();
         iter != host_usage.end();
         ++iter) {
      entries_.push_back(UsageInfo(iter->first, type, iter->second));
    }
    if (--remaining_trackers_ == 0)
      CallCompleted();
  }

  void DidGetGlobalUsage(StorageType type, int64, int64) {
    AddEntries(type, manager()->GetUsageTracker(type));
  }

  QuotaManager* manager() const {
    return static_cast<QuotaManager*>(observer());
  }

  scoped_ptr<GetUsageInfoCallback> callback_;
  UsageInfoEntries entries_;
  base::ScopedCallbackFactory<GetUsageInfoTask> callback_factory_;
  int remaining_trackers_;

  DISALLOW_COPY_AND_ASSIGN(GetUsageInfoTask);
};

 class QuotaManager::UsageAndQuotaDispatcherTaskForTemporary
     : public QuotaManager::UsageAndQuotaDispatcherTask {
  public:
  QuotaManager::~QuotaManager() {
     db_thread_->DeleteSoon(FROM_HERE, database_.release());
 }
 
void QuotaManager::GetUsageInfo(GetUsageInfoCallback* callback) {
  LazyInitialize();
  GetUsageInfoTask* get_usage_info = new GetUsageInfoTask(this, callback);
  get_usage_info->Start();
}

 void QuotaManager::GetUsageAndQuota(
     const GURL& origin, StorageType type,
     GetUsageAndQuotaCallback* callback_ptr) {",
2531,,"  class InotifyReaderTask : public Task {
       : reader_(reader),
         inotify_fd_(inotify_fd),
         shutdown_fd_(shutdown_fd) {
     
    CHECK_LE(0, inotify_fd_);
    CHECK_GT(FD_SETSIZE, inotify_fd_);
    CHECK_LE(0, shutdown_fd_);
    CHECK_GT(FD_SETSIZE, shutdown_fd_);
   }
 
   virtual void Run() {",
2532,," 
 
 #include ""base/string_util.h""
 #include ""chrome/browser/sync/engine/syncer_proto_util.h""
#include ""chrome/browser/sync/engine/syncer_util.h""
 #include ""chrome/browser/sync/protocol/bookmark_specifics.pb.h""
 #include ""chrome/browser/sync/sessions/sync_session.h""
 #include ""chrome/browser/sync/syncable/syncable.h""
 #include ""chrome/browser/sync/syncable/syncable_changes_version.h""
 
 using std::set;
 using std::string;
  void BuildCommitCommand::ExecuteImpl(SyncSession* session) {
       DCHECK(id.ServerKnows()) << meta_entry;
       sync_entry->set_version(meta_entry.Get(syncable::BASE_VERSION));
     }
    sync_entry->set_ctime(ClientTimeToServerTime(
        meta_entry.Get(syncable::CTIME)));
    sync_entry->set_mtime(ClientTimeToServerTime(
        meta_entry.Get(syncable::MTIME)));
 
      
     if (meta_entry.Get(IS_DEL)) {",
2533,,"  bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(
   DCHECK_EQ(INITIALIZED, state_);
   state_ = RENDERING;
 
   metafile_.reset(new printing::PreviewMetafile);
   if (!metafile_->Init()) {
     set_error(PREVIEW_ERROR_METAFILE_INIT_FAILED);
  bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(
   UpdatePrintableSizeInPrintParameters(frame_, node_,
                                        prep_frame_view_.get(), print_params);
 
  print_params_.reset(new PrintMsg_Print_Params(*print_params));

   total_page_count_ = prep_frame_view_->GetExpectedPageCount();
   if (total_page_count_ == 0) {
     LOG(ERROR) << ""CreatePreviewDocument got 0 page count"";",
2534,," 
 #include ""ppapi/c/ppb_graphics_3d.h""
 #include ""ppapi/c/ppb_image_data.h""
 #include ""ppapi/c/ppb_instance.h""
#include ""ppapi/c/ppb_opengles2.h""
 #include ""ppapi/c/ppb_url_loader.h""
 #include ""ppapi/lib/gl/gles2/gl2ext_ppapi.h""
 
  void TestIsGraphics3D() {
   TEST_PASSED;
 }
 
 
 void Test_glInitializePPAPI() {
   GLboolean init_ppapi = glInitializePPAPI(ppb_get_interface());
   EXPECT(init_ppapi == true);
   TEST_PASSED;
 }
 
 
 
void TestBasicSetup() {
  int32_t attribs[] = {
      PP_GRAPHICS3DATTRIB_WIDTH, kWidth,
      PP_GRAPHICS3DATTRIB_HEIGHT, kHeight,
      PP_GRAPHICS3DATTRIB_DEPTH_SIZE, 32,
      PP_GRAPHICS3DATTRIB_NONE};
  PP_Resource graphics3d_id = PPBGraphics3D()->
      Create(pp_instance(), kInvalidResource, attribs);
  EXPECT(graphics3d_id != kInvalidResource);
  glSetCurrentContextPPAPI(graphics3d_id);
  EXPECT(glGetString(GL_VERSION) != NULL);
  glGetString(GL_EXTENSIONS);
  int gl_max_texture_size;
  const int expected_lower_bound_max_texture_size = 256;
  glGetIntegerv(GL_MAX_TEXTURE_SIZE, &gl_max_texture_size);
  EXPECT(gl_max_texture_size >= expected_lower_bound_max_texture_size);
  int gl_depth_size;
  const int expected_lower_bound_depth_size = 16;
  glGetIntegerv(GL_DEPTH_BITS, &gl_depth_size);
  EXPECT(gl_depth_size >= expected_lower_bound_depth_size);
  GLenum lastError = glGetError();
  EXPECT(lastError == GL_NO_ERROR);
  glEnable(GL_LINE_LOOP);
  lastError = glGetError();
  EXPECT(lastError == GL_INVALID_ENUM);
  glSetCurrentContextPPAPI(0);
  PPBCore()->ReleaseResource(graphics3d_id);
  TEST_PASSED;
}

 struct RenderInfo {
   PP_Resource graphics3d_id;
   int32_t frame_counter;
  void TestSwapBuffers() {
 }
 
 void TestResizeAndSwapCallback(void* user_data, int32_t result) {
  const int kMinSize = 1;
   EXPECT(result == PP_OK);
   RenderInfo* info = static_cast<RenderInfo *>(user_data);
   int32_t new_width = kWidth - info->frame_counter * 2;
   int32_t new_height = kHeight - info->frame_counter * 2;
  if (new_width < kMinSize) new_width = kMinSize;
  if (new_height < kMinSize) new_height = kMinSize;
   
   
   int32_t resize_result = PPBGraphics3D()->ResizeBuffers(info->graphics3d_id,
       new_width, new_height);
   EXPECT(resize_result == PP_OK);
   glSetCurrentContextPPAPI(info->graphics3d_id);
  glViewport(0, 0, kWidth, kHeight);
   float green = float(info->frame_counter) / float(info->frame_end);
   glClearColor(0.0f, green, 0.0f, 1.0f);
   glClear(GL_COLOR_BUFFER_BIT);
  void TestResizeAndSwapCallback(void* user_data, int32_t result) {
 }
 
  
 
 void TestResizeBuffers(int32_t* attribs) {
   PP_Resource graphics3d_id = PPBGraphics3D()->
       Create(pp_instance(), kInvalidResource, attribs);
  void TestResizeBuffers(int32_t* attribs) {
   PPBCore()->CallOnMainThread(0, cc, PP_OK);
 }
 
  
 void TestResizeBuffersWithoutDepthBuffer() {
   int32_t attribs[] = {
  void TestResizeBuffersWithoutDepthBuffer() {
   TestResizeBuffers(attribs);
 }
 
  
 void TestResizeBuffersWithDepthBuffer() {
   int32_t attribs[] = {
       PP_GRAPHICS3DATTRIB_WIDTH, kWidth,
       PP_GRAPHICS3DATTRIB_HEIGHT, kHeight,
      PP_GRAPHICS3DATTRIB_DEPTH_SIZE, 16,
       PP_GRAPHICS3DATTRIB_NONE};
   TestResizeBuffers(attribs);
 }
 
  
 void Test_glTerminatePPAPI() {
   GLboolean terminate = glTerminatePPAPI();
  void SetupTests() {
   RegisterTest(""TestCreate"", TestCreate);
   RegisterTest(""TestIsGraphics3D"", TestIsGraphics3D);
   RegisterTest(""Test_glInitializePPAPI"", Test_glInitializePPAPI);
  RegisterTest(""TestBasicSetup"", TestBasicSetup);
   RegisterTest(""TestSwapBuffers"", TestSwapBuffers);
   RegisterTest(""TestResizeBuffersWithoutDepthBuffer"",
       TestResizeBuffersWithoutDepthBuffer);",
2535,CVE-2011-3898,"  bool WebRequestEventHandled::RunImpl() {
     }
 
     if (value->HasKey(""responseHeaders"")) {
      scoped_ptr<helpers::ResponseHeaders> response_headers(
          new helpers::ResponseHeaders());
       ListValue* response_headers_value = NULL;
       EXTENSION_FUNCTION_VALIDATE(value->GetList(keys::kResponseHeadersKey,
                                                  &response_headers_value));
  bool WebRequestEventHandled::RunImpl() {
             FromHeaderDictionary(header_value, &name, &value));
         response_headers->push_back(helpers::ResponseHeader(name, value));
       }
      response->response_headers.reset(response_headers.release());
     }
 
     if (value->HasKey(keys::kAuthCredentialsKey)) {","Google Chrome before 15.0.874.120, when Java Runtime Environment (JRE) 7 is used, does not request user confirmation before applet execution begins, which allows remote attackers to have an unspecified impact via a crafted applet."
2536,,"  void SyncBackendHost::Shutdown(bool sync_disabled) {
    
    
   if (sync_thread_.IsRunning()) {   
    if (core_->sync_manager()) {
       core_->sync_manager()->RequestEarlyExit();
     }
     sync_thread_.message_loop()->PostTask(FROM_HERE,",
2537,,"  void ExtensionInstallUI::Prompt::SetPermissions(
 }
 
 void ExtensionInstallUI::Prompt::SetInlineInstallWebstoreData(
    const std::string& localized_user_count,
     double average_rating,
     int rating_count) {
   CHECK_EQ(INLINE_INSTALL_PROMPT, type_);",
2538,CVE-2011-2880,"  bool FileUtilProxy::Read(
     int64 offset,
     int bytes_to_read,
     ReadCallback* callback) {
  if (bytes_to_read < 0) {
    delete callback;
     return false;
  }
   return Start(FROM_HERE, message_loop_proxy,
                new RelayRead(file, offset, bytes_to_read, callback));
 }
  bool FileUtilProxy::Write(
     const char* buffer,
     int bytes_to_write,
     WriteCallback* callback) {
  if (bytes_to_write <= 0) {
    delete callback;
     return false;
  }
   return Start(FROM_HERE, message_loop_proxy,
                new RelayWrite(file, offset, buffer, bytes_to_write, callback));
 }",Use-after-free vulnerability in Google Chrome before 14.0.835.202 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the Google V8 bindings.
2539,CVE-2011-2880,"  void EnterpriseEnrollmentScreen::OnAuthCancelled() {
                             policy::kMetricEnrollmentSize);
   auth_fetcher_.reset();
   registrar_.reset();
  g_browser_process->browser_policy_connector()->ResetDevicePolicy();
   get_screen_observer()->OnExit(
       ScreenObserver::ENTERPRISE_ENROLLMENT_CANCELLED);
 }
  void EnterpriseEnrollmentScreen::OnPolicyStateChanged(
 
    
   registrar_.reset();
  g_browser_process->browser_policy_connector()->ResetDevicePolicy();
 }
 
 void EnterpriseEnrollmentScreen::HandleAuthError(
  void EnterpriseEnrollmentScreen::RegisterForDevicePolicy(
 
    
    
  connector->RegisterForDevicePolicy(user_, token, token_type);
 }
 
 }   ",Use-after-free vulnerability in Google Chrome before 14.0.835.202 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the Google V8 bindings.
2540,CVE-2011-2835,"  IN_PROC_BROWSER_TEST_F(SSLUITest, TestRunsCachedInsecureContent) {
   CheckAuthenticationBrokenState(tab, 0, true, false);
 }
 
  
  
 
IN_PROC_BROWSER_TEST_F(SSLUITest, DISABLED_TestCNInvalidStickiness) {
   ASSERT_TRUE(https_server_.Start());
   ASSERT_TRUE(https_server_mismatched_.Start());
 ",Race condition in Google Chrome before 14.0.835.163 allows attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the certificate cache.
2541,CVE-2011-2836,"  BlockedPluginInfoBarDelegate::BlockedPluginInfoBarDelegate(
   else if (name == webkit::npapi::PluginGroup::kRealPlayerGroupName)
     UserMetrics::RecordAction(
         UserMetricsAction(""BlockedPluginInfobar.Shown.RealPlayer""));
  else if (name == webkit::npapi::PluginGroup::kWindowsMediaPlayerGroupName)
    UserMetrics::RecordAction(
        UserMetricsAction(""BlockedPluginInfobar.Shown.WindowsMediaPlayer""));
 }
 
 BlockedPluginInfoBarDelegate::~BlockedPluginInfoBarDelegate() {","Google Chrome before 14.0.835.163 does not require Infobar interaction before use of the Windows Media Player plug-in, which makes it easier for remote attackers to have an unspecified impact via crafted Flash content."
2542,CVE-2011-2838," 
  
  
  
 
 
 
 
 
 
 
 
 
 
 
 
 #ifndef CHROME_RENDERER_SAFE_BROWSING_PHISHING_CLASSIFIER_H_
 #define CHROME_RENDERER_SAFE_BROWSING_PHISHING_CLASSIFIER_H_","Google Chrome before 14.0.835.163 does not properly consider the MIME type during the loading of a plug-in, which has unspecified impact and remote attack vectors."
2543,CVE-2011-2840,"  bool TabCloseableStateWatcher::CanCloseTab(const Browser* browser) const {
       (can_close_tab_ || waiting_for_browser_);
 }
 
bool TabCloseableStateWatcher::CanCloseTabs(const Browser* browser,
    std::vector<int>* indices) const {
  if (signing_off_ || waiting_for_browser_ || tabstrip_watchers_.size() > 1 ||
      browser->type() != Browser::TYPE_NORMAL ||
      (browser->profile()->IsOffTheRecord() && !guest_session_))
    return true;

  if (!can_close_tab_) {
    indices->clear();
    return false;
  }

  TabStripModel* tabstrip_model = browser->tabstrip_model();
   
  if (static_cast<int>(indices->size()) != tabstrip_model->count())
    return true;

   
   
   
   
   
   
   
   
   
   
   
   
  for (size_t i = 0; i < indices->size(); ++i) {
    if ((*indices)[i] == 0) {
      if (tabstrip_model->GetTabContentsAt(0)->tab_contents()->GetURL() ==
          GURL(chrome::kChromeUINewTabURL)) {   
        indices->erase(indices->begin() + i);   
        return false;
      }
      break;
    }
  }
  return true;
}

 bool TabCloseableStateWatcher::CanCloseBrowser(Browser* browser) {
   BrowserActionType action_type;
   bool can_close = CanCloseBrowserImpl(browser, &action_type);",Google Chrome before 14.0.835.163 allows user-assisted remote attackers to spoof the URL bar via vectors related to *unusual user interaction.*
2544,CVE-2011-2842," 
2545,CVE-2011-2843,"  void FFmpegVideoDecodeEngine::Initialize(
 
   if (config.extra_data() != NULL) {
     codec_context_->extradata_size = config.extra_data_size();
    codec_context_->extradata = reinterpret_cast<uint8_t*>(
        av_malloc(config.extra_data_size() + FF_INPUT_BUFFER_PADDING_SIZE));
     memcpy(codec_context_->extradata, config.extra_data(),
            config.extra_data_size());
    memset(codec_context_->extradata + config.extra_data_size(), '\0',
           FF_INPUT_BUFFER_PADDING_SIZE);
   }
 
    ","Google Chrome before 14.0.835.163 does not properly handle media buffers, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2546,CVE-2011-2846,"  void TemplateURLService::OnWebDataServiceRequestDone(
         managed_default->set_created_by_policy(true);
         managed_default->set_id(0);
         AddNoNotify(managed_default);
       }
      default_search_provider = managed_default;
     }
      
     SetDefaultSearchProviderNoNotify(default_search_provider);",Use-after-free vulnerability in Google Chrome before 14.0.835.163 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to unload event handling.
2547,CVE-2011-2849,"  WebSocketJob::WebSocketJob(SocketStream::Delegate* delegate)
       handshake_request_sent_(0),
       response_cookies_save_index_(0),
       send_frame_handler_(new WebSocketFrameHandler),
      receive_frame_handler_(new WebSocketFrameHandler),
      ALLOW_THIS_IN_INITIALIZER_LIST(method_factory_(this)) {
 }
 
 WebSocketJob::~WebSocketJob() {
  void WebSocketJob::OnSentData(SocketStream* socket, int amount_sent) {
     DCHECK_GT(amount_sent, 0);
     current_buffer_ = NULL;
     send_frame_handler_->ReleaseCurrentBuffer();
    if (method_factory_.empty()) {
      MessageLoopForIO::current()->PostTask(
          FROM_HERE,
          method_factory_.NewRunnableMethod(&WebSocketJob::SendPending));
    }
     delegate_->OnSentData(socket, amount_sent);
   }
 }
 
  void WebSocketJob::Wakeup() {
   DCHECK(callback_);
   MessageLoopForIO::current()->PostTask(
       FROM_HERE,
      method_factory_.NewRunnableMethod(&WebSocketJob::RetryPendingIO));
 }
 
 void WebSocketJob::RetryPendingIO() {
  void WebSocketJob::CompleteIO(int result) {
 bool WebSocketJob::SendDataInternal(const char* data, int length) {
   if (spdy_websocket_stream_.get())
     return ERR_IO_PENDING == spdy_websocket_stream_->SendData(data, length);
  if (socket_.get())
    return socket_->SendData(data, length);
  return false;
 }
 
 void WebSocketJob::CloseInternal() {",The WebSockets implementation in Google Chrome before 14.0.835.163 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors.
2548,CVE-2011-3234,"  void ExtensionPrefs::UpdateManifest(const Extension* extension) {
 
 FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) {
   const DictionaryValue* dict = GetExtensionPref(extension_id);
  if (!dict)
    return FilePath();

   std::string path;
   if (!dict->GetString(kPrefPath, &path))
     return FilePath();","Google Chrome before 14.0.835.163 does not properly handle boxes, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2549,CVE-2011-2850,"  void GpuDataManager::UpdateGpuFeatureFlags() {
   }
 
   GpuBlacklist* gpu_blacklist = GetGpuBlacklist();
    
    
   if (!gpu_blacklist) {","Google Chrome before 14.0.835.163 does not properly handle Khmer characters, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2550,CVE-2011-2851,"  void ScaleYUVToRGB32(const uint8* y_buf,
                      YUVType yuv_type,
                      Rotate view_rotate,
                      ScaleFilter filter) {
   
  if ((yuv_type == YV12 && (source_width < 2 || source_height < 2)) ||
      (yuv_type == YV16 && (source_width < 2 || source_height < 1)) ||
      width == 0 || height == 0)
    return;

    
    
    
  void ScaleYUVToRGB32(const uint8* y_buf,
     source_height = -source_height;
   }
 
   int source_dx = source_width * kFractionMax / width;
   int source_dy = source_height * kFractionMax / height;
 #if USE_MMX && defined(_MSC_VER)","Google Chrome before 14.0.835.163 does not properly handle video, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2551,CVE-2011-2853," 
 #include ""chrome/browser/ui/views/frame/browser_non_client_frame_view.h""
 #include ""chrome/browser/ui/views/frame/browser_view.h""
 #include ""ui/gfx/font.h""
#include ""views/views_delegate.h""
 #include ""views/widget/root_view.h""
 #include ""views/widget/widget.h""
 #include ""views/window/hit_test.h""
  gboolean BrowserFrameGtk::OnConfigureEvent(GtkWidget* widget,
 NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(
     BrowserFrame* browser_frame,
     BrowserView* browser_view) {
  if (views::Widget::IsPureViews() &&
      views::ViewsDelegate::views_delegate->GetDefaultParentView())
     return new BrowserFrameViews(browser_frame, browser_view);
   return new BrowserFrameGtk(browser_frame, browser_view);
 }",Use-after-free vulnerability in Google Chrome before 14.0.835.163 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to plug-in handling.
2552,CVE-2011-2854," 
 #include <stddef.h>
 
 #include ""base/logging.h""
#include ""base/mac/mac_util.h""
 #include ""base/memory/scoped_ptr.h""
 #include ""remoting/host/capturer_helper.h""
 
  scoped_pixel_buffer_object::~scoped_pixel_buffer_object() {
 
 bool scoped_pixel_buffer_object::Init(CGLContextObj cgl_context,
                                       int size_in_bytes) {
   
   
   
   
  if (base::mac::IsOSLeopardOrEarlier()) {
    return false;
  }
   cgl_context_ = cgl_context;
   CGLContextObj CGL_MACRO_CONTEXT = cgl_context_;
   glGenBuffersARB(1, &pixel_buffer_object_);
  void CapturerMac::CaptureInvalidRects(CaptureCompletedCallback* callback) {
       if (pixel_buffer_object_.get() != 0) {
         GlBlitFast(current_buffer);
       } else {
         
         
         GlBlitSlow(current_buffer);
       }
     } else {",Use-after-free vulnerability in Google Chrome before 14.0.835.163 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to *ruby / table style handing.*
2553,CVE-2011-2859,"  void ExtensionService::OnExternalExtensionUpdateUrlFound(
   external_extension_url_added_ |= true;
 }
 
 
 
static const char* kAllowedDownloadURLPatterns[] = {
  ""https://clients2.google.com/service/update2*"",
  ""https://clients2.googleusercontent.com/crx/*""
};

 bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                              const GURL& referrer_url) {
    
  bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
   bool referrer_valid = (referrer_extension == webstore_app);
   bool download_valid = (download_extension == webstore_app);
 
   
  if (!download_valid) {
    for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
      URLPattern pattern(URLPattern::SCHEME_HTTPS,
                         kAllowedDownloadURLPatterns[i]);
      if (pattern.MatchesURL(download_url)) {
        download_valid = true;
        break;
      }
    }
  }

    
   GURL store_url =
       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(","Google Chrome before 14.0.835.163 uses incorrect permissions for non-gallery pages, which has unspecified impact and attack vectors."
2554,CVE-2011-2861,"  void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(
       switches::kProfilingAtStart,
       switches::kProfilingFile,
       switches::kProfilingFlush,
       switches::kSilentDumpOnDCHECK,
     };
 ","Google Chrome before 14.0.835.163 does not properly handle strings in PDF documents, which allows remote attackers to have an unspecified impact via a crafted document that triggers an incorrect read operation."
2555,CVE-2011-2864,"  bool SubsetterImpl::ResolveCompositeGlyphs(const unsigned int* glyph_ids,
     glyph_id_remaining.clear();
     glyph_id_remaining = comp_glyph_id;
   }

  return true;
 }
 
 CALLER_ATTACH Font* SubsetterImpl::Subset(const IntegerSet& glyph_ids) {","Google Chrome before 14.0.835.163 does not properly handle Tibetan characters, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2556,CVE-2011-2858,"  class GLES2DecoderImpl : public base::SupportsWeakPtr<GLES2DecoderImpl>,
    
   bool IsDrawValid(GLuint max_vertex_accessed);
 
   
   
  bool SimulateAttrib0(GLuint max_vertex_accessed, bool* simulated);
   void RestoreStateForSimulatedAttrib0();
 
    
  bool GLES2DecoderImpl::IsDrawValid(GLuint max_vertex_accessed) {
   return true;
 }
 
bool GLES2DecoderImpl::SimulateAttrib0(
    GLuint max_vertex_accessed, bool* simulated) {
  DCHECK(simulated);
  *simulated = false;

   if (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2)
    return true;
 
   const VertexAttribManager::VertexAttribInfo* info =
       vertex_attrib_manager_.GetVertexAttribInfo(0);
    
   bool attrib_0_used = current_program_->GetAttribInfoByLocation(0) != NULL;
   if (info->enabled() && attrib_0_used) {
    return true;
   }
 
   
   
   
   typedef VertexAttribManager::VertexAttribInfo::Vec4 Vec4;
 
  GLuint num_vertices = max_vertex_accessed + 1;
  GLuint size_needed = 0;

  if (num_vertices == 0 ||
      !SafeMultiply(num_vertices, static_cast<GLuint>(sizeof(Vec4)),
                    &size_needed) ||
      size_needed > 0x7FFFFFFFU) {
    SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: Simulating attrib 0"");
    return false;
  }

  CopyRealGLErrorsToWrapper();
   glBindBuffer(GL_ARRAY_BUFFER, attrib_0_buffer_id_);
 
  if (static_cast<GLsizei>(size_needed) > attrib_0_size_) {
     glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);
    GLenum error = glGetError();
    if (error != GL_NO_ERROR) {
      SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: Simulating attrib 0"");
      return false;
    }
     attrib_0_buffer_matches_value_ = false;
   }
   if (attrib_0_used &&
  bool GLES2DecoderImpl::SimulateAttrib0(GLuint max_vertex_accessed) {
 
   glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL);
 
  *simulated = true;
   return true;
 }
 
  bool GLES2DecoderImpl::SimulateFixedAttribs(
    
 
    
  GLuint num_vertices = max_vertex_accessed + 1;
  if (num_vertices == 0) {
    SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: Simulating attrib 0"");
    return false;
  }

  GLuint elements_needed = 0;
   const VertexAttribManager::VertexAttribInfoList& infos =
       vertex_attrib_manager_.GetEnabledVertexAttribInfos();
   for (VertexAttribManager::VertexAttribInfoList::const_iterator it =
  bool GLES2DecoderImpl::SimulateFixedAttribs(
     if (attrib_info &&
         info->CanAccess(max_vertex_accessed) &&
         info->type() == GL_FIXED) {
      GLuint elements_used = 0;
      if (!SafeMultiply(num_vertices,
                        static_cast<GLuint>(info->size()), &elements_used) ||
           !SafeAdd(elements_needed, elements_used, &elements_needed)) {
         SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: simulating GL_FIXED attribs"");
         return false;
       }
     }
   }
 
  const GLuint kSizeOfFloat = sizeof(float);   
  GLuint size_needed = 0;
  if (!SafeMultiply(elements_needed, kSizeOfFloat, &size_needed) ||
      size_needed > 0x7FFFFFFFU) {
     SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: simulating GL_FIXED attribs"");
     return false;
   }
 
  CopyRealGLErrorsToWrapper();
 
   glBindBuffer(GL_ARRAY_BUFFER, fixed_attrib_buffer_id_);
  if (static_cast<GLsizei>(size_needed) > fixed_attrib_buffer_size_) {
     glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);
    GLenum error = glGetError();
    if (error != GL_NO_ERROR) {
      SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: simulating GL_FIXED attribs"");
      return false;
    }
   }
 
    
  error::Error GLES2DecoderImpl::HandleDrawArrays(
 
   GLuint max_vertex_accessed = first + count - 1;
   if (IsDrawValid(max_vertex_accessed)) {
    bool simulated_attrib_0 = false;
    if (!SimulateAttrib0(max_vertex_accessed, &simulated_attrib_0)) {
      return error::kNoError;
    }
     bool simulated_fixed_attribs = false;
     if (SimulateFixedAttribs(max_vertex_accessed, &simulated_fixed_attribs)) {
       bool textures_set = SetBlackTextureForNonRenderableTextures();
  error::Error GLES2DecoderImpl::HandleDrawElements(
   }
 
   if (IsDrawValid(max_vertex_accessed)) {
    bool simulated_attrib_0 = false;
    if (!SimulateAttrib0(max_vertex_accessed, &simulated_attrib_0)) {
      return error::kNoError;
    }
     bool simulated_fixed_attribs = false;
     if (SimulateFixedAttribs(max_vertex_accessed, &simulated_fixed_attribs)) {
       bool textures_set = SetBlackTextureForNonRenderableTextures();","Google Chrome before 14.0.835.163 does not properly handle triangle arrays, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2557,CVE-2011-2822,"  GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,
   PrepareStringForFileOps(text, &trimmed);
 
   bool is_file = true;
   
  GURL gurl(trimmed);
  if (gurl.is_valid() && gurl.IsStandard())
    is_file = false;
   FilePath full_path;
  if (is_file && !ValidPathForFile(trimmed, &full_path)) {
      
      
      ","Google Chrome before 13.0.782.215 on Windows does not properly parse URLs located on the command line, which has unspecified impact and attack vectors."
2558,CVE-2011-2828,"  class FaviconService : public CancelableRequestProvider,
   typedef CancelableRequest<FaviconDataCallback> GetFaviconRequest;
 
    
   
   
   Handle GetFavicon(const GURL& icon_url,
                     history::IconType icon_type,
                     CancelableRequestConsumerBase* consumer,","Google V8, as used in Google Chrome before 13.0.782.215, allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors that trigger an out-of-bounds write."
2559,CVE-2011-2839," 
 
  
  
 
  DEFINE_EMPTY_PROTOCOL(NSMenuDelegate)
 DEFINE_EMPTY_PROTOCOL(NSOpenSavePanelDelegate)
 DEFINE_EMPTY_PROTOCOL(NSOutlineViewDataSource)
 DEFINE_EMPTY_PROTOCOL(NSOutlineViewDelegate)
DEFINE_EMPTY_PROTOCOL(NSSpeechSynthesizerDelegate)
 DEFINE_EMPTY_PROTOCOL(NSTableViewDataSource)
 DEFINE_EMPTY_PROTOCOL(NSTableViewDelegate)
 DEFINE_EMPTY_PROTOCOL(NSTextFieldDelegate)","The PDF implementation in Google Chrome before 13.0.782.215 on Linux does not properly use the memset library function, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
2560,CVE-2011-2358,"  ProfileSyncService* test_sync_service = NULL;
 BrowserSignin* test_signin = NULL;
 bool ignore_user_gesture_for_tests = false;
 
 
enum AutoConfirmForTest {
  DO_NOT_SKIP = 0,
  PROCEED,
  ABORT
};
AutoConfirmForTest auto_confirm_for_tests = DO_NOT_SKIP;


  
 ProfileSyncService* GetSyncService(Profile* profile) {
   if (test_sync_service)
  void BeginInstallWithManifestFunction::SetResult(ResultCode code) {
   }
 }
 
 
void BeginInstallWithManifestFunction::SetIgnoreUserGestureForTests(
    bool ignore) {
  ignore_user_gesture_for_tests = ignore;
}

void BeginInstallWithManifestFunction::SetAutoConfirmForTests(
    bool should_proceed) {
  auto_confirm_for_tests = should_proceed ? PROCEED : ABORT;
}
 
 void BeginInstallWithManifestFunction::OnParseSuccess(
     const SkBitmap& icon, DictionaryValue* parsed_manifest) {
  void BeginInstallWithManifestFunction::OnParseSuccess(
   if (icon_.empty())
     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());
 
   
   
  if (auto_confirm_for_tests != DO_NOT_SKIP) {
    if (auto_confirm_for_tests == PROCEED)
      this->InstallUIProceed();
    else
      this->InstallUIAbort();
    return;
  }

   ShowExtensionInstallDialog(profile(),
                              this,
                              dummy_extension_.get(),","Google Chrome before 13.0.782.107 does not ensure that extension installations are confirmed by a browser dialog, which makes it easier for remote attackers to modify the product's functionality via a Trojan horse extension."
2561,CVE-2011-2361," 
 
  
  
 
 #ifndef BASE_CPU_H_
 #define BASE_CPU_H_
 #pragma once
 
 #include <string>
 
#include ""base/base_api.h""

 namespace base {
 
  
class BASE_API CPU {
  public:
    
   CPU();","The Basic Authentication dialog implementation in Google Chrome before 13.0.782.107 does not properly handle strings, which might make it easier for remote attackers to capture credentials via a crafted web site."
2562,CVE-2011-2782,"  bool NavigationController::RendererDidNavigate(
         return false;
       break;
     case NavigationType::NAV_IGNORE:
       
       
       
        
      if (pending_entry_) {
        DiscardNonCommittedEntries();
        extra_invalidate_flags |= TabContents::INVALIDATE_URL;
        tab_contents_->NotifyNavigationStateChanged(extra_invalidate_flags);
      }
       return false;
     default:
       NOTREACHED();","The drag-and-drop implementation in Google Chrome before 13.0.782.107 on Linux does not properly enforce permissions for files, which allows user-assisted remote attackers to bypass intended access restrictions via unspecified vectors."
2563,CVE-2011-2783,"  IN_PROC_BROWSER_TEST_F(ExtensionBrowserTest, MAYBE_PluginLoadUnload) {
   EXPECT_FALSE(result);
 
   ExtensionService* service = browser()->profile()->GetExtensionService();
  service->set_show_extensions_prompts(false);
   const size_t size_before = service->extensions()->size();
   ASSERT_TRUE(LoadExtension(extension_dir));
   EXPECT_EQ(size_before + 1, service->extensions()->size());
  IN_PROC_BROWSER_TEST_F(ExtensionBrowserTest, MAYBE_PluginPrivate) {
       test_data_dir_.AppendASCII(""uitest"").AppendASCII(""plugins_private"");
 
   ExtensionService* service = browser()->profile()->GetExtensionService();
  service->set_show_extensions_prompts(false);
   const size_t size_before = service->extensions()->size();
   ASSERT_TRUE(LoadExtension(extension_dir));
   EXPECT_EQ(size_before + 1, service->extensions()->size());","Google Chrome before 13.0.782.107 does not ensure that developer-mode NPAPI extension installations are confirmed by a browser dialog, which makes it easier for remote attackers to modify the product's functionality via a Trojan horse extension."
2564,CVE-2011-2784," 
 #include ""chrome/browser/task_manager/task_manager.h""
 #include ""chrome/browser/ui/browser.h""
 #include ""chrome/browser/ui/browser_window.h""
#include ""chrome/browser/ui/tab_contents/tab_contents_wrapper.h""
 #include ""chrome/common/chrome_paths.h""
 #include ""chrome/common/chrome_switches.h""
 #include ""chrome/test/in_process_browser_test.h""
  class TestPrerenderContents : public PrerenderContents {
     MessageLoopForUI::current()->Quit();
   }
 
   
   virtual void RenderViewGone(RenderViewHost* render_view_host,
                               base::TerminationStatus status,
                               int error_code) OVERRIDE {
  class TestPrerenderContents : public PrerenderContents {
     PrerenderContents::RenderViewGone(render_view_host, status, error_code);
   }
 
  virtual void RenderViewGone() OVERRIDE {
     
     
     
     
    if (expected_final_status_ == FINAL_STATUS_APP_TERMINATING)
      expected_final_status_ = FINAL_STATUS_RENDERER_CRASHED;

    PrerenderContents::RenderViewGone();
  }

   virtual void DidStopLoading() OVERRIDE {
     PrerenderContents::DidStopLoading();
     ++number_of_loads_;","Google Chrome before 13.0.782.107 allows remote attackers to obtain sensitive information via a request for the GL program log, which reveals a local path in an unspecified log entry."
2565,CVE-2011-2785,"  bool Extension::InitFromValue(const DictionaryValue& source, int flags,
       return false;
     }
     homepage_url_ = GURL(tmp);
    if (!homepage_url_.is_valid() ||
        (!homepage_url_.SchemeIs(""http"") &&
            !homepage_url_.SchemeIs(""https""))) {
       *error = ExtensionErrorUtils::FormatErrorMessage(
           errors::kInvalidHomepageURL, tmp);
       return false;","The extensions implementation in Google Chrome before 13.0.782.107 does not properly validate the URL for the home page, which allows remote attackers to have an unspecified impact via a crafted extension."
2566,CVE-2011-2787,"  void GpuDataManager::UpdateGpuInfo(const GPUInfo& gpu_info) {
     base::AutoLock auto_lock(gpu_info_lock_);
     if (!gpu_info_.Merge(gpu_info))
       return;
  }

  RunGpuInfoUpdateCallbacks();
 
  {
    base::AutoLock auto_lock(gpu_info_lock_);
     content::GetContentClient()->SetGpuInfo(gpu_info_);
   }
 ","Google Chrome before 13.0.782.107 does not properly address re-entrancy issues associated with the GPU lock, which allows remote attackers to cause a denial of service (application crash) via unspecified vectors."
2567,CVE-2011-2788," 
 
 #include ""base/i18n/case_conversion.h""
 
 #include ""unicode/unistr.h""
 
 namespace base {",Buffer overflow in the inspector serialization functionality in Google Chrome before 13.0.782.107 allows user-assisted remote attackers to have an unspecified impact via unknown vectors.
2568,CVE-2011-2789,"  PPB_URLLoader_API* PPB_URLLoader_Impl::AsPPB_URLLoader_API() {
   return this;
 }
 
void PPB_URLLoader_Impl::ClearInstance() {
  Resource::ClearInstance();
  loader_.reset();
 }
 
 int32_t PPB_URLLoader_Impl::Open(PP_Resource request_id,",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to instantiation of the Pepper plug-in.
2569,CVE-2011-2793,"  void HttpBridge::MakeAsynchronousPost() {
   if (fetch_state_.aborted)
     return;
 
  fetch_state_.url_poster = URLFetcher::Create(0, url_for_request_,
                                               URLFetcher::POST, this);
   fetch_state_.url_poster->set_request_context(context_getter_for_request_);
   fetch_state_.url_poster->set_upload_data(content_type_, request_content_);
   fetch_state_.url_poster->set_extra_request_headers(extra_headers_);",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to media selectors.
2570,CVE-2011-2797,"  bool AutofillDownloadManager::StartUploadRequest(
    
   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (form.upload_required() == UPLOAD_NOT_REQUIRED ||
      (form.upload_required() == USE_UPLOAD_RATES &&
       base::RandDouble() > upload_rate)) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
      
     return false;",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to resource caching.
2571,CVE-2011-2798,"  void ChromeContentRendererClient::RenderThreadStarted() {
           switches::kEnableIPCFuzzing)) {
     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());
   }
   
   
   
   
   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));
   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);
 
  WebString dev_tools_scheme(ASCIIToUTF16(chrome::kChromeDevToolsScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(dev_tools_scheme);

  WebString internal_scheme(ASCIIToUTF16(chrome::kChromeInternalScheme));
  WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(internal_scheme);

    
   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));
   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);","Google Chrome before 13.0.782.107 does not properly restrict access to internal schemes, which allows remote attackers to have an unspecified impact via a crafted web site."
2572,CVE-2011-2803," 
 #pragma once
 
 #include <gtk/gtk.h>

 #include <set>
 #include <vector>
 
 #include ""base/basictypes.h""
#include ""base/compiler_specific.h""
 #include ""chrome/browser/remove_rows_table_model.h""
 #include ""ui/base/models/table_model_observer.h""
 #include ""ui/base/models/tree_model.h""
  class TreeAdapter : public ui::TreeModelObserver {
   virtual void TreeNodesAdded(ui::TreeModel* model,
                               ui::TreeModelNode* parent,
                               int start,
                              int count) OVERRIDE;
   virtual void TreeNodesRemoved(ui::TreeModel* model,
                                 ui::TreeModelNode* parent,
                                 int start,
                                int count) OVERRIDE;
  virtual void TreeNodeChanged(ui::TreeModel* model,
                               ui::TreeModelNode* node) OVERRIDE;
    
 
  private:","Google Chrome before 13.0.782.107 does not properly handle Skia paths, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2573,CVE-2011-2801,"  bool TypedUrlModelAssociator::AssociateModels() {
              
              
             DCHECK(visits.size() > 0);
           }
           WriteToSyncNode(new_url, visits, &write_node);
         }
  bool TypedUrlModelAssociator::AssociateModels() {
       const sync_pb::TypedUrlSpecifics& typed_url(
         sync_child_node.GetTypedUrlSpecifics());
 
      sync_child_id = sync_child_node.GetSuccessorId();

       
       
      if (typed_url.visit_transitions_size() == 0) {
        VLOG(1) << ""Ignoring obsolete sync node with no visit transition info."";
        continue;
      }

       if (current_urls.find(typed_url.url()) == current_urls.end()) {
         new_visits.push_back(
             std::pair<GURL, std::vector<history::VisitInfo> >(
  bool TypedUrlModelAssociator::AssociateModels() {
         Associate(&typed_url.url(), sync_child_node.GetId());
         new_urls.push_back(new_url);
       }
     }
   }
 ",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the frame loader.
2574,CVE-2011-2818," 
 
 #include ""remoting/host/disconnect_window.h""
 
#include <gtk/gtk.h>

 #include ""base/compiler_specific.h""
 #include ""base/logging.h""
#include ""remoting/host/chromoting_host.h""
#include ""ui/base/gtk/gtk_signal.h""
 
 namespace {

const char kDisconnectWindowTitle[] = ""Remoting"";
const char kDisconnectWindowShareText[] = ""Sharing with: "";
const char kDisconnectWindowButtonText[] = ""Disconnect"";

 class DisconnectWindowLinux : public remoting::DisconnectWindow {
  public:
  DisconnectWindowLinux();

   virtual void Show(remoting::ChromotingHost* host,
                     const std::string& username) OVERRIDE;
   virtual void Hide() OVERRIDE;
 
  private:
  CHROMEGTK_CALLBACK_1(DisconnectWindowLinux, gboolean, OnWindowDelete,
                       GdkEvent*);
  CHROMEG_CALLBACK_0(DisconnectWindowLinux, void, OnDisconnectClicked,
                     GtkButton*);

  void CreateWindow();

  remoting::ChromotingHost* host_;
  GtkWidget* disconnect_window_;
  GtkWidget* user_label_;

   DISALLOW_COPY_AND_ASSIGN(DisconnectWindowLinux);
 };
 }   
 
DisconnectWindowLinux::DisconnectWindowLinux()
    : host_(NULL),
      disconnect_window_(NULL) {
}

void DisconnectWindowLinux::CreateWindow() {
  if (disconnect_window_) return;

  disconnect_window_ = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  GtkWindow* window = GTK_WINDOW(disconnect_window_);
  gtk_window_set_title(window, kDisconnectWindowTitle);
  gtk_window_set_resizable(window, FALSE);
   
  gtk_window_stick(window);
  gtk_window_set_keep_above(window, TRUE);

  g_signal_connect(disconnect_window_, ""delete-event"",
                   G_CALLBACK(OnWindowDeleteThunk), this);

  GtkWidget* main_area = gtk_vbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(disconnect_window_), main_area);

  GtkWidget* username_row = gtk_hbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(main_area), username_row);

  GtkWidget* share_label = gtk_label_new(kDisconnectWindowShareText);
  gtk_container_add(GTK_CONTAINER(username_row), share_label);

  user_label_ = gtk_label_new(NULL);
  gtk_container_add(GTK_CONTAINER(username_row), user_label_);

  GtkWidget* disconnect_box = gtk_hbox_new(FALSE, 0);
  gtk_container_add(GTK_CONTAINER(main_area), disconnect_box);

  GtkWidget* disconnect_button = gtk_button_new_with_label(
      kDisconnectWindowButtonText);
  gtk_box_pack_start(GTK_BOX(disconnect_box), disconnect_button,
                     TRUE, FALSE, 0);

  g_signal_connect(disconnect_button, ""clicked"",
                   G_CALLBACK(OnDisconnectClickedThunk), this);

  gtk_widget_show_all(main_area);
}

 void DisconnectWindowLinux::Show(remoting::ChromotingHost* host,
                                  const std::string& username) {
  host_ = host;
  CreateWindow();
  gtk_label_set_text(GTK_LABEL(user_label_), username.c_str());
  gtk_window_present(GTK_WINDOW(disconnect_window_));
 }
 
 void DisconnectWindowLinux::Hide() {
  DCHECK(disconnect_window_);

  gtk_widget_hide(disconnect_window_);
}

gboolean DisconnectWindowLinux::OnWindowDelete(GtkWidget* widget,
                                               GdkEvent* event) {
   
  return TRUE;
}

void DisconnectWindowLinux::OnDisconnectClicked(GtkButton* sender) {
  DCHECK(host_);
  host_->Shutdown();
 }
 
 remoting::DisconnectWindow* remoting::DisconnectWindow::Create() {",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to display box rendering.
2575,CVE-2011-2804,"  void CrosMock::TearDownMocks() {
     test_api()->SetTouchpadLibrary(NULL, false);
 }
 
input_method::InputMethodDescriptors*
CrosMock::CreateInputMethodDescriptors() {
  input_method::InputMethodDescriptors* descriptors =
      new input_method::InputMethodDescriptors;
   descriptors->push_back(
       input_method::GetFallbackInputMethodDescriptor());
   return descriptors;","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
2576,CVE-2011-2345,"  bool PPVarToNPVariant(PP_Var var, NPVariant* result) {
         return false;
       }
       const std::string& value = string->value();
      char* c_string = static_cast<char*>(malloc(value.size()));
      memcpy(c_string, value.data(), value.size());
      STRINGN_TO_NPVARIANT(c_string, value.size(), *result);
       break;
     }
     case PP_VARTYPE_OBJECT: {","The NPAPI implementation in Google Chrome before 12.0.742.112 does not properly handle strings, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2577,CVE-2011-2346," 
 
  
  
 
  static void SplitStringT(const STR& str,
   }
 }
 
 void SplitString(const string16& str,
                  char16 c,
                  std::vector<string16>* r) {
   DCHECK(CBU16_IS_SINGLE(c));
   SplitStringT(str, c, true, r);
 }
 
 void SplitString(const std::string& str,
                  char c,",Use-after-free vulnerability in Google Chrome before 12.0.742.112 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG fonts.
2578,CVE-2011-2347," 
 #pragma once
 
 #include ""base/callback_internal.h""
 
  
  ","Google Chrome before 12.0.742.112 does not properly handle Cascading Style Sheets (CSS) token sequences, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors."
2579,CVE-2011-2351,"  HistoryModelWorker::~HistoryModelWorker() {
 void HistoryModelWorker::DoWorkAndWaitUntilDone(Callback0::Type* work) {
   WaitableEvent done(false, false);
   scoped_refptr<WorkerTask> task(new WorkerTask(work, &done));
  history_service_->ScheduleDBTask(task.get(), &cancelable_consumer_);
   done.Wait();
 }
 ",Use-after-free vulnerability in Google Chrome before 12.0.742.112 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG use elements.
2580,CVE-2011-2349,"  class LoginObserver : public chromeos::LoginStatusConsumer,
 
   ~LoginObserver();
 
  virtual void OnLoginFailure(const chromeos::LoginFailure& error);
 
  virtual void OnLoginSuccess(
       const std::string& username,
       const std::string& password,
       const GaiaAuthConsumer::ClientLoginResult& credentials,
       bool pending_requests);
 
  virtual void Observe(NotificationType type,
                const NotificationSource& source,
                const NotificationDetails& details);
 ",Use-after-free vulnerability in Google Chrome before 12.0.742.112 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to text selection.
2581,," 
  typedef enum {
 PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_InputEvent_MouseButton, 4);
 
 typedef enum {
  PP_INPUTEVENT_TYPE_UNDEFINED   = -1,
  PP_INPUTEVENT_TYPE_MOUSEDOWN   = 0,   
  PP_INPUTEVENT_TYPE_MOUSEUP     = 1,   
  PP_INPUTEVENT_TYPE_MOUSEMOVE   = 2,   
  PP_INPUTEVENT_TYPE_MOUSEENTER  = 3,   
  PP_INPUTEVENT_TYPE_MOUSELEAVE  = 4,   
  PP_INPUTEVENT_TYPE_MOUSEWHEEL  = 5,   
  PP_INPUTEVENT_TYPE_RAWKEYDOWN  = 6,   
  PP_INPUTEVENT_TYPE_KEYDOWN     = 7,   
  PP_INPUTEVENT_TYPE_KEYUP       = 8,   
  PP_INPUTEVENT_TYPE_CHAR        = 9,   
  PP_INPUTEVENT_TYPE_CONTEXTMENU = 10   
 } PP_InputEvent_Type;
 PP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_InputEvent_Type, 4);
 
  PP_COMPILE_ASSERT_STRUCT_SIZE_IN_BYTES(PP_InputEvent, 80);
  */
 
 #endif   
2582,,"  void BlobURLRequestJob::HeadersCompleted(int status_code,
   response_info_->headers = headers;
 
   set_expected_content_size(remaining_bytes_);
   headers_set_ = true;

  NotifyHeadersComplete();
 }
 
 void BlobURLRequestJob::NotifySuccess() {",
2583,,"  class TransportSocketParams : public base::RefCounted<TransportSocketParams> {
 };
 
  
 
 
 
 
 
 
 
 class TransportConnectJob : public ConnectJob {
  public:
   TransportConnectJob(const std::string& group_name,
                      const scoped_refptr<TransportSocketParams>& params,
                      base::TimeDelta timeout_duration,
                      ClientSocketFactory* client_socket_factory,
                      HostResolver* host_resolver,
                      Delegate* delegate,
                      NetLog* net_log);
   virtual ~TransportConnectJob();
 
    ",
2584,,"  bool PPVarToNPVariant(PP_Var var, NPVariant* result) {
         return false;
       }
       const std::string& value = string->value();
      char* c_string = static_cast<char*>(malloc(value.size()));
      memcpy(c_string, value.data(), value.size());
      STRINGN_TO_NPVARIANT(c_string, value.size(), *result);
       break;
     }
     case PP_VARTYPE_OBJECT: {",
2585,,"  void AddInstallerCopyTasks(const InstallerState& installer_state,
   FilePath exe_dst(installer_dir.Append(setup_path.BaseName()));
   FilePath archive_dst(installer_dir.Append(archive_path.BaseName()));
 
  install_list->AddCopyTreeWorkItem(setup_path.value(), exe_dst.value(),
                                    temp_path.value(), WorkItem::ALWAYS);

    
    
    
   
   
   install_list->AddMoveTreeWorkItem(archive_path.value(), archive_dst.value(),
                                     temp_path.value(), WorkItem::ALWAYS_MOVE);
 }",
2586,CVE-2011-1300," 
 #include ""chrome/browser/chromeos/cros/touchpad_library.h""
 #include ""chrome/browser/chromeos/cros/update_library.h""
 
#define DEFINE_GET_LIBRARY_METHOD(class_prefix, var_prefix)                    \
class_prefix##Library* CrosLibrary::Get##class_prefix##Library() {             \
  return var_prefix##_lib_.GetDefaultImpl(use_stub_impl_);                     \
}

#define DEFINE_SET_LIBRARY_METHOD(class_prefix, var_prefix)                    \
void CrosLibrary::TestApi::Set##class_prefix##Library(                         \
    class_prefix##Library* library, bool own) {                                \
  library_->var_prefix##_lib_.SetImpl(library, own);                           \
}


 namespace chromeos {
 
 static base::LazyInstance<CrosLibrary> g_cros_library(
  CrosLibrary* CrosLibrary::Get() {
   return g_cros_library.Pointer();
 }
 
DEFINE_GET_LIBRARY_METHOD(Brightness, brightness);
DEFINE_GET_LIBRARY_METHOD(Burn, burn);
DEFINE_GET_LIBRARY_METHOD(Cryptohome, crypto);
DEFINE_GET_LIBRARY_METHOD(Keyboard, keyboard);
DEFINE_GET_LIBRARY_METHOD(InputMethod, input_method);
DEFINE_GET_LIBRARY_METHOD(Login, login);
DEFINE_GET_LIBRARY_METHOD(Mount, mount);
DEFINE_GET_LIBRARY_METHOD(Network, network);
DEFINE_GET_LIBRARY_METHOD(Power, power);
DEFINE_GET_LIBRARY_METHOD(ScreenLock, screen_lock);
DEFINE_GET_LIBRARY_METHOD(SpeechSynthesis, speech_synthesis);
DEFINE_GET_LIBRARY_METHOD(Syslogs, syslogs);
DEFINE_GET_LIBRARY_METHOD(System, system);
DEFINE_GET_LIBRARY_METHOD(Touchpad, touchpad);
DEFINE_GET_LIBRARY_METHOD(Update, update);
 
 bool CrosLibrary::EnsureLoaded() {
   if (use_stub_impl_)
  void CrosLibrary::TestApi::SetLibraryLoader(LibraryLoader* loader, bool own) {
   library_->load_error_ = false;
 }
 
DEFINE_SET_LIBRARY_METHOD(Brightness, brightness);
DEFINE_SET_LIBRARY_METHOD(Burn, burn);
DEFINE_SET_LIBRARY_METHOD(Cryptohome, crypto);
DEFINE_SET_LIBRARY_METHOD(Keyboard, keyboard);
DEFINE_SET_LIBRARY_METHOD(InputMethod, input_method);
DEFINE_SET_LIBRARY_METHOD(Login, login);
DEFINE_SET_LIBRARY_METHOD(Mount, mount);
DEFINE_SET_LIBRARY_METHOD(Network, network);
DEFINE_SET_LIBRARY_METHOD(Power, power);
DEFINE_SET_LIBRARY_METHOD(ScreenLock, screen_lock);
DEFINE_SET_LIBRARY_METHOD(SpeechSynthesis, speech_synthesis);
DEFINE_SET_LIBRARY_METHOD(Syslogs, syslogs);
DEFINE_SET_LIBRARY_METHOD(System, system);
DEFINE_SET_LIBRARY_METHOD(Touchpad, touchpad);
DEFINE_SET_LIBRARY_METHOD(Update, update);
 
 }  ","The Program::getActiveUniformMaxLength function in libGLESv2/Program.cpp in libGLESv2.dll in the WebGLES library in Almost Native Graphics Layer Engine (ANGLE), as used in Mozilla Firefox 4.x before 4.0.1 on Windows and in the GPU process in Google Chrome before 10.0.648.205 on Windows, allows remote attackers to execute arbitrary code via unspecified vectors, related to an *off-by-three* error."
2587,CVE-2011-1301,"  namespace debug {
  
  
 bool DebugOnStart::FindArgument(wchar_t* command_line, const char* argument_c) {
  wchar_t argument[50] = {};
   for (int i = 0; argument_c[i]; ++i)
     argument[i] = argument_c[i];
 ",Use-after-free vulnerability in the GPU process in Google Chrome before 10.0.648.205 allows remote attackers to execute arbitrary code via unknown vectors.
2588,CVE-2011-1291,"  string16 TruncateString(const string16& string, size_t length) {
 
 string16 ToLower(const string16& string) {
   icu::UnicodeString lower_u_str(
      icu::UnicodeString(FALSE, string.c_str(), string.size()).toLower(
          icu::Locale::getDefault()));
   string16 result;
   lower_u_str.extract(0, lower_u_str.length(),
                       WriteInto(&result, lower_u_str.length() + 1));
  string16 ToLower(const string16& string) {
 
 string16 ToUpper(const string16& string) {
   icu::UnicodeString upper_u_str(
      icu::UnicodeString(FALSE, string.c_str(), string.size()).toUpper(
          icu::Locale::getDefault()));
   string16 result;
   upper_u_str.extract(0, upper_u_str.length(),
                       WriteInto(&result, upper_u_str.length() + 1));","Google Chrome before 10.0.648.204 does not properly handle base strings, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors, related to a *buffer error.*"
2589,CVE-2011-1292,"  void AutoFillManager::LogMetricsAboutSubmittedForm(
     cached_fields[field->FieldSignature()] = field;
   }
 
  std::string experiment_id = cached_submitted_form->server_experiment_id();
   for (size_t i = 0; i < submitted_form->field_count(); ++i) {
     const AutoFillField* field = submitted_form->field(i);
     FieldTypeSet field_types;
  void AutoFillManager::LogMetricsAboutSubmittedForm(
     }
 
      
    metric_logger_->Log(AutoFillMetrics::FIELD_SUBMITTED, experiment_id);
     if (field_types.find(EMPTY_TYPE) == field_types.end() &&
         field_types.find(UNKNOWN_TYPE) == field_types.end()) {
       if (field->is_autofilled()) {
        metric_logger_->Log(AutoFillMetrics::FIELD_AUTOFILLED, experiment_id);
       } else {
        metric_logger_->Log(AutoFillMetrics::FIELD_AUTOFILL_FAILED,
                            experiment_id);
 
         AutoFillFieldType heuristic_type = UNKNOWN_TYPE;
         AutoFillFieldType server_type = NO_SERVER_DATA;
  void AutoFillManager::LogMetricsAboutSubmittedForm(
           server_type = cached_field->second->server_type();
         }
 
        if (heuristic_type == UNKNOWN_TYPE) {
          metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_UNKNOWN,
                              experiment_id);
        } else if (field_types.count(heuristic_type)) {
          metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_MATCH,
                              experiment_id);
        } else {
          metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_MISMATCH,
                              experiment_id);
        }

        if (server_type == NO_SERVER_DATA) {
          metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_UNKNOWN,
                              experiment_id);
        } else if (field_types.count(server_type)) {
          metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_MATCH,
                              experiment_id);
        } else {
          metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_MISMATCH,
                              experiment_id);
        }
       }
 
        ",Use-after-free vulnerability in the frame-loader implementation in Google Chrome before 10.0.648.204 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2590,CVE-2011-1296," 
 #include ""chrome/browser/ui/app_modal_dialogs/app_modal_dialog_queue.h""
 #include ""chrome/browser/ui/find_bar/find_bar.h""
 #include ""chrome/browser/ui/find_bar/find_bar_controller.h""
 #include ""chrome/browser/ui/find_bar/find_notification_details.h""
#include ""chrome/browser/ui/find_bar/find_tab_helper.h""
 #include ""chrome/browser/ui/login/login_prompt.h""
 #include ""chrome/browser/ui/omnibox/location_bar.h""
 #include ""chrome/browser/ui/tab_contents/tab_contents_wrapper.h""
  void AutomationProvider::SendFindRequest(
   TabContentsWrapper* wrapper =
       TabContentsWrapper::GetCurrentWrapperForContents(tab_contents);
   if (wrapper)
    wrapper->find_tab_helper()->set_current_find_request_id(request_id);
 
   tab_contents->render_view_host()->StartFinding(
       FindInPageNotificationObserver::kFindInPageRequestId,","Google Chrome before 10.0.648.204 does not properly handle SVG text, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors that lead to a *stale pointer.*"
2591,,"  void StatusBubbleGtk::Show() {
    
   hide_timer_.Stop();
 
  gtk_widget_show(container_.get());
   if (container_->window)
     gdk_window_raise(container_->window);
 }
  void StatusBubbleGtk::Hide() {
   expand_timer_.Stop();
   expand_animation_.reset();
 
  gtk_widget_hide(container_.get());
 }
 
 void StatusBubbleGtk::SetStatusTextTo(const std::string& status_utf8) {
  void StatusBubbleGtk::InitWidgets() {
       kInternalLeftRightPadding + (ltr ? 0 : kCornerSize),
       kInternalLeftRightPadding + (ltr ? kCornerSize : 0));
   gtk_container_add(GTK_CONTAINER(padding_), label_);
  gtk_widget_show_all(padding_);
 
   container_.Own(gtk_event_box_new());
   gtk_widget_set_no_show_all(container_.get(), TRUE);",
2592,,"  const char* Pickle::FindNext(size_t header_size,
   DCHECK(header_size == AlignInt(header_size, sizeof(uint32)));
   DCHECK(header_size <= static_cast<size_t>(kPayloadUnit));
 
  if (static_cast<size_t>(end - start) < sizeof(Header))
    return NULL;

   const Header* hdr = reinterpret_cast<const Header*>(start);
   const char* payload_base = start + header_size;
   const char* payload_end = payload_base + hdr->payload_size;",
2593,," 
 
 #include ""base/logging.h""
 #include ""base/singleton.h""
#include ""chrome/browser/browser_thread.h""
#include ""chrome/browser/chromeos/audio_mixer_alsa.h""
#include ""chrome/browser/chromeos/audio_mixer_pulse.h""
 
 namespace chromeos {
 
 namespace {
 
 const double kMinVolumeDb = -90.0;
  
  
  const int kMaxReconnectTries = 4;
 
 }   
 
 
 
 
 double AudioHandler::GetVolumePercent() {
   if (!VerifyMixerConnection())
  double AudioHandler::GetVolumePercent() {
 }
 
  
 
 void AudioHandler::SetVolumePercent(double volume_percent) {
   if (!VerifyMixerConnection())
     return;
   DCHECK(volume_percent >= 0.0);
 
   double vol_db;
   if (volume_percent <= 0)
    vol_db = AudioMixer::kSilenceDb;
   else
     vol_db = PercentToVolumeDb(volume_percent);
 
  void AudioHandler::AdjustVolumeByPercent(double adjust_by_percent) {
 
   double new_volume;
   if (pct <= 0.1)
    new_volume = AudioMixer::kSilenceDb;
   else
     new_volume = PercentToVolumeDb(pct);
 
  bool AudioHandler::IsMute() {
 void AudioHandler::SetMute(bool do_mute) {
   if (!VerifyMixerConnection())
     return;
   DVLOG(1) << ""Setting Mute to "" << do_mute;
   mixer_->SetMute(do_mute);
 }
 
bool AudioHandler::TryToConnect(bool async) {
  if (mixer_type_ == MIXER_TYPE_PULSEAUDIO) {
    VLOG(1) << ""Trying to connect to PulseAudio"";
    mixer_.reset(new AudioMixerPulse());
  } else if (mixer_type_ == MIXER_TYPE_ALSA) {
    VLOG(1) << ""Trying to connect to ALSA"";
    mixer_.reset(new AudioMixerAlsa());
  } else {
    VLOG(1) << ""Cannot find valid volume mixer"";
    mixer_.reset();
    return false;
  }

  if (async) {
    mixer_->Init(NewCallback(this, &AudioHandler::OnMixerInitialized));
  } else {
    if (!mixer_->InitSync()) {
      VLOG(1) << ""Unable to reconnect to Mixer"";
      return false;
    }
  }
  return true;
}

void AudioHandler::UseNextMixer() {
  if (mixer_type_ == MIXER_TYPE_PULSEAUDIO)
    mixer_type_ = MIXER_TYPE_ALSA;
  else
    mixer_type_ = MIXER_TYPE_NONE;
}

static void ClipVolume(double* min_volume, double* max_volume) {
  if (*min_volume < kMinVolumeDb)
    *min_volume = kMinVolumeDb;
  if (*max_volume > kMaxVolumeDb)
    *max_volume = kMaxVolumeDb;
}

 void AudioHandler::OnMixerInitialized(bool success) {
   connected_ = success;
   DVLOG(1) << ""OnMixerInitialized, success = "" << success;

  if (connected_) {
    if (mixer_->GetVolumeLimits(&min_volume_db_, &max_volume_db_)) {
      ClipVolume(&min_volume_db_, &max_volume_db_);
    }
    return;
  }

  VLOG(1) << ""Unable to connect to mixer, trying next"";
  UseNextMixer();

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      NewRunnableMethod(this, &AudioHandler::TryToConnect, true));
 }
 
 AudioHandler::AudioHandler()
     : connected_(false),
      reconnect_tries_(0),
      max_volume_db_(kMaxVolumeDb),
      min_volume_db_(kMinVolumeDb),
      mixer_type_(MIXER_TYPE_PULSEAUDIO) {

   
   
   
  TryToConnect(true);
 }
 
 AudioHandler::~AudioHandler() {
   mixer_.reset();
 };
 
 bool AudioHandler::VerifyMixerConnection() {
  if (mixer_ == NULL)
    return false;

  AudioMixer::State mixer_state = mixer_->GetState();
  if (mixer_state == AudioMixer::READY)
     return true;
   if (connected_) {
      
      
     connected_ = false;
    LOG(ERROR) << ""Lost connection to mixer"";
   } else {
     LOG(ERROR) << ""Mixer not valid"";
   }
 
  if ((mixer_state == AudioMixer::INITIALIZING) ||
      (mixer_state == AudioMixer::SHUTTING_DOWN))
     return false;
 
   if (reconnect_tries_ < kMaxReconnectTries) {
     reconnect_tries_++;
    VLOG(1) << ""Re-connecting to mixer attempt "" << reconnect_tries_ << ""/""
             << kMaxReconnectTries;

    connected_ = TryToConnect(false);

     if (connected_) {
       reconnect_tries_ = 0;
       return true;
     }
    LOG(ERROR) << ""Unable to re-connect to mixer"";
   }
   return false;
 }
 
  
  
 
 
  
  
  
  
 
  
double AudioHandler::VolumeDbToPercent(double volume_db) const {
  if (volume_db < min_volume_db_)
     return 0;
  return 100.0 * pow((volume_db - min_volume_db_) /
      (max_volume_db_ - min_volume_db_), 1/kVolumeBias);
 }
 
  
double AudioHandler::PercentToVolumeDb(double volume_percent) const {
   return pow(volume_percent / 100.0, kVolumeBias) *
      (max_volume_db_ - min_volume_db_) + min_volume_db_;
 }
 
  ",
2594,,"  void Browser::CloseContents(TabContents* source) {
      
      
      
    ClearUnloadState(source, true);
     return;
   }
 
  void Browser::Observe(NotificationType type,
   switch (type.value) {
     case NotificationType::TAB_CONTENTS_DISCONNECTED:
       if (is_attempting_to_close_browser_) {
         
         
         
        ClearUnloadState(Source<TabContents>(source).ptr(), false);
       }
       break;
 
  void Browser::SyncHistoryWithTabs(int index) {
  
 
 void Browser::ProcessPendingTabs() {
  if (!is_attempting_to_close_browser_) {
     
     
     
    return;
  }
 
   if (HasCompletedUnloadProcessing()) {
      
  void Browser::ProcessPendingTabs() {
     if (tab->render_view_host()) {
       tab->render_view_host()->FirePageBeforeUnload(false);
     } else {
      ClearUnloadState(tab, true);
     }
   } else if (!tabs_needing_unload_fired_.empty()) {
      
  void Browser::ProcessPendingTabs() {
     if (tab->render_view_host()) {
       tab->render_view_host()->ClosePage(false, -1, -1);
     } else {
      ClearUnloadState(tab, true);
     }
   } else {
     NOTREACHED();
  bool Browser::RemoveFromSet(UnloadListenerSet* set, TabContents* tab) {
   return false;
 }
 
void Browser::ClearUnloadState(TabContents* tab, bool process_now) {
    
    
    
   if (is_attempting_to_close_browser_) {
     RemoveFromSet(&tabs_needing_before_unload_fired_, tab);
     RemoveFromSet(&tabs_needing_unload_fired_, tab);
    if (process_now) {
      ProcessPendingTabs();
    } else {
      MessageLoop::current()->PostTask(
          FROM_HERE,
          method_factory_.NewRunnableMethod(&Browser::ProcessPendingTabs));
    }
   }
 }
 
  
  
 
  void Browser::TabDetachedAtImpl(TabContentsWrapper* contents, int index,
     find_bar_controller_->ChangeTabContents(NULL);
   }
 
  if (is_attempting_to_close_browser_) {
     
     
     
     
    ClearUnloadState(contents->tab_contents(), false);
  }

   registrar_.Remove(this, NotificationType::TAB_CONTENTS_DISCONNECTED,
                     Source<TabContentsWrapper>(contents));
 }",
2595,,"  void NetworkScreen::OnConnectionTimeout() {
             IDS_NETWORK_SELECTION_ERROR,
             l10n_util::GetStringUTF16(IDS_PRODUCT_OS_NAME),
             network_id_)),
        UTF16ToWide(l10n_util::GetStringUTF16(IDS_LEARN_MORE)),
         this);
     network_control->RequestFocus();
   }",
2596,,"  void DataTypeManagerImpl::Restart() {
    
   state_ = DOWNLOAD_PENDING;
   backend_->ConfigureDataTypes(
      controllers_,
       last_requested_types_,
       method_factory_.NewRunnableMethod(&DataTypeManagerImpl::DownloadReady));
 ",
2597,,"  void PrintWebViewHelper::UpdatePrintableSizeInPrintParameters(
       static_cast<int>(ConvertUnitDouble(content_height_in_points,
           printing::kPointsPerInch, dpi)));
 
  double page_width_in_points = content_width_in_points +
      margin_left_in_points + margin_right_in_points;
  double page_height_in_points = content_height_in_points +
      margin_top_in_points + margin_bottom_in_points;

   params->page_size = gfx::Size(
      static_cast<int>(ConvertUnitDouble(
          page_width_in_points, printing::kPointsPerInch, dpi)),
      static_cast<int>(ConvertUnitDouble(
          page_height_in_points, printing::kPointsPerInch, dpi)));
 
   params->margin_top = static_cast<int>(ConvertUnitDouble(
       margin_top_in_points, printing::kPointsPerInch, dpi));",
2598,,"  void BlockedPlugin::LoadPlugin() {
   WebPlugin* new_plugin =
       render_view()->CreatePluginNoCheck(frame_, plugin_params_);
   if (new_plugin && new_plugin->initialize(container)) {
    plugin_->RestoreTitleText();
     container->setPlugin(new_plugin);
     container->invalidate();
     container->reportGeometry();",
2599,," 
 
 #include ""chrome/browser/autofill/autofill_cc_infobar.h""
 
#include ""chrome/browser/tab_contents/infobar_delegate.h""
 #include ""chrome/browser/ui/views/event_utils.h""
#include ""chrome/browser/ui/views/infobars/confirm_infobar.h""
 #include ""chrome/browser/ui/views/infobars/infobar_text_button.h""
 #include ""grit/chromium_strings.h""
 #include ""grit/generated_resources.h""
  SaveCCInfoConfirmInfoBar::~SaveCCInfoConfirmInfoBar() {
 
 void SaveCCInfoConfirmInfoBar::Layout() {
    
  InfoBarView::Layout();
 
   int available_width = AlertInfoBar::GetAvailableWidth();
 
  void SaveCCInfoConfirmInfoBar::LinkActivated(views::Link* source,
 void SaveCCInfoConfirmInfoBar::ViewHierarchyChanged(bool is_add,
                                                     views::View* parent,
                                                     views::View* child) {
  InfoBarView::ViewHierarchyChanged(is_add, parent, child);
   if (is_add && child == this && !initialized_) {
     Init();
     initialized_ = true;
  void SaveCCInfoConfirmInfoBar::ViewHierarchyChanged(bool is_add,
 
 void SaveCCInfoConfirmInfoBar::ButtonPressed(views::Button* sender,
                                              const views::Event& event) {
  InfoBarView::ButtonPressed(sender, event);
   if (sender == save_button_) {
     if (GetDelegate()->Accept())
       RemoveInfoBar();",
2600,," 
 #include ""chrome/common/notification_type.h""
 #include ""chrome/common/pref_names.h""
 #include ""chrome/common/translate_errors.h""
#include ""chrome/common/url_constants.h""
 #include ""grit/browser_resources.h""
 #include ""net/base/escape.h""
 #include ""net/url_request/url_request_status.h""
  TranslateManager* TranslateManager::GetInstance() {
 
  
 bool TranslateManager::IsTranslatableURL(const GURL& url) {
   
   
   
   
   
  return !url.SchemeIs(chrome::kChromeUIScheme) &&
         !url.SchemeIs(chrome::kChromeDevToolsScheme) &&
         !url.SchemeIs(chrome::kFtpScheme);
 }
 
  ",
2601,,"  void GLES2DecoderImpl::DoGetFramebufferAttachmentParameteriv(
     return;
   }
   glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
  if (pname == GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) {
    GLint type = 0;
    GLuint client_id = 0;
    glGetFramebufferAttachmentParameterivEXT(
        target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, &type);
    switch (type) {
      case GL_RENDERBUFFER: {
        renderbuffer_manager()->GetClientId(*params, &client_id);
        break;
      }
      case GL_TEXTURE: {
        texture_manager()->GetClientId(*params, &client_id);
        break;
      }
      default:
        break;
    }
    *params = client_id;
  }
 }
 
 void GLES2DecoderImpl::DoGetRenderbufferParameteriv(",
2602,,"  IN_PROC_BROWSER_TEST_F(DevToolsSanityTest,
 
  
  
IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestPauseWhenLoadingDevTools) {
   RunTest(""testPauseWhenLoadingDevTools"", kPauseWhenLoadingDevTools);
 }
 
  
  
IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestPauseWhenScriptIsRunning) {
   RunTest(""testPauseWhenScriptIsRunning"", kPauseWhenScriptIsRunning);
 }
 ",
2603,,"  bool SandboxedExtensionUnpacker::ValidateSignature() {
     ReportFailure(""Key length is zero"");
     return false;
   }
  if (header.signature_size == 0) {
    ReportFailure(""Signature length is zero"");
    return false;
  }
 
   std::vector<uint8> key;
   key.resize(header.key_size);",
2604,," 
 #include ""base/scoped_ptr.h""
 #include ""base/singleton.h""
 #include ""base/string_util.h""
#include ""base/stringprintf.h""
 #include ""base/time.h""
 #include ""base/utf_string_conversions.h""
 #include ""chrome/browser/browser_init.h""
  const char kAuthSuffix[] = ""\n"";
  
 const char kGuestModeLoggingLevel[] = ""1"";
 
 
const char kSwitchFormatString[] = ""--%s=\""%s\"""";

 }   
 
 class LoginUtilsImpl : public LoginUtils {
  void LoginUtilsImpl::CompleteOffTheRecordLogin(const GURL& start_url) {
     command_line.AppendSwitchASCII(
         switches::kLoginUser,
         UserManager::Get()->logged_in_user().email());

     if (start_url.is_valid())
       command_line.AppendArg(start_url.spec());

    std::string cmd_line_str = command_line.command_line_string();
     
     
     
    if (browser_command_line.HasSwitch(switches::kRegisterPepperPlugins)) {
      cmd_line_str += base::StringPrintf(
          kSwitchFormatString,
          switches::kRegisterPepperPlugins,
          browser_command_line.GetSwitchValueNative(
              switches::kRegisterPepperPlugins).c_str());
    }

    CrosLibrary::Get()->GetLoginLibrary()->RestartJob(getpid(), cmd_line_str);
   }
 }
 ",
2605,,"  void AudioRendererHost::OnSetVolume(const IPC::Message& msg, int stream_id,
 
    
   if (volume < 0 || volume > 1.0)
    return;
   entry->controller->SetVolume(volume);
 }
 ",
2606,,"  void AudioOutputController::DoFlush() {
   if (!sync_reader_) {
     if (state_ != kPaused)
       return;
    AutoLock auto_lock(lock_);
     buffer_.Clear();
   }
 }",
2607,CVE-2012-5112,"  bool ChromeRenderMessageFilter::OnMessageReceived(const IPC::Message& message,
     IPC_MESSAGE_HANDLER(ExtensionHostMsg_UnloadAck, OnExtensionUnloadAck)
     IPC_MESSAGE_HANDLER(ExtensionHostMsg_ResumeRequests,
                         OnExtensionResumeRequests);
     IPC_MESSAGE_HANDLER(ChromeViewHostMsg_AllowDatabase, OnAllowDatabase)
     IPC_MESSAGE_HANDLER(ChromeViewHostMsg_AllowDOMStorage, OnAllowDOMStorage)
     IPC_MESSAGE_HANDLER(ChromeViewHostMsg_AllowFileSystem, OnAllowFileSystem)
  void ChromeRenderMessageFilter::OnExtensionResumeRequests(int route_id) {
       render_process_id_, route_id);
 }
 
 void ChromeRenderMessageFilter::OnAllowDatabase(int render_view_id,
                                                 const GURL& origin_url,
                                                 const GURL& top_origin_url,","Use-after-free vulnerability in the SVG implementation in WebKit, as used in Google Chrome before 22.0.1229.94, allows remote attackers to execute arbitrary code via unspecified vectors."
2608,CVE-2012-5112,"  class QuotaManager::HostDataDeleter : public QuotaTask {
   DISALLOW_COPY_AND_ASSIGN(HostDataDeleter);
 };
 
 class QuotaManager::GetModifiedSinceHelper {
  public:
   bool GetModifiedSinceOnDBThread(StorageType type,
  void QuotaManager::GetAvailableSpace(const AvailableSpaceCallback& callback) {
     callback.Run(kQuotaStatusOk, kIncognitoDefaultTemporaryQuota);
     return;
   }

  PostTaskAndReplyWithResult(
      db_thread_,
      FROM_HERE,
      base::Bind(get_disk_space_fn_, profile_path_),
      base::Bind(&QuotaManager::DidGetAvailableSpace,
                 weak_factory_.GetWeakPtr(),
                 callback));
 }
 
 void QuotaManager::GetTemporaryGlobalQuota(const QuotaCallback& callback) {
  void QuotaManager::DidInitializeTemporaryOriginsInfo(bool success) {
     StartEviction();
 }
 
void QuotaManager::DidGetAvailableSpace(const AvailableSpaceCallback& callback,
                                        int64 space) {
  callback.Run(kQuotaStatusOk, space);
}

 void QuotaManager::DidDatabaseWork(bool success) {
   db_disabled_ = !success;
 }","Use-after-free vulnerability in the SVG implementation in WebKit, as used in Google Chrome before 22.0.1229.94, allows remote attackers to execute arbitrary code via unspecified vectors."
2609,," 
 
 #include ""content/public/common/renderer_preferences.h""
 
#include ""third_party/skia/include/core/SkColor.h""

 namespace content {
 
 RendererPreferences::RendererPreferences()
  RendererPreferences::RendererPreferences()
       subpixel_rendering(
           RENDERER_PREFERENCES_SUBPIXEL_RENDERING_SYSTEM_DEFAULT),
       use_subpixel_positioning(false),
      focus_ring_color(SkColorSetARGB(255, 229, 151, 0)),
      thumb_active_color(SkColorSetRGB(244, 244, 244)),
      thumb_inactive_color(SkColorSetRGB(234, 234, 234)),
      track_color(SkColorSetRGB(211, 211, 211)),
      active_selection_bg_color(SkColorSetRGB(30, 144, 255)),
      active_selection_fg_color(SK_ColorWHITE),
      inactive_selection_bg_color(SkColorSetRGB(200, 200, 200)),
      inactive_selection_fg_color(SkColorSetRGB(50, 50, 50)),
       browser_handles_non_local_top_level_requests(false),
       browser_handles_all_top_level_requests(false),
       caret_blink_interval(0),",
2610,CVE-2012-5139,"  class LocalHttpTestServer : public TestServer {
                    FilePath()) {}
 };
 
TEST_F(URLRequestTest, FLAKY_DelayedCookieCallback) {
   LocalHttpTestServer test_server;
   ASSERT_TRUE(test_server.Start());
 
  class URLRequestTestFTP : public URLRequestTest {
 };
 
  
TEST_F(URLRequestTestFTP, FLAKY_UnsafePort) {
   ASSERT_TRUE(test_server_.Start());
 
   URLRequestJobFactoryImpl job_factory;",Use-after-free vulnerability in Google Chrome before 23.0.1271.97 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to visibility events.
2611,CVE-2012-5140,"  PPB_URLLoader_Impl::PPB_URLLoader_Impl(PP_Instance instance,
 }
 
 PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {
   
   
   
   
   
  scoped_ptr<WebKit::WebURLLoader> for_destruction_only(loader_.release());
 }
 
 PPB_URLLoader_API* PPB_URLLoader_Impl::AsPPB_URLLoader_API() {",Use-after-free vulnerability in Google Chrome before 23.0.1271.97 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the URL loader.
2612,CVE-2012-5141," 
 #include ""media/base/media.h""
 #include ""net/socket/ssl_server_socket.h""
 #include ""ppapi/cpp/completion_callback.h""
#include ""ppapi/cpp/dev/url_util_dev.h""
 #include ""ppapi/cpp/input_event.h""
 #include ""ppapi/cpp/mouse_cursor.h""
 #include ""ppapi/cpp/rect.h""
  const int kBytesPerPixel = 4;
 
 const int kPerfStatsIntervalMs = 1000;
 
 
const char kChromeExtensionUrlScheme[] = ""chrome-extension"";

 std::string ConnectionStateToString(protocol::ConnectionToHost::State state) {
    
    
  bool ChromotingInstance::Init(uint32_t argc,
     return false;
   }
 
   
  if (!IsCallerAppOrExtension()) {
    LOG(ERROR) << ""Not an app or extension"";
    return false;
  }

    
    
    
  void ChromotingInstance::ProcessLogToUI(const std::string& message) {
   g_logging_to_plugin = false;
 }
 
bool ChromotingInstance::IsCallerAppOrExtension() {
  const pp::URLUtil_Dev* url_util = pp::URLUtil_Dev::Get();
  if (!url_util)
    return false;

  PP_URLComponents_Dev url_components;
  pp::Var url_var = url_util->GetDocumentURL(this, &url_components);
  if (!url_var.is_string())
    return false;

  std::string url = url_var.AsString();
  std::string url_scheme = url.substr(url_components.scheme.begin,
                                      url_components.scheme.len);
  return url_scheme == kChromeExtensionUrlScheme;
}

 bool ChromotingInstance::IsConnected() {
   return host_connection_.get() &&
     (host_connection_->state() == protocol::ConnectionToHost::CONNECTED);","Google Chrome before 23.0.1271.97 does not properly restrict instantiation of the Chromoting client plug-in, which has unspecified impact and attack vectors."
2613,CVE-2012-5143,"  bool PPB_ImageData_Impl::Init(PP_ImageDataFormat format,
     return false;   
   if (width <= 0 || height <= 0)
     return false;
  if (static_cast<int64>(width) * static_cast<int64>(height) >=
      std::numeric_limits<int32>::max() / 4)
     return false;   
 
   format_ = format;
  const SkBitmap* ImageDataNaClBackend::GetMappedBitmap() const {
 
 }   
 }   
2614,CVE-2012-5138,"  class ChildProcessSecurityPolicyImpl::SecurityState {
   bool HasPermissionsForFile(const FilePath& file, int permissions) {
     FilePath current_path = file.StripTrailingSeparators();
     FilePath last_path;
    int skip = 0;
     while (current_path != last_path) {
      FilePath base_name =  current_path.BaseName();
      if (base_name.value() == FilePath::kParentDirectory) {
        ++skip;
      } else if (skip > 0) {
        if (base_name.value() != FilePath::kCurrentDirectory)
          --skip;
      } else {
        if (file_permissions_.find(current_path) != file_permissions_.end())
          return (file_permissions_[current_path] & permissions) == permissions;
      }
       last_path = current_path;
       current_path = current_path.DirName();
     }","Google Chrome before 23.0.1271.95 does not properly handle file paths, which has unspecified impact and attack vectors."
2615,,"  IN_PROC_BROWSER_TEST_F(RenderViewHostManagerTest,
   EXPECT_EQ(ASCIIToUTF16(""msg3""), new_shell->web_contents()->GetTitle());
 
    
   
   
   
   WindowedNotificationObserver title_observer4(
       NOTIFICATION_WEB_CONTENTS_TITLE_UPDATED,
      Source<WebContents>(new_shell->web_contents()));
   EXPECT_TRUE(ExecuteJavaScriptAndExtractBool(
       new_contents->GetRenderViewHost(), L"""",
       L""window.domAutomationController.send(postToFooFrame('msg4'));"",
       &success));
   EXPECT_TRUE(success);
   title_observer4.Wait();
  EXPECT_EQ(ASCIIToUTF16(""msg4""), new_shell->web_contents()->GetTitle());
 }
 
  ",
2616,,"  InspectorController::InspectorController(Page* page, InspectorClient* inspectorC
     InspectorDOMAgent* domAgent = domAgentPtr.get();
     m_agents.append(domAgentPtr.release());
 
    OwnPtr<InspectorResourceAgent> resourceAgentPtr(InspectorResourceAgent::create(m_instrumentingAgents.get(), pageAgent, inspectorClient, m_state.get()));
     InspectorResourceAgent* resourceAgent = resourceAgentPtr.get();
     m_agents.append(resourceAgentPtr.release());
 ",
2617,CVE-2012-5131," 
 #include ""config.h""
 #include ""AsyncFileSystemChromium.h""
 
 #include ""AsyncFileWriterChromium.h""
 #include ""WebFileSystemCallbacksImpl.h""
 #include ""WebFileWriter.h""
 #include ""core/platform/AsyncFileSystemCallbacks.h""
 #include ""core/platform/FileMetadata.h""
#include ""public/platform/Platform.h""
#include ""public/platform/WebFileInfo.h""
#include ""public/platform/WebFileSystem.h""
 #include ""weborigin/SecurityOrigin.h""
#include ""wtf/text/CString.h""
#include ""wtf/text/StringBuilder.h""
 
 namespace WebCore {
 ","Google Chrome before 23.0.1271.91 on Mac OS X does not properly mitigate improper rendering behavior in the Intel GPU driver, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
2618,CVE-2012-5132," 
 #include ""config.h""
 #include ""bindings/v8/ScriptProfiler.h""
 
 #include ""V8Node.h""
 #include ""V8Window.h""
 #include ""bindings/v8/RetainedDOMInfo.h""",Google Chrome before 23.0.1271.91 allows remote attackers to cause a denial of service (application crash) via a response with chunked transfer coding.
2619,CVE-2012-5135,"  PrintWebViewHelper::PrintWebViewHelper(content::RenderView* render_view)
       user_cancelled_scripted_print_count_(0),
       is_scripted_printing_blocked_(false),
       notify_browser_of_print_failure_(true),
      print_for_preview_(false),
      print_node_in_progress_(false) {
 }
 
 PrintWebViewHelper::~PrintWebViewHelper() {}
  void PrintWebViewHelper::PrintNode(const WebKit::WebNode& node) {
     return;
   }
 
  if (print_node_in_progress_) {
     
     
     
    return;
  }

  print_node_in_progress_ = true;

    
    
   if (is_preview_enabled_) {
  void PrintWebViewHelper::PrintNode(const WebKit::WebNode& node) {
     WebKit::WebNode duplicate_node(node);
     Print(duplicate_node.document().frame(), duplicate_node);
   }

  print_node_in_progress_ = false;
 }
 
 void PrintWebViewHelper::Print(WebKit::WebFrame* frame,",Use-after-free vulnerability in Google Chrome before 23.0.1271.91 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to printing.
2620,CVE-2012-5136,"  Document::Document(const DocumentInit& initializer, DocumentClassFlags documentC
     , m_sawElementsInKnownNamespaces(false)
     , m_isSrcdocDocument(false)
     , m_isMobileDocument(false)
    , m_mayDisplaySeamlesslyWithParent(false)
     , m_renderer(0)
     , m_eventQueue(DocumentEventQueue::create(this))
     , m_weakFactory(this)","Google Chrome before 23.0.1271.91 does not properly perform a cast of an unspecified variable during handling of the INPUT element, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted HTML document."
2621,CVE-2012-2900,"  bool GpuProcessHost::LaunchGpuProcess(const std::string& channel_id) {
     switches::kEnableLogging,
 #if defined(OS_MACOSX)
     switches::kEnableSandboxLogging,
 #endif
     switches::kGpuNoContextLost,
     switches::kGpuStartupDialog,","Skia, as used in Google Chrome before 22.0.1229.92, does not properly render text, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via unknown vectors."
2622,CVE-2012-5108," 
 #include ""base/message_loop.h""
 #include ""base/threading/thread_restrictions.h""
 #include ""base/time.h""
 #include ""media/audio/audio_output_controller.h""
 #include ""media/audio/audio_util.h""
 #include ""media/audio/shared_memory_util.h""
  AudioOutputDevice::AudioOutputDevice(
       ipc_(ipc),
       stream_id_(0),
       play_on_start_(true),
      is_started_(false) {
   CHECK(ipc_);
 }
 
  void AudioOutputDevice::Start() {
 void AudioOutputDevice::Stop() {
   {
     base::AutoLock auto_lock(audio_thread_lock_);
    audio_thread_.Stop(MessageLoop::current());
   }
 
   message_loop()->PostTask(FROM_HERE,
  void AudioOutputDevice::ShutDownOnIOThread() {
    
    
    
   base::ThreadRestrictions::ScopedAllowIO allow_io;
  audio_thread_.Stop(NULL);
   audio_callback_.reset();
 }
 
  void AudioOutputDevice::OnStateChanged(AudioOutputIPCDelegate::State state) {
      
      
      
    if (!audio_thread_.IsStopped())
       callback_->OnRenderError();
   }
 }
  void AudioOutputDevice::OnStreamCreated(
    
   DCHECK(stream_id_);
 
   base::AutoLock auto_lock(audio_thread_lock_);
 
  DCHECK(audio_thread_.IsStopped());
   audio_callback_.reset(new AudioOutputDevice::AudioThreadCallback(
       audio_parameters_, input_channels_, handle, length, callback_));
  audio_thread_.Start(audio_callback_.get(), socket_handle,
      ""AudioOutputDevice"");
 
    
    ",Race condition in Google Chrome before 22.0.1229.92 allows remote attackers to execute arbitrary code via vectors related to audio devices.
2623,CVE-2012-5109," 
 
 
 

#include ""chrome/browser/chromeos/gdata/drive_api_parser.h""

#include <algorithm>

#include ""base/basictypes.h""
#include ""base/file_path.h""
#include ""base/json/json_value_converter.h""
#include ""base/memory/scoped_ptr.h""
#include ""base/string_number_conversions.h""
#include ""base/string_piece.h""
#include ""base/string_util.h""
#include ""base/values.h""
#include ""chrome/browser/chromeos/gdata/gdata_util.h""

using base::Value;
using base::DictionaryValue;
using base::ListValue;

namespace {

 
 
 
bool GetGURLFromString(const base::StringPiece& url_string, GURL* result) {
  *result = GURL(url_string.as_string());
  return true;
}

 

 
const char kKind[] = ""kind"";

 
const char kAboutKind[] = ""drive#about"";
const char kRootFolderId[] = ""rootFolderId"";
const char kQuotaBytesTotal[] = ""quotaBytesTotal"";
const char kQuotaBytesUsed[] = ""quotaBytesUsed"";
const char kLargestChangeId[] = ""largestChangeId"";

 
const char kCategory[] = ""category"";
const char kSize[] = ""size"";
const char kIconUrl[] = ""iconUrl"";

 
const char kAppKind[] = ""drive#app"";
const char kId[] = ""id"";
const char kETag[] = ""etag"";
const char kName[] = ""name"";
const char kObjectType[] = ""objectType"";
const char kSupportsCreate[] = ""supportsCreate"";
const char kSupportsImport[] = ""supportsImport"";
const char kInstalled[] = ""installed"";
const char kAuthorized[] = ""authorized"";
const char kProductUrl[] = ""productUrl"";
const char kPrimaryMimeTypes[] = ""primaryMimeTypes"";
const char kSecondaryMimeTypes[] = ""secondaryMimeTypes"";
const char kPrimaryFileExtensions[] = ""primaryFileExtensions"";
const char kSecondaryFileExtensions[] = ""secondaryFileExtensions"";
const char kIcons[] = ""icons"";

 
const char kAppListKind[] = ""drive#appList"";
const char kItems[] = ""items"";


 
struct AppIconCategoryMap {
  gdata::DriveAppIcon::IconCategory category;
  const char* category_name;
};

const AppIconCategoryMap kAppIconCategoryMap[] = {
  { gdata::DriveAppIcon::DOCUMENT, ""document"" },
  { gdata::DriveAppIcon::APPLICATION, ""application"" },
  { gdata::DriveAppIcon::SHARED_DOCUMENT, ""documentShared"" },
};

 
 
bool IsResourceKindExpected(const base::Value& value,
                            const std::string& expected_kind) {
  const base::DictionaryValue* as_dict = NULL;
  std::string kind;
  return value.GetAsDictionary(&as_dict) &&
      as_dict->HasKey(kKind) &&
      as_dict->GetString(kKind, &kind) &&
      kind == expected_kind;
}

}   

 
namespace gdata {

 
 

AboutResource::AboutResource()
    : quota_bytes_total_(0),
      quota_bytes_used_(0),
      largest_change_id_(0) {}

AboutResource::~AboutResource() {}

 
scoped_ptr<AboutResource> AboutResource::CreateFrom(const base::Value& value) {
  scoped_ptr<AboutResource> resource(new AboutResource());
  if (!IsResourceKindExpected(value, kAboutKind) || !resource->Parse(value)) {
    LOG(ERROR) << ""Unable to create: Invalid About resource JSON!"";
    return scoped_ptr<AboutResource>(NULL);
  }
  return resource.Pass();
}

 
void AboutResource::RegisterJSONConverter(
    base::JSONValueConverter<AboutResource>* converter) {
  converter->RegisterStringField(kRootFolderId,
                                 &AboutResource::root_folder_id_);
  converter->RegisterCustomField<int64>(kQuotaBytesTotal,
                                        &AboutResource::quota_bytes_total_,
                                        &base::StringToInt64);
  converter->RegisterCustomField<int64>(kQuotaBytesUsed,
                                        &AboutResource::quota_bytes_used_,
                                        &base::StringToInt64);
  converter->RegisterCustomField<int64>(kLargestChangeId,
                                        &AboutResource::largest_change_id_,
                                        &base::StringToInt64);
}

bool AboutResource::Parse(const base::Value& value) {
  base::JSONValueConverter<AboutResource> converter;
  if (!converter.Convert(value, this)) {
    LOG(ERROR) << ""Unable to parse: Invalid About resource JSON!"";
    return false;
  }
  return true;
}

 
 

DriveAppIcon::DriveAppIcon() {}

DriveAppIcon::~DriveAppIcon() {}

 
void DriveAppIcon::RegisterJSONConverter(
    base::JSONValueConverter<DriveAppIcon>* converter) {
  converter->RegisterCustomField<IconCategory>(
      kCategory,
      &DriveAppIcon::category_,
      &DriveAppIcon::GetIconCategory);
  converter->RegisterIntField(kSize, &DriveAppIcon::icon_side_length_);
  converter->RegisterCustomField<GURL>(kIconUrl,
                                       &DriveAppIcon::icon_url_,
                                       GetGURLFromString);
}

 
scoped_ptr<DriveAppIcon> DriveAppIcon::CreateFrom(const base::Value& value) {
  scoped_ptr<DriveAppIcon> resource(new DriveAppIcon());
  if (!resource->Parse(value)) {
    LOG(ERROR) << ""Unable to create: Invalid DriveAppIcon JSON!"";
    return scoped_ptr<DriveAppIcon>(NULL);
  }
  return resource.Pass();
}

bool DriveAppIcon::Parse(const base::Value& value) {
  base::JSONValueConverter<DriveAppIcon> converter;
  if (!converter.Convert(value, this)) {
    LOG(ERROR) << ""Unable to parse: Invalid DriveAppIcon"";
    return false;
  }
  return true;
}

 
bool DriveAppIcon::GetIconCategory(const base::StringPiece& category,
                                   DriveAppIcon::IconCategory* result) {
  for (size_t i = 0; i < arraysize(kAppIconCategoryMap); i++) {
    if (category == kAppIconCategoryMap[i].category_name) {
      *result = kAppIconCategoryMap[i].category;
      return true;
    }
  }
  DVLOG(1) << ""Unknown icon category "" << category;
  return false;
}

 
 

AppResource::AppResource() {}

AppResource::~AppResource() {}

 
void AppResource::RegisterJSONConverter(
    base::JSONValueConverter<AppResource>* converter) {
  converter->RegisterStringField(kId, &AppResource::id_);
  converter->RegisterStringField(kName, &AppResource::name_);
  converter->RegisterStringField(kObjectType, &AppResource::object_type_);
  converter->RegisterBoolField(kSupportsCreate, &AppResource::supports_create_);
  converter->RegisterBoolField(kSupportsImport, &AppResource::supports_import_);
  converter->RegisterBoolField(kInstalled, &AppResource::installed_);
  converter->RegisterBoolField(kAuthorized, &AppResource::authorized_);
  converter->RegisterCustomField<GURL>(kProductUrl,
                                       &AppResource::product_url_,
                                       GetGURLFromString);
  converter->RegisterRepeatedString(kPrimaryMimeTypes,
                                    &AppResource::primary_mimetypes_);
  converter->RegisterRepeatedString(kSecondaryMimeTypes,
                                    &AppResource::secondary_mimetypes_);
  converter->RegisterRepeatedString(kPrimaryFileExtensions,
                                    &AppResource::primary_file_extensions_);
  converter->RegisterRepeatedString(kSecondaryFileExtensions,
                                    &AppResource::secondary_file_extensions_);
  converter->RegisterRepeatedMessage(kIcons, &AppResource::icons_);
}

 
scoped_ptr<AppResource> AppResource::CreateFrom(const base::Value& value) {
  scoped_ptr<AppResource> resource(new AppResource());
  if (!IsResourceKindExpected(value, kAppKind) || !resource->Parse(value)) {
    LOG(ERROR) << ""Unable to create: Invalid AppResource JSON!"";
    return scoped_ptr<AppResource>(NULL);
  }
  return resource.Pass();
}

bool AppResource::Parse(const base::Value& value) {
  base::JSONValueConverter<AppResource> converter;
  if (!converter.Convert(value, this)) {
    LOG(ERROR) << ""Unable to parse: Invalid AppResource"";
    return false;
  }
  return true;
}

 
 

AppList::AppList() {}

AppList::~AppList() {}

 
void AppList::RegisterJSONConverter(
    base::JSONValueConverter<AppList>* converter) {
  converter->RegisterStringField(kETag, &AppList::etag_);
  converter->RegisterRepeatedMessage<AppResource>(kItems,
                                                   &AppList::items_);
}

 
scoped_ptr<AppList> AppList::CreateFrom(const base::Value& value) {
  scoped_ptr<AppList> resource(new AppList());
  if (!IsResourceKindExpected(value, kAppListKind) || !resource->Parse(value)) {
    LOG(ERROR) << ""Unable to create: Invalid AppList JSON!"";
    return scoped_ptr<AppList>(NULL);
  }
  return resource.Pass();
}

bool AppList::Parse(const base::Value& value) {
  base::JSONValueConverter<AppList> converter;
  if (!converter.Convert(value, this)) {
    LOG(ERROR) << ""Unable to parse: Invalid AppList"";
    return false;
  }
  return true;
}

}   ",The International Components for Unicode (ICU) functionality in Google Chrome before 22.0.1229.92 allows remote attackers to cause a denial of service (out-of-bounds read) via vectors related to a regular expression.
2624,CVE-2012-5111,"  void PluginInfoMessageFilter::Context::DecidePluginStatus(
   }
 
    
  if (plugin_status ==
          PluginInstaller::SECURITY_STATUS_REQUIRES_AUTHORIZATION &&
       plugin.type != WebPluginInfo::PLUGIN_TYPE_PEPPER_IN_PROCESS &&
       plugin.type != WebPluginInfo::PLUGIN_TYPE_PEPPER_OUT_OF_PROCESS &&
       !always_authorize_plugins_.GetValue() &&
  void PluginInfoMessageFilter::Context::DecidePluginStatus(
     status->value = ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized;
     return;
   }

   
  if (PluginService::GetInstance()->IsPluginUnstable(plugin.path) &&
      !always_authorize_plugins_.GetValue() &&
      plugin_setting != CONTENT_SETTING_BLOCK &&
      uses_default_content_setting) {
    status->value = ChromeViewHostMsg_GetPluginInfo_Status::kUnauthorized;
    return;
  }
 #endif
 
   if (plugin_setting == CONTENT_SETTING_ASK)","Google Chrome before 22.0.1229.92 does not monitor for crashes of Pepper plug-ins, which has unspecified impact and remote attack vectors."
2625,CVE-2012-2889,"  class ShellWindowFrameView : public views::NonClientFrameView,
  public:
   static const char kViewClassName[];
 
  explicit ShellWindowFrameView(bool frameless);
   virtual ~ShellWindowFrameView();
 
   void Init(views::Widget* frame);
  class ShellWindowFrameView : public views::NonClientFrameView,
   views::Widget* frame_;
   views::ImageButton* close_button_;
 
  bool is_frameless_;

   DISALLOW_COPY_AND_ASSIGN(ShellWindowFrameView);
 };
 
 const char ShellWindowFrameView::kViewClassName[] =
     ""browser/ui/views/extensions/ShellWindowFrameView"";
 
ShellWindowFrameView::ShellWindowFrameView(bool frameless)
     : frame_(NULL),
      close_button_(NULL),
      is_frameless_(frameless) {
 }
 
 ShellWindowFrameView::~ShellWindowFrameView() {
 }
 
 void ShellWindowFrameView::Init(views::Widget* frame) {
   frame_ = frame;

  if (!is_frameless_) {
    ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
    close_button_ = new views::ImageButton(this);
    close_button_->SetImage(views::CustomButton::BS_NORMAL,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_HOT,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_H).ToImageSkia());
    close_button_->SetImage(views::CustomButton::BS_PUSHED,
        rb.GetNativeImageNamed(IDR_CLOSE_BAR_P).ToImageSkia());
    close_button_->SetAccessibleName(
        l10n_util::GetStringUTF16(IDS_APP_ACCNAME_CLOSE));
    AddChildView(close_button_);
  }
 
 #if defined(USE_ASH)
   aura::Window* window = frame->GetNativeWindow();
  void ShellWindowFrameView::Init(views::Widget* frame) {
 }
 
 gfx::Rect ShellWindowFrameView::GetBoundsForClientView() const {
  if (is_frameless_ || frame_->IsFullscreen())
     return bounds();
   return gfx::Rect(0, kCaptionHeight, width(),
       std::max(0, height() - kCaptionHeight));
 }
 
 gfx::Rect ShellWindowFrameView::GetWindowBoundsForClientBounds(
       const gfx::Rect& client_bounds) const {
  if (is_frameless_)
    return client_bounds;

   int closeButtonOffsetX =
       (kCaptionHeight - close_button_->height()) / 2;
   int header_width = close_button_->width() + closeButtonOffsetX * 2;
  gfx::Size ShellWindowFrameView::GetPreferredSize() {
 }
 
 void ShellWindowFrameView::Layout() {
  if (is_frameless_)
    return;
   gfx::Size close_size = close_button_->GetPreferredSize();
   int closeButtonOffsetY =
       (kCaptionHeight - close_size.height()) / 2;
  void ShellWindowFrameView::Layout() {
 }
 
 void ShellWindowFrameView::OnPaint(gfx::Canvas* canvas) {
  if (is_frameless_)
    return;
    
   SkPaint paint;
   paint.setAntiAlias(false);
  std::string ShellWindowFrameView::GetClassName() const {
 
 gfx::Size ShellWindowFrameView::GetMinimumSize() {
   gfx::Size min_size = frame_->client_view()->GetMinimumSize();
  if (is_frameless_)
    return min_size;

    
   gfx::Rect client_bounds = GetBoundsForClientView();
   min_size.Enlarge(0, client_bounds.y());
  gfx::Size ShellWindowFrameView::GetMinimumSize() {
 
 gfx::Size ShellWindowFrameView::GetMaximumSize() {
   gfx::Size max_size = frame_->client_view()->GetMaximumSize();
  if (is_frameless_)
    return max_size;

   if (!max_size.IsEmpty()) {
     gfx::Rect client_bounds = GetBoundsForClientView();
     max_size.Enlarge(0, client_bounds.y());
  gfx::Size ShellWindowFrameView::GetMaximumSize() {
 
 void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                          const views::Event& event) {
  DCHECK(!is_frameless_);
   if (sender == close_button_)
     frame_->Close();
 }
  views::View* ShellWindowViews::GetContentsView() {
 
 views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(
     views::Widget* widget) {
  ShellWindowFrameView* frame_view =
      new ShellWindowFrameView(use_custom_frame_);
   frame_view->Init(window_);
   return frame_view;
 }","Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*"
2626,CVE-2012-2881,"  IN_PROC_BROWSER_TEST_F(WebUIBidiCheckerBrowserTestLTR,
   RunBidiCheckerOnPage(url);
 }
 
 
 IN_PROC_BROWSER_TEST_F(WebUIBidiCheckerBrowserTestRTL,
                       DISABLED_TestSettingsFramePasswords) {
   std::string url(chrome::kChromeUISettingsFrameURL);
   url += ""passwords"";
   RunBidiCheckerOnPage(url);","Google Chrome before 22.0.1229.79 does not properly handle plug-ins, which allows remote attackers to cause a denial of service (DOM tree corruption) or possibly have unspecified other impact via unknown vectors."
2627,CVE-2012-2876,"  class AutofillTest : public InProcessBrowserTest {
 
   void FocusFirstNameField() {
     LOG(WARNING) << ""Clicking on the tab."";
    ui_test_utils::SimulateMouseClick(browser()->GetSelectedWebContents());
 
     LOG(WARNING) << ""Focusing the first name field."";
     bool result = false;
  class AutofillTest : public InProcessBrowserTest {
     ExpectFieldValue(L""phone"", ""5125551234"");
   }
 
  void SendKeyAndWait(ui::KeyboardCode key, int notification_type) {
    ui_test_utils::WindowedNotificationObserver observer(
        notification_type, content::Source<RenderViewHost>(render_view_host()));
    ui_test_utils::SimulateKeyPress(
        browser()->GetSelectedWebContents(), key, false, false, false, false);
    observer.Wait();
  }

   void TryBasicFormFill() {
     FocusFirstNameField();
 
      
      
     LOG(WARNING) << ""Typing 'M' to bring up the Autofill popup."";
    SendKeyAndWait(
        ui::VKEY_M, chrome::NOTIFICATION_AUTOFILL_DID_SHOW_SUGGESTIONS);
 
      
      
     LOG(WARNING) << ""Simulating down arrow press to initiate Autofill preview."";
    SendKeyAndWait(
        ui::VKEY_DOWN, chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA);
 
      
     ExpectFieldValue(L""firstname"", ""M"");
  class AutofillTest : public InProcessBrowserTest {
 
      
     LOG(WARNING) << ""Simulating Return press to fill the form."";
    SendKeyAndWait(
        ui::VKEY_RETURN, chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA);
 
      
     ExpectFilledTestForm();
  IN_PROC_BROWSER_TEST_F(AutofillTest, BasicFormFill) {
   CreateTestProfile();
 
    
   ASSERT_NO_FATAL_FAILURE(ui_test_utils::NavigateToURL(browser(),
       GURL(std::string(kDataURIPrefix) + kTestFormString)));
 
  IN_PROC_BROWSER_TEST_F(AutofillTest, AutofillViaDownArrow) {
 
    
    
  SendKeyAndWait(
      ui::VKEY_DOWN, chrome::NOTIFICATION_AUTOFILL_DID_SHOW_SUGGESTIONS);
 
    
    
  SendKeyAndWait(
      ui::VKEY_DOWN, chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA);
 
    
  SendKeyAndWait(
      ui::VKEY_RETURN, chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA);
 
    
   ExpectFilledTestForm();
  IN_PROC_BROWSER_TEST_F(AutofillTest, OnChangeAfterAutofill) {
 
    
    
  SendKeyAndWait(
      ui::VKEY_M, chrome::NOTIFICATION_AUTOFILL_DID_SHOW_SUGGESTIONS);
 
    
    
  SendKeyAndWait(
      ui::VKEY_DOWN, chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA);
 
    
  SendKeyAndWait(
      ui::VKEY_RETURN, chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA);
 
    
   ExpectFilledTestForm();",Buffer overflow in the SSE2 optimization functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2628,CVE-2012-2888,"  NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)
       getenv(""NACL_UNTRUSTED_EXCEPTION_HANDLING"") != NULL) {
     enable_exception_handling_ = true;
   }
 }
 
 NaClProcessHost::~NaClProcessHost() {
  bool NaClProcessHost::OnMessageReceived(const IPC::Message& msg) {
     IPC_MESSAGE_HANDLER_DELAY_REPLY(NaClProcessMsg_AttachDebugExceptionHandler,
                                     OnAttachDebugExceptionHandler)
 #endif
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
  void NaClProcessHost::OnResourcesReady() {
   }
 }
 
bool NaClProcessHost::ReplyToRenderer() {
   std::vector<nacl::FileDescriptor> handles_for_renderer;
   for (size_t i = 0; i < internal_->sockets_for_renderer.size(); i++) {
 #if defined(OS_WIN)
  bool NaClProcessHost::ReplyToRenderer(
 #endif
 
   ChromeViewHostMsg_LaunchNaCl::WriteReplyParams(
      reply_msg_, handles_for_renderer);
   chrome_render_message_filter_->Send(reply_msg_);
   chrome_render_message_filter_ = NULL;
   reply_msg_ = NULL;
  bool NaClProcessHost::StartNaClExecution() {
   params.enable_exception_handling = enable_exception_handling_;
   params.enable_debug_stub =
       CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableNaClDebug);
 
   base::PlatformFile irt_file = nacl_browser->IrtFile();
   CHECK_NE(irt_file, base::kInvalidPlatformFileValue);
  bool NaClProcessHost::StartNaClExecution() {
 }
 
 bool NaClProcessHost::SendStart() {
  return ReplyToRenderer() && StartNaClExecution();
 }
 
 bool NaClProcessHost::StartWithLaunchedProcess() {",Use-after-free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG text references.
2629,CVE-2012-2894," 
 #include ""chrome/browser/chromeos/login/base_login_display_host.h""
 #include ""chrome/browser/chromeos/login/proxy_settings_dialog.h""
 #include ""chrome/browser/chromeos/login/webui_login_display.h""
#include ""chrome/browser/media/media_stream_devices_controller.h""
 #include ""chrome/browser/profiles/profile_manager.h""
 #include ""chrome/browser/renderer_preferences_util.h""
 #include ""chrome/browser/ui/tab_contents/tab_contents.h""
  bool WebUILoginView::TakeFocus(bool reverse) {
   return true;
 }
 
void WebUILoginView::RequestMediaAccessPermission(
    WebContents* web_contents,
    const content::MediaStreamRequest* request,
    const content::MediaResponseCallback& callback) {
  TabContents* tab = TabContents::FromWebContents(web_contents);
  DCHECK(tab);

  scoped_ptr<MediaStreamDevicesController>
      controller(new MediaStreamDevicesController(
          tab->profile(), request, callback));
  if (!controller->DismissInfoBarAndTakeActionOnSettings())
    NOTREACHED() << ""Media stream not allowed for WebUI"";
}

 void WebUILoginView::OnLoginPromptVisible() {
   if (should_emit_login_prompt_visible_) {
     chromeos::DBusThreadManager::Get()->GetSessionManagerClient()->","Google Chrome before 22.0.1229.79 does not properly handle graphics-context data structures, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via unknown vectors."
2630,CVE-2012-2896," 
 #ifndef GPU_COMMAND_BUFFER_COMMON_GLES2_CMD_UTILS_H_
 #define GPU_COMMAND_BUFFER_COMMON_GLES2_CMD_UTILS_H_
 
#include <limits>
 #include <string>
 #include <vector>
 
  namespace gles2 {
 
  
  

 
 
inline bool SafeMultiplyUint32(uint32 a, uint32 b, uint32* dst) {
   if (b == 0) {
     *dst = 0;
     return true;
   }
  uint32 v = a * b;
   if (v / b != a) {
     *dst = 0;
     return false;
  inline bool SafeMultiply(T a, T b, T* dst) {
   return true;
 }
 
  
inline bool SafeAddUint32(uint32 a, uint32 b, uint32* dst) {
   if (a + b < a) {
     *dst = 0;
     return false;
  inline bool SafeAdd(T a, T b, T* dst) {
   return true;
 }
 
 
inline bool SafeAddInt32(int32 a, int32 b, int32* dst) {
  int64 sum64 = static_cast<int64>(a) + b;
  int32 sum32 = static_cast<int32>(sum64);
  bool safe = sum64 == static_cast<int64>(sum32);
  *dst = safe ? sum32 : 0;
  return safe;
 }
 
  ",Integer overflow in the WebGL implementation in Google Chrome before 22.0.1229.79 on Mac OS X allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2631,CVE-2012-2877,"  AppModalDialog::AppModalDialog(WebContents* web_contents, const string16& title)
     : valid_(true),
       native_dialog_(NULL),
       title_(title),
      web_contents_(web_contents),
      completed_(false) {
 }
 
 AppModalDialog::~AppModalDialog() {
  CompleteDialog();
 }
 
 void AppModalDialog::ShowModalDialog() {
  void AppModalDialog::CloseModalDialog() {
 }
 
 void AppModalDialog::CompleteDialog() {
  if (!completed_) {
    completed_ = true;
    AppModalDialogQueue::GetInstance()->ShowNextDialog();
  }
 }","The extension system in Google Chrome before 22.0.1229.79 does not properly handle modal dialogs, which allows remote attackers to cause a denial of service (application crash) via unspecified vectors."
2632,CVE-2012-2884," 
 
  
  
 
  const ModuleEnumerator::BlacklistEntry ModuleEnumerator::kModuleBlacklist[] = {
    
   { ""e579a039"", ""23d01d5b"", """", """", """", kUninstallLink },
 
   
  { ""7add320b"", ""470a3da3"", """", """", """", kUninstallLink },

   
   { ""7add320b"", ""7a3c8be3"", """", """", """", kUninstallLink },
 
    ","Skia, as used in Google Chrome before 22.0.1229.79, allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2633,CVE-2012-2874," 
 #include ""chrome/browser/prefs/pref_set_observer.h""
 #include ""chrome/browser/profiles/profile.h""
 #include ""chrome/browser/protector/base_prefs_change.h""
#include ""chrome/browser/protector/protected_prefs_watcher.h""
 #include ""chrome/browser/protector/protector_service.h""
 #include ""chrome/browser/protector/protector_service_factory.h""
#include ""chrome/browser/protector/protector_utils.h""
 #include ""chrome/common/chrome_notification_types.h""
 #include ""content/public/browser/notification_service.h""
 
  bool BasePrefsChange::Init(Profile* profile) {
   return true;
 }
 
void BasePrefsChange::InitWhenDisabled(Profile* profile) {
   
   
  ProtectorServiceFactory::GetForProfile(profile)->GetPrefsWatcher()->
      ForceUpdateBackup();
}

 void BasePrefsChange::DismissOnPrefChange(const std::string& pref_name) {
   DCHECK(!pref_observer_->IsObserved(pref_name));
   pref_observer_->AddPref(pref_name);","Skia, as used in Google Chrome before 22.0.1229.79, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an out-of-bounds write operation, a different vulnerability than CVE-2012-2883."
2634,CVE-2012-2875,"  void AutocompleteProvider::Stop() {
   done_ = true;
 }
 
metrics::OmniboxEventProto_ProviderType AutocompleteProvider::
    AsOmniboxEventProviderType() const {
  if (name_ == ""HistoryURL"")
    return metrics::OmniboxEventProto::HISTORY_URL;
  if (name_ == ""HistoryContents"")
    return metrics::OmniboxEventProto::HISTORY_CONTENTS;
  if (name_ == ""HistoryQuickProvider"")
    return metrics::OmniboxEventProto::HISTORY_QUICK;
  if (name_ == ""Search"")
    return metrics::OmniboxEventProto::SEARCH;
  if (name_ == ""Keyword"")
    return metrics::OmniboxEventProto::KEYWORD;
  if (name_ == ""Builtin"")
    return metrics::OmniboxEventProto::BUILTIN;
  if (name_ == ""ShortcutsProvider"")
    return metrics::OmniboxEventProto::SHORTCUTS;
  if (name_ == ""ExtensionApps"")
    return metrics::OmniboxEventProto::EXTENSION_APPS;

  NOTREACHED();
  return metrics::OmniboxEventProto::UNKNOWN_PROVIDER;
}

 void AutocompleteProvider::DeleteMatch(const AutocompleteMatch& match) {
   DLOG(WARNING) << ""The AutocompleteProvider '"" << name()
                 << ""' has not implemented DeleteMatch."";
 }
 
void AutocompleteProvider::AddProviderInfo(
    ProvidersInfo* provider_info) const {
}

 AutocompleteProvider::~AutocompleteProvider() {
   Stop();
 }
  void AutocompleteController::OnProviderUpdate(bool updated_matches) {
     UpdateResult(false);
 }
 
void AutocompleteController::AddProvidersInfo(
    ProvidersInfo* provider_info) const {
  provider_info->clear();
  for (ACProviders::const_iterator i(providers_.begin()); i != providers_.end();
       ++i) {
     
    (*i)->AddProviderInfo(provider_info);

     
     
  }
}

 void AutocompleteController::UpdateResult(bool is_synchronous_pass) {
   AutocompleteResult last_result;
   last_result.Swap(&result_);
  AutocompleteLog::AutocompleteLog(
       elapsed_time_since_user_first_modified_omnibox(
           elapsed_time_since_user_first_modified_omnibox),
       inline_autocompleted_length(inline_autocompleted_length),
      result(result),
      providers_info() {
 }

AutocompleteLog::~AutocompleteLog() {
}
",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
2635,CVE-2012-2875," 
 
 #include ""base/logging.h""
 #include ""third_party/skia/include/core/SkBitmap.h""
#include ""ui/aura/root_window.h""
 #include ""ui/aura/window.h""
 #include ""ui/compositor/compositor.h""
 #include ""ui/compositor/dip_util.h""
  namespace browser {
 bool GrabWindowSnapshot(gfx::NativeWindow window,
                         std::vector<unsigned char>* png_representation,
                         const gfx::Rect& snapshot_bounds) {
#if defined(OS_LINUX)
   
   
  if (window->GetRootWindow()->GrabSnapshot(
          snapshot_bounds, png_representation))
    return true;
#endif   

   ui::Compositor* compositor = window->layer()->GetCompositor();
 
   gfx::Rect read_pixels_bounds = snapshot_bounds;",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
2636,CVE-2012-2875," 
 class InternalWebIntentsDispatcherTest
     : public content::RenderViewHostTestHarness {
  public:
  InternalWebIntentsDispatcherTest()
      : replied_(0),
        notified_reply_type_(webkit_glue::WEB_INTENT_REPLY_INVALID) {
   }
 
   ~InternalWebIntentsDispatcherTest() {}",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
2637,CVE-2012-2875,"  void FileSystemOperation::GetUsageAndQuotaThenRunTask(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 weak_factory_.GetWeakPtr(), params));
 }
 
 void FileSystemOperation::DidGetUsageAndQuotaAndRunTask(",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
2638,CVE-2012-2875,"  class GDataFileSystemTest : public testing::Test {
     GDataEntryProto* file_base = root_dir->mutable_gdata_entry();
     PlatformFileInfoProto* platform_info = file_base->mutable_file_info();
     file_base->set_title(""drive"");
    file_base->set_resource_id(kGDataRootDirectoryResourceId);
     platform_info->set_is_directory(true);
 
      ",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
2639,CVE-2012-2875," 
 
 #include ""chrome/browser/web_resource/promo_resource_service.h""
 
#include ""base/bind.h""
 #include ""base/command_line.h""
 #include ""base/message_loop.h""
 #include ""base/threading/thread_restrictions.h""
  namespace {
  
 static const int kStartResourceFetchDelay = 5000;
 
 
 static const int kCacheUpdateDelay = 12 * 60 * 60 * 1000;
static const int kTestCacheUpdateDelay = 10 * 1000;
 
  
  
  PromoResourceService::PromoResourceService(Profile* profile)
                          GetCacheUpdateDelay()),
                          profile_(profile),
                          ALLOW_THIS_IN_INITIALIZER_LIST(
                             weak_ptr_factory_(this)) {
   ScheduleNotificationOnInit();
 }
 
  void PromoResourceService::ScheduleNotification(double promo_start,
       PostNotification(ms_until_start);
     } else if (ms_until_end > 0) {
       if (ms_until_start <= 0) {
         
         PostNotification(0);
       }
        
       PostNotification(ms_until_end);
    } else {
       
      PostNotification(0);
     }
  } else {
       
      PostNotification(0);
   }
 }
 
  void PromoResourceService::ScheduleNotificationOnInit() {
 }
 
 void PromoResourceService::PostNotification(int64 delay_ms) {
   
   
   
   
    
    
   if (delay_ms > 0) {
     MessageLoop::current()->PostDelayedTask(
         FROM_HERE,
         base::Bind(&PromoResourceService::PromoResourceStateChange,
  void PromoResourceService::PostNotification(int64 delay_ms) {
 }
 
 void PromoResourceService::PromoResourceStateChange() {
   content::NotificationService* service =
       content::NotificationService::current();
   service->Notify(chrome::NOTIFICATION_PROMO_RESOURCE_STATE_CHANGED,",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
2640,CVE-2012-2880,"  const Experiment kExperiments[] = {
     kOsAll,
     SINGLE_VALUE_TYPE(switches::kShowAutofillTypePredictions)
   },
   {
     ""sync-tab-favicons"",
     IDS_FLAGS_SYNC_TAB_FAVICONS_NAME,",Race condition in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the plug-in paint buffer.
2641,CVE-2012-2882,"  aura::Window* GetContainerForWindow(aura::Window* window) {
 }
 
 bool IsSystemModal(aura::Window* window) {
  return window->GetProperty(aura::client::kModalKey) == ui::MODAL_TYPE_SYSTEM;
 }
 
 bool IsWindowModal(aura::Window* window) {","FFmpeg, as used in Google Chrome before 22.0.1229.79, does not properly handle OGG containers, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors, related to a *wild pointer* issue."
2642,CVE-2012-2885,"  void QuotaTask::Start() {
 
 QuotaTask::QuotaTask(QuotaTaskObserver* observer)
     : observer_(observer),
      original_task_runner_(base::MessageLoopProxy::current()),
      delete_scheduled_(false) {
 }
 
 void QuotaTask::CallCompleted() {
  void QuotaTask::Abort() {
 }
 
 void QuotaTask::DeleteSoon() {
  DCHECK(original_task_runner_->BelongsToCurrentThread());
  if (delete_scheduled_)
    return;
  delete_scheduled_ = true;
   MessageLoop::current()->DeleteSoon(FROM_HERE, this);
 }
 ",Double free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to application exit.
2643,CVE-2012-2890," 
 #include ""remoting/host/gaia_oauth_client.h""
 
 #include ""base/bind.h""
#include ""base/compiler_specific.h""
 #include ""base/json/json_reader.h""
 #include ""base/logging.h""
 #include ""base/memory/scoped_ptr.h""
 #include ""base/values.h""
 #include ""googleurl/src/gurl.h""
 #include ""net/base/escape.h""
 #include ""net/http/http_status_code.h""
#include ""net/url_request/url_fetcher.h""
#include ""net/url_request/url_fetcher_delegate.h""
 #include ""net/url_request/url_request_context_getter.h""
 #include ""net/url_request/url_request_status.h""
 
 namespace {
 
  OAuthProviderInfo OAuthProviderInfo::GetDefault() {
 }
 
 class GaiaOAuthClient::Core
    : public base::RefCountedThreadSafe<GaiaOAuthClient::Core>,
      public net::URLFetcherDelegate {
  public:
   Core(const OAuthProviderInfo& info,
        net::URLRequestContextGetter* request_context_getter)
       : provider_info_(info),
         request_context_getter_(request_context_getter),
        delegate_(NULL),
        url_fetcher_type_(URL_FETCHER_NONE) {
   }
 
   void RefreshToken(const OAuthClientInfo& oauth_client_info,
                     const std::string& refresh_token,
                     GaiaOAuthClient::Delegate* delegate);
 
   
  virtual void OnURLFetchComplete(const net::URLFetcher* source) OVERRIDE;

  private:
   friend class base::RefCountedThreadSafe<Core>;

  enum URLFetcherType {
    URL_FETCHER_NONE,
    URL_FETCHER_REFRESH_TOKEN,
    URL_FETCHER_GET_USER_INFO
  };

   virtual ~Core() {}
 
   void OnAuthTokenFetchComplete(const net::URLRequestStatus& status,
  class GaiaOAuthClient::Core
 
   scoped_refptr<net::URLRequestContextGetter> request_context_getter_;
   GaiaOAuthClient::Delegate* delegate_;
  scoped_ptr<net::URLFetcher> request_;
  URLFetcherType url_fetcher_type_;
 
   std::string access_token_;
   int expires_in_seconds_;
  void GaiaOAuthClient::Core::RefreshToken(
       ""&client_secret="" +
       net::EscapeUrlEncodedData(oauth_client_info.client_secret, true) +
       ""&grant_type=refresh_token"";
  request_.reset(net::URLFetcher::Create(
      GURL(provider_info_.access_token_url), net::URLFetcher::POST, this));
   request_->SetRequestContext(request_context_getter_);
   request_->SetUploadData(""application/x-www-form-urlencoded"", post_body);
  url_fetcher_type_ = URL_FETCHER_REFRESH_TOKEN;
  request_->Start();
}

void GaiaOAuthClient::Core::OnURLFetchComplete(
    const net::URLFetcher* source) {
  std::string response_string;
  source->GetResponseAsString(&response_string);
  switch (url_fetcher_type_) {
    case URL_FETCHER_REFRESH_TOKEN:
      OnAuthTokenFetchComplete(source->GetStatus(),
                              source->GetResponseCode(),
                              response_string);
      break;
    case URL_FETCHER_GET_USER_INFO:
      OnUserInfoFetchComplete(source->GetStatus(),
                              source->GetResponseCode(),
                              response_string);
      break;
    default:
      LOG(ERROR) << ""Unrecognised URLFetcher type: "" << url_fetcher_type_;
  }
 }
 
 void GaiaOAuthClient::Core::OnAuthTokenFetchComplete(
  void GaiaOAuthClient::Core::OnAuthTokenFetchComplete(
         message_value->IsType(Value::TYPE_DICTIONARY)) {
       scoped_ptr<DictionaryValue> response_dict(
           static_cast<DictionaryValue*>(message_value.release()));
      std::string access_token;
      response_dict->GetString(kAccessTokenValue, &access_token);
      if (access_token.find(""\r\n"") != std::string::npos) {
        LOG(ERROR) << ""Gaia response: access token include CRLF"";
        delegate_->OnOAuthError();
        return;
      }
      access_token_ = access_token;
       response_dict->GetInteger(kExpiresInValue, &expires_in_seconds_);
     }
     VLOG(1) << ""Gaia response: acess_token='"" << access_token_
  void GaiaOAuthClient::Core::OnAuthTokenFetchComplete(
 }
 
 void GaiaOAuthClient::Core::FetchUserInfoAndInvokeCallback() {
  request_.reset(net::URLFetcher::Create(
      GURL(provider_info_.user_info_url), net::URLFetcher::GET, this));
   request_->SetRequestContext(request_context_getter_);
  request_->AddExtraRequestHeader(""Authorization: Bearer "" + access_token_);
  url_fetcher_type_ = URL_FETCHER_GET_USER_INFO;
  request_->Start();
 }
 
 void GaiaOAuthClient::Core::OnUserInfoFetchComplete(
     const net::URLRequestStatus& status,
     int response_code,
     const std::string& response) {
  request_.reset();
  url_fetcher_type_ = URL_FETCHER_NONE;
   std::string email;
   if (response_code == net::HTTP_OK) {
     scoped_ptr<Value> message_value(base::JSONReader::Read(response));",Use-after-free vulnerability in the PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
2644,CVE-2012-2890,"  class PlatformAppContextMenu : public RenderViewContextMenu {
 
 }   
 
 
 
 
IN_PROC_BROWSER_TEST_F(PlatformAppBrowserTest, CreateAndCloseShellWindow) {
  const Extension* extension = LoadAndLaunchPlatformApp(""minimal"");
  ShellWindow* window = CreateShellWindow(extension);
  CloseShellWindow(window);
}

  
 IN_PROC_BROWSER_TEST_F(PlatformAppBrowserTest, OnLaunchedEvent) {
   ASSERT_TRUE(RunPlatformAppTest(""platform_apps/launch"")) << message_;
  IN_PROC_BROWSER_TEST_F(PlatformAppBrowserTest, Restrictions) {
   ASSERT_TRUE(RunPlatformAppTest(""platform_apps/restrictions"")) << message_;
 }
 
 
 IN_PROC_BROWSER_TEST_F(PlatformAppBrowserTest, WindowsApi) {
   ASSERT_TRUE(RunPlatformAppTest(""platform_apps/windows_api"")) << message_;
 }",Use-after-free vulnerability in the PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
2645,CVE-2012-2891," 
 
 #include ""base/memory/ref_counted_memory.h""
 #include ""base/memory/singleton.h""
#include ""base/stl_util.h""
 #include ""printing/print_job_constants.h""
 
  
  class PrintPreviewDataStore : public base::RefCounted<PrintPreviewDataStore> {
    
   void GetPreviewDataForIndex(int index,
                               scoped_refptr<base::RefCountedBytes>* data) {
    if (IsInvalidIndex(index))
       return;
 
     PreviewPageDataMap::iterator it = page_data_map_.find(index);
     if (it != page_data_map_.end())
  class PrintPreviewDataStore : public base::RefCounted<PrintPreviewDataStore> {
 
    
   void SetPreviewDataForIndex(int index, const base::RefCountedBytes* data) {
    if (IsInvalidIndex(index))
       return;
 
     page_data_map_[index] = const_cast<base::RefCountedBytes*>(data);
   }
 
    
   int GetAvailableDraftPageCount() {
     int page_data_map_size = page_data_map_.size();
    if (ContainsKey(page_data_map_, printing::COMPLETE_PREVIEW_DOCUMENT_INDEX))
       page_data_map_size--;
     return page_data_map_size;
   }
 
  class PrintPreviewDataStore : public base::RefCounted<PrintPreviewDataStore> {
 
   ~PrintPreviewDataStore() {}
 
  static bool IsInvalidIndex(int index) {
    return (index != printing::COMPLETE_PREVIEW_DOCUMENT_INDEX &&
            index < printing::FIRST_PAGE_INDEX);
  }

   PreviewPageDataMap page_data_map_;
 
   DISALLOW_COPY_AND_ASSIGN(PrintPreviewDataStore);
  PrintPreviewDataService::~PrintPreviewDataService() {
 }
 
 void PrintPreviewDataService::GetDataEntry(
    int32 preview_ui_id,
     int index,
     scoped_refptr<base::RefCountedBytes>* data_bytes) {
   *data_bytes = NULL;
  PreviewDataStoreMap::const_iterator it = data_store_map_.find(preview_ui_id);
   if (it != data_store_map_.end())
     it->second->GetPreviewDataForIndex(index, data_bytes);
 }
 
 void PrintPreviewDataService::SetDataEntry(
    int32 preview_ui_id,
     int index,
     const base::RefCountedBytes* data_bytes) {
  if (!ContainsKey(data_store_map_, preview_ui_id))
    data_store_map_[preview_ui_id] = new PrintPreviewDataStore();
 
  data_store_map_[preview_ui_id]->SetPreviewDataForIndex(index, data_bytes);
 }
 
void PrintPreviewDataService::RemoveEntry(int32 preview_ui_id) {
  data_store_map_.erase(preview_ui_id);
 }
 
int PrintPreviewDataService::GetAvailableDraftPageCount(int32 preview_ui_id) {
  PreviewDataStoreMap::const_iterator it = data_store_map_.find(preview_ui_id);
  return (it == data_store_map_.end()) ?
      0 : it->second->GetAvailableDraftPageCount();
 }",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
2646,CVE-2012-2895,"  using content::BrowserThread;
 namespace gdata {
 namespace {
 
const FilePath::CharType kSymLinkToDevNull[] = FILE_PATH_LITERAL(""/dev/null"");

 const FilePath::CharType kGDataCacheVersionDir[] = FILE_PATH_LITERAL(""v1"");
 const FilePath::CharType kGDataCacheMetaDir[] = FILE_PATH_LITERAL(""meta"");
 const FilePath::CharType kGDataCachePinnedDir[] = FILE_PATH_LITERAL(""pinned"");
  std::string CacheSubDirectoryTypeToString(
   return ""unknown subdir"";
 }
 
 
 
std::vector<FilePath> GetCachePaths(const FilePath& cache_root_path) {
  std::vector<FilePath> cache_paths;
   
  cache_paths.push_back(cache_root_path.Append(kGDataCacheMetaDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCachePinnedDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheOutgoingDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCachePersistentDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDownloadsDir));
  cache_paths.push_back(cache_root_path.Append(kGDataCacheTmpDocumentsDir));
  return cache_paths;
}

  
  
  
  base::PlatformFileError ModifyCacheState(
 
    
    

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

    
    
    
  bool deleted = HANDLE_EINTR(unlink(symlink_path.value().c_str())) == 0;
   if (deleted) {
     DVLOG(1) << ""Deleted symlink "" << symlink_path.value();
   } else {
  void GDataCache::Pin(const std::string& resource_id,
      
      
      
    dest_path = FilePath(kSymLinkToDevNull);
     source_path = dest_path;
 
      
  FilePath GDataCache::GetCacheRootPath(Profile* profile) {
   return cache_root_path.Append(kGDataCacheVersionDir);
 }
 
 void SetFreeDiskSpaceGetterForTesting(FreeDiskSpaceGetterInterface* getter) {
   delete global_free_disk_getter_for_testing;   
   global_free_disk_getter_for_testing = getter;",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
2647,CVE-2012-2895,"  void ChromeDownloadManagerDelegate::CheckIfSuggestedPathExists(
      
      
      
     
      
      
     int uniquifier =",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
2648,," 
 
 #include ""base/basictypes.h""
 #include ""base/command_line.h""
 #include ""base/format_macros.h""
#include ""base/i18n/number_formatting.h""
 #include ""base/metrics/histogram.h""
 #include ""base/string_number_conversions.h""
 #include ""base/string_util.h""
 
 #include ""chrome/browser/autocomplete/keyword_provider.h""
 #include ""chrome/browser/autocomplete/search_provider.h""
 #include ""chrome/browser/autocomplete/shortcuts_provider.h""
 #include ""chrome/browser/extensions/extension_service.h""
 #include ""chrome/browser/external_protocol/external_protocol_handler.h""
 #include ""chrome/browser/net/url_fixer_upper.h""
 #include ""chrome/browser/profiles/profile.h""
 #include ""chrome/browser/profiles/profile_io_data.h""
 #include ""chrome/browser/search_engines/template_url.h""
 
 #include ""chrome/browser/ui/webui/history_ui.h""
 #include ""chrome/common/chrome_notification_types.h""
 #include ""chrome/common/chrome_switches.h""
 #include ""chrome/common/url_constants.h""
 #include ""content/public/browser/notification_service.h""
 #include ""googleurl/src/gurl.h""
 #include ""googleurl/src/url_canon_ip.h""
 #include ""grit/generated_resources.h""
 #include ""grit/theme_resources.h""
 #include ""net/base/net_util.h""
  void AutocompleteInput::Clear() {
   prefer_keyword_ = false;
 }
 
  
 
  ",
2649,," 
 #include ""grit/chromium_strings.h""
 #include ""ui/base/l10n/l10n_util.h""
 #include ""ui/gfx/canvas.h""
#include ""ui/gfx/screen.h""
 #include ""ui/views/controls/button/image_button.h""
 #include ""ui/views/controls/label.h""
 #include ""ui/views/widget/widget.h""
  void PanelBrowserView::OnWidgetActivationChanged(views::Widget* widget,
     return;
   focused_ = focused;
 
   
   
   
   
   
   
   
   
  if (focused_ && panel_->IsMinimized() &&
      gfx::Screen::GetWindowAtCursorScreenPoint() !=
          widget->GetNativeWindow()) {
    panel_->Restore();
  }

   panel()->OnActiveStateChanged(focused);
 }
 
  bool PanelBrowserView::OnTitlebarMouseDragged(
   if (mouse_dragging_state_ == NO_DRAGGING &&
       ExceededDragThreshold(delta_x, delta_y)) {
      
     
    if (!panel_->IsMinimized()) {
      old_focused_view_ = GetFocusManager()->GetFocusedView();
      GetFocusManager()->SetFocusedView(GetFrameView());
    }
 
     panel_->manager()->StartDragging(panel_.get(), last_mouse_location_);
     mouse_dragging_state_ = DRAGGING_STARTED;",
2650,,"  class CaptureVideoDecoderTest : public ::testing::Test {
   }
 
   MOCK_METHOD2(FrameReady, void(media::VideoDecoder::DecoderStatus status,
                                const scoped_refptr<media::VideoFrame>&));
 
    
   scoped_refptr<CaptureVideoDecoder> decoder_;",
2651,,"  void InputMethodIBus::ProcessUnfilteredKeyPressEvent(
     string16 composed = character_composer_.composed_character();
     if (!composed.empty()) {
       client = GetTextInputClient();
      if (client) {
         
         
         
        if (composed.size() == 1)
          client->InsertChar(composed[0], state);
        else
          client->InsertText(composed);
      }
     }
     return;
   }
  void InputMethodIBus::ProcessUnfilteredFabricatedKeyPressEvent(
     string16 composed = character_composer_.composed_character();
     if (!composed.empty()) {
       client = GetTextInputClient();
      if (client) {
         
         
         
        if (composed.size() == 1)
          client->InsertChar(composed[0], flags);
        else
          client->InsertText(composed);
      }
     }
     return;
   }",
2652,,"  void WebPagePrivate::willComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    m_page->inspectorController()->willComposite();
 }
 
 void WebPagePrivate::didComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    m_page->inspectorController()->didComposite();
 }
 
 void WebPage::updateNotificationPermission(const BlackBerry::Platform::String& requestId, bool allowed)",
2653,CVE-2012-2869,"  void PPB_URLLoader_Impl::SetDefersLoading(bool defers_loading) {
 
 void PPB_URLLoader_Impl::FinishLoading(int32_t done_status) {
   done_status_ = done_status;
  user_buffer_ = NULL;
  user_buffer_size_ = 0;
    
    
    
  void PPB_URLLoader_Impl::RunCallback(int32_t result) {
     CHECK(main_document_loader_);
     return;
   }

   
   
  DCHECK(!user_buffer_);
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }
 ","Google Chrome before 21.0.1180.89 does not properly load URLs, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a *stale buffer.*"
2654,CVE-2012-2872," 
 #include ""grit/chromium_strings.h""
 #include ""grit/generated_resources.h""
 #include ""net/base/cert_status_flags.h""
#include ""net/base/escape.h""
 #include ""net/base/net_errors.h""
 #include ""net/base/ssl_info.h""
 #include ""ui/base/l10n/l10n_util.h""
  SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       details =
           l10n_util::GetStringFUTF16(IDS_CERT_ERROR_COMMON_NAME_INVALID_DETAILS,
                                      UTF8ToUTF16(request_url.host()),
                                     net::EscapeForHTML(
                                         UTF8ToUTF16(dns_names[i])),
                                      UTF8ToUTF16(request_url.host()));
       short_description = l10n_util::GetStringUTF16(
           IDS_CERT_ERROR_COMMON_NAME_INVALID_DESCRIPTION);
  SSLErrorInfo SSLErrorInfo::CreateError(ErrorType error_type,
       extra_info.push_back(
           l10n_util::GetStringFUTF16(
               IDS_CERT_ERROR_COMMON_NAME_INVALID_EXTRA_INFO_2,
              net::EscapeForHTML(UTF8ToUTF16(cert->subject().common_name)),
               UTF8ToUTF16(request_url.host())));
       break;
     }",Cross-site scripting (XSS) vulnerability in an SSL interstitial page in Google Chrome before 21.0.1180.89 allows remote attackers to inject arbitrary web script or HTML via unspecified vectors.
2655,,"  void DesktopNativeWidgetHelperAura::PreInitialize(
   root_window_->SetEventFilter(root_window_event_filter_);
 
   input_method_filter_.reset(new aura::shared::InputMethodEventFilter());
  input_method_filter_->SetInputMethodPropertyInRootWindow(root_window_.get());
   root_window_event_filter_->AddFilter(input_method_filter_.get());
 
   aura::DesktopActivationClient* activation_client =",
2656,,"  void GpuProcessHostUIShim::OnResizeView(int32 surface_id,
       std::max(1, size.width()),
       std::max(1, size.height()),
       SWP_NOSENDCHANGING | SWP_NOCOPYBITS | SWP_NOZORDER |
          SWP_NOACTIVATE | SWP_DEFERERASE | SWP_NOMOVE);
 #endif
 }
 ",
2657,,"  void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
   print_preview_ui->OnInvalidPrinterSettings();
 }
 
void PrintPreviewMessageHandler::OnPrintPreviewScalingDisabled() {
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnPrintPreviewScalingDisabled();
}

 bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message) {
   bool handled = true;
  bool PrintPreviewMessageHandler::OnMessageReceived(
                         OnPrintPreviewCancelled)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,
                         OnInvalidPrinterSettings)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewScalingDisabled,
                        OnPrintPreviewScalingDisabled)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;",
2658,,"  void ContentSettingsStore::ClearContentSettingsForExtension(
   {
     base::AutoLock lock(lock_);
     OriginIdentifierValueMap* map = GetValueMap(ext_id, scope);
     if (!map) {
       
      NOTREACHED();
      return;
     }
     notify = !map->empty();
     map->clear();",
2659,,"  namespace {
 const wchar_t* const kTroublesomeDlls[] = {
   L""adialhk.dll"",                  
   L""acpiz.dll"",                    
  L""aswjsflt.dll"",                 
   L""avgrsstx.dll"",                 
   L""babylonchromepi.dll"",          
   L""btkeyind.dll"",                 
  const wchar_t* const kTroublesomeDlls[] = {
   L""sguard.dll"",                   
   L""smum32.dll"",                   
   L""smumhook.dll"",                 
  L""snxhk.dll"",                    
   L""ssldivx.dll"",                  
   L""syncor11.dll"",                 
   L""systools.dll"",                 ",
2660,,"  AudioOutputStream* AudioManagerBase::MakeAudioOutputStreamProxy(
   if (!dispatcher) {
     base::TimeDelta close_delay =
         base::TimeDelta::FromSeconds(kStreamCloseDelaySeconds);
     const CommandLine* cmd_line = CommandLine::ForCurrentProcess();
     
     
     
    if (cmd_line->HasSwitch(switches::kEnableAudioMixer)) {
       dispatcher = new AudioOutputMixer(this, params, close_delay);
    } else {
       dispatcher = new AudioOutputDispatcherImpl(this, params, close_delay);
     }
   }",
2661,," 
 #include ""base/string_split.h""
 #include ""base/threading/thread.h""
 #include ""base/utf_string_conversions.h""
#include ""base/win/metro.h""
 #include ""base/win/registry.h""
 #include ""base/win/scoped_comptr.h""
 #include ""base/win/windows_version.h""
  std::wstring GetExtensionWithoutLeadingDot(const std::wstring& extension) {
   return extension.empty() ? extension : extension.substr(1);
 }
 
bool CallGetOpenFileName(OPENFILENAME* ofn) {
  HMODULE metro_module = base::win::GetMetroModule();
  if (metro_module != NULL) {
    typedef BOOL (*MetroGetOpenFileName)(OPENFILENAME*);
    MetroGetOpenFileName metro_get_open_file_name =
        reinterpret_cast<MetroGetOpenFileName>(
            ::GetProcAddress(metro_module, ""MetroGetOpenFileName""));

    return !!metro_get_open_file_name(ofn);
  } else {
    return !!GetOpenFileName(ofn);
  }
}

 }   
 
  
  bool SelectFileDialogImpl::RunOpenFileDialog(
 
   if (!filter.empty())
     ofn.lpstrFilter = filter.c_str();
  bool success = CallGetOpenFileName(&ofn);
   DisableOwner(owner);
   if (success)
     *path = FilePath(filename);
  bool SelectFileDialogImpl::RunOpenMultiFileDialog(
   if (!filter.empty()) {
     ofn.lpstrFilter = filter.c_str();
   }

  bool success = CallGetOpenFileName(&ofn);
   DisableOwner(owner);
   if (success) {
     std::vector<FilePath> files;",
2662,," 
 
 #include ""base/command_line.h""
 #include ""base/debug/debugger.h""
#include ""base/i18n/rtl.h""
 #include ""base/message_loop.h""
 #include ""base/threading/platform_thread.h""
 #include ""build/build_config.h""
 
 #include ""content/public/common/content_switches.h""
 #include ""content/public/common/main_function_params.h""
 #include ""ppapi/proxy/proxy_module.h""
#include ""ui/base/ui_base_switches.h""
 
 #if defined(OS_WIN)
 #include ""sandbox/win/src/sandbox.h""
  int PpapiPluginMain(const content::MainFunctionParams& parameters) {
       ChildProcess::WaitForDebugger(""Ppapi"");
   }
 
   
   
   
  if (command_line.HasSwitch(switches::kLang)) {
    std::string locale = command_line.GetSwitchValueASCII(switches::kLang);
    base::i18n::SetICUDefaultLocale(locale);
  }

   MessageLoop main_message_loop;
   base::PlatformThread::SetName(""CrPPAPIMain"");
 ",
2663,," 
 #include <string>
 #include <vector>
 
#include ""base/callback.h""
 #include ""base/compiler_specific.h""
 #include ""base/logging.h""
 #include ""base/tracked_objects.h""
 #include ""google/cacheinvalidation/include/invalidation-client.h""
 #include ""google/cacheinvalidation/include/types.h""
 #include ""google/cacheinvalidation/types.pb.h""
  ChromeInvalidationClient::~ChromeInvalidationClient() {
 }
 
 void ChromeInvalidationClient::Start(
    const CreateInvalidationClientCallback&
        create_invalidation_client_callback,
     const std::string& client_id, const std::string& client_info,
     const std::string& state,
     const InvalidationVersionMap& initial_max_invalidation_versions,
  void ChromeInvalidationClient::Start(
 
   int client_type = ipc::invalidation::ClientType::CHROME_SYNC;
   invalidation_client_.reset(
      create_invalidation_client_callback.Run(
           &chrome_system_resources_, client_type, client_id,
           kApplicationName, this));
   invalidation_client_->Start();
  void ChromeInvalidationClient::UpdateCredentials(
   chrome_system_resources_.network()->UpdateCredentials(email, token);
 }
 
void ChromeInvalidationClient::UpdateRegisteredIds(const ObjectIdSet& ids) {
   DCHECK(CalledOnValidThread());
   registered_ids_ = ids;
    
    
    
   if (ticl_state_ == NO_NOTIFICATION_ERROR && registration_manager_.get()) {
    registration_manager_->UpdateRegisteredIds(registered_ids_);
   }
    
 }
 
 void ChromeInvalidationClient::Ready(
     invalidation::InvalidationClient* client) {
  DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   ticl_state_ = NO_NOTIFICATION_ERROR;
   EmitStateChange();
  registration_manager_->UpdateRegisteredIds(registered_ids_);
 }
 
 void ChromeInvalidationClient::Invalidate(
     invalidation::InvalidationClient* client,
     const invalidation::Invalidation& invalidation,
     const invalidation::AckHandle& ack_handle) {
   DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   DVLOG(1) << ""Invalidate: "" << InvalidationToString(invalidation);
 
   const invalidation::ObjectId& id = invalidation.object_id();
  void ChromeInvalidationClient::InvalidateUnknownVersion(
     const invalidation::ObjectId& object_id,
     const invalidation::AckHandle& ack_handle) {
   DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   DVLOG(1) << ""InvalidateUnknownVersion"";
 
   ObjectIdPayloadMap id_payloads;
  void ChromeInvalidationClient::InvalidateAll(
     invalidation::InvalidationClient* client,
     const invalidation::AckHandle& ack_handle) {
   DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   DVLOG(1) << ""InvalidateAll"";
 
   ObjectIdPayloadMap id_payloads;
  void ChromeInvalidationClient::InformRegistrationStatus(
       const invalidation::ObjectId& object_id,
       InvalidationListener::RegistrationState new_state) {
   DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   DVLOG(1) << ""InformRegistrationStatus: ""
            << ObjectIdToString(object_id) << "" "" << new_state;
 
  void ChromeInvalidationClient::InformRegistrationFailure(
     bool is_transient,
     const std::string& error_message) {
   DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   DVLOG(1) << ""InformRegistrationFailure: ""
            << ObjectIdToString(object_id)
            << ""is_transient="" << is_transient
  void ChromeInvalidationClient::ReissueRegistrations(
     const std::string& prefix,
     int prefix_length) {
   DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   DVLOG(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }
 
 void ChromeInvalidationClient::InformError(
     invalidation::InvalidationClient* client,
     const invalidation::ErrorInfo& error_info) {
  DCHECK(CalledOnValidThread());
  DCHECK_EQ(client, invalidation_client_.get());
   LOG(ERROR) << ""Ticl error "" << error_info.error_reason() << "": ""
              << error_info.error_message()
              << "" (transient = "" << error_info.is_transient() << "")"";
  void ChromeInvalidationClient::WriteState(const std::string& state) {
       FROM_HERE, &InvalidationStateTracker::SetInvalidationState, state);
 }
 
void ChromeInvalidationClient::StopForTest() {
  DCHECK(CalledOnValidThread());
  Stop();
}

 void ChromeInvalidationClient::Stop() {
   DCHECK(CalledOnValidThread());
   if (!invalidation_client_.get()) {",
2664,CVE-2012-2862,"  class SystemTrayDelegate : public ash::SystemTrayDelegate,
   }
 
   virtual const std::string GetUserEmail() const OVERRIDE {
    return UserManager::Get()->GetLoggedInUser().display_email();
   }
 
   virtual const SkBitmap& GetUserImage() const OVERRIDE {",Use-after-free vulnerability in the PDF functionality in Google Chrome before 21.0.1180.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
2665,CVE-2012-2862,"  class TestTarget : public ui::AcceleratorTarget {
 
 class ReleaseAccelerator : public ui::Accelerator {
  public:
  ReleaseAccelerator(ui::KeyboardCode keycode, int modifiers)
      : ui::Accelerator(keycode, modifiers) {
     set_type(ui::ET_KEY_RELEASED);
   }
 };
  AcceleratorController* AcceleratorControllerTest::GetController() {
 }
 
 TEST_F(AcceleratorControllerTest, Register) {
  const ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
   TestTarget target;
   GetController()->Register(accelerator_a, &target);
 
  TEST_F(AcceleratorControllerTest, Register) {
 }
 
 TEST_F(AcceleratorControllerTest, RegisterMultipleTarget) {
  const ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
   TestTarget target1;
   GetController()->Register(accelerator_a, &target1);
   TestTarget target2;
  TEST_F(AcceleratorControllerTest, RegisterMultipleTarget) {
 }
 
 TEST_F(AcceleratorControllerTest, Unregister) {
  const ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
   TestTarget target;
   GetController()->Register(accelerator_a, &target);
  const ui::Accelerator accelerator_b(ui::VKEY_B, ui::EF_NONE);
   GetController()->Register(accelerator_b, &target);
 
    
  TEST_F(AcceleratorControllerTest, Unregister) {
 }
 
 TEST_F(AcceleratorControllerTest, UnregisterAll) {
  const ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
   TestTarget target1;
   GetController()->Register(accelerator_a, &target1);
  const ui::Accelerator accelerator_b(ui::VKEY_B, ui::EF_NONE);
   GetController()->Register(accelerator_b, &target1);
  const ui::Accelerator accelerator_c(ui::VKEY_C, ui::EF_NONE);
   TestTarget target2;
   GetController()->Register(accelerator_c, &target2);
   GetController()->UnregisterAll(&target1);
  TEST_F(AcceleratorControllerTest, UnregisterAll) {
 }
 
 TEST_F(AcceleratorControllerTest, Process) {
  const ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
   TestTarget target1;
   GetController()->Register(accelerator_a, &target1);
 
  TEST_F(AcceleratorControllerTest, Process) {
   EXPECT_EQ(1, target1.accelerator_pressed_count());
 
    
  const ui::Accelerator accelerator_b(ui::VKEY_B, ui::EF_NONE);
   EXPECT_FALSE(GetController()->Process(accelerator_b));
 }
 
 TEST_F(AcceleratorControllerTest, IsRegistered) {
  const ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
  const ui::Accelerator accelerator_shift_a(ui::VKEY_A, ui::EF_SHIFT_DOWN);
   TestTarget target;
   GetController()->Register(accelerator_a, &target);
   EXPECT_TRUE(GetController()->IsRegistered(accelerator_a));
  TEST_F(AcceleratorControllerTest, IsRegistered) {
 
 #if defined(OS_WIN) || defined(USE_X11)
 TEST_F(AcceleratorControllerTest, ProcessOnce) {
  ui::Accelerator accelerator_a(ui::VKEY_A, ui::EF_NONE);
   TestTarget target;
   GetController()->Register(accelerator_a, &target);
 
  TEST_F(AcceleratorControllerTest, ProcessOnce) {
 TEST_F(AcceleratorControllerTest, DISABLED_GlobalAccelerators) {
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_F5, ui::EF_CONTROL_DOWN)));
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_TAB, ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN)));
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_F5, ui::EF_NONE)));
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_TAB, ui::EF_ALT_DOWN)));
    
    
   {
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_F5, ui::EF_CONTROL_DOWN)));
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_PRINT, ui::EF_NONE)));
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_F5, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN)));
     DummyScreenshotDelegate* delegate = new DummyScreenshotDelegate;
     GetController()->SetScreenshotDelegate(
         scoped_ptr<ScreenshotDelegate>(delegate).Pass());
     EXPECT_EQ(0, delegate->handle_take_screenshot_count());
     EXPECT_EQ(0, delegate->handle_take_partial_screenshot_count());
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_F5, ui::EF_CONTROL_DOWN)));
     EXPECT_EQ(1, delegate->handle_take_screenshot_count());
     EXPECT_EQ(0, delegate->handle_take_partial_screenshot_count());
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_PRINT, ui::EF_NONE)));
     EXPECT_EQ(2, delegate->handle_take_screenshot_count());
     EXPECT_EQ(0, delegate->handle_take_partial_screenshot_count());
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_F5, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN)));
     EXPECT_EQ(2, delegate->handle_take_screenshot_count());
     EXPECT_EQ(1, delegate->handle_take_partial_screenshot_count());
   }
    
   {
     EXPECT_FALSE(ash::Shell::GetInstance()->GetAppListTargetVisibility());
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_LWIN, ui::EF_CONTROL_DOWN)));
     EXPECT_TRUE(ash::Shell::GetInstance()->GetAppListTargetVisibility());
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_LWIN, ui::EF_CONTROL_DOWN)));
     EXPECT_FALSE(ash::Shell::GetInstance()->GetAppListTargetVisibility());
   }
    
   {
     EXPECT_FALSE(GetController()->Process(
        ui::Accelerator(ui::VKEY_LWIN, ui::EF_SHIFT_DOWN)));
     DummyCapsLockDelegate* delegate = new DummyCapsLockDelegate(false);
     GetController()->SetCapsLockDelegate(
         scoped_ptr<CapsLockDelegate>(delegate).Pass());
     EXPECT_EQ(0, delegate->handle_caps_lock_count());
     EXPECT_FALSE(GetController()->Process(
        ui::Accelerator(ui::VKEY_LWIN, ui::EF_SHIFT_DOWN)));
     EXPECT_EQ(1, delegate->handle_caps_lock_count());
   }
   {
  TEST_F(AcceleratorControllerTest, DISABLED_GlobalAccelerators) {
         scoped_ptr<CapsLockDelegate>(delegate).Pass());
     EXPECT_EQ(0, delegate->handle_caps_lock_count());
     EXPECT_TRUE(GetController()->Process(
        ui::Accelerator(ui::VKEY_LWIN, ui::EF_SHIFT_DOWN)));
     EXPECT_EQ(1, delegate->handle_caps_lock_count());
   }
    
  const ui::Accelerator f8(ui::VKEY_F8, ui::EF_NONE);
  const ui::Accelerator f9(ui::VKEY_F9, ui::EF_NONE);
  const ui::Accelerator f10(ui::VKEY_F10, ui::EF_NONE);
   {
     EXPECT_FALSE(GetController()->Process(f8));
     EXPECT_FALSE(GetController()->Process(f9));
  TEST_F(AcceleratorControllerTest, DISABLED_GlobalAccelerators) {
     EXPECT_EQ(1, delegate->handle_volume_up_count());
     EXPECT_EQ(f10, delegate->last_accelerator());
   }
  const ui::Accelerator volume_mute(ui::VKEY_VOLUME_MUTE, ui::EF_NONE);
  const ui::Accelerator volume_down(ui::VKEY_VOLUME_DOWN, ui::EF_NONE);
  const ui::Accelerator volume_up(ui::VKEY_VOLUME_UP, ui::EF_NONE);
   {
     DummyVolumeControlDelegate* delegate =
         new DummyVolumeControlDelegate(false);
  TEST_F(AcceleratorControllerTest, DISABLED_GlobalAccelerators) {
     EXPECT_EQ(volume_up, delegate->last_accelerator());
   }
    
  const ui::Accelerator f6(ui::VKEY_F6, ui::EF_NONE);
  const ui::Accelerator f7(ui::VKEY_F7, ui::EF_NONE);
   {
     EXPECT_FALSE(GetController()->Process(f6));
     EXPECT_FALSE(GetController()->Process(f7));
  TEST_F(AcceleratorControllerTest, DISABLED_GlobalAccelerators) {
   }
 #if defined(OS_CHROMEOS)
    
  const ui::Accelerator brightness_down(ui::VKEY_BRIGHTNESS_DOWN, ui::EF_NONE);
  const ui::Accelerator brightness_up(ui::VKEY_BRIGHTNESS_UP, ui::EF_NONE);
   {
     DummyBrightnessControlDelegate* delegate =
         new DummyBrightnessControlDelegate(false);
  TEST_F(AcceleratorControllerTest, DISABLED_GlobalAccelerators) {
 #if !defined(NDEBUG)
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_HOME, ui::EF_CONTROL_DOWN)));
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_B, ui::EF_CONTROL_DOWN | ui::EF_ALT_DOWN)));
 #if !defined(OS_LINUX)
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_F11, ui::EF_CONTROL_DOWN)));
 #endif  
 #endif  
 
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_Q, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN)));
 
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_N, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN)));
 
    
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_N, ui::EF_CONTROL_DOWN)));
 
 #if defined(OS_CHROMEOS)
   EXPECT_TRUE(GetController()->Process(
      ui::Accelerator(ui::VKEY_L, ui::EF_SHIFT_DOWN | ui::EF_CONTROL_DOWN)));
 #endif
 }
 
 TEST_F(AcceleratorControllerTest, ImeGlobalAccelerators) {
    
   {
    const ui::Accelerator control_space(ui::VKEY_SPACE, ui::EF_CONTROL_DOWN);
    const ui::Accelerator convert(ui::VKEY_CONVERT, ui::EF_NONE);
    const ui::Accelerator non_convert(ui::VKEY_NONCONVERT, ui::EF_NONE);
    const ui::Accelerator wide_half_1(ui::VKEY_DBE_SBCSCHAR, ui::EF_NONE);
    const ui::Accelerator wide_half_2(ui::VKEY_DBE_DBCSCHAR, ui::EF_NONE);
    const ui::Accelerator hangul(ui::VKEY_HANGUL, ui::EF_NONE);
    const ui::Accelerator shift_space(ui::VKEY_SPACE, ui::EF_SHIFT_DOWN);
     EXPECT_FALSE(GetController()->Process(control_space));
     EXPECT_FALSE(GetController()->Process(convert));
     EXPECT_FALSE(GetController()->Process(non_convert));
  TEST_F(AcceleratorControllerTest, ImeGlobalAccelerators) {
 
    
   {
    const ui::Accelerator shift_alt_press(ui::VKEY_MENU,
                                          ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN);
    const ReleaseAccelerator shift_alt(ui::VKEY_MENU,
                                       ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN);
    const ui::Accelerator alt_shift_press(ui::VKEY_SHIFT,
                                          ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN);
    const ReleaseAccelerator alt_shift(ui::VKEY_SHIFT,
                                       ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN);
 
     DummyImeControlDelegate* delegate = new DummyImeControlDelegate(true);
     GetController()->SetImeControlDelegate(
  TEST_F(AcceleratorControllerTest, ImeGlobalAccelerators) {
 
      
      
    const ui::Accelerator shift_alt_x_press(ui::VKEY_X,
       ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN);
    const ReleaseAccelerator shift_alt_x(ui::VKEY_X,
                                         ui::EF_SHIFT_DOWN | ui::EF_ALT_DOWN);
 
     EXPECT_FALSE(GetController()->Process(shift_alt_press));
     EXPECT_FALSE(GetController()->Process(shift_alt_x_press));",Use-after-free vulnerability in the PDF functionality in Google Chrome before 21.0.1180.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
2666,CVE-2012-2863," 
 
  
  
 
  class ScopedGenericObj {
    
    
    
  explicit ScopedGenericObj(C p = C()): obj_(p) {}
 
    
   ~ScopedGenericObj() {
  class ScopedGenericObj {
    
    
    
  void reset(C p = C()) {
     if (obj_ != p) {
       FreeProc free_proc;
       free_proc(obj_);",The PDF functionality in Google Chrome before 21.0.1180.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
2667,CVE-2012-2842,"  class PowerPopupView : public views::Label {
  public:
   PowerPopupView() {
     SetHorizontalAlignment(ALIGN_RIGHT);
    SetMultiLine(true);
     UpdateText();
   }
 ",Use-after-free vulnerability in Google Chrome before 20.0.1132.57 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to counter handling.
2668,CVE-2012-2816,"  bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {
                               sandbox::USER_RESTRICTED);
         policy->SetJobLevel(sandbox::JOB_LOCKDOWN,
                             JOB_OBJECT_UILIMIT_HANDLES);
         
         
         
        policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);
       }
 
       policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
  bool AddPolicyForRenderer(sandbox::TargetPolicy* policy) {
   }
 
   policy->SetTokenLevel(initial_token, sandbox::USER_LOCKDOWN);
   
  policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);
 
   bool use_winsta = !CommandLine::ForCurrentProcess()->HasSwitch(
                         switches::kDisableAltWinstation);","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
2669,CVE-2012-2816,"  bool ChromeContentClient::SandboxPlugin(CommandLine* command_line,
     return false;
   }
 
   
   
  if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,
                      sandbox::TargetPolicy::HANDLES_DUP_ANY,
                      L""Event"") != sandbox::SBOX_ALL_OK) {
    NOTREACHED();
    return false;
  }

    
   if (policy->AddRule(sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,
                       sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
2670,CVE-2012-2817,"  MediaStreamImpl::~MediaStreamImpl() {
       chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind(
           &MediaStreamImpl::DeleteIpcNetworkManager,
           base::Unretained(this)));
       
       
       
      chrome_worker_thread_.Stop();
     } else {
       NOTREACHED() << ""Worker thread not running."";
     }",Use-after-free vulnerability in Google Chrome before 20.0.1132.43 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to tables that have sections.
2671,CVE-2012-2819,"  void TestOfflineLoadPage::NotifyBlockingPageComplete(bool proceed) {
   test_page_->OnBlockingPageComplete(proceed);
 }
 
 
TEST_F(OfflineLoadPageTest, DISABLED_OfflinePageProceed) {
    
   Navigate(kURL1, 1);
    
  TEST_F(OfflineLoadPageTest, OfflinePageProceed) {
 }
 
  
TEST_F(OfflineLoadPageTest, DISABLED_OfflinePageDontProceed) {
    
   Navigate(kURL1, 1);
   controller().LoadURL(GURL(kURL2), content::Referrer(),","The texSubImage2D implementation in the WebGL subsystem in Google Chrome before 20.0.1132.43 does not properly handle uploads to floating-point textures, which allows remote attackers to cause a denial of service (assertion failure and application crash) or possibly have unspecified other impact via a crafted web page, as demonstrated by certain WebGL performance tests, aka rdar problem 11520387."
2672,CVE-2012-2820,"  COMPILE_ASSERT(arraysize(kConfidenceCutoff) ==
                NetworkActionPredictor::LAST_PREDICT_ACTION,
                ConfidenceCutoff_count_mismatch);
 
 }
 
 const int NetworkActionPredictor::kMaximumDaysToKeepEntry = 14;","Google Chrome before 20.0.1132.43 does not properly implement SVG filters, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2673,CVE-2012-2821,"  IN_PROC_BROWSER_TEST_F(IndexedDBBrowserTest, Bug109187Test) {
   ui_test_utils::NavigateToURLBlockUntilNavigationsComplete(browser(), url, 1);
 }
 
#if defined(OS_MACOSX)
 
#define MAYBE_ClearLocalState DISABLED_ClearLocalState
#else
#define MAYBE_ClearLocalState ClearLocalState
#endif

  
  
IN_PROC_BROWSER_TEST_F(IndexedDBBrowserTest, MAYBE_ClearLocalState) {
   ScopedTempDir temp_dir;
   ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
 
  IN_PROC_BROWSER_TEST_F(IndexedDBBrowserTest, ClearSessionOnlyDatabases) {
   EXPECT_FALSE(file_util::DirectoryExists(session_only_path));
 }
 
#if defined(OS_MACOSX)
 
#define MAYBE_SaveSessionState DISABLED_SaveSessionState
#else
#define MAYBE_SaveSessionState SaveSessionState
#endif

IN_PROC_BROWSER_TEST_F(IndexedDBBrowserTest, MAYBE_SaveSessionState) {
   ScopedTempDir temp_dir;
   ASSERT_TRUE(temp_dir.CreateUniqueTempDir());
 ","The autofill implementation in Google Chrome before 20.0.1132.43 does not properly display text, which has unspecified impact and remote attack vectors."
2674,CVE-2012-2823,"  IN_PROC_BROWSER_TEST_F(GpuFeatureTest, CanOpenPopupAndRenderWith2DCanvas) {
   RunTest(url, ""\""SUCCESS\"""", false);
 }
 
 }   
 ",Use-after-free vulnerability in Google Chrome before 20.0.1132.43 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to SVG resources.
2675,CVE-2012-2828,"  TEST_PPAPI_IN_PROCESS(Var)
 TEST_PPAPI_OUT_OF_PROCESS(Var)
 TEST_PPAPI_NACL_VIA_HTTP(Var)
 
 
#if defined(OS_MACOSX)
#define MAYBE_VarDeprecated DISABLED_VarDeprecated
#else
#define MAYBE_VarDeprecated VarDeprecated
#endif

 TEST_PPAPI_IN_PROCESS(VarDeprecated)
TEST_PPAPI_OUT_OF_PROCESS(MAYBE_VarDeprecated)
 
  
 #ifdef PostMessage",Multiple integer overflows in the PDF functionality in Google Chrome before 20.0.1132.43 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
2676,CVE-2012-2764,"  TEST_F(ProfileSyncServiceSessionTest, TabNodePoolEmpty) {
   ASSERT_TRUE(model_associator_->tab_pool_.full());
 }
 
 
  
TEST_F(ProfileSyncServiceSessionTest, DISABLED_TabNodePoolNonEmpty) {
   CreateRootHelper create_root(this);
   ASSERT_TRUE(StartSyncService(create_root.callback(), false));
   ASSERT_TRUE(create_root.success());
  TEST_F(ProfileSyncServiceSessionTest, SessionsRefresh) {
 }
 
  
 
 TEST_F(ProfileSyncServiceSessionTest, DISABLED_ExistingTabs) {
   AddTab(browser(), GURL(""http://foo1""));
   NavigateAndCommitActiveTab(GURL(""http://foo2""));
  TEST_F(ProfileSyncServiceSessionTest, DISABLED_ExistingTabs) {
       GetEntryAtIndex(1)->GetVirtualURL());
 }
 
 
TEST_F(ProfileSyncServiceSessionTest, DISABLED_MissingHeaderAndTab) {
   AddTab(browser(), GURL(""http://foo1""));
   NavigateAndCommitActiveTab(GURL(""http://foo2""));
   AddTab(browser(), GURL(""http://bar1""));
  TEST_F(ProfileSyncServiceSessionTest, MissingHeaderAndTab) {
   ASSERT_FALSE(error.IsSet());
 }
 
 
TEST_F(ProfileSyncServiceSessionTest, DISABLED_MultipleHeaders) {
   AddTab(browser(), GURL(""http://foo1""));
   NavigateAndCommitActiveTab(GURL(""http://foo2""));
   AddTab(browser(), GURL(""http://bar1""));
  TEST_F(ProfileSyncServiceSessionTest, MultipleHeaders) {
   ASSERT_FALSE(error.IsSet());
 }
 
 
TEST_F(ProfileSyncServiceSessionTest, DISABLED_CorruptedForeign) {
   AddTab(browser(), GURL(""http://foo1""));
   NavigateAndCommitActiveTab(GURL(""http://foo2""));
   AddTab(browser(), GURL(""http://bar1""));",Untrusted search path vulnerability in Google Chrome before 20.0.1132.43 on Windows might allow local users to gain privileges via a Trojan horse Metro DLL in the current working directory.
2677,CVE-2011-3079,"  bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {
                               sandbox::USER_RESTRICTED);
         policy->SetJobLevel(sandbox::JOB_LOCKDOWN,
                             JOB_OBJECT_UILIMIT_HANDLES);
         
         
         
        policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);
       }
 
       policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
  bool AddPolicyForRenderer(sandbox::TargetPolicy* policy) {
   }
 
   policy->SetTokenLevel(initial_token, sandbox::USER_LOCKDOWN);
   
  policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);
 
   bool use_winsta = !CommandLine::ForCurrentProcess()->HasSwitch(
                         switches::kDisableAltWinstation);","The Inter-process Communication (IPC) implementation in Google Chrome before 18.0.1025.168, as used in Mozilla Firefox before 38.0 and other products, does not properly validate messages, which has unspecified impact and attack vectors."
2678,CVE-2011-3954," 
 #define PPAPI_C_PPB_FILE_REF_H_
 
 #include ""ppapi/c/pp_bool.h""
#include ""ppapi/c/pp_completion_callback.h""
 #include ""ppapi/c/pp_file_info.h""
 #include ""ppapi/c/pp_resource.h""
 #include ""ppapi/c/pp_var.h""
 
 
  * file in a file system.
  */
 
 #define PPB_FILEREF_INTERFACE_0_9 ""PPB_FileRef;0.9""
 #define PPB_FILEREF_INTERFACE_1_0 ""PPB_FileRef;1.0""
 #define PPB_FILEREF_INTERFACE PPB_FILEREF_INTERFACE_1_0
 
  
 /**",Google Chrome before 17.0.963.46 allows remote attackers to cause a denial of service (application crash) via vectors that trigger a large amount of database usage.
2679,CVE-2011-3965,"  void SignatureUtil::CheckSignature(
     for (DWORD i = 0; i < prov_data->csSigners; ++i) {
       const CERT_CHAIN_CONTEXT* cert_chain_context =
           prov_data->pasSigners[i].pChainContext;
      if (!cert_chain_context)
        break;
       for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {
         CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];
         ClientDownloadRequest_CertificateChain* chain =
             signature_info->add_certificate_chain();
        if (!simple_chain)
          break;
         for (DWORD k = 0; k < simple_chain->cElement; ++k) {
           CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];
           chain->add_element()->set_certificate(","Google Chrome before 17.0.963.46 does not properly check signatures, which allows remote attackers to cause a denial of service (application crash) via unspecified vectors."
2680,CVE-2011-3967,"  std::string ProcessRawBytesWithSeparators(const unsigned char* data,
    
   std::string ret;
   size_t kMin = 0U;

  if (!data_length)
    return """";

   ret.reserve(std::max(kMin, data_length * 3 - 1));
 
   for (size_t i = 0; i < data_length; ++i) {",Unspecified vulnerability in Google Chrome before 17.0.963.46 allows remote attackers to cause a denial of service (application crash) via a crafted certificate.
2681,,"  IN_PROC_BROWSER_TEST_F(PanelBrowserTest, MAYBE_FocusLostOnMinimize) {
   panel->Close();
 }
 
 
 
#if defined(OS_MACOSX)
 #define MAYBE_MinimizeTwoPanelsWithoutTabbedWindow \
     MinimizeTwoPanelsWithoutTabbedWindow
 #else",
2682,,"  ChromotingHost::ChromotingHost(ChromotingHostContext* context,
       config_(config),
       access_verifier_(access_verifier),
       allow_nat_traversal_(allow_nat_traversal),
       stopping_recorders_(0),
      state_(kInitial),
       protocol_config_(protocol::CandidateSessionConfig::CreateDefault()),
       is_curtained_(false),
       is_it2me_(false) {
  void ChromotingHost::Start() {
   DCHECK(access_verifier_.get());
 
    
  if (state_ != kInitial)
    return;
  state_ = kStarted;
 
    
   std::string xmpp_login;
  void ChromotingHost::Start() {
 
  
 void ChromotingHost::Shutdown(const base::Closure& shutdown_task) {
  if (!context_->network_message_loop()->BelongsToCurrentThread()) {
    context_->network_message_loop()->PostTask(
        FROM_HERE, base::Bind(&ChromotingHost::Shutdown, this, shutdown_task));
     return;
   }
 
    
  if (state_ == kInitial || state_ == kStopped) {
        
    state_ = kStopped;
    context_->network_message_loop()->PostTask(FROM_HERE, shutdown_task);
    return;
   }
  if (!shutdown_task.is_null())
    shutdown_tasks_.push_back(shutdown_task);
  if (state_ == kStopping)
    return;
  state_ = kStopping;
 
    
   while (!clients_.empty()) {
    clients_.front()->Disconnect();
  }

   
  if (session_manager_.get()) {
    session_manager_->Close();
     
     
     
     
    context_->network_message_loop()->DeleteSoon(
        FROM_HERE, session_manager_.release());
   }
 
   
  if (signal_strategy_.get()) {
    signal_strategy_->Close();
    signal_strategy_.reset();

    for (StatusObserverList::iterator it = status_observers_.begin();
         it != status_observers_.end(); ++it) {
      (*it)->OnSignallingDisconnected();
    }
  }

  if (recorder_.get()) {
    StopScreenRecorder();
  } else {
    ShutdownFinish();
  }
 }
 
 void ChromotingHost::AddStatusObserver(HostStatusObserver* observer) {
  void ChromotingHost::AddStatusObserver(HostStatusObserver* observer) {
  
 void ChromotingHost::OnSessionAuthenticated(ClientSession* client) {
   DCHECK(context_->network_message_loop()->BelongsToCurrentThread());

   
   
   
  ClientList clients_copy(clients_);
  for (ClientList::const_iterator other_client = clients_copy.begin();
       other_client != clients_copy.end(); ++other_client) {
    if ((*other_client) != client) {
      (*other_client)->Disconnect();
    }
  }

   
  if (!recorder_.get()) {
     
     
    Encoder* encoder = CreateEncoder(client->connection()->session()->config());

    recorder_ = new ScreenRecorder(context_->main_message_loop(),
                                   context_->encode_message_loop(),
                                   context_->network_message_loop(),
                                   desktop_environment_->capturer(),
                                   encoder);
  }

   
  recorder_->AddConnection(client->connection());
  recorder_->Start();

   
  const std::string& jid = client->connection()->session()->jid();
  for (StatusObserverList::iterator it = status_observers_.begin();
       it != status_observers_.end(); ++it) {
    (*it)->OnClientAuthenticated(jid);
  }
   
   
  EnableCurtainMode(true);

  std::string username = jid.substr(0, jid.find('/'));
  desktop_environment_->OnConnect(username);
 }
 
 void ChromotingHost::OnSessionClosed(ClientSession* client) {
   DCHECK(context_->network_message_loop()->BelongsToCurrentThread());
 
  scoped_refptr<ClientSession> client_ref = client;

  ClientList::iterator it = std::find(clients_.begin(), clients_.end(), client);
  CHECK(it != clients_.end());
  clients_.erase(it);

  if (recorder_.get()) {
    recorder_->RemoveConnection(client->connection());
  }

  for (StatusObserverList::iterator it = status_observers_.begin();
       it != status_observers_.end(); ++it) {
    (*it)->OnClientDisconnected(client->client_jid());
  }

  if (AuthenticatedClientsCount() == 0) {
    if (recorder_.get()) {
       
      StopScreenRecorder();
    }

     
    EnableCurtainMode(false);
    desktop_environment_->OnLastDisconnect();
  }
 }
 
 void ChromotingHost::OnSessionSequenceNumber(ClientSession* session,
                                              int64 sequence_number) {
  DCHECK(context_->network_message_loop()->BelongsToCurrentThread());
   if (recorder_.get())
     recorder_->UpdateSequenceNumber(sequence_number);
 }
  void ChromotingHost::OnIncomingSession(
       protocol::SessionManager::IncomingSessionResponse* response) {
   DCHECK(context_->network_message_loop()->BelongsToCurrentThread());
 
   if (state_ != kStarted) {
     *response = protocol::SessionManager::DECLINE;
     return;
  void ChromotingHost::OnIncomingSession(
       new protocol::ConnectionToClient(context_->network_message_loop(),
                                        session);
   ClientSession* client = new ClientSession(
      this, connection, desktop_environment_->event_executor(),
       desktop_environment_->capturer());
   clients_.push_back(client);
 }
 
 void ChromotingHost::set_protocol_config(
     protocol::CandidateSessionConfig* config) {
  DCHECK(config);
   DCHECK_EQ(state_, kInitial);
   protocol_config_.reset(config);
 }
  void ChromotingHost::LocalMouseMoved(const SkIPoint& new_pos) {
         FROM_HERE, base::Bind(&ChromotingHost::LocalMouseMoved, this, new_pos));
     return;
   }

   ClientList::iterator client;
   for (client = clients_.begin(); client != clients_.end(); ++client) {
     client->get()->LocalMouseMoved(new_pos);
   }
 }
 
 void ChromotingHost::PauseSession(bool pause) {
  if (!context_->network_message_loop()->BelongsToCurrentThread()) {
    context_->network_message_loop()->PostTask(
         FROM_HERE, base::Bind(&ChromotingHost::PauseSession, this, pause));
     return;
   }

   ClientList::iterator client;
   for (client = clients_.begin(); client != clients_.end(); ++client) {
     client->get()->set_awaiting_continue_approval(pause);
  void ChromotingHost::SetUiStrings(const UiStrings& ui_strings) {
   ui_strings_ = ui_strings;
 }
 
  
 Encoder* ChromotingHost::CreateEncoder(const protocol::SessionConfig& config) {
   const protocol::ChannelConfig& video_config = config.video_config();
  std::string ChromotingHost::GenerateHostAuthToken(
 }
 
 int ChromotingHost::AuthenticatedClientsCount() const {
  DCHECK(context_->network_message_loop()->BelongsToCurrentThread());

   int authenticated_clients = 0;
   for (ClientList::const_iterator it = clients_.begin(); it != clients_.end();
        ++it) {
  void ChromotingHost::EnableCurtainMode(bool enable) {
   is_curtained_ = enable;
 }
 
 void ChromotingHost::StopScreenRecorder() {
  DCHECK(context_->network_message_loop()->BelongsToCurrentThread());
   DCHECK(recorder_.get());
 
   ++stopping_recorders_;
  scoped_refptr<ScreenRecorder> recorder = recorder_;
   recorder_ = NULL;
  recorder->Stop(base::Bind(&ChromotingHost::OnScreenRecorderStopped, this));
 }
 
 void ChromotingHost::OnScreenRecorderStopped() {
  if (!context_->network_message_loop()->BelongsToCurrentThread()) {
    context_->network_message_loop()->PostTask(
         FROM_HERE, base::Bind(&ChromotingHost::OnScreenRecorderStopped, this));
     return;
   }
 
   --stopping_recorders_;
   DCHECK_GE(stopping_recorders_, 0);
 
  if (!stopping_recorders_ && state_ == kStopping)
     ShutdownFinish();
 }
 
 void ChromotingHost::ShutdownFinish() {
  DCHECK(context_->network_message_loop()->BelongsToCurrentThread());
 
  state_ = kStopped;
 
    
    ",
2683,,"  void SafeBrowsingBlockingPage::CommandReceived(const std::string& cmd) {
   }
 
   if (command == kTakeMeBackCommand) {
    if (is_main_frame_load_blocked_) {
       
       
      DontProceed();
       
      return;
    }

     
     
    if (tab()->controller().CanGoBack()) {
      tab()->controller().GoBack();
    } else {
      tab()->controller().LoadURL(GURL(chrome::kChromeUINewTabURL),
                                  content::Referrer(),
                                  content::PAGE_TRANSITION_START_PAGE,
                                  std::string());
    }
     return;
   }
 
  void SafeBrowsingBlockingPage::DontProceed() {
 
    
    
   
   
   
  int last_committed_index = tab()->controller().last_committed_entry_index();
  if (navigation_entry_index_to_remove_ != -1 &&
      navigation_entry_index_to_remove_ != last_committed_index &&
      !tab()->is_being_destroyed()) {
    tab()->controller().RemoveEntryAtIndex(navigation_entry_index_to_remove_);
     navigation_entry_index_to_remove_ = -1;
   }
   InterstitialPage::DontProceed();",
2684,CVE-2011-3105,"  namespace {
 static const int kSyncRefreshDelayMsec = 500;
 static const int kSyncSchedulerDelayMsec = 250;
 
 GetUpdatesCallerInfo::GetUpdatesSource GetSourceFromReason(
     sync_api::ConfigureReason reason) {
   switch (reason) {
  void SyncManager::SyncInternal::OnIPAddressChanged() {
     return;
   }
 
   OnIPAddressChangedImpl();
 }
 
 void SyncManager::SyncInternal::OnIPAddressChangedImpl() {",Use-after-free vulnerability in the Cascading Style Sheets (CSS) implementation in Google Chrome before 19.0.1084.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the :first-letter pseudo-element.
2685,CVE-2011-3106,"  ResourceDispatcherHostImpl::ResourceDispatcherHostImpl()
     : download_file_manager_(new DownloadFileManager(NULL)),
       save_file_manager_(new SaveFileManager()),
       request_id_(-1),
       is_shutdown_(false),
       max_outstanding_requests_cost_per_process_(
           kMaxOutstandingRequestsCostPerProcess),
  void ResourceDispatcherHostImpl::OnSSLCertificateError(
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  SSLManager::OnSSLCertificateError(
      AsWeakPtr(), request_id, info->GetResourceType(), request->url(),
      render_process_id, render_view_id, ssl_info, is_hsts_host);
 }
 
 void ResourceDispatcherHostImpl::OnResponseStarted(net::URLRequest* request) {
  void ResourceDispatcherHostImpl::PauseRequest(int child_id,
    
   if (info->pause_count() == 0) {
     MessageLoop::current()->PostTask(FROM_HERE,
        base::Bind(&ResourceDispatcherHostImpl::ResumeRequest,
                   AsWeakPtr(), global_id));
   }
 }
 
  void ResourceDispatcherHostImpl::OnReadCompleted(net::URLRequest* request,
         GlobalRequestID id(info->GetChildID(), info->GetRequestID());
         MessageLoop::current()->PostTask(
             FROM_HERE,
            base::Bind(&ResourceDispatcherHostImpl::ResumeRequest,
                       AsWeakPtr(), id));
         return;
       }
     }","The WebSockets implementation in Google Chrome before 19.0.1084.52 does not properly handle use of SSL, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via unspecified vectors."
2686,CVE-2011-3108,"  TEST(HttpCache, GET_IncompleteResource_Cancel) {
   int rv = cache.http_cache()->CreateTransaction(&c->trans);
   EXPECT_EQ(net::OK, rv);
 
   
   
   
   
  Context* pending = new Context();
  EXPECT_EQ(net::OK, cache.http_cache()->CreateTransaction(&pending->trans));

   rv = c->trans->Start(&request, c->callback.callback(), net::BoundNetLog());
  EXPECT_EQ(net::ERR_IO_PENDING,
            pending->trans->Start(&request, pending->callback.callback(),
                                  net::BoundNetLog()));
   EXPECT_EQ(net::OK, c->callback.GetResult(rv));
 
    
   scoped_refptr<net::IOBufferWithSize> buf(new net::IOBufferWithSize(5));
   rv = c->trans->Read(buf, buf->size(), c->callback.callback());
   EXPECT_EQ(5, c->callback.GetResult(rv));
 
   
   delete c;
  delete pending;
 
   EXPECT_EQ(1, cache.network_layer()->transaction_count());
   EXPECT_EQ(1, cache.disk_cache()->open_count());
  EXPECT_EQ(2, cache.disk_cache()->create_count());
 
   MessageLoop::current()->RunAllPending();
   RemoveMockTransaction(&transaction);
 }",Use-after-free vulnerability in Google Chrome before 19.0.1084.52 allows remote attackers to execute arbitrary code via vectors related to the browser cache.
2687,CVE-2011-3109,"  AutocompleteMatch HistoryQuickProvider::QuickMatchToACMatch(
   const history::URLRow& info = history_match.url_info;
   AutocompleteMatch match(this, score, !!info.visit_count(),
       history_match.url_matches.empty() ?
          AutocompleteMatch::HISTORY_TITLE : AutocompleteMatch::HISTORY_URL);
   match.destination_url = info.url();
   DCHECK(match.destination_url.is_valid());
 ","Google Chrome before 19.0.1084.52 on Linux does not properly perform a cast of an unspecified variable, which allows remote attackers to cause a denial of service or possibly have unknown other impact by leveraging an error in the GTK implementation of the UI."
2688,CVE-2011-3110,"  bool ChromeContentRendererClient::WillSendRequest(WebKit::WebFrame* frame,
   if (url.SchemeIs(chrome::kExtensionScheme) &&
       !ExtensionResourceRequestPolicy::CanRequestResource(
           url,
          frame,
           extension_dispatcher_->extensions())) {
     *new_url = GURL(""chrome-extension://invalid/"");
     return true;",The PDF functionality in Google Chrome before 19.0.1084.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
2689,CVE-2011-3114,"  SkBitmap BrowserNonClientFrameViewAura::GetFaviconForTabIconView() {
 
 int BrowserNonClientFrameViewAura::NonClientTopBorderHeight(
     bool force_restored) const {
  if (force_restored)
    return kTabstripTopSpacingRestored;
  if (frame()->IsFullscreen())
    return 0;
  if (frame()->IsMaximized())
    return kTabstripTopSpacingMaximized;
   if (frame()->widget_delegate() &&
       frame()->widget_delegate()->ShouldShowWindowTitle()) {
      
     return close_button_->bounds().bottom();
   }
  return kTabstripTopSpacingRestored;
 }
 
 void BrowserNonClientFrameViewAura::LayoutAvatar() {",Multiple buffer overflows in the PDF functionality in Google Chrome before 19.0.1084.52 allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger unknown function calls.
2690,CVE-2011-3083," 
 
  
  
 
  void ProfileImplIOData::LazyInitializeInternal(
   ftp_factory_.reset(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
   main_context->set_ftp_transaction_factory(ftp_factory_.get());
  media_request_context_->set_ftp_transaction_factory(ftp_factory_.get());
 
   main_context->set_chrome_url_data_manager_backend(
       chrome_url_data_manager_backend());","browser/profiles/profile_impl_io_data.cc in Google Chrome before 19.0.1084.46 does not properly handle a malformed ftp URL in the SRC attribute of a VIDEO element, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted web page."
2691,CVE-2011-3084," 
 #include ""content/public/browser/render_view_host.h""
 #include ""content/public/browser/render_view_host_delegate.h""
 #include ""content/public/browser/web_contents.h""
#include ""content/public/common/content_client.h""
 #include ""grit/generated_resources.h""
 #include ""ui/base/l10n/l10n_util.h""
 #include ""webkit/glue/webkit_glue.h""
  bool DebuggerFunction::InitTabContents() {
   }
   contents_ = wrapper->web_contents();
 
  if (content::GetContentClient()->HasWebUIScheme(
           contents_->GetURL())) {
     error_ = ExtensionErrorUtils::FormatErrorMessage(
         keys::kAttachToWebUIError,","Google Chrome before 19.0.1084.46 does not use a dedicated process for the loading of links found on an internal page, which might allow attackers to bypass intended sandbox restrictions via a crafted page."
2692,CVE-2011-3088,"  using content::WebContents;
 
 namespace {
 
class SessionRestoreImpl;

  
std::set<SessionRestoreImpl*>* active_session_restorers = NULL;
 
  
 
  class SessionRestoreImpl : public content::NotificationObserver {
         urls_to_open_(urls_to_open),
         restore_started_(base::TimeTicks::Now()),
         browser_shown_(false) {
 
     
     
     
    if (active_session_restorers == NULL)
      active_session_restorers = new std::set<SessionRestoreImpl*>();

    std::set<SessionRestoreImpl*>::const_iterator it;
    for (it = active_session_restorers->begin();
         it != active_session_restorers->end(); ++it) {
      if ((*it)->profile_ == profile)
        break;
    }
    DCHECK(it == active_session_restorers->end());

    active_session_restorers->insert(this);
 
      
      
      
  class SessionRestoreImpl : public content::NotificationObserver {
   ~SessionRestoreImpl() {
     STLDeleteElements(&windows_);
 
    active_session_restorers->erase(this);
    if (active_session_restorers->empty()) {
      delete active_session_restorers;
      active_session_restorers = NULL;
     }

     g_browser_process->ReleaseModule();
   }
 
  class SessionRestoreImpl : public content::NotificationObserver {
     }
   }
 
  Profile* profile() { return profile_; }

  private:
    
   void StartTabCreation() {
  void SessionRestore::RestoreForeignSessionTab(Profile* profile,
 
  
 bool SessionRestore::IsRestoring(const Profile* profile) {
  if (active_session_restorers == NULL)
    return false;
  for (std::set<SessionRestoreImpl*>::const_iterator it =
           active_session_restorers->begin();
       it != active_session_restorers->end(); ++it) {
    if ((*it)->profile() == profile)
      return true;
  }
  return false;
 }","Google Chrome before 19.0.1084.46 does not properly draw hairlines, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2693,CVE-2011-3091,"  static base::LazyInstance<ThreadLocalPointer<IndexedDBDispatcher> >::Leaky
 
 namespace {
 
IndexedDBDispatcher* const HAS_BEEN_DELETED =
    reinterpret_cast<IndexedDBDispatcher*>(0x1);

 int32 CurrentWorkerId() {
   return WorkerTaskRunner::Instance()->CurrentWorkerId();
 }
  IndexedDBDispatcher::IndexedDBDispatcher() {
 }
 
 IndexedDBDispatcher::~IndexedDBDispatcher() {
  g_idb_dispatcher_tls.Pointer()->Set(HAS_BEEN_DELETED);
 }
 
 IndexedDBDispatcher* IndexedDBDispatcher::ThreadSpecificInstance() {
  if (g_idb_dispatcher_tls.Pointer()->Get() == HAS_BEEN_DELETED) {
    NOTREACHED() << ""Re-instantiating TLS IndexedDBDispatcher."";
    g_idb_dispatcher_tls.Pointer()->Set(NULL);
  }
   if (g_idb_dispatcher_tls.Pointer()->Get())
     return g_idb_dispatcher_tls.Pointer()->Get();
 ",Use-after-free vulnerability in the IndexedDB implementation in Google Chrome before 19.0.1084.46 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2694,CVE-2011-3096," 
 #include ""ui/base/gtk/gtk_compat.h""
 #include ""ui/base/gtk/gtk_hig_constants.h""
 #include ""ui/base/gtk/gtk_screen_util.h""
#include ""ui/base/gtk/gtk_signal_registrar.h""
 #include ""ui/base/gtk/gtk_windowing.h""
 #include ""ui/gfx/color_utils.h""
 #include ""ui/gfx/font.h""
  OmniboxPopupViewGtk::OmniboxPopupViewGtk(const gfx::Font& font,
                                          OmniboxView* omnibox_view,
                                          AutocompleteEditModel* edit_model,
                                          GtkWidget* location_bar)
    : signal_registrar_(new ui::GtkSignalRegistrar),
      model_(new AutocompletePopupModel(this, edit_model)),
       omnibox_view_(omnibox_view),
       location_bar_(location_bar),
       window_(gtk_window_new(GTK_WINDOW_POPUP)),
  OmniboxPopupViewGtk::OmniboxPopupViewGtk(const gfx::Font& font,
                                  GDK_POINTER_MOTION_MASK |
                                  GDK_BUTTON_PRESS_MASK |
                                  GDK_BUTTON_RELEASE_MASK);
  signal_registrar_->Connect(window_, ""motion-notify-event"",
                             G_CALLBACK(HandleMotionThunk), this);
  signal_registrar_->Connect(window_, ""button-press-event"",
                             G_CALLBACK(HandleButtonPressThunk), this);
  signal_registrar_->Connect(window_, ""button-release-event"",
                             G_CALLBACK(HandleButtonReleaseThunk), this);
  signal_registrar_->Connect(window_, ""expose-event"",
                             G_CALLBACK(HandleExposeThunk), this);
 
   registrar_.Add(this,
                  chrome::NOTIFICATION_BROWSER_THEME_CHANGED,
  OmniboxPopupViewGtk::OmniboxPopupViewGtk(const gfx::Font& font,
 }
 
 OmniboxPopupViewGtk::~OmniboxPopupViewGtk() {
   
   
  signal_registrar_.reset();

    
    
    ",Use-after-free vulnerability in Google Chrome before 19.0.1084.46 on Linux allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an error in the GTK implementation of the omnibox.
2695,CVE-2011-3097,"  bool BaseSessionService::RestoreUpdateTabNavigationCommand(
         policy);
 
      
    base::TimeTicks start_time_ = base::TimeTicks::Now();
     std::string content_state;
     if (CompressDataHelper::ReadAndDecompressStringFromPickle(
             *pickle.get(), &iterator, &content_state) &&
         !content_state.empty()) {
       navigation->state_ = content_state;
     }
    base::TimeDelta total_time = base::TimeTicks::Now() - start_time_;
    time_spent_reading_compressed_content_states += total_time;
   }
 
   navigation->virtual_url_ = GURL(url_spec);
  bool BaseSessionService::RunTaskOnBackendThread(
     return true;
   }
 }

void BaseSessionService::ResetContentStateReadingMetrics() {
  time_spent_reading_compressed_content_states = base::TimeDelta();
}

void BaseSessionService::WriteContentStateReadingMetrics() {
  UMA_HISTOGRAM_TIMES(""SessionService.ReadingCompressedContentStates"",
                      time_spent_reading_compressed_content_states);
  ResetContentStateReadingMetrics();
}",The PDF functionality in Google Chrome before 19.0.1084.46 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging an out-of-bounds write error in the implementation of sampled functions.
2696,CVE-2011-3101,"  bool GLES2DecoderImpl::SimulateAttrib0(
   CopyRealGLErrorsToWrapper();
   glBindBuffer(GL_ARRAY_BUFFER, attrib_0_buffer_id_);
 
  bool new_buffer = static_cast<GLsizei>(size_needed) > attrib_0_size_;
  if (new_buffer) {
     glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);
     GLenum error = glGetError();
     if (error != GL_NO_ERROR) {
       SetGLError(GL_OUT_OF_MEMORY, ""glDrawXXX: Simulating attrib 0"");
       return false;
     }
  }
  if (new_buffer ||
      (attrib_0_used &&
       (!attrib_0_buffer_matches_value_ ||
        (info->value().v[0] != attrib_0_value_.v[0] ||
         info->value().v[1] != attrib_0_value_.v[1] ||
         info->value().v[2] != attrib_0_value_.v[2] ||
         info->value().v[3] != attrib_0_value_.v[3])))) {
     std::vector<Vec4> temp(num_vertices, info->value());
     glBufferSubData(GL_ARRAY_BUFFER, 0, size_needed, &temp[0].v[0]);
     attrib_0_buffer_matches_value_ = true;","Google Chrome before 19.0.1084.46 on Linux does not properly mitigate an unspecified flaw in an NVIDIA driver, which has unknown impact and attack vectors.  NOTE: see CVE-2012-3105 for the related MFSA 2012-34 issue in Mozilla products."
2697,CVE-2011-3050,"  BookmarkManagerView::BookmarkManagerView(Profile* profile)
   layout->StartRow(1, split_cs_id);
   layout->AddView(split_view_);
 
   
  AddAccelerator(views::Accelerator('W', false, true, false));

   BookmarkModel* bookmark_model = profile_->GetBookmarkModel();
   if (!bookmark_model->IsLoaded())
     bookmark_model->AddObserver(this);
  void BookmarkManagerView::WindowClosing() {
       prefs::kBookmarkManagerSplitLocation, split_view_->divider_x());
 }
 
bool BookmarkManagerView::AcceleratorPressed(
    const views::Accelerator& accelerator) {
   
  DCHECK(accelerator.GetKeyCode() == 'W' && accelerator.IsCtrlDown());
  window()->Close();
  return true;
}

 void BookmarkManagerView::OnDoubleClick() {
   std::vector<BookmarkNode*> nodes = GetSelectedTableNodes();
   if (nodes.empty())",Use-after-free vulnerability in the Cascading Style Sheets (CSS) implementation in Google Chrome before 17.0.963.83 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the :first-letter pseudo-element.
2698,CVE-2011-3051," 
 
  
  
 
  class UI_EXPORT InputMethod {
   virtual ~InputMethod() {}
 
    
   
   virtual void SetDelegate(internal::InputMethodDelegate* delegate) = 0;
 
    ",Use-after-free vulnerability in the Cascading Style Sheets (CSS) implementation in Google Chrome before 17.0.963.83 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the cross-fade function.
2699,CVE-2011-3052,"  void WebGraphicsContext3DCommandBufferImpl::reshape(int width, int height) {
   cached_height_ = height;
 
   gl_->ResizeCHROMIUM(width, height);
 }
 
 #ifdef FLIP_FRAMEBUFFER_VERTICALLY
 void WebGraphicsContext3DCommandBufferImpl::FlipVertically(
     uint8* framebuffer,
     unsigned int width,
     unsigned int height) {
  if (width == 0)
     return;
  scanline_.resize(width * 4);
  uint8* scanline = &scanline_[0];
   unsigned int row_bytes = width * 4;
   unsigned int count = height / 2;
   for (unsigned int i = 0; i < count; i++) {","The WebGL implementation in Google Chrome before 17.0.963.83 does not properly handle CANVAS elements, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors."
2700,CVE-2011-3053," 
 #include ""chrome/browser/automation/automation_provider_json.h""
 #include ""chrome/browser/automation/automation_provider_observers.h""
 #include ""chrome/browser/browser_process.h""
#include ""chrome/browser/chromeos/audio/audio_handler.h""
 #include ""chrome/browser/chromeos/cros/cros_library.h""
 #include ""chrome/browser/chromeos/cros/network_library.h""
 #include ""chrome/browser/chromeos/dbus/dbus_thread_manager.h""",Use-after-free vulnerability in Google Chrome before 17.0.963.83 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to block splitting.
2701,CVE-2011-3054," 
 #include ""content/browser/tab_contents/test_tab_contents.h""
 #include ""content/common/view_messages.h""
 #include ""content/public/browser/navigation_entry.h""
#include ""content/public/common/bindings_policy.h""
 #include ""content/public/common/page_transition_types.h""
 #include ""third_party/WebKit/Source/WebKit/chromium/public/WebDragOperation.h""
 #include ""webkit/glue/webdropdata.h""
  TEST_F(RenderViewHostTest, ResetUnloadOnReload) {
   EXPECT_FALSE(test_rvh()->is_waiting_for_unload_ack_for_testing());
 }
 
 
TEST_F(RenderViewHostTest, DontGrantBindingsToSharedProcess) {
   
  scoped_ptr<TestTabContents> new_tab(
      new TestTabContents(browser_context(), rvh()->GetSiteInstance()));

  rvh()->AllowBindings(content::BINDINGS_POLICY_WEB_UI);
  EXPECT_FALSE(rvh()->GetEnabledBindings() & content::BINDINGS_POLICY_WEB_UI);
}

 class MockDraggingRenderViewHostDelegateView
     : public content::RenderViewHostDelegate::View {
  public:","The WebUI privilege implementation in Google Chrome before 17.0.963.83 does not properly perform isolation, which allows remote attackers to bypass intended access restrictions via unspecified vectors."
2702,CVE-2011-3049,"  bool IsSensitiveURL(const GURL& url) {
   bool is_google_com_chrome_url =
       EndsWith(url.host(), ""google.com"", true) &&
       StartsWithASCII(url.path(), ""/chrome"", true);
  GURL::Replacements replacements;
  replacements.ClearQuery();
  replacements.ClearRef();
  GURL url_without_query = url.ReplaceComponents(replacements);
   return is_webstore_gallery_url || is_google_com_chrome_url ||
      extension_urls::IsWebstoreUpdateUrl(url_without_query) ||
       extension_urls::IsBlacklistUpdateUrl(url);
 }
 ","Google Chrome before 17.0.963.83 does not properly restrict the extension web request API, which allows remote attackers to cause a denial of service (disrupted system requests) via a crafted extension."
2703,CVE-2011-3046," 
 
  
  
 
  const char kChromeUIHangURL[] = ""chrome://hang"";
 const char kChromeUIKillURL[] = ""chrome://kill"";
 const char kChromeUIShorthangURL[] = ""chrome://shorthang"";
 
 
 
const char kUnreachableWebDataURL[] = ""data:text/html,chromewebdata"";
 
 const char** GetSavableSchemes() {
   return const_cast<const char**>(g_savable_schemes);","The extension subsystem in Google Chrome before 17.0.963.78 does not properly handle history navigation, which allows remote attackers to execute arbitrary code by leveraging a *Universal XSS (UXSS)* issue."
2704,CVE-2013-6632,"  ChildThreadImpl::Options::Options()
       in_browser_process(false) {
 }
 
ChildThreadImpl::Options::~Options() {
 }
 
ChildThreadImpl::Options::Builder::Builder() {
 }
 
ChildThreadImpl::Options::Builder&
ChildThreadImpl::Options::Builder::InBrowserProcess(bool in_browser_process) {
  options_.in_browser_process = in_browser_process;
  return *this;
}

ChildThreadImpl::Options::Builder&
ChildThreadImpl::Options::Builder::UseMojoChannel(bool use_mojo_channel) {
  options_.use_mojo_channel = use_mojo_channel;
  return *this;
}

ChildThreadImpl::Options::Builder&
ChildThreadImpl::Options::Builder::WithChannelName(
    const std::string& channel_name) {
  options_.channel_name = channel_name;
  return *this;
}

ChildThreadImpl::Options::Builder&
ChildThreadImpl::Options::Builder::AddStartupFilter(
    IPC::MessageFilter* filter) {
  options_.startup_filters.push_back(filter);
  return *this;
}

ChildThreadImpl::Options ChildThreadImpl::Options::Builder::Build() {
  return options_;
 }
 
 ChildThreadImpl::ChildThreadMessageRouter::ChildThreadMessageRouter(
  ChildThreadImpl::ChildThreadImpl()
     : router_(this),
       in_browser_process_(false),
       channel_connected_factory_(this) {
  Init(Options::Builder().Build());
 }
 
 ChildThreadImpl::ChildThreadImpl(const Options& options)","Integer overflow in Google Chrome before 31.0.1650.57 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via unspecified vectors, as demonstrated during a Mobile Pwn2Own competition at PacSec 2013."
2705,CVE-2013-6634,"  void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
             << "" g-c-s='"" << google_chrome_signin_value << ""'"";
   }
 
  if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))
     return;
 
    ","The OneClickSigninHelper::ShowInfoBarIfPossible function in browser/ui/sync/one_click_signin_helper.cc in Google Chrome before 31.0.1650.63 uses an incorrect URL during realm validation, which allows remote attackers to conduct session fixation attacks and hijack web sessions by triggering improper sync after a 302 (aka Found) HTTP status code."
2706,CVE-2013-6636,"  bool DialogNotification::HasCheckbox() const {
 }
 
 SkColor const kWarningColor = SkColorSetRGB(0xde, 0x49, 0x32);
SkColor const kLightShadingColor = SkColorSetARGB(7, 0, 0, 0);
SkColor const kSubtleBorderColor = SkColorSetARGB(10, 0, 0, 0);
 
 SuggestionState::SuggestionState()
     : visible(false) {}","The FrameLoader::notifyIfInitialDocumentAccessed function in core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 31.0.1650.63, makes an incorrect check for an empty document during presentation of a modal dialog, which allows remote attackers to spoof the address bar via vectors involving the document.write method."
2707,CVE-2013-6638," 
  
  
 
#ifndef BASE_ALLOCATOR_ALLOCATOR_EXTENSION_H_
#define BASE_ALLOCATOR_ALLOCATOR_EXTENSION_H_
 
 #include <stddef.h>  
 
  BASE_EXPORT void SetReleaseFreeMemoryFunction(
 }   
 }   
 
#endif   ","Multiple buffer overflows in runtime.cc in Google V8 before 3.22.24.7, as used in Google Chrome before 31.0.1650.63, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a large typed array, related to the (1) Runtime_TypedArrayInitialize and (2) Runtime_TypedArrayInitializeFromArrayLike functions."
2708,CVE-2013-6621,"  bool RenderFrameImpl::Send(IPC::Message* message) {
 }
 
 bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {
  GetContentClient()->SetActiveURL(frame_->document().url());

   ObserverListBase<RenderFrameObserver>::Iterator it(observers_);
   RenderFrameObserver* observer;
   while ((observer = it.GetNext()) != NULL) {
  bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {
   if (!msg_is_ok) {
      
      
    int id = msg.type();
    CHECK(false) << ""Unable to deserialize "" << id << "" in RenderFrameImpl."";
   }
 
   return handled;",Use-after-free vulnerability in Google Chrome before 31.0.1650.48 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the x-webkit-speech attribute in a text INPUT element.
2709,CVE-2013-6623,"  class LoginUtilsTest : public testing::Test,
   DISALLOW_COPY_AND_ASSIGN(LoginUtilsTest);
 };
 
struct LoginUtilsBlockingLoginTestParam {
  const int steps;
  const char* username;
  const bool enroll_device;
};

 class LoginUtilsBlockingLoginTest
     : public LoginUtilsTest,
      public testing::WithParamInterface<LoginUtilsBlockingLoginTestParam> {};
 
 #if defined(ENABLE_RLZ)
 TEST_F(LoginUtilsTest, RlzInitialized) {
  TEST_F(LoginUtilsTest, RlzInitialized) {
 }
 #endif
 
TEST_P(LoginUtilsBlockingLoginTest, LoginBlocksForUser) {
   UserManager* user_manager = UserManager::Get();
   EXPECT_FALSE(user_manager->IsUserLoggedIn());
   EXPECT_FALSE(connector_->IsEnterpriseManaged());
   EXPECT_FALSE(prepared_profile_);
 
  if (GetParam().enroll_device) {
     
    EnrollDevice(kUsername);
 
    EXPECT_FALSE(user_manager->IsUserLoggedIn());
    EXPECT_TRUE(connector_->IsEnterpriseManaged());
    EXPECT_EQ(kDomain, connector_->GetEnterpriseDomain());
    EXPECT_FALSE(prepared_profile_);
    EXPECT_EQ(policy::USER_AFFILIATION_MANAGED,
              connector_->GetUserAffiliation(kUsername));
    EXPECT_FALSE(user_manager->IsKnownUser(kUsername));
  }
 
  PrepareProfile(GetParam().username);
 
   EXPECT_FALSE(prepared_profile_);
   ASSERT_TRUE(user_manager->IsUserLoggedIn());
  TEST_P(LoginUtilsBlockingLoginTest, EnterpriseLoginBlocksForEnterpriseUser) {
    
    
    
  int steps = GetParam().steps;
 
    
   int next_expected_fetcher_id = 0;
  TEST_P(LoginUtilsBlockingLoginTest, EnterpriseLoginBlocksForEnterpriseUser) {
   EXPECT_TRUE(prepared_profile_);
 }
 
const LoginUtilsBlockingLoginTestParam kBlockinLoginTestCases[] = {
    {0, kUsername, true},
    {1, kUsername, true},
    {2, kUsername, true},
    {3, kUsername, true},
    {4, kUsername, true},
    {5, kUsername, true},
    {0, kUsername, false},
    {1, kUsername, false},
    {2, kUsername, false},
    {3, kUsername, false},
    {4, kUsername, false},
    {5, kUsername, false},
    {0, kUsernameOtherDomain, true},
    {1, kUsernameOtherDomain, true},
    {2, kUsernameOtherDomain, true},
    {3, kUsernameOtherDomain, true},
    {4, kUsernameOtherDomain, true},
    {5, kUsernameOtherDomain, true}};

INSTANTIATE_TEST_CASE_P(LoginUtilsBlockingLoginTestInstance,
                        LoginUtilsBlockingLoginTest,
                        testing::ValuesIn(kBlockinLoginTestCases));
 
 }   
 ","The SVG implementation in Blink, as used in Google Chrome before 31.0.1650.48, allows remote attackers to cause a denial of service (out-of-bounds read) by leveraging the use of tree order, rather than transitive dependency order, for layout."
2710,CVE-2013-6626," 
 #include ""chrome/browser/sessions/session_service_factory.h""
 #include ""chrome/browser/translate/translate_tab_helper.h""
 #include ""chrome/browser/ui/app_modal_dialogs/app_modal_dialog.h""
#include ""chrome/browser/ui/app_modal_dialogs/app_modal_dialog_queue.h""
 #include ""chrome/browser/ui/app_modal_dialogs/javascript_app_modal_dialog.h""
 #include ""chrome/browser/ui/app_modal_dialogs/native_app_modal_dialog.h""
 #include ""chrome/browser/ui/browser.h""
  IN_PROC_BROWSER_TEST_F(BrowserTest, InterstitialCommandDisable) {
   EXPECT_TRUE(command_updater->IsCommandEnabled(IDC_ENCODING_MENU));
 }
 
 
 
IN_PROC_BROWSER_TEST_F(BrowserTest, InterstitialClosesDialogs) {
  ASSERT_TRUE(test_server()->Start());
  host_resolver()->AddRule(""www.example.com"", ""127.0.0.1"");
  GURL url(test_server()->GetURL(""empty.html""));
  ui_test_utils::NavigateToURL(browser(), url);

  WebContents* contents = browser()->tab_strip_model()->GetActiveWebContents();
  contents->GetRenderViewHost()->ExecuteJavascriptInWebFrame(
      string16(),
      ASCIIToUTF16(""alert('Dialog showing!');""));
  AppModalDialog* alert = ui_test_utils::WaitForAppModalDialog();
  EXPECT_TRUE(alert->IsValid());
  AppModalDialogQueue* dialog_queue = AppModalDialogQueue::GetInstance();
  EXPECT_TRUE(dialog_queue->HasActiveDialog());

  TestInterstitialPage* interstitial = NULL;
  {
    scoped_refptr<content::MessageLoopRunner> loop_runner(
        new content::MessageLoopRunner);

    InterstitialObserver observer(contents,
                                  loop_runner->QuitClosure(),
                                  base::Closure());
    interstitial = new TestInterstitialPage(contents, false, GURL());
    loop_runner->Run();
  }

   
  EXPECT_TRUE(contents->ShowingInterstitialPage());
  EXPECT_FALSE(dialog_queue->HasActiveDialog());

  {
    scoped_refptr<content::MessageLoopRunner> loop_runner(
        new content::MessageLoopRunner);

    InterstitialObserver observer(contents,
                                  base::Closure(),
                                  loop_runner->QuitClosure());
    interstitial->Proceed();
    loop_runner->Run();
     
  }
}


 IN_PROC_BROWSER_TEST_F(BrowserTest, InterstitialCloseTab) {
   WebContents* contents = browser()->tab_strip_model()->GetActiveWebContents();
 ","The WebContentsImpl::AttachInterstitialPage function in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 31.0.1650.48 does not cancel JavaScript dialogs upon generating an interstitial warning, which allows remote attackers to spoof the address bar via a crafted web site."
2711,CVE-2013-6630,"  TEST(ProcMapsTest, Permissions) {
          MappedMemoryRegion::EXECUTE | MappedMemoryRegion::PRIVATE},
   };
 
  for (size_t i = 0; i < arraysize(kTestCases); ++i) {
     SCOPED_TRACE(
         base::StringPrintf(""kTestCases[%zu] = %s"", i, kTestCases[i].input));
 ","The get_dht function in jdmarker.c in libjpeg-turbo through 1.3.0, as used in Google Chrome before 31.0.1650.48 and other products, does not set all elements of a certain Huffman value array during the reading of segments that follow Define Huffman Table (DHT) JPEG markers, which allows remote attackers to obtain sensitive information from uninitialized memory locations via a crafted JPEG image."
2712,CVE-2013-6631," 
 #include ""base/profiler/tracked_time.h""
 #include ""base/tracked_objects.h""
 
 #define PASTE_LINE_NUMBER_ON_NAME(name, line) name##line
 
 #define LINE_BASED_VARIABLE_NAME_FOR_PROFILING                                 \
     PASTE_LINE_NUMBER_ON_NAME(some_profiler_variable_, __LINE__)
 
 
 
 
#define TRACK_RUN_IN_THIS_SCOPED_REGION(dispatch_function_name)                \
    ::tracked_objects::ScopedProfile LINE_BASED_VARIABLE_NAME_FOR_PROFILING(   \
         FROM_HERE_WITH_EXPLICIT_FUNCTION(#dispatch_function_name))
 
 ","Use-after-free vulnerability in the Channel::SendRTCPPacket function in voice_engine/channel.cc in libjingle in WebRTC, as used in Google Chrome before 31.0.1650.48 and other products, allows remote attackers to cause a denial of service (heap memory corruption) or possibly have unspecified other impact via vectors that trigger the absence of certain statistics initialization, leading to the skipping of a required DeRegisterExternalTransport call."
2713,CVE-2013-2926,"  void ApplyBlockElementCommand::formatSelection(const VisiblePosition& startOfSel
         if (endAfterSelection.isNotNull() && !endAfterSelection.deepEquivalent().inDocument())
             break;
          
         
        if (endOfNextParagraph.isNotNull() && !endOfNextParagraph.deepEquivalent().inDocument())
             return;
         endOfCurrentParagraph = endOfNextParagraph;
     }
 }","Use-after-free vulnerability in the IndentOutdentCommand::tryIndentingAsListItem function in core/editing/IndentOutdentCommand.cpp in Blink, as used in Google Chrome before 30.0.1599.101, allows user-assisted remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to list elements."
2714,CVE-2013-2906,"  double ConvolverNode::tailTime() const
 
 double ConvolverNode::latencyTime() const
 {
    MutexTryLocker tryLocker(m_processLock);
    if (tryLocker.locked())
        return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;
     
     
    return std::numeric_limits<double>::infinity();
 }
 
 }  ","Multiple race conditions in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to threading in core/html/HTMLMediaElement.cpp, core/platform/audio/AudioDSPKernelProcessor.cpp, core/platform/audio/HRTFElevation.cpp, and modules/webaudio/ConvolverNode.cpp."
2715,CVE-2013-2906," 
 
  
  
 
 
 #include ""base/i18n/string_compare.h""
 #include ""base/metrics/histogram.h""
 #include ""base/prefs/pref_service.h""
 #include ""chrome/browser/infobars/infobar_service.h""
 #include ""chrome/browser/translate/translate_tab_helper.h""
 #include ""components/infobars/core/infobar.h""
 #include ""components/translate/core/browser/translate_accept_languages.h""
 #include ""components/translate/core/browser/translate_download_manager.h""
 #include ""components/translate/core/browser/translate_manager.h""
 #include ""components/translate/core/common/translate_constants.h""
#include ""content/public/browser/browser_context.h""
 #include ""content/public/browser/web_contents.h""
 #include ""grit/generated_resources.h""
 #include ""grit/theme_resources.h""
  void TranslateInfoBarDelegate::TranslationDeclined() {
 }
 
 bool TranslateInfoBarDelegate::IsTranslatableLanguageByPrefs() {
  TranslateTabHelper* translate_tab_helper =
      TranslateTabHelper::FromWebContents(GetWebContents());
   scoped_ptr<TranslatePrefs> translate_prefs(
      TranslateTabHelper::CreateTranslatePrefs(
          translate_tab_helper->GetPrefs()));
   TranslateAcceptLanguages* accept_languages =
      translate_tab_helper->GetTranslateAcceptLanguages();
   return translate_prefs->CanTranslateLanguage(accept_languages,
                                                original_language_code());
 }
  content::WebContents* TranslateInfoBarDelegate::GetWebContents() {
   return InfoBarService::WebContentsFromInfoBar(infobar());
 }
 
  
 void TranslateInfoBarDelegate::GetAfterTranslateStrings(
     std::vector<base::string16>* strings,","Multiple race conditions in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to threading in core/html/HTMLMediaElement.cpp, core/platform/audio/AudioDSPKernelProcessor.cpp, core/platform/audio/HRTFElevation.cpp, and modules/webaudio/ConvolverNode.cpp."
2716,CVE-2013-2906,"  const OmniboxEditModel::State OmniboxEditModel::GetStateForTabSwitch() {
 void OmniboxEditModel::RestoreState(const State* state) {
    
    
  bool url_replacement_enabled = !state || state->url_replacement_enabled;
   controller_->GetToolbarModel()->set_url_replacement_enabled(
      url_replacement_enabled);
  controller_->GetToolbarModel()->set_origin_chip_enabled(
      url_replacement_enabled);
   permanent_text_ = controller_->GetToolbarModel()->GetText();
    
    ","Multiple race conditions in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to threading in core/html/HTMLMediaElement.cpp, core/platform/audio/AudioDSPKernelProcessor.cpp, core/platform/audio/HRTFElevation.cpp, and modules/webaudio/ConvolverNode.cpp."
2717,CVE-2013-2906,"  void RenderThreadImpl::Shutdown() {
 
    
   if (webkit_platform_support_) {
     
     
     
    WebView::willEnterModalLoop();
     webkit_platform_support_->web_database_observer_impl()->
         WaitForAllDatabasesToClose();
    WebView::didExitModalLoop();
   }
 
    ","Multiple race conditions in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to threading in core/html/HTMLMediaElement.cpp, core/platform/audio/AudioDSPKernelProcessor.cpp, core/platform/audio/HRTFElevation.cpp, and modules/webaudio/ConvolverNode.cpp."
2718,CVE-2013-2906,"  void ScreenOrientationDispatcherHost::OnLockRequest(
                     blink::WebLockOrientationErrorCanceled);
   }
 
   if (!provider_) {
     NotifyLockError(request_id,
                     blink::WebLockOrientationErrorNotAvailable);
     return;
   }
 
  current_lock_ = new LockInformation(request_id,
                                      render_frame_host->GetProcess()->GetID(),
                                      render_frame_host->GetRoutingID());

   provider_->LockOrientation(request_id, orientation);
 }
 
  void ScreenOrientationDispatcherHost::OnUnlockRequest(
                     blink::WebLockOrientationErrorCanceled);
   }
 
  if (!provider_)
     return;
 
   provider_->UnlockOrientation();","Multiple race conditions in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to threading in core/html/HTMLMediaElement.cpp, core/platform/audio/AudioDSPKernelProcessor.cpp, core/platform/audio/HRTFElevation.cpp, and modules/webaudio/ConvolverNode.cpp."
2719,CVE-2013-2908,"  ScriptValue ScriptController::executeScriptInMainWorld(const ScriptSourceCode& s
     if (v8Context.IsEmpty())
         return ScriptValue();
 
     RefPtr<Frame> protect(m_frame);
    if (m_frame->loader()->stateMachine()->isDisplayingInitialEmptyDocument())
        m_frame->loader()->didAccessInitialDocument();

    v8::Context::Scope scope(v8Context);
     v8::Local<v8::Value> object = compileAndRunScript(sourceCode, corsStatus);
 
     m_sourceURL = savedSourceURL;","Google Chrome before 30.0.1599.66 uses incorrect function calls to determine the values of NavigationEntry objects, which allows remote attackers to spoof the address bar via vectors involving a response with a 204 (aka No Content) status code."
2720,CVE-2013-2910,"  IN_PROC_BROWSER_TEST_F(ResetTest, ShowAndCancel) {
   JSExpect(""!document.querySelector('#reset.hidden')"");
   CloseResetScreen();
   JSExpect(""!!document.querySelector('#reset.hidden')"");
  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableRollbackOption))
    EXPECT_EQ(1, update_engine_client_->can_rollback_call_count());
 }
 
 IN_PROC_BROWSER_TEST_F(ResetTest, PRE_RestartBeforePowerwash) {
  IN_PROC_BROWSER_TEST_F(ResetFirstAfterBootTest, ShortcutInvokedCases) {
   CloseResetScreen();
   OobeScreenWaiter(OobeDisplay::SCREEN_ACCOUNT_PICKER).Wait();
 
  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableRollbackOption)) {
     
    InvokeResetScreen();
    ASSERT_TRUE(content::ExecuteScript(
        web_contents(),
        ""$('reset-rollback-checkbox').checked = true;""));
    ClickResetButton();
    EXPECT_EQ(0, power_manager_client_->num_request_restart_calls());
    EXPECT_EQ(2, session_manager_client_->start_device_wipe_call_count());
    EXPECT_EQ(1, update_engine_client_->rollback_call_count());
  }
 }
 
 IN_PROC_BROWSER_TEST_F(ResetFirstAfterBootTest, PRE_PowerwashRequested) {
  IN_PROC_BROWSER_TEST_F(ResetFirstAfterBootTest, ErrorOnRollbackRequested) {
   EXPECT_EQ(0, update_engine_client_->rollback_call_count());
   JSExpect(""!$('reset').classList.contains('revert-promise')"");
   ClickResetButton();
  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableRollbackOption)) {
    EXPECT_EQ(0, power_manager_client_->num_request_restart_calls());
    EXPECT_EQ(0, session_manager_client_->start_device_wipe_call_count());
    EXPECT_EQ(1, update_engine_client_->rollback_call_count());
    JSExpect(""$('reset').classList.contains('revert-promise')"");
    UpdateEngineClient::Status error_update_status;
    error_update_status.status = UpdateEngineClient::UPDATE_STATUS_ERROR;
    update_engine_client_->NotifyObserversThatStatusChanged(
        error_update_status);
    OobeScreenWaiter(OobeDisplay::SCREEN_ERROR_MESSAGE).Wait();
  }
 }
 
 IN_PROC_BROWSER_TEST_F(ResetFirstAfterBootTest,","Use-after-free vulnerability in modules/webaudio/AudioScheduledSourceNode.cpp in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
2721,CVE-2013-2913," 
 #include ""chrome/browser/extensions/api/bookmarks/bookmark_api_helpers.h""
 
 #include ""base/memory/scoped_ptr.h""
#include ""base/strings/string_number_conversions.h""
 #include ""base/strings/utf_string_conversions.h""
 #include ""base/values.h""
 #include ""chrome/browser/bookmarks/bookmark_model_factory.h""
  namespace bookmark_api_helpers {
 class ExtensionBookmarksTest : public testing::Test {
  public:
   ExtensionBookmarksTest()
      : client_(NULL), model_(NULL), node_(NULL), node2_(NULL), folder_(NULL) {}
 
   virtual void SetUp() OVERRIDE {
     profile_.CreateBookmarkModel(false);
  class ExtensionBookmarksTest : public testing::Test {
 
     node_ = model_->AddURL(model_->other_node(), 0, base::ASCIIToUTF16(""Digg""),
                            GURL(""http://www.reddit.com""));
    model_->SetNodeMetaInfo(node_, ""some_key1"", ""some_value1"");
    model_->SetNodeMetaInfo(node_, ""some_key2"", ""some_value2"");
     model_->AddURL(model_->other_node(), 0, base::ASCIIToUTF16(""News""),
                    GURL(""http://www.foxnews.com""));
     folder_ = model_->AddFolder(
         model_->other_node(), 0, base::ASCIIToUTF16(""outer folder""));
    model_->SetNodeMetaInfo(folder_, ""some_key1"", ""some_value1"");
     model_->AddFolder(folder_, 0, base::ASCIIToUTF16(""inner folder 1""));
     model_->AddFolder(folder_, 0, base::ASCIIToUTF16(""inner folder 2""));
    node2_ = model_->AddURL(
         folder_, 0, base::ASCIIToUTF16(""Digg""), GURL(""http://reddit.com""));
    model_->SetNodeMetaInfo(node2_, ""some_key2"", ""some_value2"");
     model_->AddURL(
         folder_, 0, base::ASCIIToUTF16(""CNet""), GURL(""http://cnet.com""));
   }
  class ExtensionBookmarksTest : public testing::Test {
   ChromeBookmarkClient* client_;
   BookmarkModel* model_;
   const BookmarkNode* node_;
  const BookmarkNode* node2_;
   const BookmarkNode* folder_;
 };
 
  TEST_F(ExtensionBookmarksTest, RemoveNodeRecursive) {
   EXPECT_EQ(2, model_->other_node()->child_count());
 }
 
TEST_F(ExtensionBookmarksTest, GetMetaInfo) {
  base::DictionaryValue id_to_meta_info_map;
  GetMetaInfo(*model_->other_node(), &id_to_meta_info_map);
  EXPECT_EQ(8u, id_to_meta_info_map.size());

   
  const base::Value* value = NULL;
  EXPECT_TRUE(id_to_meta_info_map.Get(
      base::Int64ToString(model_->other_node()->id()), &value));
  ASSERT_TRUE(NULL != value);
  const base::DictionaryValue* dictionary_value = NULL;
  EXPECT_TRUE(value->GetAsDictionary(&dictionary_value));
  ASSERT_TRUE(NULL != dictionary_value);
  EXPECT_EQ(0u, dictionary_value->size());

   
  value = NULL;
  EXPECT_TRUE(id_to_meta_info_map.Get(
      base::Int64ToString(node_->id()), &value));
  ASSERT_TRUE(NULL != value);
  dictionary_value = NULL;
  EXPECT_TRUE(value->GetAsDictionary(&dictionary_value));
  ASSERT_TRUE(NULL != dictionary_value);
  EXPECT_EQ(2u, dictionary_value->size());
  std::string string_value;
  EXPECT_TRUE(dictionary_value->GetString(""some_key1"", &string_value));
  EXPECT_EQ(""some_value1"", string_value);
  EXPECT_TRUE(dictionary_value->GetString(""some_key2"", &string_value));
  EXPECT_EQ(""some_value2"", string_value);

   
  value = NULL;
  EXPECT_TRUE(id_to_meta_info_map.Get(
      base::Int64ToString(folder_->id()), &value));
  ASSERT_TRUE(NULL != value);
  dictionary_value = NULL;
  EXPECT_TRUE(value->GetAsDictionary(&dictionary_value));
  ASSERT_TRUE(NULL != dictionary_value);
  EXPECT_EQ(1u, dictionary_value->size());
  EXPECT_TRUE(dictionary_value->GetString(""some_key1"", &string_value));
  EXPECT_EQ(""some_value1"", string_value);

   
  value = NULL;
  EXPECT_TRUE(id_to_meta_info_map.Get(
      base::Int64ToString(node2_->id()), &value));
  ASSERT_TRUE(NULL != value);
  dictionary_value = NULL;
  EXPECT_TRUE(value->GetAsDictionary(&dictionary_value));
  ASSERT_TRUE(NULL != dictionary_value);
  EXPECT_EQ(1u, dictionary_value->size());
  string_value.clear();
  EXPECT_FALSE(dictionary_value->GetString(""some_key1"", &string_value));
  EXPECT_EQ("""", string_value);
  EXPECT_TRUE(dictionary_value->GetString(""some_key2"", &string_value));
  EXPECT_EQ(""some_value2"", string_value);

}

 }   
 }   ","Use-after-free vulnerability in the XMLDocumentParser::append function in core/xml/parser/XMLDocumentParser.cpp in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving an XML document."
2722,CVE-2013-2914,"  void ColorChooserDialog::ExecuteOpen(const ExecuteOpenParams& params) {
 void ColorChooserDialog::DidCloseDialog(bool chose_color,
                                         SkColor color,
                                         RunState run_state) {
   EndRun(run_state);
   CopyCustomColors(custom_colors_, g_custom_colors);
  if (listener_) {
    if (chose_color)
      listener_->OnColorChosen(color);
    listener_->OnColorChooserDialogClosed();
  }
 }
 
 void ColorChooserDialog::CopyCustomColors(COLORREF* src, COLORREF* dst) {",Use-after-free vulnerability in the color-chooser dialog in Google Chrome before 30.0.1599.66 on Windows allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to color_chooser_dialog.cc and color_chooser_win.cc in browser/ui/views/.
2723,CVE-2013-2915,"  void NavigationControllerImpl::FinishRestore(int selected_index,
 }
 
 void NavigationControllerImpl::DiscardNonCommittedEntriesInternal() {
  DiscardPendingEntry();
  DiscardTransientEntry();
}

void NavigationControllerImpl::DiscardPendingEntry() {
   if (pending_entry_index_ == -1)
     delete pending_entry_;
   pending_entry_ = NULL;
   pending_entry_index_ = -1;
 }
 
 void NavigationControllerImpl::DiscardTransientEntry() {","Google Chrome before 30.0.1599.66 preserves pending NavigationEntry objects in certain invalid circumstances, which allows remote attackers to spoof the address bar via a URL with a malformed scheme, as demonstrated by a nonexistent:12121 URL."
2724,CVE-2013-2916,"  void FrameLoader::didAccessInitialDocumentTimerFired(Timer<FrameLoader>*)
     m_client->didAccessInitialDocument();
 }
 
void FrameLoader::notifyIfInitialDocumentAccessed()
{
    if (m_didAccessInitialDocumentTimer.isActive()
        && m_stateMachine.isDisplayingInitialEmptyDocument()) {
        m_didAccessInitialDocumentTimer.stop();
        didAccessInitialDocumentTimerFired(0);
    }
}

 bool FrameLoader::isLoading() const
 {
     DocumentLoader* docLoader = activeDocumentLoader();","Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to spoof the address bar via vectors involving a response with a 204 (aka No Content) status code, in conjunction with a delay in notifying the user of an attempted spoof."
2725,CVE-2013-2917,"  ReverbConvolverStage::ReverbConvolverStage(const float* impulseResponse, size_t,
         m_fftKernel->doPaddedFFT(impulseResponse + stageOffset, stageLength);
         m_fftConvolver = adoptPtr(new FFTConvolver(fftSize));
     } else {
        ASSERT(!stageOffset);
        ASSERT(stageLength <= fftSize / 2);

         m_directKernel = adoptPtr(new AudioFloatArray(fftSize / 2));
        m_directKernel->copyToRange(impulseResponse, 0, stageLength);
         m_directConvolver = adoptPtr(new DirectConvolver(renderSliceSize));
     }
     m_temporaryBuffer.allocate(renderSliceSize);","The ReverbConvolverStage::ReverbConvolverStage function in core/platform/audio/ReverbConvolverStage.cpp in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service (out-of-bounds read) via vectors related to the impulseResponse array."
2726,CVE-2013-2920,"  bool DoResolveRelativeHost(const char* base_url,
    
    
   url_parse::Parsed relative_parsed;   
  url_parse::ParseAfterScheme(relative_url, relative_component.end(),
                              relative_component.begin, &relative_parsed);
 
    
    ","The DoResolveRelativeHost function in url/url_canon_relative.cc in Google Chrome before 30.0.1599.66 allows remote attackers to cause a denial of service (out-of-bounds read) via a relative URL containing a hostname, as demonstrated by a protocol-relative URL beginning with a //www.google.com/ substring."
2727,CVE-2013-2921,"  void DelegatedFrameHost::RequestCopyOfOutput(
 
 void DelegatedFrameHost::CopyFromCompositingSurface(
     const gfx::Rect& src_subrect,
    const gfx::Size& output_size,
     const base::Callback<void(bool, const SkBitmap&)>& callback,
     const SkColorType color_type) {
    
  void DelegatedFrameHost::CopyFromCompositingSurface(
     return;
   }
 
   scoped_ptr<cc::CopyOutputRequest> request =
       cc::CopyOutputRequest::CreateRequest(base::Bind(
           &DelegatedFrameHost::CopyFromCompositingSurfaceHasResult,
          output_size,
           color_type,
           callback));
  request->set_area(src_subrect);
   client_->RequestCopyOfOutput(request.Pass());
 }
 ","Double free vulnerability in the ResourceFetcher::didLoadResource function in core/fetch/ResourceFetcher.cpp in the resource loader in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering certain callback processing during the reporting of a resource entry."
2728,CVE-2013-2922,"  bool FileBrowserPrivateGetShareUrlFunction::RunAsync() {
 
   file_system->GetShareUrl(
       drive_path,
      GURL(""chrome-extension://"" + extension_id()),   
       base::Bind(&FileBrowserPrivateGetShareUrlFunction::OnGetShareUrl, this));
   return true;
 }","Use-after-free vulnerability in core/html/HTMLTemplateElement.cpp in Blink, as used in Google Chrome before 30.0.1599.66, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that operates on a TEMPLATE element."
2729,CVE-2013-2905," 
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
#include <sys/types.h>
 #include <unistd.h>
 
 #include ""base/file_util.h""
  bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
     if (!FilePathForMemoryName(*options.name, &path))
       return false;
 
     
     
    const mode_t kOwnerOnly = S_IRUSR | S_IWUSR;

     
    int fd = HANDLE_EINTR(
        open(path.value().c_str(), O_RDWR | O_CREAT | O_EXCL, kOwnerOnly));
    if (fd == -1 && options.open_existing) {
       
       
       
       
       
       
       
      fd = HANDLE_EINTR(
          open(path.value().c_str(), O_RDWR | O_APPEND | O_NOFOLLOW));

       
       
       
      const uid_t real_uid = getuid();
      const uid_t effective_uid = geteuid();
      struct stat sb;
      if (fd >= 0 &&
          (fstat(fd, &sb) != 0 || sb.st_uid != real_uid ||
           sb.st_uid != effective_uid)) {
        LOG(ERROR) <<
            ""Invalid owner when opening existing shared memory file."";
        HANDLE_EINTR(close(fd));
        return false;
      }

       
       fix_size = false;
     }
    fp = NULL;
    if (fd >= 0) {
       
      fp = fdopen(fd, ""a+"");
    }
   }
   if (fp && fix_size) {
      ","The SharedMemory::Create function in memory/shared_memory_posix.cc in Google Chrome before 29.0.1547.57 uses weak permissions under /dev/shm/, which allows attackers to obtain sensitive information via direct access to a POSIX shared-memory file."
2730,CVE-2013-2903,"  size_t kMaxFolderItems = 16;
  
 const size_t kNumFolderTopItems = 4;
 
 
const size_t kMaxFolderNameChars = 40;

  
 const ui::ResourceBundle::FontStyle kItemTextFontStyle =
     ui::ResourceBundle::SmallBoldFont;","Use-after-free vulnerability in the HTMLMediaElement::didMoveToNewDocument function in core/html/HTMLMediaElement.cpp in Blink, as used in Google Chrome before 29.0.1547.57, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving moving a (1) AUDIO or (2) VIDEO element between documents."
2731,CVE-2013-2904,"  class CryptohomeClientImpl : public CryptohomeClient {
       const AsyncMethodCallback& callback) OVERRIDE {
     dbus::MethodCall method_call(
         cryptohome::kCryptohomeInterface,
        cryptohome::kCryptohomeAsyncTpmAttestationCreateEnrollRequest);
     dbus::MessageWriter writer(&method_call);
     writer.AppendInt32(pca_type);
     proxy_->CallMethod(&method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT,
  class CryptohomeClientImpl : public CryptohomeClient {
       const AsyncMethodCallback& callback) OVERRIDE {
     dbus::MethodCall method_call(
         cryptohome::kCryptohomeInterface,
        cryptohome::kCryptohomeAsyncTpmAttestationEnroll);
     dbus::MessageWriter writer(&method_call);
     writer.AppendInt32(pca_type);
     writer.AppendArrayOfBytes(","Use-after-free vulnerability in the Document::finishedParsing function in core/dom/Document.cpp in Blink, as used in Google Chrome before 29.0.1547.57, allows remote attackers to cause a denial of service or possibly have unspecified other impact via an onload event that changes an IFRAME element so that its src attribute is no longer an XML document, leading to unintended garbage collection of this document."
2732,CVE-2013-2887,"  class GestureEventConsumeDelegate : public TestWindowDelegate {
     tap_count_ = 0;
     scale_ = 0;
     flags_ = 0;
    latency_info_.Clear();
   }
 
   const std::vector<ui::EventType>& events() const { return events_; };
  class GestureEventConsumeDelegate : public TestWindowDelegate {
   const gfx::Rect& bounding_box() const { return bounding_box_; }
   int tap_count() const { return tap_count_; }
   int flags() const { return flags_; }
  const ui::LatencyInfo& latency_info() const { return latency_info_; }
 
   void WaitUntilReceivedGesture(ui::EventType type) {
     wait_until_event_ = type;
  class GestureEventConsumeDelegate : public TestWindowDelegate {
     events_.push_back(gesture->type());
     bounding_box_ = gesture->details().bounding_box();
     flags_ = gesture->flags();
    latency_info_ = *gesture->latency();
     switch (gesture->type()) {
       case ui::ET_GESTURE_TAP:
         tap_location_ = gesture->location();
  class GestureEventConsumeDelegate : public TestWindowDelegate {
   gfx::Rect bounding_box_;
   int tap_count_;
   int flags_;
  ui::LatencyInfo latency_info_;
 
   ui::EventType wait_until_event_;
 
  TEST_P(GestureRecognizerTest, GestureEventFlagsPassedFromTouchEvent) {
   EXPECT_NE(default_flags, delegate->flags());
 }
 
 
TEST_P(GestureRecognizerTest, LatencyPassedFromTouchEvent) {
  scoped_ptr<GestureEventConsumeDelegate> delegate(
      new GestureEventConsumeDelegate());
  TimedEvents tes;
  const int kWindowWidth = 123;
  const int kWindowHeight = 45;
  const int kTouchId = 6;

  const base::TimeTicks time_original = base::TimeTicks::FromInternalValue(100);
  const base::TimeTicks time_ui = base::TimeTicks::FromInternalValue(200);
  const base::TimeTicks time_acked = base::TimeTicks::FromInternalValue(300);

  gfx::Rect bounds(100, 200, kWindowWidth, kWindowHeight);
  scoped_ptr<aura::Window> window(CreateTestWindowWithDelegate(
      delegate.get(), -1234, bounds, root_window()));

  delegate->Reset();

  ui::TouchEvent press1(ui::ET_TOUCH_PRESSED, gfx::Point(101, 201),
                        kTouchId, tes.Now());

   
  press1.latency()->Clear();

  press1.latency()->AddLatencyNumberWithTimestamp(
      ui::INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT, 0, 0, time_original, 1);

  press1.latency()->AddLatencyNumberWithTimestamp(
      ui::INPUT_EVENT_LATENCY_UI_COMPONENT, 0, 0, time_ui, 1);

  press1.latency()->AddLatencyNumberWithTimestamp(
      ui::INPUT_EVENT_LATENCY_ACKED_TOUCH_COMPONENT, 0, 0, time_acked, 1);

  DispatchEventUsingWindowDispatcher(&press1);
  EXPECT_TRUE(delegate->tap_down());

  ui::LatencyInfo::LatencyComponent component;

  EXPECT_EQ(3U, delegate->latency_info().latency_components.size());
  ASSERT_TRUE(delegate->latency_info().FindLatency(
      ui::INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT, 0, &component));
  EXPECT_EQ(time_original, component.event_time);

  ASSERT_TRUE(delegate->latency_info().FindLatency(
      ui::INPUT_EVENT_LATENCY_UI_COMPONENT, 0, &component));
  EXPECT_EQ(time_ui, component.event_time);

  ASSERT_TRUE(delegate->latency_info().FindLatency(
      ui::INPUT_EVENT_LATENCY_ACKED_TOUCH_COMPONENT, 0, &component));
  EXPECT_EQ(time_acked, component.event_time);

  delegate->WaitUntilReceivedGesture(ui::ET_GESTURE_SHOW_PRESS);
  EXPECT_TRUE(delegate->show_press());
  EXPECT_EQ(0U, delegate->latency_info().latency_components.size());
}

 INSTANTIATE_TEST_CASE_P(GestureRecognizer,
                         GestureRecognizerTest,
                         ::testing::Bool());",Multiple unspecified vulnerabilities in Google Chrome before 29.0.1547.57 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2733,CVE-2013-2882,"  IN_PROC_BROWSER_TEST_F(AutofillInteractiveTest, AutofillSelectViaTab) {
 }
 
  
 
IN_PROC_BROWSER_TEST_F(AutofillInteractiveTest,
                       DISABLED_OnChangeAfterAutofill) {
   CreateTestProfile();
 
   const char* kOnChangeScript =","Google V8, as used in Google Chrome before 28.0.1500.95, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*"
2734,CVE-2013-2867,"  void FakeBluetoothAgentManagerClient::UnregisterAgent(
     const base::Closure& callback,
     const ErrorCallback& error_callback) {
   VLOG(1) << ""UnregisterAgent: "" << agent_path.value();
  if (service_provider_ == NULL) {
    error_callback.Run(bluetooth_agent_manager::kErrorDoesNotExist,
                       ""No agent registered"");
  } else if (service_provider_->object_path_ != agent_path) {
    error_callback.Run(bluetooth_agent_manager::kErrorDoesNotExist,
                        ""Agent still registered"");
   } else {
     callback.Run();","Google Chrome before 28.0.1500.71 does not properly prevent pop-under windows, which allows remote attackers to have an unspecified impact via a crafted web site."
2735,CVE-2013-2879,"  void StartSync(const StartSyncArgs& args,
     return;
   }
 
    
   new OneClickSigninSyncStarter(args.profile, args.browser, args.session_index,
                                 args.email, args.password, start_mode,
                                 args.force_same_tab_navigation,
                                args.confirmation_required,
                                args.source);
 
   int action = one_click_signin::HISTOGRAM_MAX;
   switch (args.auto_accept) {
  void OneClickSigninHelper::DidStopLoading(
       LogOneClickHistogramValue(one_click_signin::HISTOGRAM_ACCEPTED);
       LogOneClickHistogramValue(one_click_signin::HISTOGRAM_WITH_ADVANCED);
       SigninManager::DisableOneClickSignIn(profile);
       
       
       StartSync(
           StartSyncArgs(profile, browser, auto_accept_, session_index_, email_,
                         password_, false  ,
                        true  , source_),
           OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST);
       break;
     case AUTO_ACCEPT_EXPLICIT: {","Google Chrome before 28.0.1500.71 does not properly determine the circumstances in which a renderer process can be considered a trusted process for sign-in and subsequent sync operations, which makes it easier for remote attackers to conduct phishing attacks via a crafted web site."
2736,CVE-2013-2868,"  SyncType GetSyncType(const Extension* extension) {
    
    
    
  if (PluginInfo::HasPlugins(extension) ||
      extension->HasAPIPermission(APIPermission::kPlugin)) {
     return SYNC_TYPE_NONE;
  }
 
   switch (extension->GetType()) {
     case Manifest::TYPE_EXTENSION:","common/extensions/sync_helper.cc in Google Chrome before 28.0.1500.71 proceeds with sync operations for NPAPI extensions without checking for a certain plugin permission setting, which might allow remote attackers to trigger unwanted extension changes via unspecified vectors."
2737,CVE-2013-2869," 
 
 namespace chrome {
 
 extern const char kAboutComponentsURL[];
 extern const char kAboutPluginsURL[];
 extern const char kAboutVersionURL[];",Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted JPEG2000 image.
2738,CVE-2013-2870,"  ChromeURLRequestContextGetter::CreateOffTheRecordForIsolatedApp(
 ChromeURLRequestContext::ChromeURLRequestContext(
     ContextType type,
     chrome_browser_net::LoadTimeStats* load_time_stats)
    : weak_factory_(this),
      load_time_stats_(load_time_stats) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
   if (load_time_stats_)
     load_time_stats_->RegisterURLRequestContext(this, type);",Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote servers to execute arbitrary code via crafted response traffic after a URL request.
2739,CVE-2013-2853,"  NET_ERROR(INCOMPLETE_CHUNKED_ENCODING, -355)
  
 NET_ERROR(QUIC_PROTOCOL_ERROR, -356)
 
 
NET_ERROR(HEADERS_TRUNCATED, -357)

  
 NET_ERROR(CACHE_MISS, -400)
 ","The HTTPS implementation in Google Chrome before 28.0.1500.71 does not ensure that headers are terminated by rnrn (carriage return, newline, carriage return, newline), which allows man-in-the-middle attackers to have an unspecified impact via vectors that trigger header truncation."
2740,CVE-2013-2871,"  PixelBufferRasterWorkerPool::PixelBufferRasterWorkerPool(
       check_for_completed_raster_tasks_pending_(false),
       should_notify_client_if_no_tasks_are_pending_(false),
       should_notify_client_if_no_tasks_required_for_activation_are_pending_(
          false),
      raster_finished_task_pending_(false),
      raster_required_for_activation_finished_task_pending_(false) {
 }
 
 PixelBufferRasterWorkerPool::~PixelBufferRasterWorkerPool() {
  void PixelBufferRasterWorkerPool::OnRasterTasksFinished() {
    
   if (!should_notify_client_if_no_tasks_are_pending_)
     return;
  raster_finished_task_pending_ = false;
 
    
    
  void PixelBufferRasterWorkerPool::OnRasterTasksRequiredForActivationFinished() {
    
   if (!should_notify_client_if_no_tasks_required_for_activation_are_pending_)
     return;
  raster_required_for_activation_finished_task_pending_ = false;
 
    
    
  void PixelBufferRasterWorkerPool::CheckForCompletedRasterTasks() {
    
   bool will_notify_client_that_no_tasks_required_for_activation_are_pending =
       (should_notify_client_if_no_tasks_required_for_activation_are_pending_ &&
       !raster_required_for_activation_finished_task_pending_ &&
        !HasPendingTasksRequiredForActivation());
   bool will_notify_client_that_no_tasks_are_pending =
       (should_notify_client_if_no_tasks_are_pending_ &&
       !raster_finished_task_pending_ &&
        !HasPendingTasks());
 
    
  void PixelBufferRasterWorkerPool::ScheduleMoreTasks() {
       should_notify_client_if_no_tasks_required_for_activation_are_pending_) {
     new_raster_required_for_activation_finished_task =
         CreateRasterRequiredForActivationFinishedTask();
    raster_required_for_activation_finished_task_pending_ = true;
     internal::GraphNode* raster_required_for_activation_finished_node =
         CreateGraphNodeForTask(
             new_raster_required_for_activation_finished_task.get(),
  void PixelBufferRasterWorkerPool::ScheduleMoreTasks() {
   if (!did_throttle_raster_tasks &&
       should_notify_client_if_no_tasks_are_pending_) {
     new_raster_finished_task = CreateRasterFinishedTask();
    raster_finished_task_pending_ = true;
     internal::GraphNode* raster_finished_node =
         CreateGraphNodeForTask(new_raster_finished_task.get(),
                                1u,   ",Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of input.
2741,CVE-2013-2873,"  IN_PROC_BROWSER_TEST_F(WebKitBrowserTest, PrerenderNoCrash) {
   EXPECT_FALSE(shell()->web_contents()->IsCrashed());
 }
 
 
 
 
 
const char kErrorBodyNoCrash[] =
    ""files/error-body-no-crash.html"";
IN_PROC_BROWSER_TEST_F(WebKitBrowserTest, ErrorBodyNoCrash) {
  ASSERT_TRUE(test_server()->Start());
  GURL url = test_server()->GetURL(kErrorBodyNoCrash);

  NavigateToURL(shell(), url);

  EXPECT_FALSE(shell()->web_contents()->IsCrashed());
}

 }   ",Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving a 404 HTTP status code during the loading of resources.
2742,CVE-2013-2874,"  IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,
       &chrome::CloseAllBrowsers));
 }
 
 
 
 
IN_PROC_BROWSER_TEST_F(DevToolsBeforeUnloadTest,
                       TestUndockedDevToolsUnresponsive) {
  ASSERT_TRUE(test_server()->Start());
  LoadTestPage(kDebuggerTestPage);
  DevToolsWindow* devtools_window = OpenDevToolWindowOnWebContents(
      GetInspectedTab());
  devtools_window->SetDockSideForTest(DEVTOOLS_DOCK_SIDE_UNDOCKED);
  content::WindowedNotificationObserver devtools_close_observer(
      content::NOTIFICATION_WEB_CONTENTS_DESTROYED,
      content::Source<content::WebContents>(
          devtools_window->web_contents()));

  ASSERT_TRUE(content::ExecuteScript(
      devtools_window->web_contents()->GetRenderViewHost(),
      ""window.addEventListener('beforeunload',""
      ""function(event) { while (true); });""));
  CloseInspectedTab();
  devtools_close_observer.Wait();
}

  
  
  ","Google Chrome before 28.0.1500.71 on Windows, when an Nvidia GPU is used, allows remote attackers to bypass intended restrictions on access to screen data via vectors involving IPC transmission of GL textures."
2743,CVE-2013-2876,"  bool TabsCaptureVisibleTabFunction::RunImpl() {
     }
   }
 
   
   
   
   
   
   
   
   
  NavigationEntry* last_committed_entry =
      web_contents->GetController().GetLastCommittedEntry();
  GURL last_committed_url = last_committed_entry ?
      last_committed_entry->GetURL() : GURL();
  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
                                             SessionID::IdForTab(web_contents),
                                             &error_)) {
     return false;
   }
 ","browser/extensions/api/tabs/tabs_api.cc in Google Chrome before 28.0.1500.71 does not properly enforce restrictions on the capture of screenshots by extensions, which allows remote attackers to obtain sensitive information about the content of a previous page via vectors involving an interstitial page."
2744,,"  void LocalReaderProxy::OnCompleted(FileError error) {
 }
 
 NetworkReaderProxy::NetworkReaderProxy(
    int64 offset,
     int64 content_length,
     const base::Closure& job_canceller)
    : remaining_offset_(offset),
      remaining_content_length_(content_length),
       error_code_(net::OK),
       buffer_length_(0),
       job_canceller_(job_canceller) {
  int NetworkReaderProxy::Read(net::IOBuffer* buffer, int buffer_length,
     return 0;
   }
 
  if (buffer_length > remaining_content_length_) {
     
    buffer_length = static_cast<int>(remaining_content_length_);
  }

   if (pending_data_.empty()) {
      
     buffer_ = buffer;
  void NetworkReaderProxy::OnGetContent(scoped_ptr<std::string> data) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
   DCHECK(data && !data->empty());
 
  if (remaining_offset_ >= static_cast<int64>(data->length())) {
     
    remaining_offset_ -= data->length();
    return;
  }

  if (remaining_offset_ > 0) {
     
    data->erase(0, static_cast<size_t>(remaining_offset_));
    remaining_offset_ = 0;
  }

   pending_data_.push_back(data.release());
   if (!buffer_) {
      
  void DriveFileStreamReader::InitializeAfterGetFileContentByPathInitialized(
      
     reader_proxy_.reset(
         new internal::NetworkReaderProxy(
            0, entry->file_info().size(),
             base::Bind(&internal::CancelGetFile,
                        drive_file_system_getter_, drive_file_path)));
     callback.Run(FILE_ERROR_OK, entry.Pass());",
2745,CVE-2013-2878,"  bool SimplifiedBackwardsTextIterator::handleTextNode()
     m_textLength = m_positionEndOffset - m_positionStartOffset;
     m_textCharacters = text.characters() + (m_positionStartOffset - offsetInNode);
     ASSERT(m_textCharacters >= text.characters());
    RELEASE_ASSERT(m_textCharacters + m_textLength <= text.characters() + static_cast<int>(text.length()));
 
     m_lastCharacter = text[m_positionEndOffset - 1];
 ",Google Chrome before 28.0.1500.71 allows remote attackers to cause a denial of service (out-of-bounds read) via vectors related to the handling of text.
2746,,"  void ChangeListLoader::LoadAfterGetAboutResource(
 
   FileError error = GDataToFileError(status);
   if (error != FILE_ERROR_OK) {
    if (directory_fetch_info.empty() || is_initial_load)
      OnChangeListLoadComplete(error);
    else
      OnDirectoryLoadComplete(directory_fetch_info, error);
     return;
   }
 
   DCHECK(about_resource);
 
   int64 remote_changestamp = about_resource->largest_change_id();
   int64 start_changestamp = local_changestamp > 0 ? local_changestamp + 1 : 0;
   if (directory_fetch_info.empty()) {
    if (local_changestamp >= remote_changestamp) {
      if (local_changestamp > remote_changestamp) {
        LOG(WARNING) << ""Local resource metadata is fresher than server, ""
                     << ""local = "" << local_changestamp
                     << "", server = "" << remote_changestamp;
      }

       
      OnChangeListLoadComplete(FILE_ERROR_OK);
      return;
    }

      
      
     LoadChangeListFromServer(start_changestamp);",
2747,CVE-2013-2866,"  void MediaStreamDevicesController::Accept(bool update_content_setting) {
         break;
     }
 
     
     
     
    if (update_content_setting) {
      if ((IsSchemeSecure() && !devices.empty()) ||
          request_.request_type == content::MEDIA_OPEN_DEVICE) {
        SetPermission(true);
      }
    }
   }
 
   scoped_ptr<content::MediaStreamUI> ui;
  bool MediaStreamDevicesController::IsRequestAllowedByDefault() const {
 
     DevicePolicy policy = GetDevicePolicy(device_checks[i].policy_name,
                                           device_checks[i].list_policy_name);

    if (policy == ALWAYS_DENY)
       return false;

    if (policy == POLICY_NOT_SET) {
       
       
      if (!IsSchemeSecure() &&
          request_.request_type != content::MEDIA_OPEN_DEVICE) {
        return false;
      }
      if (profile_->GetHostContentSettingsMap()->GetContentSetting(
              request_.security_origin, request_.security_origin,
              device_checks[i].settings_type, NO_RESOURCE_IDENTIFIER) !=
              CONTENT_SETTING_ALLOW) {
        return false;
      }
     }
      
      ","The Flash plug-in in Google Chrome before 27.0.1453.116, as used on Google Chrome OS before 27.0.1453.116 and separately, does not properly determine whether a user wishes to permit camera or microphone access by a Flash application, which allows remote attackers to obtain sensitive information from a machine's physical environment via a clickjacking attack, as demonstrated by an attack using a crafted Cascading Style Sheets (CSS) opacity property."
2748,,"  class ServiceWorkerVersionBrowserTest : public ServiceWorkerBrowserTest {
     }
   }
 
  void InstallTestHelper(const std::string& worker_url) {
    RunOnIOThread(base::Bind(&self::SetUpRegistrationOnIOThread, this,
                             worker_url));

     
    ServiceWorkerStatusCode status = SERVICE_WORKER_ERROR_FAILED;
    base::RunLoop install_run_loop;
    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                            base::Bind(&self::InstallOnIOThread, this,
                                       install_run_loop.QuitClosure(),
                                       &status));
    install_run_loop.Run();
    ASSERT_EQ(SERVICE_WORKER_OK, status);

     
    status = SERVICE_WORKER_ERROR_FAILED;
    base::RunLoop stop_run_loop;
    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                            base::Bind(&self::StopOnIOThread, this,
                                       stop_run_loop.QuitClosure(),
                                       &status));
    stop_run_loop.Run();
    ASSERT_EQ(SERVICE_WORKER_OK, status);
  }

   void SetUpRegistrationOnIOThread(const std::string& worker_url) {
     const int64 version_id = 1L;
     registration_ = new ServiceWorkerRegistration(
  IN_PROC_BROWSER_TEST_F(ServiceWorkerVersionBrowserTest, StartNotFound) {
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceWorkerVersionBrowserTest, Install) {
  InstallTestHelper(""/service_worker/worker.js"");
}
 
IN_PROC_BROWSER_TEST_F(ServiceWorkerVersionBrowserTest,
                       InstallWithWaitUntil_Fulfilled) {
  InstallTestHelper(""/service_worker/worker_install_fulfilled.js"");
}
 
IN_PROC_BROWSER_TEST_F(ServiceWorkerVersionBrowserTest,
                       InstallWithWaitUntil_Rejected) {
   
   
  InstallTestHelper(""/service_worker/worker_install_rejected.js"");
 }
 
 }   ",
2749,CVE-2013-2854,"  PlatformFileForTransit GetFileHandleForProcess(base::PlatformFile handle,
   DWORD options = DUPLICATE_SAME_ACCESS;
   if (close_source_handle)
     options |= DUPLICATE_CLOSE_SOURCE;
  if (handle == INVALID_HANDLE_VALUE ||
      !::DuplicateHandle(::GetCurrentProcess(),
                          handle,
                          process,
                          &out_handle,","Google Chrome before 27.0.1453.110 on Windows provides an incorrect handle to a renderer process in unspecified circumstances, which allows remote attackers to cause a denial of service or possibly have other impact via unknown vectors."
2750,CVE-2013-2855,"  class Storage;
 
 struct EventListenerInfo;
 
 
 
 
 

 class InjectedScriptHost : public RefCounted<InjectedScriptHost>, public ScriptWrappable {
 public:
     static PassRefPtr<InjectedScriptHost> create();",The Developer Tools API in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors.
2751,CVE-2013-2856,"  int UDPSocketLibevent::InternalConnect(const IPEndPoint& address) {
    
 
   if (rv < 0) {
    UMA_HISTOGRAM_SPARSE_SLOWLY(""Net.UdpSocketRandomBindErrorCode"", -rv);
     Close();
     return rv;
   }
  int UDPSocketLibevent::DoBind(const IPEndPoint& address) {
     return OK;
   int last_error = errno;
   UMA_HISTOGRAM_SPARSE_SLOWLY(""Net.UdpSocketBindErrorFromPosix"", last_error);
#if defined(OS_CHROMEOS)
  if (last_error == EINVAL)
    return ERR_ADDRESS_IN_USE;
#elif defined(OS_MACOSX)
  if (last_error == EADDRNOTAVAIL)
    return ERR_ADDRESS_IN_USE;
#endif
   return MapSystemError(last_error);
 }
 ",Use-after-free vulnerability in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of input.
2752,CVE-2013-2858,"  void IOThread::RegisterPrefs(PrefRegistrySimple* registry) {
       prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled);
   registry->RegisterListPref(
       prefs::kDailyContentLengthWithDataReductionProxyEnabled);
  registry->RegisterListPref(
      prefs::kDailyContentLengthHttpsWithDataReductionProxyEnabled);
  registry->RegisterListPref(
      prefs::kDailyContentLengthShortBypassWithDataReductionProxyEnabled);
  registry->RegisterListPref(
      prefs::kDailyContentLengthLongBypassWithDataReductionProxyEnabled);
  registry->RegisterListPref(
      prefs::kDailyContentLengthUnknownWithDataReductionProxyEnabled);
   registry->RegisterListPref(
       prefs::kDailyOriginalContentLengthViaDataReductionProxy);
   registry->RegisterListPref(",Use-after-free vulnerability in the HTML5 Audio implementation in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2753,CVE-2013-2860," 
 
 #include ""chrome/browser/net/client_hints.h""
 
#include <locale.h>

 #include ""base/logging.h""
 #include ""testing/gtest/include/gtest/gtest.h""
 
 class ClientHintsTest : public testing::Test {
  TEST_F(ClientHintsTest, HintsWellFormatted) {
 }
 
 TEST_F(ClientHintsTest, HintsWellFormattedWithNonEnLocale) {
  setlocale(LC_ALL, ""fr_FR.UTF-8"");
   UpdateScreenInfo(1.567f);
   std::string hint = client_hints_.GetDevicePixelRatioHeader();
   EXPECT_EQ(""1.57"", hint);",Use-after-free vulnerability in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving access to a database API by a worker process.
2754,CVE-2013-2861,"  void AppListController::Init(Profile* initial_profile) {
         ShowAppListDuringModeSwitch(initial_profile);
   }
 
   
   
#if defined(GOOGLE_CHROME_BUILD)
  if (!InstallUtil::IsChromeSxSProcess() &&
      !chrome_launcher_support::GetAnyAppHostPath().empty()) {
    chrome_launcher_support::InstallationState state =
        chrome_launcher_support::GetAppLauncherInstallationState();
    if (state == chrome_launcher_support::NOT_INSTALLED) {
       
       
      return;
    } else if (state == chrome_launcher_support::INSTALLED_AT_SYSTEM_LEVEL) {
      chrome_launcher_support::UninstallLegacyAppLauncher(
          chrome_launcher_support::SYSTEM_LEVEL_INSTALLATION);
    } else if (state == chrome_launcher_support::INSTALLED_AT_USER_LEVEL) {
      chrome_launcher_support::UninstallLegacyAppLauncher(
          chrome_launcher_support::USER_LEVEL_INSTALLATION);
    }
    EnableAppList();
  }
#endif

    
   AppListController::GetInstance();
 
  void AppListController::EnableAppList() {
    
    
   PrefService* local_state = g_browser_process->local_state();
  local_state->SetBoolean(apps::prefs::kAppLauncherHasBeenEnabled, true);
  ShellIntegration::ShortcutLocations shortcut_locations;
  shortcut_locations.on_desktop = true;
  shortcut_locations.in_quick_launch_bar = true;
  shortcut_locations.in_applications_menu = true;
  BrowserDistribution* dist = BrowserDistribution::GetDistribution();
  shortcut_locations.applications_menu_subdir = dist->GetAppShortCutName();
  base::FilePath user_data_dir(
      g_browser_process->profile_manager()->user_data_dir());

  content::BrowserThread::PostTask(
      content::BrowserThread::FILE,
      FROM_HERE,
      base::Bind(&CreateAppListShortcuts,
                  user_data_dir, GetAppModelId(), shortcut_locations));
 }
 
 void AppListController::DisableAppList() {",Use-after-free vulnerability in the SVG implementation in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2755,CVE-2013-2862,"  class HostProcess
   void CreateAuthenticatorFactory() {
     DCHECK(context_->network_task_runner()->BelongsToCurrentThread());
 
    if (!host_ || shutting_down_)
      return;

     std::string local_certificate = key_pair_.GenerateCertificate();
     if (local_certificate.empty()) {
       LOG(ERROR) << ""Failed to generate host certificate."";","Skia, as used in Google Chrome before 27.0.1453.110, does not properly handle GPU acceleration, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors."
2756,CVE-2013-2863,"  void SSLClientSocketNSS::Core::OnSendComplete(int result) {
   int rv_write = ERR_IO_PENDING;
   bool network_moved;
   do {
    if (user_read_buf_)
      rv_read = DoPayloadRead();
    if (user_write_buf_)
      rv_write = DoPayloadWrite();
    network_moved = DoTransportIO();
   } while (rv_read == ERR_IO_PENDING &&
            rv_write == ERR_IO_PENDING &&
            (user_read_buf_ || user_write_buf_) &&
            network_moved);
 
   
   
   
   
   
  scoped_refptr<Core> guard(this);
   if (user_read_buf_ && rv_read != ERR_IO_PENDING)
    DoReadCallback(rv_read);

  if (OnNetworkTaskRunner() && detached_)
    return;

   if (user_write_buf_ && rv_write != ERR_IO_PENDING)
    DoWriteCallback(rv_write);
 }
 
  ","Google Chrome before 27.0.1453.110 does not properly handle SSL sockets, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via unspecified vectors."
2757,CVE-2013-2865,"  class FillLayout : public aura::LayoutManager {
   }
 
   virtual void OnWindowAddedToLayout(aura::Window* child) OVERRIDE {
    child->SetBounds(root_->window()->bounds());
   }
 
   virtual void OnWillRemoveWindowFromLayout(aura::Window* child) OVERRIDE {",Multiple unspecified vulnerabilities in Google Chrome before 27.0.1453.110 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2758,CVE-2013-0879," 
 
 
 

#include ""chrome/browser/extensions/api/dial/dial_api.h""

#include <vector>

#include ""chrome/browser/extensions/api/dial/dial_api_factory.h""
#include ""chrome/browser/extensions/event_names.h""
#include ""chrome/browser/extensions/event_router.h""
#include ""chrome/browser/extensions/extension_system.h""
#include ""chrome/browser/profiles/profile.h""
#include ""chrome/common/extensions/api/dial.h""
#include ""content/public/browser/browser_thread.h""

namespace {

const char kDialServiceError[] = ""Dial service error."";

}   

namespace extensions {

DialAPI::DialAPI(Profile* profile)
    : RefcountedProfileKeyedService(content::BrowserThread::IO),
      profile_(profile) {
  ExtensionSystem::Get(profile)->event_router()->RegisterObserver(
      this, extensions::event_names::kOnDialDeviceList);
}

DialAPI::~DialAPI() {}

DialRegistry* DialAPI::dial_registry() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  if (!dial_registry_.get()) {
    dial_registry_.reset(new DialRegistry(this));
  }
  return dial_registry_.get();
}

void DialAPI::OnListenerAdded(const EventListenerInfo& details) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&DialAPI::NotifyListenerAddedOnIOThread, this));
}

void DialAPI::OnListenerRemoved(const EventListenerInfo& details) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  BrowserThread::PostTask(
      BrowserThread::IO, FROM_HERE,
      base::Bind(&DialAPI::NotifyListenerRemovedOnIOThread, this));
}

void DialAPI::NotifyListenerAddedOnIOThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  DVLOG(1) << ""DIAL device event listener added."";
  dial_registry()->OnListenerAdded();
}

void DialAPI::NotifyListenerRemovedOnIOThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  DVLOG(1) << ""DIAL device event listener removed"";
  dial_registry()->OnListenerRemoved();
}

void DialAPI::OnDialDeviceEvent(const DialRegistry::DeviceList& devices) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
      base::Bind(&DialAPI::SendEventOnUIThread, this, devices));
}

void DialAPI::SendEventOnUIThread(const DialRegistry::DeviceList& devices) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  std::vector<linked_ptr<api::dial::DialDevice> > args;
  for (DialRegistry::DeviceList::const_iterator it = devices.begin();
       it != devices.end(); ++it) {
    linked_ptr<api::dial::DialDevice> api_device =
        make_linked_ptr(new api::dial::DialDevice);
    it->FillDialDevice(api_device.get());
    args.push_back(api_device);
  }
  scoped_ptr<base::ListValue> results = api::dial::OnDeviceList::Create(args);

  scoped_ptr<Event> event(
      new Event(event_names::kOnDialDeviceList, results.Pass()));

  extensions::ExtensionSystem::Get(profile_)->event_router()->
      BroadcastEvent(event.Pass());
}

void DialAPI::ShutdownOnUIThread() {}

namespace api {

DialDiscoverNowFunction::DialDiscoverNowFunction()
    : dial_(NULL), result_(false) {
}

bool DialDiscoverNowFunction::Prepare() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  DCHECK(profile());
  dial_ = DialAPIFactory::GetInstance()->GetForProfile(profile());
  return true;
}

void DialDiscoverNowFunction::Work() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  result_ = dial_->dial_registry()->DiscoverNow();
}

bool DialDiscoverNowFunction::Respond() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
  if (!result_)
    error_ = kDialServiceError;

  SetResult(base::Value::CreateBooleanValue(result_));
  return true;
}

}   

}   ","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly implement web audio nodes, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors."
2759,CVE-2013-0880,"  void PPB_Buffer_Proxy::OnMsgCreate(
   HostDispatcher* dispatcher = HostDispatcher::GetForInstance(instance);
   if (!dispatcher)
     return;
  if (!dispatcher->permissions().HasPermission(ppapi::PERMISSION_DEV))
    return;
 
   thunk::EnterResourceCreation enter(instance);
   if (enter.failed())","Use-after-free vulnerability in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to databases."
2760,CVE-2013-0882,"  bool HTMLButtonElement::isInteractiveContent() const
     return true;
 }
 
bool HTMLButtonElement::supportsAutofocus() const
{
    return true;
}

 }  ","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service (incorrect memory access) or possibly have unspecified other impact via a large number of SVG parameters."
2761,CVE-2013-0884,"  void InspectorController::initializeDeferredAgents()
     InjectedScriptManager* injectedScriptManager = m_injectedScriptManager.get();
     InspectorOverlay* overlay = m_overlay.get();
 
    OwnPtr<InspectorResourceAgent> resourceAgentPtr(InspectorResourceAgent::create(m_pageAgent));
     InspectorResourceAgent* resourceAgent = resourceAgentPtr.get();
     m_agents.append(resourceAgentPtr.release());
 ","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly load Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
2762,CVE-2013-0885,"  bool ExtensionFunctionDispatcher::CheckPermissions(
   return true;
 }
 
namespace {

 
 
 
 
 
 
bool AllowHostedAppAPICall(const Extension& extension,
                           const GURL& source_url,
                           const std::string& function_name) {
  if (extension.location() != extensions::Manifest::COMPONENT)
    return false;

  if (!extension.web_extent().MatchesURL(source_url))
    return false;

   
  scoped_refptr<const extensions::PermissionSet> permissions =
      extension.GetActivePermissions();
  return (permissions->HasAccessToFunction(function_name, false) ||
          StartsWithASCII(function_name, ""test."", true  ));
}

}   


  
 ExtensionFunction* ExtensionFunctionDispatcher::CreateExtensionFunction(
     const ExtensionHostMsg_Request_Params& params,
  ExtensionFunction* ExtensionFunctionDispatcher::CreateExtensionFunction(
     return NULL;
   }
 
   
  bool allowed = true;
  if (extension->is_hosted_app())
      allowed = AllowHostedAppAPICall(*extension, params.source_url,
                                      params.name);

   
   
  if (allowed && api->IsPrivileged(params.name))
    allowed = process_map.Contains(extension->id(), requesting_process_id);

  if (!allowed) {
    LOG(ERROR) << ""Extension API call disallowed - name:"" << params.name
               << "" pid:"" << requesting_process_id
                << "" from URL "" << params.source_url.spec();
     SendAccessDenied(ipc_sender, routing_id, params.request_id);
     return NULL;","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly restrict API privileges during interaction with the Chrome Web Store, which has unspecified impact and attack vectors."
2763,CVE-2013-0886,"  void BrowserPluginGuest::SetCompositingBufferData(int gpu_process_id,
   surface_handle_ = gfx::GLSurfaceHandle(gfx::kNullPluginWindow, true);
   surface_handle_.parent_gpu_process_id = gpu_process_id;
   surface_handle_.parent_client_id = client_id;
 }
 
 bool BrowserPluginGuest::InAutoSizeBounds(const gfx::Size& size) const {","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
2764,CVE-2013-0889,"  bool ChromeDownloadManagerDelegate::IsDangerousFile(
     bool visited_referrer_before) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
    
    
    
  bool ChromeDownloadManagerDelegate::IsDangerousFile(
    
   download_util::DownloadDangerLevel danger_level =
       download_util::GetFileDangerLevel(suggested_path.BaseName());
  if (danger_level == download_util::AllowOnUserGesture) {
    if (download.GetTransitionType() &
            content::PAGE_TRANSITION_FROM_ADDRESS_BAR) {
      return false;
    }
     return !download.HasUserGesture() || !visited_referrer_before;
  }
 
   return danger_level == download_util::Dangerous;
 }","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly enforce a user gesture requirement before proceeding with a file download, which might make it easier for remote attackers to execute arbitrary code via a crafted file."
2765,CVE-2013-0890,"  void SafeBrowsingBlockingPage::CommandReceived(const std::string& cmd) {
 
    
    
  size_t element_index = 0;
   size_t colon_index = command.find(':');
   if (colon_index != std::string::npos) {
     DCHECK(colon_index < command.size() - 1);
    int result_int = 0;
     bool result = base::StringToInt(base::StringPiece(command.begin() +
                                                       colon_index + 1,
                                                       command.end()),
                                    &result_int);
     command = command.substr(0, colon_index);
    if (result)
      element_index = static_cast<size_t>(result_int);
   }
 
  if (element_index >= unsafe_resources_.size()) {
     NOTREACHED();
     return;
   }","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service (memory corruption) or possibly have other impact via unknown vectors."
2766,CVE-2013-0891," 
 
 #include ""webkit/blob/blob_url_request_job.h""
 
#include <limits>

 #include ""base/bind.h""
 #include ""base/compiler_specific.h""
 #include ""base/files/file_util_proxy.h""
  const char kHTTPRequestedRangeNotSatisfiableText[] =
     ""Requested Range Not Satisfiable"";
 const char kHTTPInternalErrorText[] = ""Internal Server Error"";
 
const int64 kMaxTotalSize = std::numeric_limits<int64>::max();

 bool IsFileType(BlobData::Item::Type type) {
   switch (type) {
     case BlobData::Item::TYPE_FILE:
  void BlobURLRequestJob::DidStart() {
   CountSize();
 }
 
bool BlobURLRequestJob::AddItemLength(size_t index, int64 item_length) {
  if (item_length > kMaxTotalSize - total_size_) {
    NotifyFailure(net::ERR_FAILED);
    return false;
  }

   
  DCHECK_LT(index, item_length_list_.size());
  item_length_list_[index] = item_length;
  total_size_ += item_length;
  return true;
}

 void BlobURLRequestJob::CountSize() {
   error_ = false;
   pending_get_file_info_count_ = 0;
  void BlobURLRequestJob::CountSize() {
                      weak_factory_.GetWeakPtr(), i));
       continue;
     }

    if (!AddItemLength(i, item.length()))
      return;
   }
 
   if (pending_get_file_info_count_ == 0)
  void BlobURLRequestJob::DidGetFileItemLength(size_t index, int64 result) {
   const BlobData::Item& item = blob_data_->items().at(index);
   DCHECK(IsFileType(item.type()));
 
  uint64 file_length = result;
  uint64 item_offset = item.offset();
  uint64 item_length = item.length();

  if (item_offset > file_length) {
    NotifyFailure(net::ERR_FILE_NOT_FOUND);
    return;
  }

  uint64 max_length = file_length - item_offset;

    
    
  if (item_length == static_cast<uint64>(-1)) {
    item_length = max_length;
  } else if (item_length > max_length) {
    NotifyFailure(net::ERR_FILE_NOT_FOUND);
    return;
  }
 
  if (!AddItemLength(index, item_length))
    return;
 
   if (--pending_get_file_info_count_ == 0)
     DidCountSize(net::OK);
  int BlobURLRequestJob::BytesReadCompleted() {
 }
 
 int BlobURLRequestJob::ComputeBytesToRead() const {
  int64 current_item_length = item_length_list_[current_item_index_];

  int64 item_remaining = current_item_length - current_item_offset_;
  int64 buf_remaining = read_buf_->BytesRemaining();
  int64 max_remaining = std::numeric_limits<int>::max();

  int64 min = std::min(std::min(std::min(item_remaining,
                                         buf_remaining),
                                         remaining_bytes_),
                                         max_remaining);

  return static_cast<int>(min);
 }
 
 bool BlobURLRequestJob::ReadLoop(int* bytes_read) {","Integer overflow in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a blob."
2767,CVE-2013-0892,"  void SavePackage::OnReceivedSavableResourceLinksForCurrentPage(
   if (wait_state_ != RESOURCES_LIST)
     return;
 
  if (resources_list.size() != referrers_list.size())
    return;

   all_save_items_count_ = static_cast<int>(resources_list.size()) +
                            static_cast<int>(frames_list.size());
 ","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service or possibly have other impact via unknown vectors."
2768,CVE-2013-0892,"  namespace {
  
  
 const int kMaxMenuDepth = 2;
const uint32_t kMaxMenuEntries = 1000;
 
 bool CheckMenu(int depth, const PP_Flash_Menu* menu);
 void FreeMenu(const PP_Flash_Menu* menu);
  PP_Flash_Menu* ReadMenu(int depth,
   if (menu->count == 0)
     return menu;
 
  if (menu->count > kMaxMenuEntries) {
    FreeMenu(menu);
    return NULL;
  }

   menu->items = new PP_Flash_MenuItem[menu->count];
   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);
   for (uint32_t i = 0; i < menu->count; ++i) {","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service or possibly have other impact via unknown vectors."
2769,CVE-2013-0892,"  InspectorAgentRegistry::InspectorAgentRegistry(InstrumentingAgents* instrumentin
 {
 }
 
bool InspectorAgentRegistry::hasAgent(const String& name)
{
    for (size_t i = 0; i < m_agents.size(); i++) {
        if (m_agents[i]->name() == name)
            return true;
    }
    return false;
}

 void InspectorAgentRegistry::append(PassOwnPtr<InspectorAgent> agent)
 {
     agent->appended(m_instrumentingAgents, m_inspectorState->createAgentState(agent->name()));","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service or possibly have other impact via unknown vectors."
2770,CVE-2013-0892,"  void GpuCommandBufferStub::OnRescheduled() {
     ReportState();
 }
 
void GpuCommandBufferStub::OnCreateTransferBuffer(uint32 size,
                                                   int32 id_request,
                                                   IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnCreateTransferBuffer"");
  void GpuCommandBufferStub::OnCreateTransferBuffer(int32 size,
 
 void GpuCommandBufferStub::OnRegisterTransferBuffer(
     base::SharedMemoryHandle transfer_buffer,
    uint32 size,
     int32 id_request,
     IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnRegisterTransferBuffer"");","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service or possibly have other impact via unknown vectors."
2771,CVE-2013-0895,"  bool CopyDirectory(const FilePath& from_path,
   DCHECK(recursive || S_ISDIR(info.stat.st_mode));
 
   while (success && !current.empty()) {
     
     
    FilePath target_path(to_path);
    if (from_path_base != current) {
      if (!from_path_base.AppendRelativePath(current, &target_path)) {
        success = false;
        break;
      }
     }
 
     if (S_ISDIR(info.stat.st_mode)) {
       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&","Google Chrome before 25.0.1364.97 on Linux, and before 25.0.1364.99 on Mac OS X, does not properly handle pathnames during copy operations, which might make it easier for remote attackers to execute arbitrary programs via unspecified vectors."
2772,CVE-2013-0896,"  class TestConnectionHelper : public QuicConnectionHelper {
 class QuicConnectionHelperTest : public ::testing::Test {
  protected:
   QuicConnectionHelperTest()
      : guid_(0),
        framer_(QuicDecrypter::Create(kNULL), QuicEncrypter::Create(kNULL)),
         creator_(guid_, &framer_),
         net_log_(BoundNetLog()),
         scheduler_(new MockScheduler()),
  class QuicConnectionHelperTest : public ::testing::Test {
 
   QuicPacket* ConstructDataPacket(QuicPacketSequenceNumber number,
                                   QuicFecGroupNumber fec_group) {
    header_.guid = guid_;
     header_.packet_sequence_number = number;
    header_.transmission_time = 0;
    header_.retransmission_count = 0;
     header_.flags = PACKET_FLAGS_NONE;
     header_.fec_group = fec_group;
 ","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly manage memory during message handling for plug-ins, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
2773,CVE-2013-0917,"  namespace {
 
 class CreateFileHelper FINAL : public AsyncFileSystemCallbacks {
 public:
    class CreateFileResult : public GarbageCollectedFinalized<CreateFileResult> {
       public:
        static CreateFileResult* create()
         {
            return new CreateFileResult();
         }
 
         bool m_failed;
  class CreateFileHelper FINAL : public AsyncFileSystemCallbacks {
             , m_code(0)
         {
         }
     };
 
    static PassOwnPtr<AsyncFileSystemCallbacks> create(CreateFileResult* result, const String& name, const KURL& url, FileSystemType type)
     {
         return adoptPtr(static_cast<AsyncFileSystemCallbacks*>(new CreateFileHelper(result, name, url, type)));
     }
  class CreateFileHelper FINAL : public AsyncFileSystemCallbacks {
     }
 
 private:
    CreateFileHelper(CreateFileResult* result, const String& name, const KURL& url, FileSystemType type)
         : m_result(result)
         , m_name(name)
         , m_url(url)
         , m_type(type)
     {
     }
 
    Persistent<CreateFileResult> m_result;
     String m_name;
     KURL m_url;
     FileSystemType m_type;
  class CreateFileHelper FINAL : public AsyncFileSystemCallbacks {
 PassRefPtrWillBeRawPtr<File> DOMFileSystemSync::createFile(const FileEntrySync* fileEntry, ExceptionState& exceptionState)
 {
     KURL fileSystemURL = createFileSystemURL(fileEntry);
    CreateFileHelper::CreateFileResult* result(CreateFileHelper::CreateFileResult::create());
     fileSystem()->createSnapshotFileAndReadMetadata(fileSystemURL, CreateFileHelper::create(result, fileEntry->name(), fileSystemURL, type()));
     if (result->m_failed) {
         exceptionState.throwDOMException(result->m_code, ""Could not create '"" + fileEntry->name() + ""'."");",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
2774,CVE-2013-0918," 
 #include ""chrome/common/chrome_notification_types.h""
 #include ""chrome/common/chrome_paths.h""
 #include ""chrome/common/chrome_switches.h""
#include ""chrome/common/url_constants.h""
 #include ""chrome/test/base/in_process_browser_test.h""
 #include ""chrome/test/base/ui_test_utils.h""
 #include ""content/public/browser/child_process_data.h""
  IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestConsoleOnNavigateBack) {
   RunTest(""testConsoleOnNavigateBack"", kNavigateBackTestPage);
 }
 

 
 
IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestDevToolsExternalNavigation) {
  OpenDevToolsWindow(kDebuggerTestPage);
  GURL url = test_server()->GetURL(kNavigateBackTestPage);
  content::WindowedNotificationObserver observer(
      content::NOTIFICATION_LOAD_STOP,
      content::NotificationService::AllSources());
  ASSERT_TRUE(content::ExecuteScript(
      window_->web_contents(),
      std::string(""window.location = \"""") + url.spec() + ""\""""));
  observer.Wait();

  ASSERT_TRUE(window_->web_contents()->GetURL().
                  SchemeIs(chrome::kChromeDevToolsScheme));
  ASSERT_EQ(GetInspectedTab()->GetURL(), url);
}

  
  
 IN_PROC_BROWSER_TEST_F(DevToolsSanityTest, TestReattachAfterCrash) {","Google Chrome before 26.0.1410.43 does not prevent navigation to developer tools in response to a drag-and-drop operation, which allows user-assisted remote attackers to have an unspecified impact via a crafted web site."
2775,CVE-2013-0919,"  class ActionBoxTest : public InProcessBrowserTest,
       case content::NOTIFICATION_WEB_CONTENTS_DESTROYED:
       case chrome::NOTIFICATION_TAB_PARENTED:
       case chrome::NOTIFICATION_AUTOCOMPLETE_CONTROLLER_RESULT_READY:
       case chrome::NOTIFICATION_HISTORY_LOADED:
       case chrome::NOTIFICATION_HISTORY_URLS_MODIFIED:
       case chrome::NOTIFICATION_TEMPLATE_URL_SERVICE_LOADED:",Use-after-free vulnerability in Google Chrome before 26.0.1410.43 on Linux allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging the presence of an extension that creates a pop-up window.
2776,CVE-2013-0920,"  void BookmarksIOFunction::SelectFile(ui::SelectFileDialog::Type type) {
 void BookmarksIOFunction::ShowSelectFileDialog(
     ui::SelectFileDialog::Type type,
     const base::FilePath& default_path) {
  if (!dispatcher())
    return;   

    
    
   AddRef();",Use-after-free vulnerability in the extension bookmarks API in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2777,CVE-2013-0921,"  void ChromeContentBrowserClient::SiteInstanceDeleting(
 }
 
 bool ChromeContentBrowserClient::ShouldSwapProcessesForNavigation(
    SiteInstance* site_instance,
     const GURL& current_url,
     const GURL& new_url) {
   if (current_url.is_empty()) {
  bool ChromeContentBrowserClient::ShouldSwapProcessesForNavigation(
       return true;
   }
 
   
   
  Profile* profile =
      Profile::FromBrowserContext(site_instance->GetBrowserContext());
  ExtensionService* service =
      extensions::ExtensionSystem::Get(profile)->extension_service();
  if (!service)
    return false;

   
   
  const Extension* new_extension =
      service->extensions()->GetExtensionOrAppByURL(ExtensionURLInfo(new_url));
   
   
  if (new_extension &&
      new_extension->is_hosted_app() &&
      new_extension->id() != extension_misc::kWebStoreAppId)
    new_extension = NULL;
  if (new_extension &&
      site_instance->HasProcess() &&
      !service->process_map()->Contains(new_extension->id(),
                                        site_instance->GetProcess()->GetID()))
    return true;

   return false;
 }
 ","The Isolated Sites feature in Google Chrome before 26.0.1410.43 does not properly enforce the use of separate processes, which makes it easier for remote attackers to bypass intended access restrictions via a crafted web site."
2778,CVE-2013-0922,"  IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest, NoLoginPromptForFavicon) {
 }
 
  
 
IN_PROC_BROWSER_TEST_F(LoginPromptBrowserTest,
                       DISABLED_BlockCrossdomainPrompt) {
   const char* kTestPage = ""files/login/load_img_from_b.html"";
 
   host_resolver()->AddRule(""www.a.com"", ""127.0.0.1"");","Google Chrome before 26.0.1410.43 does not properly restrict brute-force access attempts against web sites that require HTTP Basic Authentication, which has unspecified impact and attack vectors."
2779,CVE-2013-0924," 
 
 #include ""base/memory/scoped_ptr.h""
 #include ""chrome/browser/extensions/api/permissions/permissions_api_helpers.h""
#include ""chrome/browser/extensions/extension_prefs.h""
#include ""chrome/browser/extensions/extension_system.h""
 #include ""chrome/browser/extensions/permissions_updater.h""
 #include ""chrome/browser/profiles/profile.h""
 #include ""chrome/common/chrome_notification_types.h""
  using extensions::api::permissions::Permissions;
 using extensions::APIPermission;
 using extensions::APIPermissionSet;
 using extensions::ErrorUtils;
using extensions::ExtensionPrefs;
using extensions::ExtensionSystem;
 using extensions::PermissionSet;
 using extensions::PermissionsInfo;
 using extensions::PermissionsUpdater;
  bool ignore_user_gesture_for_tests = false;
 
 bool PermissionsContainsFunction::RunImpl() {
   scoped_ptr<Contains::Params> params(Contains::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params);
 
  ExtensionPrefs* prefs = ExtensionSystem::Get(profile_)->extension_prefs();
   scoped_refptr<PermissionSet> permissions =
      helpers::UnpackPermissionSet(params->permissions,
                                   prefs->AllowFileAccess(extension_->id()),
                                   &error_);
   if (!permissions.get())
     return false;
 
  bool PermissionsGetAllFunction::RunImpl() {
 
 bool PermissionsRemoveFunction::RunImpl() {
   scoped_ptr<Remove::Params> params(Remove::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params);
 
  ExtensionPrefs* prefs = ExtensionSystem::Get(profile_)->extension_prefs();
   scoped_refptr<PermissionSet> permissions =
      helpers::UnpackPermissionSet(params->permissions,
                                   prefs->AllowFileAccess(extension_->id()),
                                   &error_);
   if (!permissions.get())
     return false;
 
  void PermissionsRequestFunction::InstallUIProceed() {
 }
 
 void PermissionsRequestFunction::InstallUIAbort(bool user_initiated) {
   SendResponse(true);
 
   Release();   
  void PermissionsRequestFunction::InstallUIAbort(bool user_initiated) {
 PermissionsRequestFunction::~PermissionsRequestFunction() {}
 
 bool PermissionsRequestFunction::RunImpl() {
  results_ = Request::Results::Create(false);

   if (!user_gesture() && !ignore_user_gesture_for_tests) {
     error_ = kUserGestureRequiredError;
     return false;
  bool PermissionsRequestFunction::RunImpl() {
   scoped_ptr<Request::Params> params(Request::Params::Create(*args_));
   EXTENSION_FUNCTION_VALIDATE(params.get());
 
  ExtensionPrefs* prefs = ExtensionSystem::Get(profile_)->extension_prefs();

   requested_permissions_ =
      helpers::UnpackPermissionSet(params->permissions,
                                   prefs->AllowFileAccess(extension_->id()),
                                   &error_);
   if (!requested_permissions_.get())
     return false;
 
    
   APIPermissionSet apis = requested_permissions_->apis();
   for (APIPermissionSet::const_iterator i = apis.begin();","The extension functionality in Google Chrome before 26.0.1410.43 does not verify that use of the permissions API is consistent with file permissions, which has unspecified impact and attack vectors."
2780,CVE-2013-0925,"  void MessageService::OpenChannelToExtension(
   std::string tab_json = ""null"";
   if (source_contents) {
     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(
        source_contents));
     base::JSONWriter::Write(tab_value.get(), &tab_json);
   }
 
  void MessageService::OpenChannelToNativeApp(
   std::string tab_json = ""null"";
   if (source_contents) {
     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(
        source_contents));
     base::JSONWriter::Write(tab_value.get(), &tab_json);
   }
 
  void MessageService::OpenChannelToTab(
   std::string tab_json = ""null"";
   if (source_contents) {
     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(
        source_contents));
     base::JSONWriter::Write(tab_value.get(), &tab_json);
   }
 ","Google Chrome before 26.0.1410.43 does not ensure that an extension has the tabs (aka APIPermission::kTab) permission before providing a URL to this extension, which has unspecified impact and remote attack vectors."
2781,CVE-2013-0926,"  void WebPreferences::Apply(WebView* web_view) const {
   settings->setDeferredImageDecodingEnabled(deferred_image_decoding_enabled);
   settings->setShouldRespectImageOrientation(should_respect_image_orientation);
 
  settings->setUnsafePluginPastingEnabled(false);
   settings->setEditingBehavior(
       static_cast<WebSettings::EditingBehavior>(editing_behavior));
 ","Google Chrome before 26.0.1410.43 does not properly handle active content in an EMBED element during a copy-and-paste operation, which allows user-assisted remote attackers to have an unspecified impact via a crafted web site."
2782,CVE-2013-0903,"  void SavePackage::OnReceivedSavableResourceLinksForCurrentPage(
   if (wait_state_ != RESOURCES_LIST)
     return;
 
  if (resources_list.size() != referrers_list.size())
    return;

   all_save_items_count_ = static_cast<int>(resources_list.size()) +
                            static_cast<int>(frames_list.size());
 ",Use-after-free vulnerability in Google Chrome before 25.0.1364.152 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of browser navigation.
2783,CVE-2013-0904,"  namespace blink {
 class WebArrayBuffer;
 class WebString;
 
 enum WebCryptoErrorType {
     WebCryptoErrorTypeType,
     WebCryptoErrorTypeNotSupported,",The Web Audio implementation in Google Chrome before 25.0.1364.152 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors.
2784,CVE-2013-0904,"  void SimplifyMarkupCommand::doApply()
             }
 
             unsigned context;
            if (currentNode->renderStyle()->visualInvalidationDiff(*startingStyle, context).hasNoChange() && !context)
                 topNodeWithStartingStyle = currentNode;
 
         }",The Web Audio implementation in Google Chrome before 25.0.1364.152 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors.
2785,CVE-2013-0909,"  int ShellBrowserMain(const content::MainFunctionParams& parameters) {
     std::cout.flush();
 #endif
 
    FilePath original_cwd;
    {
       
      base::ThreadRestrictions::ScopedAllowIO allow_io;
      file_util::GetCurrentDirectory(&original_cwd);
    }

     while (GetNextTest(args, &command_line_position, &test_string)) {
       if (test_string.empty())
         continue;
  int ShellBrowserMain(const content::MainFunctionParams& parameters) {
       ran_at_least_once = true;
       main_runner_->Run();
 
      {
         
        base::ThreadRestrictions::ScopedAllowIO allow_io;
        file_util::SetCurrentDirectory(original_cwd);
      }

       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())
         break;
     }",The XSS Auditor in Google Chrome before 25.0.1364.152 allows remote attackers to obtain sensitive HTTP Referer information via unspecified vectors.
2786,CVE-2013-0910,"  void ChromePluginServiceFilter::UnrestrictPlugin(
   restricted_plugins_.erase(plugin_path);
 }
 
bool ChromePluginServiceFilter::IsPluginAvailable(
     int render_process_id,
     int render_view_id,
     const void* context,
  bool ChromePluginServiceFilter::IsPluginEnabled(
            details->overridden_plugins[i].url.is_empty())) {
 
         bool use = details->overridden_plugins[i].plugin.path == plugin->path;
        if (use)
          *plugin = details->overridden_plugins[i].plugin;
        return use;
       }
     }
   }","Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in."
2787,CVE-2013-0911,"  void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));

  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
    BadMessageReceived();
    return;
  }

   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
  void DatabaseMessageFilter::OnHandleSqliteError(
     const string16& database_name,
     int error) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
  if (!DatabaseUtil::IsValidOriginIdentifier(origin_identifier)) {
    RecordAction(UserMetricsAction(""BadMessageTerminate_DBMF""));
    BadMessageReceived();
    return;
  }

   db_tracker_->HandleSqliteError(origin_identifier, database_name, error);
 }
 ",Directory traversal vulnerability in Google Chrome before 25.0.1364.152 allows remote attackers to have an unspecified impact via vectors related to databases.
2788,,"  bool RenderViewImpl::isPointerLocked() {
 }
 
 void RenderViewImpl::didActivateCompositor(int input_handler_identifier) {
#if !defined(OS_WIN)   
   CompositorThread* compositor_thread =
       RenderThreadImpl::current()->compositor_thread();
   if (compositor_thread)
     compositor_thread->AddInputHandler(
         routing_id_, input_handler_identifier, AsWeakPtr());
#endif
 
   RenderWidget::didActivateCompositor(input_handler_identifier);
 ",
2789,,"  Player* DocumentTimeline::createPlayer(TimedItem* child)
 Player* DocumentTimeline::play(TimedItem* child)
 {
     Player* player = createPlayer(child);
    player->setStartTime(currentTime(), false);
     return player;
 }
 ",
2790,CVE-2013-0839,"  void GDataFileSystem::OnGetDocumentEntry(const FilePath& cache_file_path,
   if (error == GDATA_FILE_OK) {
     scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::ExtractAndParse(*data));
     if (doc_entry.get()) {
      fresh_entry.reset(directory_service_->FromDocumentEntry(doc_entry.get()));
     }
     if (!fresh_entry.get() || !fresh_entry->AsGDataFile()) {
       LOG(ERROR) << ""Got invalid entry from server for "" << params.resource_id;
  void GDataFileSystem::OnSearch(const SearchCallback& callback,
    
   for (size_t i = 0; i < feed->entries().size(); ++i) {
     DocumentEntry* doc = const_cast<DocumentEntry*>(feed->entries()[i]);
    scoped_ptr<GDataEntry> entry(directory_service_->FromDocumentEntry(doc));
 
     if (!entry.get())
       continue;
  void GDataFileSystem::OnCopyDocumentCompleted(
     return;
   }
 
  GDataEntry* entry = directory_service_->FromDocumentEntry(doc_entry.get());
   if (!entry) {
     callback.Run(GDATA_FILE_ERROR_FAILED);
     return;
  GDataFileError GDataFileSystem::AddNewDirectory(
   if (!parent_dir)
     return GDATA_FILE_ERROR_FAILED;
 
  GDataEntry* new_entry =
      directory_service_->FromDocumentEntry(doc_entry.get());
   if (!new_entry)
     return GDATA_FILE_ERROR_FAILED;
 
  void GDataFileSystem::AddUploadedFileOnUIThread(
     return;
 
   scoped_ptr<GDataEntry> new_entry(
      directory_service_->FromDocumentEntry(entry.get()));
   if (!new_entry.get())
     return;
 ",Use-after-free vulnerability in Google Chrome before 24.0.1312.56 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of fonts in CANVAS elements.
2791,CVE-2013-0840,"  void RenderMessageFilter::OnCreateWindow(
   bool no_javascript_access;
   bool can_create_window =
       GetContentClient()->browser()->CanCreateWindow(
          params.opener_url,
          params.opener_security_origin,
           params.window_container_type,
           resource_context_,
           render_process_id_,","Google Chrome before 24.0.1312.56 does not validate URLs during the opening of new windows, which has unspecified impact and remote attack vectors."
2792,CVE-2013-0841,"  void TabSpecificContentSettings::OnContentBlocked(
     const std::string& resource_identifier) {
   DCHECK(type != CONTENT_SETTINGS_TYPE_GEOLOCATION)
       << ""Geolocation settings handled by OnGeolocationPermissionSet"";
  if (type < 0 || type >= CONTENT_SETTINGS_NUM_TYPES)
    return;
   content_accessed_[type] = true;
    
    ",Array index error in the content-blocking functionality in Google Chrome before 24.0.1312.56 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2793,CVE-2013-0842,"  bool ParamTraits<FilePath>::Read(const Message* m,
   FilePath::StringType value;
   if (!ParamTraits<FilePath::StringType>::Read(m, iter, &value))
     return false;
   
  if (value.find(FILE_PATH_LITERAL('\0')) != FilePath::StringType::npos)
    return false;
   *r = FilePath(value);
   return true;
 }","Google Chrome before 24.0.1312.56 does not properly handle %00 characters in pathnames, which has unspecified impact and attack vectors."
2794,CVE-2013-0843,"  bool WebRtcAudioRenderer::Initialize(WebRtcAudioRendererSource* source) {
 
    
    
   
 
    
  if (sample_rate == 96000 || sample_rate == 48000) {
    buffer_size = (sample_rate / 100);
   } else {
      
      ","content/renderer/media/webrtc_audio_renderer.cc in Google Chrome before 24.0.1312.56 on Mac OS X does not use an appropriate buffer size for the 96 kHz sampling rate, which allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via a web site that provides WebRTC audio."
2795,CVE-2012-5146,"  namespace IPC {
 
 void ParamTraits<GURL>::Write(Message* m, const GURL& p) {
   DCHECK(p.possibly_invalid_spec().length() <= content::kMaxURLChars);

   
   
   
   
   
   
  if (!p.is_valid()) {
    GURL reconstructed_url(p.possibly_invalid_spec());
    if (reconstructed_url.is_valid()) {
      DLOG(WARNING) << ""GURL string "" << p.possibly_invalid_spec()
                    << "" (marked invalid) but parsed as valid."";
      m->WriteString(std::string());
      return;
    }
  }

   m->WriteString(p.possibly_invalid_spec());
    
 }",Google Chrome before 24.0.1312.52 allows remote attackers to bypass the Same Origin Policy via a malformed URL.
2796,CVE-2012-5148,"  void TabCountChangeObserver::TabInsertedAt(WebContents* contents,
   CheckTabCount();
 }
 
void TabCountChangeObserver::TabDetachedAt(WebContents* contents,
                                            int index) {
   CheckTabCount();
 }","The hyphenation functionality in Google Chrome before 24.0.1312.52 does not properly validate file names, which has unspecified impact and attack vectors."
2797,CVE-2012-5149,"  void AudioInputRendererHost::OnCreateStream(
   VLOG(1) << ""AudioInputRendererHost::OnCreateStream(stream_id=""
           << stream_id << "")"";
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
   
  if (LookupById(stream_id) != NULL) {
    SendErrorMessage(stream_id);
    return;
  }
 
   media::AudioParameters audio_params(params);
 
  void AudioInputRendererHost::OnCreateStream(
                        params.bits_per_sample(), params.frames_per_buffer());
   }
 
   uint32 buffer_size = audio_params.GetBytesPerBuffer();
 
    ",Integer overflow in the audio IPC layer in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2798,CVE-2012-5150,"  class DateTimeChooserClient;
 class FileChooser;
 class FloatRect;
 class Frame;
 class HTMLInputElement;
 class HitTestResult;
 class IntRect;",Use-after-free vulnerability in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving seek operations on video data.
2799,CVE-2012-5152,"  int AudioRendererAlgorithm::FillBuffer(
   if (playback_rate_ == 0.0f)
     return 0;
 
  int slower_step = ceil(window_size_ * playback_rate_);
  int faster_step = ceil(window_size_ / playback_rate_);
  AlignToFrameBoundary(&slower_step);
  AlignToFrameBoundary(&faster_step);

   int total_frames_rendered = 0;
   uint8* output_ptr = dest;
   while (total_frames_rendered < requested_frames) {
     if (index_into_window_ == window_size_)
       ResetWindow();
 
     bool rendered_frame = true;
    if (window_size_ > faster_step) {
      rendered_frame = OutputFasterPlayback(
          output_ptr, window_size_, faster_step);
    } else if (slower_step < window_size_) {
      rendered_frame = OutputSlowerPlayback(
          output_ptr, slower_step, window_size_);
    } else {
       rendered_frame = OutputNormalPlayback(output_ptr);
    }
 
     if (!rendered_frame) {
       needs_more_data_ = true;
  void AudioRendererAlgorithm::ResetWindow() {
   crossfade_frame_number_ = 0;
 }
 
bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest,
                                                  int input_step,
                                                  int output_step) {
   
  CHECK_GT(input_step, output_step);
   DCHECK_LT(index_into_window_, window_size_);
   DCHECK_GT(playback_rate_, 1.0);
 
  bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest) {
    
    
    
   int bytes_to_crossfade = bytes_in_crossfade_;
   if (muted_ || bytes_to_crossfade > output_step)
     bytes_to_crossfade = 0;
  bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest) {
   return true;
 }
 
bool AudioRendererAlgorithm::OutputSlowerPlayback(uint8* dest,
                                                  int input_step,
                                                  int output_step) {
   
  CHECK_LT(input_step, output_step);
   DCHECK_LT(index_into_window_, window_size_);
   DCHECK_LT(playback_rate_, 1.0);
   DCHECK_NE(playback_rate_, 0.0);
  bool AudioRendererAlgorithm::OutputSlowerPlayback(uint8* dest) {
    
    
    
   int bytes_to_crossfade = bytes_in_crossfade_;
   if (muted_ || bytes_to_crossfade > input_step)
     bytes_to_crossfade = 0;",Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service (out-of-bounds read) via vectors involving seek operations on video data.
2800,CVE-2012-5153,"  class SyncScheduler : public sessions::SyncSession::Delegate {
 
    
    
   virtual void ScheduleNudgeAsync(
      const base::TimeDelta& delay,
       NudgeSource source,
       ModelTypeSet types,
       const tracked_objects::Location& nudge_location) = 0;
   virtual void ScheduleNudgeWithStatesAsync(
      const base::TimeDelta& delay, NudgeSource source,
       const ModelTypeInvalidationMap& invalidation_map,
       const tracked_objects::Location& nudge_location) = 0;
 ","Google V8 before 3.14.5.3, as used in Google Chrome before 24.0.1312.52, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers an out-of-bounds access to stack memory."
2801,CVE-2012-5154,"  bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {
    
    
   uint32 rounded_size = (options.size + 0xffff) & ~0xffff;
  if (rounded_size < options.size)
    return false;
   name_ = ASCIIToWide(options.name == NULL ? """" : *options.name);
   mapped_file_ = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
       PAGE_READWRITE, 0, static_cast<DWORD>(rounded_size),",Integer overflow in Google Chrome before 24.0.1312.52 on Windows allows attackers to cause a denial of service or possibly have unspecified other impact via vectors related to allocation of shared memory.
2802,CVE-2012-5155,"  bool ReturnsValidPath(int dir_type) {
       check_path_exists = false;
   }
 #endif
#if defined(OS_MACOSX)
   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&
       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {
     if (path.ReferencesParent())","Google Chrome before 24.0.1312.52 on Mac OS X does not use an appropriate sandboxing approach for worker processes, which makes it easier for remote attackers to bypass intended access restrictions via unspecified vectors."
2803,CVE-2012-5156,"  void DaemonProcess::OnConfigWatcherError() {
   Stop();
 }
 
void DaemonProcess::OnChannelConnected(int32 peer_pid) {
   DCHECK(caller_task_runner()->BelongsToCurrentThread());
 
   DeleteAllDesktopSessions();",Use-after-free vulnerability in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving PDF fields.
2804,CVE-2012-5157,"  class Element : public ContainerNode {
     virtual void accessKeyAction(bool  ) { }
 
     virtual bool isURLAttribute(const Attribute&) const { return false; }
     virtual bool isHTMLContentAttribute(const Attribute&) const { return false; }
 
     KURL getURLAttribute(const QualifiedName&) const;
  class Element : public ContainerNode {
     void detachAttrNodeFromElementWithValue(Attr*, const AtomicString& value);
     void detachAttrNodeAtIndex(Attr*, size_t index);
 
    bool isJavaScriptURLAttribute(const Attribute&) const;

     RefPtr<ElementData> m_elementData;
 };
 ","Google Chrome before 24.0.1312.52 does not properly handle image data in PDF documents, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted document."
2805,CVE-2013-0828,"  RuleSet* CSSDefaultStyleSheets::defaultPrintStyle;
 RuleSet* CSSDefaultStyleSheets::defaultViewSourceStyle;
 RuleSet* CSSDefaultStyleSheets::defaultXHTMLMobileProfileStyle;
 
 StyleSheetContents* CSSDefaultStyleSheets::defaultStyleSheet;
 StyleSheetContents* CSSDefaultStyleSheets::quirksStyleSheet;
 StyleSheetContents* CSSDefaultStyleSheets::svgStyleSheet;
 StyleSheetContents* CSSDefaultStyleSheets::mediaControlsStyleSheet;
 StyleSheetContents* CSSDefaultStyleSheets::fullscreenStyleSheet;
 
 static const MediaQueryEvaluator& screenEval()
 {
     DEFINE_STATIC_LOCAL(const MediaQueryEvaluator, staticScreenEval, (""screen""));
  static StyleSheetContents* parseUASheet(const char* characters, unsigned size)
     return parseUASheet(String(characters, size));
 }
 
void CSSDefaultStyleSheets::loadDefaultStylesheetIfNecessary()
 {
    if (!defaultStyle)
        loadDefaultStyle();
 }
 
void CSSDefaultStyleSheets::loadDefaultStyle()
 {
    ASSERT(!defaultStyle);
    defaultStyle = RuleSet::create().leakPtr();
    defaultPrintStyle = RuleSet::create().leakPtr();
    defaultQuirksStyle = RuleSet::create().leakPtr();
 
      
     String defaultRules = String(htmlUserAgentStyleSheet, sizeof(htmlUserAgentStyleSheet)) + RenderTheme::theme().extraDefaultStyleSheet();
  void CSSDefaultStyleSheets::loadFullDefaultStyle()
     defaultQuirksStyle->addRulesFromSheet(quirksStyleSheet, screenEval());
 }
 
 RuleSet* CSSDefaultStyleSheets::viewSourceStyle()
 {
     if (!defaultViewSourceStyle) {
  RuleSet* CSSDefaultStyleSheets::xhtmlMobileProfileStyle()
 
 void CSSDefaultStyleSheets::ensureDefaultStyleSheetsForElement(Element* element, bool& changedDefaultStyle)
 {
      
     if (element->isSVGElement() && !svgStyleSheet) {
         svgStyleSheet = parseUASheet(svgUserAgentStyleSheet, sizeof(svgUserAgentStyleSheet));","The PDF functionality in Google Chrome before 24.0.1312.52 does not properly perform a cast of an unspecified variable during processing of the root of the structure tree, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document."
2806,CVE-2013-0829,"  void FileAPIMessageFilter::OnCreateSnapshotFile(
   FileSystemURL url(path);
   base::Callback<void(const FilePath&)> register_file_callback =
       base::Bind(&FileAPIMessageFilter::RegisterFileAsBlob,
                 this, blob_url, url);

   
   
   
  base::PlatformFileError error;
  if (!HasPermissionsForFile(url, kReadFilePermissions, &error)) {
    Send(new FileSystemMsg_DidFail(request_id, error));
    return;
  }
 
   FileSystemOperation* operation = GetNewOperation(url, request_id);
   if (!operation)
  void FileAPIMessageFilter::DidCreateSnapshot(
 }
 
 void FileAPIMessageFilter::RegisterFileAsBlob(const GURL& blob_url,
                                              const FileSystemURL& url,
                                               const FilePath& platform_path) {
    
  FilePath::StringType extension = url.path().Extension();
   if (!extension.empty())
     extension = extension.substr(1);   
 
   scoped_refptr<webkit_blob::ShareableFileReference> shareable_file =
       webkit_blob::ShareableFileReference::Get(platform_path);
  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanReadFile(
           process_id_, platform_path)) {
     
     
     
     
     
    DCHECK(shareable_file ||
           fileapi::SandboxMountPointProvider::CanHandleType(url.type()));
     ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(
         process_id_, platform_path);
    if (shareable_file) {
       
       
      shareable_file->AddFinalReleaseCallback(
          base::Bind(&RevokeFilePermission, process_id_));
    }
   }
 
    ","Google Chrome before 24.0.1312.52 does not properly maintain database metadata, which allows remote attackers to bypass intended file-access restrictions via unspecified vectors."
2807,CVE-2013-0830," 
 
 #if defined(OS_POSIX)
 #include ""ipc/file_descriptor_set_posix.h""
#elif defined(OS_WIN)
#include <tchar.h>
 #endif
 
 namespace IPC {
  bool ParamTraits<LOGFONT>::Read(const Message* m, PickleIterator* iter,
                                 param_type* r) {
   const char *data;
   int data_size = 0;
  if (m->ReadData(iter, &data, &data_size) && data_size == sizeof(LOGFONT)) {
    const LOGFONT *font = reinterpret_cast<LOGFONT*>(const_cast<char*>(data));
    if (_tcsnlen(font->lfFaceName, LF_FACESIZE) < LF_FACESIZE) {
      memcpy(r, data, sizeof(LOGFONT));
      return true;
    }
   }
 
  NOTREACHED();
  return false;
 }
 
 void ParamTraits<LOGFONT>::Log(const param_type& p, std::string* l) {","The IPC layer in Google Chrome before 24.0.1312.52 on Windows omits a NUL character required for termination of an unspecified data structure, which has unknown impact and attack vectors."
2808,CVE-2013-0835,"  ChromeGeolocationPermissionContext::ChromeGeolocationPermissionContext(
          new GeolocationInfoBarQueueController(
              base::Bind(
                  &ChromeGeolocationPermissionContext::NotifyPermissionSet,
                 base::Unretained(this)),
              profile))) {
 }
 ",Unspecified vulnerability in the Geolocation implementation in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service (application crash) via unknown vectors.
2809,CVE-2013-0836,"  class JPEGImageReader {
                     if (m_info.output_scanline == 0xffffff)
                         m_info.output_scanline = 0;
 
                     
                     
                     
                    JPEGImageDecoder* decoder = m_decoder;
                    if (!decoder->outputScanlines()) {
                        if (decoder->failed())  
                            return false;
                         if (!m_info.output_scanline)
                              
                              ","Google V8 before 3.14.5.3, as used in Google Chrome before 24.0.1312.52, does not properly implement garbage collection, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted JavaScript code."
2810,CVE-2013-0838,"  bool BackingStoreGtk::CopyFromBackingStore(const gfx::Rect& rect,
       return false;
     }
     shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height,
                           IPC_CREAT|0600);
     if (shminfo.shmid == -1) {
       XDestroyImage(image);
      LOG(WARNING) << ""Failed to get shared memory segment. ""
                      ""Performance may be degraded."";
       return false;
    } else {
      VLOG(1) << ""Got shared memory segment "" << shminfo.shmid;
     }
 
     void* mapped_memory = shmat(shminfo.shmid, NULL, SHM_RDONLY);
  bool BackingStoreGtk::CopyFromBackingStore(const gfx::Rect& rect,
         !XShmGetImage(display_, pixmap_, image, rect.x(), rect.y(),
                       AllPlanes)) {
       DestroySharedImage(display_, image, &shminfo);
      LOG(WARNING) << ""X failed to get shared memory segment. ""
                      ""Performance may be degraded."";
       return false;
     }

    VLOG(1) << ""Using X shared memory segment "" << shminfo.shmid;
   } else {
    LOG(WARNING) << ""Not using X shared memory."";
      
     image = XGetImage(display_, pixmap_,
                       rect.x(), rect.y(), width, height,","Google Chrome before 24.0.1312.52 on Linux uses weak permissions for shared memory segments, which has unspecified impact and attack vectors."
2811,CVE-2014-7901,"  const v8::PropertyCallbackInfo<v8::Value>& info
 const v8::FunctionCallbackInfo<v8::Value>& info
 {%- endif %})
 {
     {# holder #}
     {% if not attribute.is_static %}
     {% if attribute.is_lenient_this %}
  const v8::FunctionCallbackInfo<v8::Value>& info
         }
     }
     {% endif %}
     {# Local variables #}
     {% if attribute.is_call_with_execution_context %}
     ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
  v8::Local<v8::Value> v8Value, const v8::PropertyCallbackInfo<void>& info
 v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info
 {%- endif %})
 {
     {% if attribute.has_setter_exception_state or
           ((not attribute.is_replaceable and
             not attribute.constructor_type and
  v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info
             not attribute.constructor_type %}
     {{cpp_class}}* impl = {{v8_class}}::toImpl(holder);
     {% endif %}
     {# Security checks #}
     {% if not attribute.is_replaceable and
           not attribute.constructor_type %}","Integer overflow in the opj_t2_read_packet_data function in fxcodec/fx_libopenjpeg/libopenjpeg20/t2.c in OpenJPEG in PDFium, as used in Google Chrome before 39.0.2171.65, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a long segment in a JPEG image."
2812,CVE-2014-7903,"  class TouchActionBrowserTest : public ContentBrowserTest {
      
      
     while (wait_until_scrolled &&
           frame_watcher->LastMetadata().root_scroll_offset.y() <
               distance.y()) {
       frame_watcher->WaitFrames(1);
     }
 ","Buffer overflow in OpenJPEG before r2911 in PDFium, as used in Google Chrome before 39.0.2171.65, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted JPEG image."
2813,CVE-2014-7904,"  TEST(ExtensionWebRequestHelpersTest, TestMergeOnBeforeRequestResponses3) {
 
 TEST(ExtensionWebRequestHelpersTest, TestMergeOnBeforeSendHeadersResponses) {
   net::HttpRequestHeaders base_headers;
  base_headers.SetHeader(""key1"", ""value 1"");
  base_headers.SetHeader(""key2"", ""value 2"");
   net::BoundTestNetLog capturing_net_log;
   net::BoundNetLog net_log = capturing_net_log.bound();
   WarningSet warning_set;
  TEST(ExtensionWebRequestHelpersTest, TestMergeOnBeforeSendHeadersResponses) {
   linked_ptr<EventResponseDelta> d1(
       new EventResponseDelta(""extid1"", base::Time::FromInternalValue(2000)));
   d1->deleted_request_headers.push_back(""key1"");
  d1->modified_request_headers.SetHeader(""key2"", ""value 3"");
  d1->modified_request_headers.SetHeader(""key3"", ""value 3"");
   deltas.push_back(d1);
   deltas.sort(&InDecreasingExtensionInstallationTimeOrder);
   warning_set.clear();
  TEST(ExtensionWebRequestHelpersTest, TestMergeOnBeforeSendHeadersResponses) {
   linked_ptr<EventResponseDelta> d2(
       new EventResponseDelta(""extid2"", base::Time::FromInternalValue(1500)));
    
  d2->modified_request_headers.SetHeader(""key3"", ""value 0"");
  d2->modified_request_headers.SetHeader(""key4"", ""value 4"");
   deltas.push_back(d2);
   deltas.sort(&InDecreasingExtensionInstallationTimeOrder);
   warning_set.clear();
  TEST(ExtensionWebRequestHelpersTest, TestMergeOnBeforeSendHeadersResponses) {
   linked_ptr<EventResponseDelta> d3(
       new EventResponseDelta(""extid3"", base::Time::FromInternalValue(1000)));
   d3->deleted_request_headers.push_back(""key1"");
  d3->modified_request_headers.SetHeader(""key2"", ""value 3"");
  d3->modified_request_headers.SetHeader(""key5"", ""value 5"");
   deltas.push_back(d3);
   deltas.sort(&InDecreasingExtensionInstallationTimeOrder);
   warning_set.clear();","Buffer overflow in Skia, as used in Google Chrome before 39.0.2171.65, allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
2814,CVE-2014-7905,"  X11SurfaceFactory::~X11SurfaceFactory() {}
 
 std::vector<gl::GLImplementation>
 X11SurfaceFactory::GetAllowedGLImplementations() {
  DCHECK(thread_checker_.CalledOnValidThread());
   std::vector<gl::GLImplementation> impls;
   impls.push_back(gl::kGLImplementationEGLGLES2);
    
  X11SurfaceFactory::GetAllowedGLImplementations() {
 }
 
 GLOzone* X11SurfaceFactory::GetGLOzone(gl::GLImplementation implementation) {
  DCHECK(thread_checker_.CalledOnValidThread());
   switch (implementation) {
     case gl::kGLImplementationDesktopGL:
       return glx_implementation_.get();","Google Chrome before 39.0.2171.65 on Android does not prevent navigation to a URL in cases where an intent for the URL lacks CATEGORY_BROWSABLE, which allows remote attackers to bypass intended access restrictions via a crafted web site."
2815,CVE-2014-7906,"  class PepperDeviceEnumerationHostHelper::ScopedRequest
      
      
     sync_call_ = true;
    DCHECK(owner_->delegate_);
     request_id_ = owner_->delegate_->EnumerateDevices(
         owner_->device_type_,
         owner_->document_url_,
  class PepperDeviceEnumerationHostHelper::ScopedRequest
   }
 
   ~ScopedRequest() {
    if (requested_ && owner_->delegate_) {
       owner_->delegate_->StopEnumerateDevices(request_id_);
     }
   }
  class PepperDeviceEnumerationHostHelper::ScopedRequest
 
 PepperDeviceEnumerationHostHelper::PepperDeviceEnumerationHostHelper(
     ppapi::host::ResourceHost* resource_host,
    base::WeakPtr<Delegate> delegate,
     PP_DeviceType_Dev device_type,
     const GURL& document_url)
     : resource_host_(resource_host),",Use-after-free vulnerability in the Pepper plugins in Google Chrome before 39.0.2171.65 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted Flash content that triggers an attempted PepperMediaDeviceManager access outside of the object's lifetime.
2816,CVE-2014-7907,"  class ScreenOrientationBrowserTest : public ContentBrowserTest  {
   ScreenOrientationBrowserTest() {
   }
 
   void SetUp() override {
      
      
  IN_PROC_BROWSER_TEST_F(ScreenOrientationBrowserTest, LockSmoke) {
   EXPECT_EQ(expected, shell()->web_contents()->GetLastCommittedURL().ref());
 }
 
 
 
 
 
IN_PROC_BROWSER_TEST_F(ScreenOrientationBrowserTest, CrashTest_UseAfterDetach) {
  GURL test_url = GetTestUrl(""screen_orientation"",
                             ""screen_orientation_use_after_detach.html"");

  TestNavigationObserver navigation_observer(shell()->web_contents(), 2);
  shell()->LoadURL(test_url);

#if defined(OS_WIN)
   
   
  if (base::win::OSInfo::GetInstance()->version() >= base::win::VERSION_WIN8) {
    EXPECT_EQ(false, ScreenOrientationSupported());
    return;
  }
#endif  

  navigation_observer.Wait();

   
   
}

 }  ","Multiple use-after-free vulnerabilities in modules/screen_orientation/ScreenOrientationController.cpp in Blink, as used in Google Chrome before 39.0.2171.65, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger improper handling of a detached frame, related to the (1) lock and (2) unlock methods."
2817,CVE-2014-7908,"  static bool CheckMov(const uint8* buffer, int buffer_size) {
 
   int offset = 0;
   while (offset + 8 < buffer_size) {
    uint32 atomsize = Read32(buffer + offset);
     uint32 atomtype = Read32(buffer + offset + 4);
      
     switch (atomtype) {
  static bool CheckMov(const uint8* buffer, int buffer_size) {
         break;   
       atomsize = Read32(buffer + offset + 12);
     }
    if (atomsize == 0 || atomsize > static_cast<size_t>(buffer_size))
       break;   
     offset += atomsize;
   }",Multiple integer overflows in the CheckMov function in media/base/container_names.cc in Google Chrome before 39.0.2171.65 allow remote attackers to cause a denial of service or possibly have unspecified other impact via a large atom in (1) MPEG-4 or (2) QuickTime .mov data.
2818,CVE-2014-7909,"  void DocumentThreadableLoader::loadRequest(const ResourceRequest& request, Resou
             newRequest.setOriginRestriction(FetchRequest::NoOriginRestriction);
         ASSERT(!resource());
 
        WeakPtr<DocumentThreadableLoader> self(m_weakFactory.createWeakPtr());

         if (request.requestContext() == WebURLRequest::RequestContextVideo || request.requestContext() == WebURLRequest::RequestContextAudio)
             setResource(RawResource::fetchMedia(newRequest, document().fetcher()));
         else if (request.requestContext() == WebURLRequest::RequestContextManifest)
             setResource(RawResource::fetchManifest(newRequest, document().fetcher()));
         else
             setResource(RawResource::fetch(newRequest, document().fetcher()));
 
         
         
        if (!self)
            return;

         if (!resource()) {
             InspectorInstrumentation::documentThreadableLoaderFailedToStartLoadingForClient(m_document, m_client);
             ThreadableLoaderClient* client = m_client;
             clear();
             
             
             
            if (!client)
                return;
             client->didFail(ResourceError(errorDomainBlinkInternal, 0, requestURL.getString(), ""Failed to start loading.""));
              
             return;","effects/SkDashPathEffect.cpp in Skia, as used in Google Chrome before 39.0.2171.65, computes a hash key using uninitialized integer values, which might allow remote attackers to cause a denial of service by rendering crafted data."
2819,CVE-2014-1743,"  gfx::Vector2d BrowserViewRenderer::max_scroll_offset() const {
       max_scroll_offset_dip_, dip_scale_ * page_scale_factor_));
 }
 
void BrowserViewRenderer::ScrollTo(const gfx::Vector2d& scroll_offset) {
   gfx::Vector2d max_offset = max_scroll_offset();
   gfx::Vector2dF scroll_offset_dip;
    
  void BrowserViewRenderer::DidUpdateContent() {
 }
 
 void BrowserViewRenderer::SetTotalRootLayerScrollOffset(
    const gfx::Vector2dF& scroll_offset_dip) {
   if (scroll_offset_dip_ == scroll_offset_dip)
     return;
   scroll_offset_dip_ = scroll_offset_dip;
  BrowserViewRenderer::RootLayerStateAsValue(
   return state;
 }
 
void BrowserViewRenderer::DidOverscroll(
    const gfx::Vector2dF& accumulated_overscroll,
    const gfx::Vector2dF& latest_overscroll_delta,
    const gfx::Vector2dF& current_fling_velocity) {
   const float physical_pixel_scale = dip_scale_ * page_scale_factor_;
   if (accumulated_overscroll == latest_overscroll_delta)
     overscroll_rounding_error_ = gfx::Vector2dF();","Use-after-free vulnerability in the StyleElement::removedFromDocument function in core/dom/StyleElement.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted JavaScript code that triggers tree mutation."
2820,CVE-2014-1746," 
 #define WTF_CPU_64BIT 1
 #endif
 
 
#if defined(__mips__) && (__mips == 64)
#define WTF_CPU_MIPS64 1
 #define WTF_CPU_64BIT 1
#elif defined(__mips__)
#define WTF_CPU_MIPS 1
 #endif
 
 #if !defined(WTF_CPU_64BIT)","The InMemoryUrlProtocol::Read function in media/filters/in_memory_url_protocol.cc in Google Chrome before 35.0.1916.114 relies on an insufficiently large integer data type, which allows remote attackers to cause a denial of service (out-of-bounds read) via vectors that trigger use of a large buffer."
2821,CVE-2014-1748,"  class PluginDataRemoverImpl::Context
     std::vector<WebPluginInfo> plugins;
     plugin_service->GetPluginInfoArray(
         GURL(), mime_type, false, &plugins, NULL);

    if (plugins.empty()) {
       
      event_->Signal();
      return;
    }

    base::FilePath plugin_path = plugins[0].path;
 
     DCHECK_CURRENTLY_ON(BrowserThread::IO);
     remove_start_time_ = base::Time::Now();","The ScrollView::paint function in platform/scroll/ScrollView.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to spoof the UI by extending scrollbar painting into the parent frame."
2822,CVE-2014-3194,"  void ShellSurface::OnSurfaceCommit() {
     UpdateWidgetBounds();
 
     gfx::Point surface_origin = GetSurfaceOrigin();

     
     
     
     
     
     
    if (container_ == ash::kShellWindowId_SystemModalContainer) {
      gfx::Rect hit_test_bounds =
          surface_->GetHitTestBounds() + surface_origin.OffsetFromOrigin();

       
      bool activatable = activatable_ && !hit_test_bounds.IsEmpty();
      if (activatable != CanActivate()) {
        set_can_activate(activatable);

         
        aura::client::ActivationClient* activation_client =
            ash::Shell::GetInstance()->activation_client();
        if (activatable)
          activation_client->ActivateWindow(widget_->GetNativeWindow());
        else if (widget_->IsActive())
          activation_client->DeactivateWindow(widget_->GetNativeWindow());
      }
     }
 
      
  void ShellSurface::CreateShellSurfaceWidget(ui::WindowShowState show_state) {
   params.parent =
       ash::Shell::GetContainer(ash::Shell::GetPrimaryRootWindow(), container_);
   params.bounds = initial_bounds_;
  bool activatable = activatable_;
   
   
  if (container_ == ash::kShellWindowId_SystemModalContainer)
    activatable &= !surface_->GetHitTestBounds().IsEmpty();
   params.activatable = activatable ? views::Widget::InitParams::ACTIVATABLE_YES
                                    : views::Widget::InitParams::ACTIVATABLE_NO;
 ",Use-after-free vulnerability in the Web Workers implementation in Google Chrome before 38.0.2125.101 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2823,CVE-2014-3198,"  bool Instance::HandleInputEvent(const pp::InputEvent& event) {
     }
     if (page_down) {
       int page = engine_->GetFirstVisiblePage();
      if (page == -1)
        return true;
        
        
        
  bool Instance::HandleInputEvent(const pp::InputEvent& event) {
       return true;
     } else if (page_up) {
       int page = engine_->GetFirstVisiblePage();
      if (page == -1)
        return true;
       if (engine_->GetPageRect(page).y() * zoom_ >= v_scrollbar_->GetValue())
         page--;
       ScrollToPage(page);","The Instance::HandleInputEvent function in pdf/instance.cc in the PDFium component in Google Chrome before 38.0.2125.101 interprets a certain -1 value as an index instead of a no-visible-page error code, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2824,"CVE-2014-3176, CVE-2014-3177","  void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
   }
 
   if (!was_current) {
    if (previous_context) {
      previous_context->MakeCurrent(previous_surface.get());
    } else {
      context_->ReleaseCurrent(this);
    }
   }
 }
 ",
2825,CVE-2014-3169,"  extern NSString* const kBrowserActionButtonDragEndNotification;
 - (void)setTestContextMenu:(NSMenu*)testContextMenu;
  
 - (BOOL)wantsToRunForTesting;
 
- (BOOL)isHighlighted;
 @end
 
 @interface BrowserActionCell : ImageButtonCell {","Use-after-free vulnerability in core/dom/ContainerNode.cpp in the DOM implementation in Blink, as used in Google Chrome before 37.0.2062.94, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging script execution that occurs before notification of node removal."
2826,CVE-2014-3170,"  const char kParseErrorEmptyHost[] = ""Host can not be empty."";
 const char kParseErrorInvalidHostWildcard[] = ""Invalid host wildcard."";
 const char kParseErrorEmptyPath[] = ""Empty path."";
 const char kParseErrorInvalidPort[] = ""Invalid port."";
const char kParseErrorInvalidHost[] = ""Invalid host."";
 
  
 const char* const kParseResultMessages[] = {
  const char* const kParseResultMessages[] = {
   kParseErrorInvalidHostWildcard,
   kParseErrorEmptyPath,
   kParseErrorInvalidPort,
  kParseErrorInvalidHost,
 };
 
 COMPILE_ASSERT(URLPattern::NUM_PARSE_RESULTS == arraysize(kParseResultMessages),
  URLPattern::ParseResult URLPattern::Parse(const std::string& pattern) {
   if (host_.find('*') != std::string::npos)
     return PARSE_ERROR_INVALID_HOST_WILDCARD;
 
   
  if (host_.find('\0') != std::string::npos)
    return PARSE_ERROR_INVALID_HOST;

   return PARSE_SUCCESS;
 }
 ","extensions/common/url_pattern.cc in Google Chrome before 37.0.2062.94 does not prevent use of a '0' character in a host name, which allows remote attackers to spoof the extension permission dialog by relying on truncation after this character."
2827,CVE-2014-3171,"  class DOMWrapperMap {
             Impl* impl, KeyType* key, v8::PersistentContainerValue value)
         {
             v8::PersistentContainerValue oldValue = Get(impl, key);
            impl->set(key, value);
             return oldValue;
         }
         static v8::PersistentContainerValue Get(const Impl* impl, KeyType* key)","Use-after-free vulnerability in the V8 bindings in Blink, as used in Google Chrome before 37.0.2062.94, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper use of HashMap add operations instead of HashMap set operations, related to bindings/core/v8/DOMWrapperMap.h and bindings/core/v8/SerializedScriptValue.cpp."
2828,CVE-2014-3172," 
 #include ""extensions/browser/extension_registry.h""
 #include ""extensions/browser/extension_registry_observer.h""
 #include ""extensions/browser/extension_system.h""
#include ""extensions/common/constants.h""
 #include ""extensions/common/error_utils.h""
 #include ""extensions/common/extension.h""
#include ""extensions/common/manifest_constants.h""
#include ""extensions/common/permissions/permissions_data.h""
#include ""extensions/common/switches.h""
 #include ""grit/generated_resources.h""
 #include ""ui/base/l10n/l10n_util.h""
 
  void DebuggerFunction::FormatErrorMessage(const std::string& format) {
 }
 
 bool DebuggerFunction::InitAgentHost() {
  const Extension* extension = GetExtension();
   if (debuggee_.tab_id) {
     WebContents* web_contents = NULL;
     bool result = ExtensionTabUtil::GetTabById(*debuggee_.tab_id,
  bool DebuggerFunction::InitAgentHost() {
                                                &web_contents,
                                                NULL);
     if (result && web_contents) {
       
      GURL url = web_contents->GetVisibleURL();
      if (PermissionsData::IsRestrictedUrl(url, url, extension, &error_))
         return false;
       agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents);
     }
   } else if (debuggee_.extension_id) {
  bool DebuggerFunction::InitAgentHost() {
             ->process_manager()
             ->GetBackgroundHostForExtension(*debuggee_.extension_id);
     if (extension_host) {
      if (PermissionsData::IsRestrictedUrl(extension_host->GetURL(),
                                           extension_host->GetURL(),
                                           extension,
                                           &error_)) {
        return false;
      }
       agent_host_ = DevToolsAgentHost::GetOrCreateFor(
           extension_host->render_view_host());
     }
  bool DebuggerAttachFunction::RunAsync() {
     return false;
   }
 
  const Extension* extension = GetExtension();
   infobars::InfoBar* infobar = NULL;
   if (!CommandLine::ForCurrentProcess()->
       HasSwitch(::switches::kSilentDebuggerExtensionAPI)) {
      
      
     infobar = ExtensionDevToolsInfoBarDelegate::Create(
        agent_host_->GetRenderViewHost(), extension->name());
     if (!infobar) {
       error_ = ErrorUtils::FormatErrorMessage(
           keys::kSilentDebuggingRequired,
          ::switches::kSilentDebuggerExtensionAPI);
       return false;
     }
   }
 
   new ExtensionDevToolsClientHost(GetProfile(),
                                   agent_host_.get(),
                                  extension->id(),
                                  extension->name(),
                                   debuggee_,
                                   infobar);
   SendResponse(true);","The Debugger extension API in browser/extensions/api/debugger/debugger_api.cc in Google Chrome before 37.0.2062.94 does not validate a tab's URL before an attach operation, which allows remote attackers to bypass intended access limitations via an extension that uses a restricted URL, as demonstrated by a chrome:// URL."
2829,CVE-2014-3173,"  bool Framebuffer::HasUnclearedAttachment(
   return false;
 }
 
bool Framebuffer::HasUnclearedColorAttachments() const {
  for (AttachmentMap::const_iterator it = attachments_.begin();
       it != attachments_.end(); ++it) {
    if (it->first >= GL_COLOR_ATTACHMENT0 &&
        it->first < GL_COLOR_ATTACHMENT0 + manager_->max_draw_buffers_) {
      const Attachment* attachment = it->second.get();
      if (!attachment->cleared())
        return true;
    }
  }
  return false;
}

void Framebuffer::ChangeDrawBuffersHelper(bool recover) const {
  scoped_ptr<GLenum[]> buffers(new GLenum[manager_->max_draw_buffers_]);
  for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i)
    buffers[i] = GL_NONE;
  for (AttachmentMap::const_iterator it = attachments_.begin();
       it != attachments_.end(); ++it) {
    if (it->first >= GL_COLOR_ATTACHMENT0 &&
        it->first < GL_COLOR_ATTACHMENT0 + manager_->max_draw_buffers_) {
      buffers[it->first - GL_COLOR_ATTACHMENT0] = it->first;
    }
  }
  bool different = false;
  for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i) {
    if (buffers[i] != draw_buffers_[i]) {
      different = true;
      break;
    }
  }
  if (different) {
    if (recover)
      glDrawBuffersARB(manager_->max_draw_buffers_, draw_buffers_.get());
    else
      glDrawBuffersARB(manager_->max_draw_buffers_, buffers.get());
  }
}

void Framebuffer::PrepareDrawBuffersForClear() const {
  bool recover = false;
  ChangeDrawBuffersHelper(recover);
}

void Framebuffer::RestoreDrawBuffersAfterClear() const {
  bool recover = true;
  ChangeDrawBuffersHelper(recover);
}

 void Framebuffer::MarkAttachmentAsCleared(
       RenderbufferManager* renderbuffer_manager,
       TextureManager* texture_manager,
  void Framebuffer::SetDrawBuffers(GLsizei n, const GLenum* bufs) {
     draw_buffers_[i] = bufs[i];
 }
 


 bool Framebuffer::HasAlphaMRT() const {
   for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i) {
     if (draw_buffers_[i] != GL_NONE) {","The WebGL implementation in Google Chrome before 37.0.2062.94 does not ensure that clear calls interact properly with the state of a draw buffer, which allows remote attackers to cause a denial of service (read of uninitialized memory) via a crafted CANVAS element, related to gpu/command_buffer/service/framebuffer_manager.cc and gpu/command_buffer/service/gles2_cmd_decoder.cc."
2830,CVE-2014-3174,"  bool AudioParam::smooth()
 
 float AudioParam::finalValue()
 {
    float value = m_value;
     calculateFinalValues(&value, 1, false);
     return value;
 }","modules/webaudio/BiquadDSPKernel.cpp in the Web Audio API implementation in Blink, as used in Google Chrome before 37.0.2062.94, does not properly consider concurrent threads during attempts to update biquad filter coefficients, which allows remote attackers to cause a denial of service (read of uninitialized memory) via crafted API calls."
2831,CVE-2014-3175,"  const char kHistogramLoadTypeParseStartForwardBack[] =
 const char kHistogramLoadTypeParseStartNewNavigation[] =
     ""PageLoad.ParseTiming.NavigationToParseStart.LoadType.NewNavigation"";
 
 const char kHistogramFirstBackground[] =
     ""PageLoad.Timing2.NavigationToFirstBackground"";
 const char kHistogramFirstForeground[] =
  void CorePageLoadMetricsObserver::RecordTimingHistograms(
             timing.first_contentful_paint, info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstContentfulPaint,
                           timing.first_contentful_paint.value());
       PAGE_LOAD_HISTOGRAM(
           internal::kHistogramParseStartToFirstContentfulPaint,
           timing.first_contentful_paint.value() - timing.parse_start.value());","Multiple unspecified vulnerabilities in Google Chrome before 37.0.2062.94 allow attackers to cause a denial of service or possibly have other impact via unknown vectors, related to the load_truetype_glyph function in truetype/ttgload.c in FreeType and other functions in other components."
2832,CVE-2014-3165,"  EVENT_TYPE(SOCKS_UNEXPECTED_AUTH)
 EVENT_TYPE(SOCKS_UNKNOWN_ADDRESS_TYPE)
 
  
 
 
 
 
 
 
 
 
 EVENT_TYPE(SSL_CONNECT)
 
  ","Use-after-free vulnerability in modules/websockets/WorkerThreadableWebSocketChannel.cpp in the Web Sockets implementation in Blink, as used in Google Chrome before 36.0.1985.143, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an unexpectedly long lifetime of a temporary object during method completion."
2833,CVE-2014-3154," 
 #include ""content/child/child_resource_message_filter.h""
 #include ""content/child/child_shared_bitmap_manager.h""
 #include ""content/child/fileapi/file_system_dispatcher.h""
#include ""content/child/fileapi/webfilesystem_impl.h""
 #include ""content/child/mojo/mojo_application.h""
 #include ""content/child/power_monitor_broadcast_source.h""
 #include ""content/child/quota_dispatcher.h""
  void ChildThread::Shutdown() {
    
   file_system_dispatcher_.reset();
   quota_dispatcher_.reset();
  WebFileSystemImpl::DeleteThreadSpecificInstance();
 }
 
 void ChildThread::OnChannelConnected(int32 peer_pid) {",Use-after-free vulnerability in the ChildThread::Shutdown function in content/child/child_thread.cc in the filesystem API in Google Chrome before 35.0.1916.153 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to a Blink shutdown.
2834,CVE-2014-3155," 
 #include ""net/spdy/spdy_write_queue.h""
 
 #include <cstddef>
#include <vector>
 
 #include ""base/logging.h""
#include ""base/stl_util.h""
 #include ""net/spdy/spdy_buffer.h""
 #include ""net/spdy/spdy_buffer_producer.h""
 #include ""net/spdy/spdy_stream.h""
  void SpdyWriteQueue::RemovePendingWritesForStream(
   }
 #endif
 
   
   
  std::vector<SpdyBufferProducer*> erased_buffer_producers;

    
   std::deque<PendingWrite>* queue = &queue_[priority];
   std::deque<PendingWrite>::iterator out_it = queue->begin();
   for (std::deque<PendingWrite>::const_iterator it = queue->begin();
        it != queue->end(); ++it) {
     if (it->stream.get() == stream.get()) {
      erased_buffer_producers.push_back(it->frame_producer);
     } else {
       *out_it = *it;
       ++out_it;
     }
   }
   queue->erase(out_it, queue->end());
   removing_writes_ = false;
  STLDeleteElements(&erased_buffer_producers);   
 }
 
 void SpdyWriteQueue::RemovePendingWritesForStreamsAfter(
     SpdyStreamId last_good_stream_id) {
   CHECK(!removing_writes_);
   removing_writes_ = true;
  std::vector<SpdyBufferProducer*> erased_buffer_producers;

   for (int i = MINIMUM_PRIORITY; i <= MAXIMUM_PRIORITY; ++i) {
      
     std::deque<PendingWrite>* queue = &queue_[i];
  void SpdyWriteQueue::RemovePendingWritesForStreamsAfter(
          it != queue->end(); ++it) {
       if (it->stream.get() && (it->stream->stream_id() > last_good_stream_id ||
                                it->stream->stream_id() == 0)) {
        erased_buffer_producers.push_back(it->frame_producer);
       } else {
         *out_it = *it;
         ++out_it;
  void SpdyWriteQueue::RemovePendingWritesForStreamsAfter(
     queue->erase(out_it, queue->end());
   }
   removing_writes_ = false;
  STLDeleteElements(&erased_buffer_producers);   
 }
 
 void SpdyWriteQueue::Clear() {
   CHECK(!removing_writes_);
   removing_writes_ = true;
  std::vector<SpdyBufferProducer*> erased_buffer_producers;

   for (int i = MINIMUM_PRIORITY; i <= MAXIMUM_PRIORITY; ++i) {
     for (std::deque<PendingWrite>::iterator it = queue_[i].begin();
          it != queue_[i].end(); ++it) {
      erased_buffer_producers.push_back(it->frame_producer);
     }
     queue_[i].clear();
   }
   removing_writes_ = false;
  STLDeleteElements(&erased_buffer_producers);   
 }
 
 }   ",net/spdy/spdy_write_queue.cc in the SPDY implementation in Google Chrome before 35.0.1916.153 allows remote attackers to cause a denial of service (out-of-bounds read) by leveraging incorrect queue maintenance.
2835,CVE-2014-3156,"  void SystemClipboard::WriteImage(Image* image,
   if (bitmap.isNull())
     return;
 
   
  CHECK(bitmap.getPixels());
 
   clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap);
 ","Buffer overflow in the clipboard implementation in Google Chrome before 35.0.1916.153 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger unexpected bitmap data, related to content/renderer/renderer_clipboard_client.cc and content/renderer/webclipboard_impl.cc."
2836,CVE-2014-3157,"  FLAKY_FFMPEG_TEST_CASE(BIG_MEM_4, ""security/looping4.mov"");
 FLAKY_FFMPEG_TEST_CASE(Cr99652, ""security/99652.webm"");
 FLAKY_FFMPEG_TEST_CASE(Cr100464, ""security/100464.webm"");
 FLAKY_FFMPEG_TEST_CASE(Cr111342, ""security/111342.ogm"");
FLAKY_FFMPEG_TEST_CASE(Cr368980, ""security/368980.mp4"");
 FLAKY_FFMPEG_TEST_CASE(OGV_0, ""security/big_dims.ogv"");
 FLAKY_FFMPEG_TEST_CASE(OGV_3, ""security/smclock_1_0.ogv"");
 FLAKY_FFMPEG_TEST_CASE(OGV_4, ""security/smclock.ogv.1.0.ogv"");",Heap-based buffer overflow in the FFmpegVideoDecoder::GetVideoBuffer function in media/filters/ffmpeg_video_decoder.cc in Google Chrome before 35.0.1916.153 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging VideoFrame data structures that are too small for proper interaction with an underlying FFmpeg library.
2837,CVE-2014-1742,"  void TraceEvent::AppendAsJSON(
                 name_);
 
    
   
   
   
  ArgumentNameFilterPredicate argument_name_filter_predicate;
  bool strip_args =
      arg_names_[0] && !argument_filter_predicate.is_null() &&
      !argument_filter_predicate.Run(category_group_name, name_,
                                     &argument_name_filter_predicate);
 
   if (strip_args) {
     *out += ""\""__stripped__\"""";
  void TraceEvent::AppendAsJSON(
       *out += arg_names_[i];
       *out += ""\"":"";
 
      if (argument_name_filter_predicate.is_null() ||
          argument_name_filter_predicate.Run(arg_names_[i])) {
        if (arg_types_[i] == TRACE_VALUE_TYPE_CONVERTABLE)
          convertable_values_[i]->AppendAsTraceFormat(out);
        else
          AppendValueAsJSON(arg_types_[i], arg_values_[i], out);
      } else {
        *out += ""\""__stripped__\"""";
      }
     }
 
     *out += ""}"";","Use-after-free vulnerability in the FrameSelection::updateAppearance function in core/editing/FrameSelection.cpp in Blink, as used in Google Chrome before 34.0.1847.137, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper RenderObject handling."
2838,," 
 
 #include <objbase.h>
 #include <windows.h>
#include <winternl.h>
 
#include <cstdlib>
 #include <map>
 #include <utility>
#include <vector>
 
#include ""base/lazy_instance.h""
 #include ""base/logging.h""
#include ""base/macros.h""
#include ""base/memory/scoped_ptr.h""
 #include ""base/profiler/native_stack_sampler.h""
 #include ""base/profiler/win32_stack_frame_unwinder.h""
 #include ""base/strings/string_util.h""
  namespace base {
 
 namespace {
 
 
struct TEB {
  NT_TIB Tib;
   
};

 
const TEB* GetThreadEnvironmentBlock(HANDLE thread_handle) {
   
  enum THREAD_INFORMATION_CLASS { ThreadBasicInformation };

  struct CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
  };

  struct THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    TEB* Teb;
    CLIENT_ID ClientId;
    KAFFINITY AffinityMask;
    LONG Priority;
    LONG BasePriority;
  };

  using NtQueryInformationThreadFunction =
      NTSTATUS (WINAPI*)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG,
                         PULONG);

  const NtQueryInformationThreadFunction nt_query_information_thread =
      reinterpret_cast<NtQueryInformationThreadFunction>(
          ::GetProcAddress(::GetModuleHandle(L""ntdll.dll""),
                           ""NtQueryInformationThread""));
  if (!nt_query_information_thread)
    return nullptr;

  THREAD_BASIC_INFORMATION basic_info = {0};
  NTSTATUS status =
      nt_query_information_thread(thread_handle, ThreadBasicInformation,
                                  &basic_info, sizeof(THREAD_BASIC_INFORMATION),
                                  nullptr);
  if (status != 0)
    return nullptr;

  return basic_info.Teb;
}

 
 
void RewritePointerIfInOriginalStack(uintptr_t top, uintptr_t bottom,
                                     void* stack_copy, const void** pointer) {
  const uintptr_t value = reinterpret_cast<uintptr_t>(*pointer);
  if (value >= bottom && value < top) {
    *pointer = reinterpret_cast<const void*>(
        static_cast<unsigned char*>(stack_copy) + (value - bottom));
  }
}

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
void RewritePointersToStackMemory(uintptr_t top, uintptr_t bottom,
                                  CONTEXT* context, void* stack_copy) {
#if defined(_WIN64)
  DWORD64 CONTEXT::* const nonvolatile_registers[] = {
    &CONTEXT::R12,
    &CONTEXT::R13,
    &CONTEXT::R14,
    &CONTEXT::R15,
    &CONTEXT::Rdi,
    &CONTEXT::Rsi,
    &CONTEXT::Rbx,
    &CONTEXT::Rbp,
    &CONTEXT::Rsp
  };

   
  for (size_t i = 0; i < arraysize(nonvolatile_registers); ++i) {
    DWORD64* const reg = &(context->*nonvolatile_registers[i]);
    RewritePointerIfInOriginalStack(top, bottom, stack_copy,
                                    reinterpret_cast<const void**>(reg));
  }

   
  const void** start = reinterpret_cast<const void**>(stack_copy);
  const void** end = reinterpret_cast<const void**>(
      reinterpret_cast<char*>(stack_copy) + (top - bottom));
  for (const void** loc = start; loc < end; ++loc)
    RewritePointerIfInOriginalStack(top, bottom, stack_copy, loc);
#endif
}

  
  
int RecordStack(CONTEXT* context, int max_stack_size,
                const void* instruction_pointers[]) {
 #ifdef _WIN64
  Win32StackFrameUnwinder frame_unwinder;
   int i = 0;
   for (; (i < max_stack_size) && context->Rip; ++i) {
     instruction_pointers[i] = reinterpret_cast<const void*>(context->Rip);
    if (!frame_unwinder.TryUnwind(context))
       return i + 1;
   }
   return i;
  ScopedDisablePriorityBoost::~ScopedDisablePriorityBoost() {
     ::SetThreadPriorityBoost(thread_handle_, boost_state_was_disabled_);
 }
 
 

 
class ScopedSuspendThread {
 public:
  ScopedSuspendThread(HANDLE thread_handle);
  ~ScopedSuspendThread();
 
  bool was_successful() const { return was_successful_; }
 
 private:
  HANDLE thread_handle_;
  bool was_successful_;

  DISALLOW_COPY_AND_ASSIGN(ScopedSuspendThread);
};

ScopedSuspendThread::ScopedSuspendThread(HANDLE thread_handle)
    : thread_handle_(thread_handle),
      was_successful_(::SuspendThread(thread_handle) != -1) {
}

ScopedSuspendThread::~ScopedSuspendThread() {
  if (!was_successful_)
    return;
 
    
    
  int SuspendThreadAndRecordStack(HANDLE thread_handle, int max_stack_size,
    
    
    
  ScopedDisablePriorityBoost disable_priority_boost(thread_handle_);
  bool resume_thread_succeeded = ::ResumeThread(thread_handle_) != -1;
   CHECK(resume_thread_succeeded) << ""ResumeThread failed: "" << GetLastError();
}

 
 
 
 
 
 
 
 
 
int SuspendThreadAndRecordStack(HANDLE thread_handle,
                                const void* base_address,
                                void* stack_copy_buffer,
                                size_t stack_copy_buffer_size,
                                int max_stack_size,
                                const void* instruction_pointers[]) {
  CONTEXT thread_context = {0};
  thread_context.ContextFlags = CONTEXT_FULL;
   
   
   
  const uintptr_t top = reinterpret_cast<uintptr_t>(base_address);
  uintptr_t bottom = 0u;

  {
    ScopedSuspendThread suspend_thread(thread_handle);

    if (!suspend_thread.was_successful())
      return 0;

    if (!::GetThreadContext(thread_handle, &thread_context))
      return 0;
#if defined(_WIN64)
    bottom = thread_context.Rsp;
#else
    bottom = thread_context.Esp;
#endif

    if ((top - bottom) > stack_copy_buffer_size)
      return 0;

    std::memcpy(stack_copy_buffer, reinterpret_cast<const void*>(bottom),
                top - bottom);
  }

  RewritePointersToStackMemory(top, bottom, &thread_context, stack_copy_buffer);
 
  return RecordStack(&thread_context, max_stack_size, instruction_pointers);
 }
 
  
  class NativeStackSamplerWin : public NativeStackSampler {
   void ProfileRecordingStopped() override;
 
  private:
  enum {
     
     
     
     
     
    kStackCopyBufferSize = 2 * 1024 * 1024
  };

    
    
   static bool GetModuleForHandle(HMODULE module_handle,
  class NativeStackSamplerWin : public NativeStackSampler {
                     std::vector<StackSamplingProfiler::Module>* modules);
 
   win::ScopedHandle thread_handle_;

   
  const void* const thread_stack_base_address_;

   
   
  const scoped_ptr<unsigned char[]> stack_copy_buffer_;

    
    
   std::vector<StackSamplingProfiler::Module>* current_modules_;

    
    
   std::map<HMODULE, size_t> profile_module_index_;
  class NativeStackSamplerWin : public NativeStackSampler {
 };
 
 NativeStackSamplerWin::NativeStackSamplerWin(win::ScopedHandle thread_handle)
    : thread_handle_(thread_handle.Take()),
      thread_stack_base_address_(
          GetThreadEnvironmentBlock(thread_handle_.Get())->Tib.StackBase),
      stack_copy_buffer_(new unsigned char[kStackCopyBufferSize]) {
 }
 
 NativeStackSamplerWin::~NativeStackSamplerWin() {
  void NativeStackSamplerWin::RecordStackSample(
     StackSamplingProfiler::Sample* sample) {
   DCHECK(current_modules_);
 
  if (!stack_copy_buffer_)
    return;

   const int max_stack_size = 64;
   const void* instruction_pointers[max_stack_size] = {0};
   HMODULE module_handles[max_stack_size] = {0};
 
   int stack_depth = SuspendThreadAndRecordStack(thread_handle_.Get(),
                                                thread_stack_base_address_,
                                                stack_copy_buffer_.get(),
                                                kStackCopyBufferSize,
                                                 max_stack_size,
                                                 instruction_pointers);
   FindModuleHandlesForAddresses(instruction_pointers, module_handles,",
2839,," 
 #include ""base/bind.h""
 #include ""base/callback_helpers.h""
 #include ""base/debug/alias.h""
#include ""base/numerics/safe_math.h""
 #include ""content/browser/renderer_host/dip_util.h""
 #include ""content/public/browser/user_metrics.h""
 
  bool SoftwareFrameManager::SwapToNewFrame(
 
    
   if (base::SharedMemory::IsHandleValid(shared_memory->handle())) {
    base::CheckedNumeric<size_t> size_in_bytes_checked =
        base::CheckedNumeric<size_t>(4) *
        base::CheckedNumeric<size_t>(frame_data->size.width()) *
        base::CheckedNumeric<size_t>(frame_data->size.height());
    if (!size_in_bytes_checked.IsValid()) {
      DLOG(ERROR) << ""Integer overflow when computing bytes to map."";
      return false;
    }
    size_t size_in_bytes = size_in_bytes_checked.ValueOrDie();
 #ifdef OS_WIN
     if (!shared_memory->Map(0)) {
       DLOG(ERROR) << ""Unable to map renderer memory."";",
2840,," 
 #include ""components/translate/content/common/cld_data_source.h""
 #include ""components/translate/core/browser/translate_download_manager.h""
 #include ""components/variations/net/variations_http_header_provider.h""
#include ""components/variations/pref_names.h""
 #include ""components/variations/variations_associated_data.h""
 #include ""components/version_info/version_info.h""
 #include ""content/public/browser/browser_thread.h""
  int ChromeBrowserMainParts::PreCreateThreadsImpl() {
     if (!master_prefs_->variations_seed.empty() ||
         !master_prefs_->compressed_variations_seed.empty()) {
       if (!master_prefs_->variations_seed.empty()) {
        local_state_->SetString(chrome_variations::prefs::kVariationsSeed,
                                master_prefs_->variations_seed);
       }
       if (!master_prefs_->compressed_variations_seed.empty()) {
        local_state_->SetString(
            chrome_variations::prefs::kVariationsCompressedSeed,
            master_prefs_->compressed_variations_seed);
       }
       if (!master_prefs_->variations_seed_signature.empty()) {
        local_state_->SetString(
            chrome_variations::prefs::kVariationsSeedSignature,
            master_prefs_->variations_seed_signature);
       }
        
        
        
        
      local_state_->SetInt64(chrome_variations::prefs::kVariationsSeedDate,
                              base::Time::Now().ToInternalValue());
     }
 ",
2841,," 
 #include ""chrome/browser/ui/webui/settings/appearance_handler.h""
 #include ""chrome/browser/ui/webui/settings/downloads_handler.h""
 #include ""chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.h""
#include ""chrome/browser/ui/webui/settings/settings_clear_browsing_data_handler.h""
 #include ""chrome/browser/ui/webui/settings/settings_startup_pages_handler.h""
 #include ""chrome/common/url_constants.h""
 #include ""content/public/browser/web_contents.h""
  SettingsPageUIHandler::~SettingsPageUIHandler() {
 MdSettingsUI::MdSettingsUI(content::WebUI* web_ui)
     : content::WebUIController(web_ui) {
   AddSettingsPageUIHandler(new AppearanceHandler(web_ui));
  AddSettingsPageUIHandler(new ClearBrowsingDataHandler(web_ui));
   AddSettingsPageUIHandler(new DownloadsHandler());
   AddSettingsPageUIHandler(new StartupPagesHandler(web_ui));
 ",
2842,,"  class DEVICE_BLUETOOTH_EXPORT BluetoothAdapter
     : public base::RefCounted<BluetoothAdapter> {
  public:
    
  class DEVICE_BLUETOOTH_EXPORT Observer {
    public:
     virtual ~Observer() {}
 ",
2843,,"  const wchar_t* g_troublesome_dlls[kTroublesomeDllsMaxCount] = {
                                          
   L""activedetect64.dll"",                 
   L""bitguard.dll"",                       
  L""bsvc.dll"",                           
   L""chrmxtn.dll"",                        
   L""cplushook.dll"",                      
   L""crdli.dll"",                          ",
2844,," 
 #include ""content/common/frame_messages.h""
 #include ""content/common/input_messages.h""
 #include ""content/common/inter_process_time_ticks_converter.h""
#include ""content/common/swapped_out_messages.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/content_browser_client.h""
 #include ""content/public/browser/render_process_host.h""
  bool RenderFrameHostImpl::Send(IPC::Message* message) {
 }
 
 bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {
   
   
   
   
   
  if (render_view_host_->IsSwappedOut()) {
    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {
       
       
       
      if (msg.is_sync()) {
        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);
        reply->set_reply_error();
        Send(reply);
      }
       
      return true;
    }
  }

   if (delegate_->OnMessageReceived(this, msg))
     return true;
 ",
2845,,"  template<class T>
 class ScopedHGlobal {
  public:
   explicit ScopedHGlobal(HGLOBAL glob) : glob_(glob) {
    data_ = static_cast<T>(GlobalLock(glob_));
   }
   ~ScopedHGlobal() {
     GlobalUnlock(glob_);
   }
 
  T get() { return data_; }
 
   size_t Size() const { return GlobalSize(glob_); }
 
  T operator->() const {
     assert(data_ != 0);
     return data_;
   }
 
  T release() {
    T data = data_;
     data_ = NULL;
     return data;
   }
 
  private:
   HGLOBAL glob_;
 
  T data_;
 
   DISALLOW_COPY_AND_ASSIGN(ScopedHGlobal);
 };",
2846,,"  class RendererWebColorChooserImpl : public blink::WebColorChooser,
 
   blink::WebColorChooserClient* client() { return client_; }
 
   
   
   
  virtual void OnDestruct() OVERRIDE {}

  private:
    
   virtual bool OnMessageReceived(const IPC::Message& message) OVERRIDE;",
2847,,"  base::string16 GenerateKeywordFromNavigationEntry(
       return base::string16();
   }
 
   
   
   
    
    
    
    
  if (!(url.SchemeIs(url::kHttpScheme) || url.SchemeIs(url::kHttpsScheme)) ||
      (url.path().length() > 1)) {
     return base::string16();
  }
 
   return TemplateURL::GenerateKeyword(url, accept_languages);
 }",
2848,,"  void ShutdownWatcherHelper::Arm(const base::TimeDelta& duration) {
   version_info::Channel channel = chrome::GetChannel();
   if (channel == version_info::Channel::STABLE) {
     actual_duration *= 20;
  } else if (channel == version_info::Channel::BETA) {
     actual_duration *= 10;
  } else if (channel == version_info::Channel::DEV) {
    actual_duration *= 4;
  } else {
    actual_duration *= 2;
   }
 
 #if defined(OS_WIN)",
2849,," 
 #include ""base/time/time.h""
 #include ""base/win/registry.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/safe_browsing/srt_fetcher_win.h""
 #include ""chrome/browser/safe_browsing/srt_field_trial_win.h""
 #include ""components/component_updater/component_updater_paths.h""
  class SwReporterInstallerTraits : public ComponentInstallerTraits {
 }   
 
 void RegisterSwReporterComponent(ComponentUpdateService* cus) {
  if (!safe_browsing::IsSwReporterEnabled())
     return;
 
    
   base::string16 cleaner_key_name(kSoftwareRemovalToolRegistryKey);",
2850,CVE-2014-1710,"  bool AsyncPixelTransfersCompletedQuery::End(
   mem_params.shm_size = buffer.size;
   mem_params.shm_data_offset = shm_offset();
   mem_params.shm_data_size = sizeof(QuerySync);
  uint32 end = mem_params.shm_data_offset + mem_params.shm_data_size;
  if (end > mem_params.shm_size || end < mem_params.shm_data_offset)
    return false;
 
   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);
 ","The AsyncPixelTransfersCompletedQuery::End function in gpu/command_buffer/service/query_manager.cc in Google Chrome, as used in Google Chrome OS before 33.0.1750.152, does not check whether a certain position is within the bounds of a shared-memory segment, which allows remote attackers to cause a denial of service (GPU command-buffer memory corruption) or possibly have unspecified other impact via unknown vectors."
2851,CVE-2014-1713,"  v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info
     {% endif %}
     {% if attribute.put_forwards %}
     {{cpp_class}}* proxyImp = {{v8_class}}::toNative(info.Holder());
    RefPtr<{{attribute.idl_type}}> imp = WTF::getPtr(proxyImp->{{attribute.name}}());
     if (!imp)
         return;
     {% elif not attribute.is_static %}","Use-after-free vulnerability in the AttributeSetter function in bindings/templates/attributes.cpp in the bindings in Blink, as used in Google Chrome before 33.0.1750.152 on OS X and Linux and before 33.0.1750.154 on Windows, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving the document.location value."
2852,CVE-2014-1714,"  void WriteObjectsOnUIThread(ui::Clipboard::ObjectMap* objects) {
   clipboard->WriteObjects(ui::CLIPBOARD_TYPE_COPY_PASTE, *objects);
 }
 
enum BitmapPolicy {
  kFilterBitmap,
  kAllowBitmap,
};
void SanitizeObjectMap(ui::Clipboard::ObjectMap* objects,
                       BitmapPolicy bitmap_policy) {
  if (bitmap_policy != kAllowBitmap)
    objects->erase(ui::Clipboard::CBF_SMBITMAP);

  ui::Clipboard::ObjectMap::iterator data_it =
      objects->find(ui::Clipboard::CBF_DATA);
  if (data_it != objects->end()) {
    const ui::Clipboard::FormatType& web_custom_format =
        ui::Clipboard::GetWebCustomDataFormatType();
    if (data_it->second.size() != 2 ||
        !web_custom_format.Equals(
            ui::Clipboard::FormatType::Deserialize(std::string(
                &data_it->second[0].front(),
                data_it->second[0].size())))) {
       
       
       
      objects->erase(ui::Clipboard::CBF_DATA);
    }
  }
}

 }   
 
 
  void ClipboardMessageFilter::OnWriteObjectsSync(
    
   scoped_ptr<ui::Clipboard::ObjectMap> long_living_objects(
       new ui::Clipboard::ObjectMap(objects));
  SanitizeObjectMap(long_living_objects.get(), kAllowBitmap);
    
    
    
  void ClipboardMessageFilter::OnWriteObjectsAsync(
    
   scoped_ptr<ui::Clipboard::ObjectMap> sanitized_objects(
       new ui::Clipboard::ObjectMap(objects));
  SanitizeObjectMap(sanitized_objects.get(), kFilterBitmap);
 
 #if defined(OS_WIN)
    ","The ScopedClipboardWriter::WritePickledData function in ui/base/clipboard/scoped_clipboard_writer.cc in Google Chrome before 33.0.1750.152 on OS X and Linux and before 33.0.1750.154 on Windows does not verify a certain format value, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the clipboard."
2853,CVE-2014-1700," 
 
 
 

#ifndef CONTENT_CHILD_SCOPED_WEB_CALLBACKS_H_
#define CONTENT_CHILD_SCOPED_WEB_CALLBACKS_H_

#include ""base/callback.h""
#include ""base/memory/scoped_ptr.h""
#include ""base/move.h""
#include ""third_party/WebKit/public/platform/WebCallbacks.h""

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
template <typename CallbacksType>
class ScopedWebCallbacks {
  MOVE_ONLY_TYPE_FOR_CPP_03(ScopedWebCallbacks, RValue);

 public:
  using DestructionCallback =
      base::Callback<void(scoped_ptr<CallbacksType> callbacks)>;

  ScopedWebCallbacks(scoped_ptr<CallbacksType> callbacks,
                     const DestructionCallback& destruction_callback)
      : callbacks_(callbacks.Pass()),
        destruction_callback_(destruction_callback) {}

  ~ScopedWebCallbacks() {
    if (callbacks_)
      destruction_callback_.Run(callbacks_.Pass());
  }

  ScopedWebCallbacks(RValue other) { *this = other; }

  ScopedWebCallbacks& operator=(RValue other) {
    callbacks_ = other.object->callbacks_.Pass();
    destruction_callback_ = other.object->destruction_callback_;
    return *this;
  }

  scoped_ptr<CallbacksType> PassCallbacks() { return callbacks_.Pass(); }

 private:
  scoped_ptr<CallbacksType> callbacks_;
  DestructionCallback destruction_callback_;
};

template <typename CallbacksType>
ScopedWebCallbacks<CallbacksType> make_scoped_web_callbacks(
    CallbacksType* callbacks,
    const typename ScopedWebCallbacks<CallbacksType>::DestructionCallback&
        destruction_callback) {
  return ScopedWebCallbacks<CallbacksType>(make_scoped_ptr(callbacks),
                                           destruction_callback);
}

#endif   ","Use-after-free vulnerability in modules/speech/SpeechSynthesis.cpp in Blink, as used in Google Chrome before 33.0.1750.149, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of a certain utterance data structure."
2854,CVE-2014-1700,"  bool IsSmartVirtualKeyboardEnabled() {
           keyboard::switches::kEnableVirtualKeyboard)) {
     return false;
   }
  return keyboard::IsSmartDeployEnabled();
 }
 
 }   ","Use-after-free vulnerability in modules/speech/SpeechSynthesis.cpp in Blink, as used in Google Chrome before 33.0.1750.149, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of a certain utterance data structure."
2855,CVE-2014-1703,"  void UsbDevice::CheckUsbAccess(const ResultCallback& callback) {
   callback.Run(true);
 }
 
 }   ",Use-after-free vulnerability in the WebSocketDispatcherHost::SendOrDrop function in content/browser/renderer_host/websocket_dispatcher_host.cc in the Web Sockets implementation in Google Chrome before 33.0.1750.149 might allow remote attackers to bypass the sandbox protection mechanism by leveraging an incorrect deletion in a certain failure case.
2856,,"  void ChromotingInstance::HandleMessage(const pp::Var& message) {
     HandleSendMouseInputWhenUnfocused();
   } else if (method == ""delegateLargeCursors"") {
     HandleDelegateLargeCursors();
  } else if (method == ""enableDebugRegion"") {
    HandleEnableDebugRegion(*data);
   }
 }
 
  void ChromotingInstance::OnVideoShape(const webrtc::DesktopRegion& shape) {
   PostLegacyJsonMessage(""onDesktopShape"", data.Pass());
 }
 
void ChromotingInstance::OnVideoFrameDirtyRegion(
    const webrtc::DesktopRegion& dirty_region) {
  scoped_ptr<base::ListValue> rects_value(new base::ListValue());
  for (webrtc::DesktopRegion::Iterator i(dirty_region); !i.IsAtEnd();
       i.Advance()) {
    const webrtc::DesktopRect& rect = i.rect();
    scoped_ptr<base::ListValue> rect_value(new base::ListValue());
    rect_value->AppendInteger(rect.left());
    rect_value->AppendInteger(rect.top());
    rect_value->AppendInteger(rect.width());
    rect_value->AppendInteger(rect.height());
    rects_value->Append(rect_value.release());
  }

  scoped_ptr<base::DictionaryValue> data(new base::DictionaryValue());
  data->Set(""rects"", rects_value.release());
  PostLegacyJsonMessage(""onDebugRegion"", data.Pass());
}

 void ChromotingInstance::OnConnectionState(
     protocol::ConnectionToHost::State state,
     protocol::ErrorCode error) {
  void ChromotingInstance::HandleDelegateLargeCursors() {
   cursor_setter_.set_delegate_stub(this);
 }
 
void ChromotingInstance::HandleEnableDebugRegion(
    const base::DictionaryValue& data) {
  bool enable = false;
  if (!data.GetBoolean(""enable"", &enable)) {
    LOG(ERROR) << ""Invalid enableDebugRegion."";
    return;
  }

  video_renderer_->EnableDebugDirtyRegion(enable);
}

 void ChromotingInstance::Disconnect() {
   DCHECK(plugin_task_runner_->BelongsToCurrentThread());
 ",
2857,,"  void PictureLayer::PushPropertiesTo(LayerImpl* base_layer) {
   Layer::PushPropertiesTo(base_layer);
   PictureLayerImpl* layer_impl = static_cast<PictureLayerImpl*>(base_layer);
    
  DCHECK_EQ(layer_impl->is_mask(), is_mask_);
 
   int source_frame_number = layer_tree_host()->source_frame_number();
   gfx::Size impl_bounds = layer_impl->bounds();",
2858,,"  bool CanRendererHandleEvent(const ui::MouseEvent* event) {
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
    case WM_NCLBUTTONDOWN:
    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
    case WM_NCRBUTTONDOWN:
    case WM_NCRBUTTONUP:
    case WM_NCRBUTTONDBLCLK:
    case WM_NCMBUTTONDOWN:
    case WM_NCMBUTTONUP:
    case WM_NCMBUTTONDBLCLK:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:",
2859,,"  HWNDMessageHandler::HWNDMessageHandler(HWNDMessageHandlerDelegate* delegate)
       menu_depth_(0),
       autohide_factory_(this),
       id_generator_(0),
      needs_scroll_styles_(false),
      in_size_move_loop_(false) {
 }
 
 HWNDMessageHandler::~HWNDMessageHandler() {
  void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {
 
    
   WindowImpl::Init(parent, bounds);

#if defined(USE_AURA)
   
   
   
   
   
   
   
   
   
   
   
  if (IsTopLevelWindow(hwnd())) {
    long current_style = ::GetWindowLong(hwnd(), GWL_STYLE);
    if (!(current_style & WS_POPUP)) {
      AddScrollStylesToWindow(hwnd());
      needs_scroll_styles_ = true;
    }
  }
#endif
 }
 
 void HWNDMessageHandler::InitModalType(ui::ModalType modal_type) {
  LRESULT HWNDMessageHandler::OnCreate(CREATESTRUCT* create_struct) {
 
   delegate_->HandleCreate();
 
    
   return 0;
 }
  void HWNDMessageHandler::OnEnterMenuLoop(BOOL from_track_popup_menu) {
 }
 
 void HWNDMessageHandler::OnEnterSizeMove() {
  in_size_move_loop_ = true;

   
   
   
   
  if (needs_scroll_styles_)
    ShowScrollBar(hwnd(), SB_BOTH, FALSE);

   delegate_->HandleBeginWMSizeMove();
   SetMsgHandled(FALSE);
 }
  void HWNDMessageHandler::OnExitMenuLoop(BOOL is_shortcut_menu) {
 void HWNDMessageHandler::OnExitSizeMove() {
   delegate_->HandleEndWMSizeMove();
   SetMsgHandled(FALSE);
  in_size_move_loop_ = false;
   
   
   
   
   
  if (needs_scroll_styles_)
    AddScrollStylesToWindow(hwnd());
 }
 
 void HWNDMessageHandler::OnGetMinMaxInfo(MINMAXINFO* minmax_info) {
  void HWNDMessageHandler::OnSize(UINT param, const CSize& size) {
    
    
    
   
   
   
   
  if (needs_scroll_styles_ && !in_size_move_loop_) {
     ShowScrollBar(hwnd(), SB_BOTH, FALSE);
     base::MessageLoop::current()->PostTask(
        FROM_HERE, base::Bind(&AddScrollStylesToWindow, hwnd()));
   }
#endif
 }
 
 void HWNDMessageHandler::OnSysCommand(UINT notification_code,",
2860,," 
 
 #include ""components/scheduler/child/scheduler_helper.h""
 
#include ""base/time/default_tick_clock.h""
 #include ""base/trace_event/trace_event.h""
 #include ""base/trace_event/trace_event_argument.h""
 #include ""components/scheduler/child/nestable_single_thread_task_runner.h""
 
 namespace scheduler {
 
  SchedulerHelper::SchedulerHelper(
           QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)),
       default_task_runner_(
           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),
      time_source_(new base::DefaultTickClock),
       tracing_category_(tracing_category),
       disabled_by_default_tracing_category_(
           disabled_by_default_tracing_category) {
  SchedulerHelper::ControlAfterWakeUpTaskRunner() {
 }
 
 void SchedulerHelper::SetTimeSourceForTesting(
    scoped_ptr<base::TickClock> time_source) {
   CheckOnValidThread();
   time_source_ = time_source.Pass();
 }
  TaskQueueManager* SchedulerHelper::GetTaskQueueManagerForTesting() {
 }
 
 base::TimeTicks SchedulerHelper::Now() const {
  return time_source_->NowTicks();
 }
 
 scoped_refptr<base::SingleThreadTaskRunner> SchedulerHelper::TaskRunnerForQueue(",
2861,CVE-2013-6663," 
 
 #include ""chrome/renderer/pepper/pepper_flash_renderer_host.h""
 
#include <map>
 #include <vector>
 
#include ""base/lazy_instance.h""
#include ""base/metrics/histogram.h""
#include ""base/strings/string_util.h""
 #include ""chrome/renderer/pepper/ppb_pdf_impl.h""
 #include ""content/public/renderer/pepper_plugin_instance.h""
 #include ""content/public/renderer/render_thread.h""
 #include ""content/public/renderer/renderer_ppapi_host.h""
 #include ""ipc/ipc_message_macros.h""
#include ""net/http/http_util.h""
 #include ""ppapi/c/pp_errors.h""
 #include ""ppapi/c/trusted/ppb_browser_font_trusted.h""
 #include ""ppapi/host/dispatch_host_message.h""
 
 using ppapi::thunk::EnterResourceNoLock;
 using ppapi::thunk::PPB_ImageData_API;
 
namespace {

 
 
 
 
 
 
 
 
 
 
const char* kRejectedHttpRequestHeaders[] = {
  ""authorization"",
  ""cache-control"",
  ""content-encoding"",
  ""content-md5"",
  ""content-type"",   
                    
  ""expires"",
  ""from"",
  ""if-match"",
  ""if-none-match"",
  ""if-range"",
  ""if-unmodified-since"",
  ""pragma"",
  ""referer""
};

 
 
 
enum FlashNavigateUsage {
   
  REJECT_AUTHORIZATION = 0,
  REJECT_CACHE_CONTROL,
  REJECT_CONTENT_ENCODING,
  REJECT_CONTENT_MD5,
  REJECT_CONTENT_TYPE,
  REJECT_EXPIRES,
  REJECT_FROM,
  REJECT_IF_MATCH,
  REJECT_IF_NONE_MATCH,
  REJECT_IF_RANGE,
  REJECT_IF_UNMODIFIED_SINCE,
  REJECT_PRAGMA,
  REJECT_REFERER,

   
   
  REJECT_OTHER_HEADERS,

   
  TOTAL_REJECTED_NAVIGATE_REQUESTS,

   
  TOTAL_NAVIGATE_REQUESTS,

  FLASH_NAVIGATE_USAGE_ENUM_COUNT
};

static base::LazyInstance<std::map<std::string, FlashNavigateUsage> >
    g_rejected_headers = LAZY_INSTANCE_INITIALIZER;

bool IsSimpleHeader(const std::string& lower_case_header_name,
                    const std::string& header_value) {
  if (lower_case_header_name == ""accept"" ||
      lower_case_header_name == ""accept-language"" ||
      lower_case_header_name == ""content-language"") {
    return true;
  }

  if (lower_case_header_name == ""content-type"") {
    std::string lower_case_mime_type;
    std::string lower_case_charset;
    bool had_charset = false;
    net::HttpUtil::ParseContentType(header_value, &lower_case_mime_type,
                                    &lower_case_charset, &had_charset, NULL);
    return lower_case_mime_type == ""application/x-www-form-urlencoded"" ||
           lower_case_mime_type == ""multipart/form-data"" ||
           lower_case_mime_type == ""text/plain"";
  }

  return false;
}

void RecordFlashNavigateUsage(FlashNavigateUsage usage) {
  DCHECK_NE(FLASH_NAVIGATE_USAGE_ENUM_COUNT, usage);
  UMA_HISTOGRAM_ENUMERATION(""Plugin.FlashNavigateUsage"", usage,
                            FLASH_NAVIGATE_USAGE_ENUM_COUNT);
}

}   

 PepperFlashRendererHost::PepperFlashRendererHost(
     content::RendererPpapiHost* host,
     PP_Instance instance,
  int32_t PepperFlashRendererHost::OnNavigate(
   if (!plugin_instance)
     return PP_ERROR_FAILED;
 
  std::map<std::string, FlashNavigateUsage>& rejected_headers =
      g_rejected_headers.Get();
  if (rejected_headers.empty()) {
    for (size_t i = 0; i < arraysize(kRejectedHttpRequestHeaders); ++i)
      rejected_headers[kRejectedHttpRequestHeaders[i]] =
          static_cast<FlashNavigateUsage>(i);
  }

  net::HttpUtil::HeadersIterator header_iter(data.headers.begin(),
                                             data.headers.end(),
                                             ""\n\r"");
  bool rejected = false;
  while (header_iter.GetNext()) {
    std::string lower_case_header_name = StringToLowerASCII(header_iter.name());
    if (!IsSimpleHeader(lower_case_header_name, header_iter.values())) {
      rejected = true;

      std::map<std::string, FlashNavigateUsage>::const_iterator iter =
          rejected_headers.find(lower_case_header_name);
      FlashNavigateUsage usage = iter != rejected_headers.end() ?
          iter->second : REJECT_OTHER_HEADERS;
      RecordFlashNavigateUsage(usage);
    }
  }

  RecordFlashNavigateUsage(TOTAL_NAVIGATE_REQUESTS);
  if (rejected) {
    RecordFlashNavigateUsage(TOTAL_REJECTED_NAVIGATE_REQUESTS);
    return PP_ERROR_NOACCESS;
  }

    
    
    ","Use-after-free vulnerability in the SVGImage::setContainerSize function in core/svg/graphics/SVGImage.cpp in the SVG implementation in Blink, as used in Google Chrome before 33.0.1750.146, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the resizing of a view."
2862,CVE-2013-6667,"  namespace switches {
 
 const char kEnablePageVisibility[] = ""enable-page-visibility"";
 const char kUseInProcCommandBuffer[] = ""use-in-proc-command-buffer"";
const char kWebViewSandboxedRenderer[] = ""webview-sandboxed-renderer"";
 
 }   ",Multiple unspecified vulnerabilities in Google Chrome before 33.0.1750.146 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2863,CVE-2013-6663,"  void ScreenPositionController::ConvertHostPointToRelativeToRootWindow(
   gfx::Point point_in_root(*point);
   root_window->GetHost()->ConvertPointFromHost(&point_in_root);
 
 #if defined(USE_X11) || defined(USE_OZONE)
  gfx::Rect host_bounds(root_window->GetHost()->GetBounds().size());
  if (!host_bounds.Contains(*point)) {
      
      
      
  void ScreenPositionController::ConvertHostPointToRelativeToRootWindow(
         *target_root = root_windows[i];
         *point = location_in_native;
         host->ConvertPointFromNativeScreen(point);
        return;
       }
     }
   }
 #endif
  *target_root = root_window;
  *point = point_in_root;
 }
 
 void ScreenPositionController::ConvertPointToScreen(","Use-after-free vulnerability in the SVGImage::setContainerSize function in core/svg/graphics/SVGImage.cpp in the SVG implementation in Blink, as used in Google Chrome before 33.0.1750.146, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the resizing of a view."
2864,,"  void OverscrollControllerAndroid::OnOverscrolled(
 bool OverscrollControllerAndroid::Animate(base::TimeTicks current_time,
                                           cc::Layer* parent_layer) {
   DCHECK(parent_layer);
  if (!enabled_ || !glow_effect_)
     return false;
 
   return glow_effect_->Animate(current_time, parent_layer);",
2865,,"  ColorChooserWin* ColorChooserWin::current_color_chooser_ = NULL;
 
 ColorChooserWin* ColorChooserWin::Open(content::WebContents* web_contents,
                                        SkColor initial_color) {
  if (current_color_chooser_)
    return NULL;
  current_color_chooser_ = new ColorChooserWin(web_contents, initial_color);
   return current_color_chooser_;
 }
 ",
2866,,"  class SearchEnginesPrivateApiTest : public ExtensionApiTest {
 
 }   
 
IN_PROC_BROWSER_TEST_F(SearchEnginesPrivateApiTest, SetSelectedSearchEngine) {
   EXPECT_TRUE(RunSearchEnginesSubtest(""setSelectedSearchEngine"")) << message_;
 }
 ",
2867,,"  void LinuxSandbox::EngageNamespaceSandbox() {
    
    
   CHECK(sandbox::Credentials::DropFileSystemAccess(proc_fd_));
  CHECK(sandbox::Credentials::DropAllCapabilities(proc_fd_));
 
    
    ",
2868,,"  int MapOpenSSLErrorSSL() {
     case SSL_R_TLSV1_ALERT_RECORD_OVERFLOW:
     case SSL_R_TLSV1_ALERT_USER_CANCELLED:
       return ERR_SSL_PROTOCOL_ERROR;
    case SSL_R_CERTIFICATE_VERIFY_FAILED:
       
       
      return ERR_SSL_SERVER_CERT_CHANGED;
     default:
       LOG(WARNING) << ""Unmapped error reason: "" << ERR_GET_REASON(error_code);
       return ERR_FAILED;
  int MapOpenSSLError(int err, const crypto::OpenSSLErrStackTracer& tracer) {
   }
 }
 
  
  
 struct SslSetClearMask {
  class SSLClientSocketOpenSSL::SSLContext {
     DCHECK_NE(ssl_socket_data_index_, -1);
     ssl_ctx_.reset(SSL_CTX_new(SSLv23_client_method()));
     session_cache_.Reset(ssl_ctx_.get(), kDefaultSessionCacheConfig);
    SSL_CTX_set_cert_verify_callback(ssl_ctx_.get(), CertVerifyCallback, NULL);
     SSL_CTX_set_client_cert_cb(ssl_ctx_.get(), ClientCertCallback);
     SSL_CTX_set_channel_id_cb(ssl_ctx_.get(), ChannelIDCallback);
    SSL_CTX_set_verify(ssl_ctx_.get(), SSL_VERIFY_PEER, NULL);
 #if defined(OPENSSL_NPN_NEGOTIATED)
      
      
  class SSLClientSocketOpenSSL::SSLContext {
     socket->ChannelIDRequestCallback(ssl, pkey);
   }
 
  static int CertVerifyCallback(X509_STORE_CTX *store_ctx, void *arg) {
    SSL* ssl = reinterpret_cast<SSL*>(X509_STORE_CTX_get_ex_data(
        store_ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));
    SSLClientSocketOpenSSL* socket = GetInstance()->GetClientSocketFromSSL(ssl);
    CHECK(socket);

    return socket->CertVerifyCallback(store_ctx);
  }

   static int SelectNextProtoCallback(SSL* ssl,
                                      unsigned char** out, unsigned char* outlen,
                                      const unsigned char* in,
  void SSLClientSocketOpenSSL::ChannelIDRequestCallback(SSL* ssl,
   *pkey = EVP_PKEY_dup(ec_private_key->key());
 }
 
int SSLClientSocketOpenSSL::CertVerifyCallback(X509_STORE_CTX* store_ctx) {
  if (!completed_handshake_) {
     
     
    return 1;
  }

  if (X509Certificate::IsSameOSCert(server_cert_->os_cert_handle(),
                                    sk_X509_value(store_ctx->untrusted, 0))) {
    return 1;
  }

  LOG(ERROR) << ""Server certificate changed between handshakes"";
  return 0;
}

  
  
  ",
2869,CVE-2013-6661," 
 #include ""net/url_request/url_request_context_getter.h""
 #include ""net/url_request/url_request_status.h""
 
#if defined(OS_MACOSX)
#include ""chrome/browser/safe_browsing/sandboxed_dmg_analyzer_mac.h""
#endif

 using content::BrowserThread;
 
 namespace {
  class DownloadProtectionService::CheckClientDownloadRequest
         referrer_url_(item->GetReferrerUrl()),
         tab_url_(item->GetTabUrl()),
         tab_referrer_url_(item->GetTabReferrerUrl()),
        archived_executable_(false),
         callback_(callback),
         service_(service),
         binary_feature_extractor_(binary_feature_extractor),
  class DownloadProtectionService::CheckClientDownloadRequest
     if (item_->GetTargetFilePath().MatchesExtension(
         FILE_PATH_LITERAL("".zip""))) {
       StartExtractZipFeatures();
#if defined(OS_MACOSX)
    } else if (item_->GetTargetFilePath().MatchesExtension(
                  FILE_PATH_LITERAL("".dmg""))) {
      StartExtractDmgFeatures();
#endif
     } else {
       DCHECK(!download_protection_util::IsArchiveFile(
           item_->GetTargetFilePath()));
  class DownloadProtectionService::CheckClientDownloadRequest
     if (!service_)
       return;
     if (results.success) {
      archived_executable_ = results.has_executable;
       archived_binary_.CopyFrom(results.archived_binary);
       DVLOG(1) << ""Zip analysis finished for "" << item_->GetFullPath().value()
                << "", has_executable="" << results.has_executable
  class DownloadProtectionService::CheckClientDownloadRequest
       DVLOG(1) << ""Zip analysis failed for "" << item_->GetFullPath().value();
     }
     UMA_HISTOGRAM_BOOLEAN(""SBClientDownload.ZipFileHasExecutable"",
                          archived_executable_);
     UMA_HISTOGRAM_BOOLEAN(""SBClientDownload.ZipFileHasArchiveButNoExecutable"",
                          results.has_archive && !archived_executable_);
     UMA_HISTOGRAM_TIMES(""SBClientDownload.ExtractZipFeaturesTime"",
                         base::TimeTicks::Now() - zip_analysis_start_time_);
     for (const auto& file_extension : results.archived_archive_filetypes)
       RecordArchivedArchiveFileExtensionType(file_extension);
 
    if (!archived_executable_ && !results.has_archive) {
       PostFinishTask(UNKNOWN, REASON_ARCHIVE_WITHOUT_BINARIES);
       return;
     }
 
    if (!archived_executable_ && results.has_archive)
       type_ = ClientDownloadRequest::ZIPPED_ARCHIVE;
     OnFileFeatureExtractionDone();
   }
 
#if defined(OS_MACOSX)
  void StartExtractDmgFeatures() {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
    DCHECK(item_);
    dmg_analyzer_ = new SandboxedDMGAnalyzer(
        item_->GetFullPath(),
        base::Bind(&CheckClientDownloadRequest::OnDmgAnalysisFinished,
                   weakptr_factory_.GetWeakPtr()));
    dmg_analyzer_->Start();
    dmg_analysis_start_time_ = base::TimeTicks::Now();
  }

  void OnDmgAnalysisFinished(const zip_analyzer::Results& results) {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
    DCHECK_EQ(ClientDownloadRequest::MAC_EXECUTABLE, type_);
    if (!service_)
      return;

    if (results.success) {
      archived_executable_ = results.has_executable;
      archived_binary_.CopyFrom(results.archived_binary);
      DVLOG(1) << ""DMG analysis has finished for ""
               << item_->GetFullPath().value() << "", has_executable=""
               << results.has_executable;
    } else {
      DVLOG(1) << ""DMG analysis failed for ""<< item_->GetFullPath().value();
    }

    UMA_HISTOGRAM_BOOLEAN(""SBClientDownload.DmgFileSuccess"", results.success);
    UMA_HISTOGRAM_BOOLEAN(""SBClientDownload.DmgFileHasExecutable"",
                          archived_executable_);
    UMA_HISTOGRAM_TIMES(""SBClientDownload.ExtractDmgFeaturesTime"",
                        base::TimeTicks::Now() - dmg_analysis_start_time_);

    if (!archived_executable_) {
      PostFinishTask(UNKNOWN, REASON_ARCHIVE_WITHOUT_BINARIES);
      return;
    }

    OnFileFeatureExtractionDone();
  }
#endif   

   static void RecordCountOfSignedOrWhitelistedDownload() {
     UMA_HISTOGRAM_COUNTS(""SBClientDownload.SignedOrWhitelistedDownload"", 1);
   }
  class DownloadProtectionService::CheckClientDownloadRequest
     request.mutable_signature()->CopyFrom(signature_info_);
     if (image_headers_)
       request.set_allocated_image_headers(image_headers_.release());
    if (archived_executable_)
       request.mutable_archived_binary()->Swap(&archived_binary_);
     if (!request.SerializeToString(&client_download_request_data_)) {
       FinishRequest(UNKNOWN, REASON_INVALID_REQUEST_PROTO);
  class DownloadProtectionService::CheckClientDownloadRequest
 
     DVLOG(2) << ""Sending a request for URL: ""
              << item_->GetUrlChain().back();
    DVLOG(2) << ""Detected "" << request.archived_binary().size() << "" archived ""
             << ""binaries"";
     fetcher_ = net::URLFetcher::Create(0  ,
                                        GetDownloadRequestUrl(),
                                        net::URLFetcher::POST, this);
  class DownloadProtectionService::CheckClientDownloadRequest
   GURL tab_url_;
   GURL tab_referrer_url_;
 
  bool archived_executable_;
   ClientDownloadRequest_SignatureInfo signature_info_;
   scoped_ptr<ClientDownloadRequest_ImageHeaders> image_headers_;
   google::protobuf::RepeatedPtrField<ClientDownloadRequest_ArchivedBinary>
  class DownloadProtectionService::CheckClientDownloadRequest
   scoped_ptr<net::URLFetcher> fetcher_;
   scoped_refptr<SandboxedZipAnalyzer> analyzer_;
   base::TimeTicks zip_analysis_start_time_;
#if defined(OS_MACOSX)
  scoped_refptr<SandboxedDMGAnalyzer> dmg_analyzer_;
  base::TimeTicks dmg_analysis_start_time_;
#endif
   bool finished_;
   ClientDownloadRequest::DownloadType type_;
   std::string client_download_request_data_;","Multiple unspecified vulnerabilities in Google Chrome before 33.0.1750.117 allow attackers to bypass the sandbox protection mechanism after obtaining renderer access, or have other impact, via unknown vectors."
2870,CVE-2013-6644,"  class ExtensionServiceInterface
    
    
    
   
   virtual const extensions::Extension* GetInstalledExtension(
       const std::string& id) const = 0;
 ",Multiple unspecified vulnerabilities in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2871,,"  void InputMethodBase::OnTextInputTypeChanged(const TextInputClient* client) {
   NotifyTextInputStateChanged(client);
 }
 
void InputMethodBase::OnCaretBoundsChanged(const TextInputClient* client) {
  if (!IsTextInputClientFocused(client))
    return;
  FOR_EACH_OBSERVER(InputMethodObserver,
                    observer_list_,
                    OnCaretBoundsChanged(client));
}

void InputMethodBase::OnInputLocaleChanged() {
  FOR_EACH_OBSERVER(InputMethodObserver,
                    observer_list_,
                    OnInputLocaleChanged());
}

 TextInputType InputMethodBase::GetTextInputType() const {
   TextInputClient* client = GetTextInputClient();
   return client ? client->GetTextInputType() : TEXT_INPUT_TYPE_NONE;",
2872,,"  EventType EventTypeFromNative(const base::NativeEvent& native_event) {
     case WM_NCMOUSEMOVE:
       return ET_MOUSE_MOVED;
     case WM_MOUSEWHEEL:
    case WM_MOUSEHWHEEL:
       return ET_MOUSEWHEEL;
     case WM_MOUSELEAVE:
     case WM_NCMOUSELEAVE:
  int GetChangedMouseButtonFlagsFromNative(
 }
 
 gfx::Vector2d GetMouseWheelOffset(const base::NativeEvent& native_event) {
  DCHECK(native_event.message == WM_MOUSEWHEEL ||
         native_event.message == WM_MOUSEHWHEEL);
  if (native_event.message == WM_MOUSEWHEEL)
    return gfx::Vector2d(0, GET_WHEEL_DELTA_WPARAM(native_event.wParam));
  return gfx::Vector2d(GET_WHEEL_DELTA_WPARAM(native_event.wParam), 0);
 }
 
 void ClearTouchIdIfReleased(const base::NativeEvent& xev) {",
2873,,"  TEST_F(BookmarkNodeDataTest, URL) {
    
   GURL read_url;
   base::string16 read_title;
  EXPECT_TRUE(data2.GetURLAndTitle(
      ui::OSExchangeData::CONVERT_FILENAMES, &read_url, &read_title));
   EXPECT_EQ(url, read_url);
   EXPECT_EQ(title, read_title);
 }",
2874,,"  void BrowserViewRenderer::DidDestroyCompositor(
     content::SynchronousCompositor* compositor) {
   TRACE_EVENT0(""android_webview"", ""BrowserViewRenderer::DidDestroyCompositor"");
   DCHECK(compositor_);
  compositor_->SetIsActive(false);
   compositor_ = NULL;
 }
 ",
2875,," 
 #ifndef EXTENSIONS_BROWSER_GUEST_VIEW_GUEST_VIEW_H_
 #define EXTENSIONS_BROWSER_GUEST_VIEW_GUEST_VIEW_H_
 
 #include ""content/public/browser/render_frame_host.h""
 #include ""extensions/browser/guest_view/guest_view_base.h""
#include ""extensions/browser/guest_view/guest_view_manager.h""
 
 namespace extensions {
 
  namespace extensions {
 template <typename T>
 class GuestView : public GuestViewBase {
  public:
   static T* From(int embedder_process_id, int guest_instance_id) {
     auto guest = GuestViewBase::From(embedder_process_id, guest_instance_id);
     if (!guest)",
2876,," 
 #include <errno.h>
 #include <linux/input.h>
 
#include ""base/trace_event/trace_event.h""
 #include ""ui/events/event.h""
 #include ""ui/events/event_utils.h""
 #include ""ui/events/keycodes/dom4/keycode_converter.h""
  EventConverterEvdevImpl::~EventConverterEvdevImpl() {
 }
 
 void EventConverterEvdevImpl::OnFileCanReadWithoutBlocking(int fd) {
  TRACE_EVENT1(""evdev"", ""EventConverterEvdevImpl::OnFileCanReadWithoutBlocking"",
               ""fd"", fd);

   input_event inputs[4];
   ssize_t read_size = read(fd, inputs, sizeof(inputs));
   if (read_size < 0) {",
2877,CVE-2015-6790,"  void WebPageSerializerImpl::encodeAndFlushBuffer(
                                        status);
 }
 
 
 
 
 void WebPageSerializerImpl::openTagToString(Element* element,
                                             SerializeDomParam* param)
 {
  void WebPageSerializerImpl::openTagToString(Element* element,
             if (element->hasLegalLinkAttribute(attrName)) {
                  
                 if (attrValue.startsWith(""javascript:"", TextCaseInsensitive)) {
                    result.append(m_htmlEntities.convertEntitiesInString(attrValue));
                 } else {
                      
                     WebLocalFrameImpl* subFrame = WebLocalFrameImpl::fromFrameOwnerElement(element);
  void WebPageSerializerImpl::openTagToString(Element* element,
                             result.append(param->directoryName);
                             result.append('/');
                         }
                        result.append(m_htmlEntities.convertEntitiesInString(m_localLinks.get(completeURL)));
                     } else {
                        result.append(m_htmlEntities.convertEntitiesInString(completeURL));
                     }
                 }
             } else {","The WebPageSerializerImpl::openTagToString function in WebKit/Source/web/WebPageSerializerImpl.cpp in the page serializer in Google Chrome before 47.0.2526.80 does not properly use HTML entities, which might allow remote attackers to inject arbitrary web script or HTML via a crafted document, as demonstrated by a double-quote character inside a single-quoted string."
2878,CVE-2015-6791," 
 #include ""chromeos/chromeos_paths.h""
 #include ""chromeos/chromeos_switches.h""
 #include ""chromeos/components/drivefs/drive_file_stream_service_provider_delegate.h""
#include ""chromeos/components/drivefs/fake_drivefs_launcher_client.h""
 #include ""chromeos/cryptohome/async_method_caller.h""
 #include ""chromeos/cryptohome/cryptohome_parameters.h""
 #include ""chromeos/cryptohome/homedir_methods.h""
  int ChromeBrowserMainPartsChromeos::PreEarlyInitialization() {
 
   dbus_pre_early_init_ = std::make_unique<internal::DBusPreEarlyInit>();
 
  if (!base::SysInfo::IsRunningOnChromeOS() &&
      parsed_command_line().HasSwitch(
          switches::kFakeDriveFsLauncherChrootPath) &&
      parsed_command_line().HasSwitch(
          switches::kFakeDriveFsLauncherSocketPath)) {
    drivefs::FakeDriveFsLauncherClient::Init(
        parsed_command_line().GetSwitchValuePath(
            switches::kFakeDriveFsLauncherChrootPath),
        parsed_command_line().GetSwitchValuePath(
            switches::kFakeDriveFsLauncherSocketPath));
  }

   return ChromeBrowserMainPartsLinux::PreEarlyInitialization();
 }
 ",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.80 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2879,CVE-2015-6765,"  AppCacheUpdateJob::~AppCacheUpdateJob() {
   if (internal_state_ != COMPLETED)
     Cancel();
 
   DCHECK(!inprogress_cache_.get());
   DCHECK(pending_master_entries_.empty());

   
  CHECK(!manifest_fetcher_);
  CHECK(pending_url_fetches_.empty());
  CHECK(master_entry_fetches_.empty());
 
   if (group_)
     group_->SetUpdateAppCacheStatus(AppCacheGroup::IDLE);
  void AppCacheUpdateJob::StartUpdate(AppCacheHost* host,
     DCHECK(!new_master_resource.has_ref());
     DCHECK(new_master_resource.GetOrigin() == manifest_url_.GetOrigin());
 
    if (ContainsKey(failed_master_entries_, new_master_resource))
      return;

      
     if (IsTerminating()) {
       group_->QueueUpdate(host, new_master_resource);
  void AppCacheUpdateJob::HandleMasterEntryFetchCompleted(
     }
     hosts.clear();
 
    failed_master_entries_.insert(url);

     const char* kFormatString = ""Manifest fetch failed (%d) %s"";
     std::string message = FormatUrlErrorMessage(
         kFormatString, request->url(), fetcher->result(), response_code);",Use-after-free vulnerability in content/browser/appcache/appcache_update_job.cc in Google Chrome before 47.0.2526.73 allows remote attackers to execute arbitrary code or cause a denial of service by leveraging the mishandling of AppCache update jobs.
2880,CVE-2015-6766,"  bool AppCacheBackendImpl::SelectCache(
     const int64 cache_document_was_loaded_from,
     const GURL& manifest_url) {
   AppCacheHost* host = GetHost(host_id);
  if (!host)
     return false;
 
  return host->SelectCache(document_url, cache_document_was_loaded_from,
                     manifest_url);
 }
 
 bool AppCacheBackendImpl::SelectCacheForWorker(
     int host_id, int parent_process_id, int parent_host_id) {
   AppCacheHost* host = GetHost(host_id);
  if (!host)
     return false;
 
  return host->SelectCacheForWorker(parent_process_id, parent_host_id);
 }
 
 bool AppCacheBackendImpl::SelectCacheForSharedWorker(
     int host_id, int64 appcache_id) {
   AppCacheHost* host = GetHost(host_id);
  if (!host)
     return false;
 
  return host->SelectCacheForSharedWorker(appcache_id);
 }
 
 bool AppCacheBackendImpl::MarkAsForeignEntry(
  bool AppCacheBackendImpl::MarkAsForeignEntry(
   if (!host)
     return false;
 
  return host->MarkAsForeignEntry(document_url, cache_document_was_loaded_from);
 }
 
 bool AppCacheBackendImpl::GetStatusWithCallback(",Use-after-free vulnerability in the AppCache implementation in Google Chrome before 47.0.2526.73 allows remote attackers with renderer access to cause a denial of service or possibly have unspecified other impact by leveraging incorrect AppCacheUpdateJob behavior associated with duplicate cache selection.
2881,CVE-2015-6767,"  AppCacheDispatcherHost::AppCacheDispatcherHost(
     : BrowserMessageFilter(AppCacheMsgStart),
       appcache_service_(appcache_service),
       frontend_proxy_(this),
      process_id_(process_id),
      weak_factory_(this) {
 }
 
 void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {
  void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {
         appcache_service_.get(), &frontend_proxy_, process_id_);
     get_status_callback_ =
         base::Bind(&AppCacheDispatcherHost::GetStatusCallback,
                    weak_factory_.GetWeakPtr());
     start_update_callback_ =
         base::Bind(&AppCacheDispatcherHost::StartUpdateCallback,
                    weak_factory_.GetWeakPtr());
     swap_cache_callback_ =
         base::Bind(&AppCacheDispatcherHost::SwapCacheCallback,
                    weak_factory_.GetWeakPtr());
   }
 }
 ",Use-after-free vulnerability in content/browser/appcache/appcache_dispatcher_host.cc in the AppCache implementation in Google Chrome before 47.0.2526.73 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect pointer maintenance associated with certain callbacks.
2882,CVE-2015-6768,"  void Document::attach(const AttachContext& context)
 void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 ","The DOM implementation in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy via unspecified vectors, a different vulnerability than CVE-2015-6770."
2883,CVE-2015-6769,"  const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableManualFallbacksFillingDescription,
      kOsDesktop | kOsAndroid,
      FEATURE_VALUE_TYPE(
         password_manager::features::kManualFallbacksFilling)},
 
 #if !defined(OS_ANDROID)
     {""voice-search-on-local-ntp"", flag_descriptions::kVoiceSearchOnLocalNtpName,",The provisional-load commit implementation in WebKit/Source/bindings/core/v8/WindowProxy.cpp in Google Chrome before 47.0.2526.73 allows remote attackers to bypass the Same Origin Policy by leveraging a delay in window proxy clearing.
2884,CVE-2015-6764," 
 #ifndef BASE_FUCHSIA_COMPONENT_CONTEXT_H_
 #define BASE_FUCHSIA_COMPONENT_CONTEXT_H_
 
#include ""base/base_export.h""
 #include ""base/fuchsia/fidl_interface_request.h""
 #include ""base/fuchsia/scoped_zx_handle.h""
 #include ""base/macros.h""
  namespace fuchsia {
 
  
  
class BASE_EXPORT ComponentContext {
  public:
   ComponentContext();
   ~ComponentContext();","The BasicJsonStringifier::SerializeJSArray function in json-stringifier.h in the JSON stringifier in Google V8, as used in Google Chrome before 47.0.2526.73, improperly loads array elements, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted JavaScript code."
2885,CVE-2015-6773,"  void Editor::ChangeSelectionAfterCommand(
   bool selection_did_not_change_dom_position =
       new_selection == GetFrame().Selection().GetSelectionInDOMTree();
   GetFrame().Selection().SetSelection(
      new_selection,
      SetSelectionData::Builder(options)
          .SetShouldShowHandle(GetFrame().Selection().IsHandleVisible())
          .Build());
 
    
    ","The convolution implementation in Skia, as used in Google Chrome before 47.0.2526.73, does not properly constrain row lengths, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted graphics data."
2886,CVE-2015-6774,"  class LoadTimesExtensionWrapper : public v8::Extension {
 
   static void GetLoadTimes(const v8::FunctionCallbackInfo<v8::Value>& args) {
     WebLocalFrame* frame = WebLocalFrame::frameForCurrentContext();
    if (!frame) {
      args.GetReturnValue().SetNull();
      return;
     }
    WebDataSource* data_source = frame->dataSource();
    if (!data_source) {
      args.GetReturnValue().SetNull();
      return;
    }
    DocumentState* document_state = DocumentState::FromDataSource(data_source);
    if (!document_state) {
      args.GetReturnValue().SetNull();
      return;
    }
    double request_time = document_state->request_time().ToDoubleT();
    double start_load_time = document_state->start_load_time().ToDoubleT();
    double commit_load_time = document_state->commit_load_time().ToDoubleT();
    double finish_document_load_time =
        document_state->finish_document_load_time().ToDoubleT();
    double finish_load_time = document_state->finish_load_time().ToDoubleT();
    double first_paint_time = document_state->first_paint_time().ToDoubleT();
    double first_paint_after_load_time =
        document_state->first_paint_after_load_time().ToDoubleT();
    std::string navigation_type =
        GetNavigationType(data_source->navigationType());
    bool was_fetched_via_spdy = document_state->was_fetched_via_spdy();
    bool was_npn_negotiated = document_state->was_npn_negotiated();
    std::string npn_negotiated_protocol =
        document_state->npn_negotiated_protocol();
    bool was_alternate_protocol_available =
        document_state->was_alternate_protocol_available();
    std::string connection_info = net::HttpResponseInfo::ConnectionInfoToString(
        document_state->connection_info());
     
     
     
    v8::Isolate* isolate = args.GetIsolate();
    v8::Local<v8::Object> load_times = v8::Object::New(isolate);
    load_times->Set(v8::String::NewFromUtf8(isolate, ""requestTime""),
                    v8::Number::New(isolate, request_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""startLoadTime""),
                    v8::Number::New(isolate, start_load_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""commitLoadTime""),
                    v8::Number::New(isolate, commit_load_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""finishDocumentLoadTime""),
                    v8::Number::New(isolate, finish_document_load_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""finishLoadTime""),
                    v8::Number::New(isolate, finish_load_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""firstPaintTime""),
                    v8::Number::New(isolate, first_paint_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""firstPaintAfterLoadTime""),
                    v8::Number::New(isolate, first_paint_after_load_time));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""navigationType""),
                    v8::String::NewFromUtf8(isolate, navigation_type.c_str()));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""wasFetchedViaSpdy""),
                    v8::Boolean::New(isolate, was_fetched_via_spdy));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""wasNpnNegotiated""),
                    v8::Boolean::New(isolate, was_npn_negotiated));
    load_times->Set(
        v8::String::NewFromUtf8(isolate, ""npnNegotiatedProtocol""),
        v8::String::NewFromUtf8(isolate, npn_negotiated_protocol.c_str()));
    load_times->Set(
        v8::String::NewFromUtf8(isolate, ""wasAlternateProtocolAvailable""),
        v8::Boolean::New(isolate, was_alternate_protocol_available));
    load_times->Set(v8::String::NewFromUtf8(isolate, ""connectionInfo""),
                    v8::String::NewFromUtf8(isolate, connection_info.c_str()));
    args.GetReturnValue().Set(load_times);
   }
 
   static void GetCSI(const v8::FunctionCallbackInfo<v8::Value>& args) {",Use-after-free vulnerability in the GetLoadTimes function in renderer/loadtimes_extension_bindings.cc in the Extensions implementation in Google Chrome before 47.0.2526.73 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that modifies a pointer used for reporting loadTimes data.
2887,CVE-2015-6779," 
 #include ""chrome/browser/extensions/extension_service.h""
 #include ""chrome/browser/extensions/window_controller.h""
 #include ""chrome/common/extensions/chrome_extension_messages.h""
#include ""chrome/common/url_constants.h""
 #include ""content/public/browser/browser_context.h""
#include ""content/public/browser/child_process_security_policy.h""
 #include ""content/public/browser/render_frame_host.h""
 #include ""content/public/browser/render_process_host.h""
 #include ""content/public/browser/render_view_host.h""
  void ChromeExtensionWebContentsObserver::RenderViewCreated(
     content::RenderViewHost* render_view_host) {
   ReloadIfTerminated(render_view_host);
   ExtensionWebContentsObserver::RenderViewCreated(render_view_host);

  const Extension* extension = GetExtension(render_view_host);
  if (!extension)
    return;

  int process_id = render_view_host->GetProcess()->GetID();
  auto policy = content::ChildProcessSecurityPolicy::GetInstance();

   
   
  if ((extension->is_extension() || extension->is_platform_app()) &&
      Manifest::IsComponentLocation(extension->location())) {
    policy->GrantOrigin(process_id,
                        url::Origin(GURL(content::kChromeUIResourcesURL)));
  }

   
   
   
   
  if (extension->is_extension() ||
      extension->is_legacy_packaged_app() ||
      (extension->is_platform_app() &&
       Manifest::IsComponentLocation(extension->location()))) {
    policy->GrantOrigin(process_id,
                        url::Origin(GURL(chrome::kChromeUIFaviconURL)));
    policy->GrantOrigin(process_id,
                        url::Origin(GURL(chrome::kChromeUIExtensionIconURL)));
  }
 }
 
 bool ChromeExtensionWebContentsObserver::OnMessageReceived(","PDFium, as used in Google Chrome before 47.0.2526.73, does not properly restrict use of chrome: URLs, which allows remote attackers to bypass intended scheme restrictions via a crafted PDF document, as demonstrated by a document with a link to a chrome://settings URL."
2888,CVE-2015-6780,"  ConnectionInfoPopupAndroid::ConnectionInfoPopupAndroid(
       this,
       Profile::FromBrowserContext(web_contents->GetBrowserContext()),
       TabSpecificContentSettings::FromWebContents(web_contents),
      web_contents,
       nav_entry->GetURL(),
       nav_entry->GetSSL(),
       content::CertStore::GetInstance()));","Use-after-free vulnerability in the Infobars implementation in Google Chrome before 47.0.2526.73 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted web site, related to browser/ui/views/website_settings/website_settings_popup_view.cc."
2889,CVE-2015-6784,"  void LinkChangeSerializerMarkupAccumulator::appendElement(StringBuilder& result,
          
          
         result.append('\n');
        MarkupFormatter::appendComment(result, PageSerializer::markOfTheWebDeclaration(document().url()));
         result.append('\n');
     }
 
  PageSerializer::Delegate* PageSerializer::delegate()
     return m_delegate.get();
 }
 
 
 
 
String PageSerializer::markOfTheWebDeclaration(const KURL& url)
{
    StringBuilder builder;
    bool emitsMinus = false;
    CString orignalUrl = url.string().ascii();
    for (const char* string = orignalUrl.data(); *string; ++string) {
        const char ch = *string;
        if (ch == '-' && emitsMinus) {
            builder.append(""%2D"");
            emitsMinus = false;
            continue;
        }
        emitsMinus = ch == '-';
        builder.append(ch);
    }
    CString escapedUrl = builder.toString().ascii();
    return String::format(""saved from url=(%04d)%s"", static_cast<int>(escapedUrl.length()), escapedUrl.data());
}

 }  ","The page serializer in Google Chrome before 47.0.2526.73 mishandles Mark of the Web (MOTW) comments for URLs containing a *--* sequence, which might allow remote attackers to inject HTML via a crafted URL, as demonstrated by an initial http://example.com?-- substring."
2890,CVE-2015-6787,"  void BlockPainter::PaintScrollHitTestDisplayItem(const PaintInfo& paint_info) {
         DisplayItem::kScrollHitTest);
     ScrollHitTestDisplayItem::Record(paint_info.context, layout_block_,
                                      DisplayItem::kScrollHitTest,
                                     *properties->ScrollTranslation());
   }
 }
 ",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2891,CVE-2015-6757,"  void EmbeddedWorkerInstance::Start(int64 service_worker_version_id,
                                    const StatusCallback& callback) {
   if (!context_) {
     callback.Run(SERVICE_WORKER_ERROR_ABORT);
     
     return;
   }
   DCHECK(status_ == STOPPED);
  void EmbeddedWorkerInstance::ProcessAllocated(
                          params.get(),
                          ""Status"", status);
   if (status != SERVICE_WORKER_OK) {
    OnStartFailed(callback, status);
     return;
   }
   const int64 service_worker_version_id = params->service_worker_version_id;
  void EmbeddedWorkerInstance::SendStartWorker(
    
    
   if (status_ != STARTING) {
    OnStartFailed(callback, SERVICE_WORKER_ERROR_ABORT);
     return;
   }
 
  void EmbeddedWorkerInstance::SendStartWorker(
   ServiceWorkerStatusCode status =
       registry_->SendStartWorker(params.Pass(), process_id_);
   if (status != SERVICE_WORKER_OK) {
    OnStartFailed(callback, status);
     return;
   }
   DCHECK(start_callback_.is_null());
  void EmbeddedWorkerInstance::OnScriptEvaluated(bool success) {
     UMA_HISTOGRAM_TIMES(""EmbeddedWorkerInstance.ScriptEvaluate"",
                         base::TimeTicks::Now() - start_timing_);
   }
  StatusCallback callback = start_callback_;
   start_callback_.Reset();
  callback.Run(success ? SERVICE_WORKER_OK
                       : SERVICE_WORKER_ERROR_SCRIPT_EVALUATE_FAILED);
   
 }
 
 void EmbeddedWorkerInstance::OnStarted() {
  void EmbeddedWorkerInstance::ReleaseProcess() {
   start_callback_.Reset();
 }
 
void EmbeddedWorkerInstance::OnStartFailed(const StatusCallback& callback,
                                           ServiceWorkerStatusCode status) {
  Status old_status = status_;
  ReleaseProcess();
  base::WeakPtr<EmbeddedWorkerInstance> weak_this = weak_factory_.GetWeakPtr();
  callback.Run(status);
  if (weak_this && old_status != STOPPED)
    FOR_EACH_OBSERVER(Listener, weak_this->listener_list_,
                      OnStopped(old_status));
}

  
 std::string EmbeddedWorkerInstance::StatusToString(Status status) {
   switch (status) {",Use-after-free vulnerability in content/browser/service_worker/embedded_worker_instance.cc in the ServiceWorker implementation in Google Chrome before 46.0.2490.71 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging object destruction in a callback.
2892,CVE-2015-6763,"  class RenderWidgetHostViewMacEditCommandHelper;
 class WebContents;
 }
 
namespace ui {
class ScopedPasswordInputEnabler;
}

 @class FullscreenWindowManager;
 @protocol RenderWidgetHostViewMacDelegate;
 
  class CONTENT_EXPORT RenderWidgetHostViewMac
 
   std::unique_ptr<CursorManager> cursor_manager_;
 
   
  std::unique_ptr<ui::ScopedPasswordInputEnabler> password_input_enabler_;

    
   base::WeakPtrFactory<RenderWidgetHostViewMac> weak_factory_;
 ",Multiple unspecified vulnerabilities in Google Chrome before 46.0.2490.71 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2893,"CVE-2015-7181, CVE-2015-7182, CVE-2015-7183"," 
 #include ""content/public/common/previews_state.h""
 #include ""content/public/common/renderer_preferences.h""
 #include ""content/public/renderer/content_renderer_client.h""
#include ""content/public/renderer/render_view_visitor.h""
 #include ""content/public/test/frame_load_waiter.h""
 #include ""content/renderer/history_serialization.h""
 #include ""content/renderer/render_thread_impl.h""
  using blink::WebScriptSource;
 using blink::WebString;
 using blink::WebURLRequest;
 
namespace content {

 namespace {
 
class CloseMessageSendingRenderViewVisitor : public RenderViewVisitor {
 public:
  CloseMessageSendingRenderViewVisitor() = default;
  ~CloseMessageSendingRenderViewVisitor() override = default;

 protected:
  bool Visit(RenderView* render_view) override {
     
     
     
    ViewMsg_Close msg(render_view->GetRoutingID());
    static_cast<RenderViewImpl*>(render_view)->OnMessageReceived(msg);
    return true;
  }

 private:
  DISALLOW_COPY_AND_ASSIGN(CloseMessageSendingRenderViewVisitor);
};
 
  
  
  bool GetWindowsKeyCode(char ascii_character, int* key_code) {
 
 }   
 
 class RendererBlinkPlatformImplTestOverrideImpl
     : public RendererBlinkPlatformImpl {
  public:
  void RenderViewTest::TearDown() {
    
   base::RunLoop().RunUntilIdle();
 
   
   
  CloseMessageSendingRenderViewVisitor closing_visitor;
  RenderView::ForEach(&closing_visitor);
 
   std::unique_ptr<blink::WebLeakDetector> leak_detector =
       base::WrapUnique(blink::WebLeakDetector::Create(this));",
2894,CVE-2015-1292,"  const char* NavigatorServiceWorker::supplementName()
     return ""NavigatorServiceWorker"";
 }
 
ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(ExecutionContext* executionContext, Navigator& navigator, ExceptionState& exceptionState)
 {
    ASSERT(!navigator.frame() || executionContext->securityOrigin()->canAccessCheckSuborigins(navigator.frame()->securityContext()->securityOrigin()));
     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);
 }
 ","The NavigatorServiceWorker::serviceWorker function in modules/serviceworkers/NavigatorServiceWorker.cpp in Blink, as used in Google Chrome before 45.0.2454.85, allows remote attackers to bypass the Same Origin Policy by accessing a Service Worker."
2895,CVE-2015-1293,"  typedef struct _NPDeviceContext2DConfig {
 
 typedef struct _NPDeviceContext2D
 {
   
   void* reserved;

   
   void* region;

   
   int32 stride;
 
   /* The dirty region that the plugin has painted into the buffer. This","The DOM implementation in Blink, as used in Google Chrome before 45.0.2454.85, allows remote attackers to bypass the Same Origin Policy via unspecified vectors."
2896,CVE-2015-1294,"  void MessageLoop::SetNestableTasksAllowed(bool allowed) {
     CHECK(RunLoop::IsNestingAllowedOnCurrentThread());
 
      
     
     pump_->ScheduleWork();
   }
   nestable_tasks_allowed_ = allowed;
 }
 
 bool MessageLoop::NestableTasksAllowed() const {
  return nestable_tasks_allowed_ || run_loop_client_->ProcessingTasksAllowed();
 }
 
  
  void MessageLoop::Quit() {
   pump_->Quit();
 }
 
void MessageLoop::EnsureWorkScheduled() {
  DCHECK_EQ(this, current());
  ReloadWorkQueue();
  if (!work_queue_.empty())
    pump_->ScheduleWork();
}

 void MessageLoop::SetThreadTaskRunnerHandle() {
   DCHECK_EQ(this, current());
    
  bool MessageLoop::ProcessNextDelayedNonNestableTask() {
 }
 
 void MessageLoop::RunTask(PendingTask* pending_task) {
  DCHECK(NestableTasksAllowed());
   current_pending_task_ = pending_task;
 
 #if defined(OS_WIN)
  void MessageLoop::ScheduleWork() {
 }
 
 bool MessageLoop::DoWork() {
  if (!NestableTasksAllowed()) {
      
     return false;
   }
  bool MessageLoop::DoWork() {
 }
 
 bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!NestableTasksAllowed() ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;","Use-after-free vulnerability in the SkMatrix::invertNonIdentity function in core/SkMatrix.cpp in Skia, as used in Google Chrome before 45.0.2454.85, allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering the use of matrix elements that lead to an infinite result during an inversion calculation."
2897,CVE-2015-1295,"  PrintWebViewHelper::PrintWebViewHelper(content::RenderView* render_view,
       print_node_in_progress_(false),
       is_loading_(false),
       is_scripted_preview_delayed_(false),
      ipc_nesting_level_(0),
       weak_ptr_factory_(this) {
   if (!delegate_->IsPrintPreviewEnabled())
     DisablePreview();
  void PrintWebViewHelper::PrintPage(blink::WebLocalFrame* frame,
 }
 
 bool PrintWebViewHelper::OnMessageReceived(const IPC::Message& message) {
   
   
   
   
   
   
   
  ++ipc_nesting_level_;

   bool handled = true;
   IPC_BEGIN_MESSAGE_MAP(PrintWebViewHelper, message)
 #if defined(ENABLE_BASIC_PRINTING)
  bool PrintWebViewHelper::OnMessageReceived(const IPC::Message& message) {
     IPC_MESSAGE_HANDLER(PrintMsg_SetScriptedPrintingBlocked,
                         SetScriptedPrintBlocked)
     IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()

  --ipc_nesting_level_;
   return handled;
 }
 
 void PrintWebViewHelper::OnPrintForPrintPreview(
     const base::DictionaryValue& job_settings) {
  CHECK_LE(ipc_nesting_level_, 1);
    
   if (prep_frame_view_)
     return;
  bool PrintWebViewHelper::GetPrintFrame(blink::WebLocalFrame** frame) {
 
 #if defined(ENABLE_BASIC_PRINTING)
 void PrintWebViewHelper::OnPrintPages() {
  CHECK_LE(ipc_nesting_level_, 1);
   blink::WebLocalFrame* frame;
   if (!GetPrintFrame(&frame))
     return;
  void PrintWebViewHelper::OnPrintPages() {
 }
 
 void PrintWebViewHelper::OnPrintForSystemDialog() {
  CHECK_LE(ipc_nesting_level_, 1);
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
  bool PrintWebViewHelper::IsPrintToPdfRequested(
 }
 
 void PrintWebViewHelper::OnPrintPreview(const base::DictionaryValue& settings) {
  CHECK_LE(ipc_nesting_level_, 1);

   print_preview_context_.OnPrintPreview();
 
   UMA_HISTOGRAM_ENUMERATION(""PrintPreview.PreviewEvent"",
  bool PrintWebViewHelper::FinalizePrintReadyDocument() {
 }
 
 void PrintWebViewHelper::OnPrintingDone(bool success) {
  CHECK_LE(ipc_nesting_level_, 1);
   notify_browser_of_print_failure_ = false;
   if (!success)
     LOG(ERROR) << ""Failure in OnPrintingDone"";
  void PrintWebViewHelper::SetScriptedPrintBlocked(bool blocked) {
 }
 
 void PrintWebViewHelper::OnInitiatePrintPreview(bool selection_only) {
  CHECK_LE(ipc_nesting_level_, 1);
   blink::WebLocalFrame* frame = NULL;
   GetPrintFrame(&frame);
   DCHECK(frame);","Multiple use-after-free vulnerabilities in the PrintWebViewHelper class in components/printing/renderer/print_web_view_helper.cc in Google Chrome before 45.0.2454.85 allow user-assisted remote attackers to cause a denial of service or possibly have unspecified other impact by triggering nested IPC messages during preparation for printing, as demonstrated by messages associated with PDF documents in conjunction with messages about printer capabilities."
2898,CVE-2015-1297,"  IN_PROC_BROWSER_TEST_F(ExtensionWebRequestApiTest, IncognitoSplitModeReload) {
   EXPECT_TRUE(listener2.WaitUntilSatisfied());
   EXPECT_TRUE(listener_incognito2.WaitUntilSatisfied());
 }

IN_PROC_BROWSER_TEST_F(ExtensionWebRequestApiTest, ExtensionRequests) {
  ASSERT_TRUE(StartEmbeddedTestServer());
  ExtensionTestMessageListener listener_main1(""web_request_status1"", true);
  ExtensionTestMessageListener listener_main2(""web_request_status2"", true);

  ExtensionTestMessageListener listener_app(""app_done"", false);
  ExtensionTestMessageListener listener_extension(""extension_done"", true);

   
  ASSERT_TRUE(LoadExtension(
          test_data_dir_.AppendASCII(""webrequest_extensions/main"")));
  EXPECT_TRUE(listener_main1.WaitUntilSatisfied());
  EXPECT_TRUE(listener_main2.WaitUntilSatisfied());

   
  ASSERT_TRUE(LoadExtension(
          test_data_dir_.AppendASCII(""webrequest_extensions/app"")));
  ASSERT_TRUE(LoadExtension(
          test_data_dir_.AppendASCII(""webrequest_extensions/extension"")));

  EXPECT_TRUE(listener_app.WaitUntilSatisfied());
  EXPECT_TRUE(listener_extension.WaitUntilSatisfied());

   
  ExtensionTestMessageListener listener_pageready(""contentscript_ready"", true);
  ui_test_utils::NavigateToURL(browser(), embedded_test_server()->GetURL(
          ""/extensions/test_file.html?match_webrequest_test""));

   
   
   
   
  ExtensionTestMessageListener listener_result(false);
  listener_main1.Reply("""");
  EXPECT_TRUE(listener_result.WaitUntilSatisfied());
  EXPECT_EQ(""Did not intercept any requests."", listener_result.message());

   
  EXPECT_TRUE(listener_pageready.WaitUntilSatisfied());
  listener_pageready.Reply("""");

  ExtensionTestMessageListener listener_contentscript(""contentscript_done"",
                                                      true);
  ExtensionTestMessageListener listener_framescript(""framescript_done"", false);
  EXPECT_TRUE(listener_contentscript.WaitUntilSatisfied());
  listener_contentscript.Reply("""");
  EXPECT_TRUE(listener_framescript.WaitUntilSatisfied());

   
   
   
  listener_result.Reset();
  listener_main2.Reply("""");
  EXPECT_TRUE(listener_result.WaitUntilSatisfied());
  if (content::AreAllSitesIsolatedForTesting()) {
     
     
    EXPECT_EQ(""Intercepted requests: ?contentscript"",
              listener_result.message());
  } else {
    EXPECT_EQ(""Intercepted requests: ?contentscript, ?framescript"",
              listener_result.message());
  }
}","The WebRequest API implementation in extensions/browser/api/web_request/web_request_api.cc in Google Chrome before 45.0.2454.85 does not properly consider a request's source before accepting the request, which allows remote attackers to bypass intended access restrictions via a crafted (1) app or (2) extension."
2899,CVE-2015-1299,"  void RenderThreadImpl::EnsureWebKitInitialized() {
 
   webkit_platform_support_.reset(new RendererWebKitPlatformSupportImpl);
   blink::initialize(webkit_platform_support_.get());
  main_thread_compositor_task_runner_ = base::MessageLoopProxy::current();
 
   v8::Isolate* isolate = blink::mainThreadIsolate();
 ","Use-after-free vulnerability in the shared-timer implementation in Blink, as used in Google Chrome before 45.0.2454.85, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging erroneous timer firing, related to ThreadTimers.cpp and Timer.cpp."
2900,CVE-2015-1301,"  void SetSitesMuted(const TabStripModel& tab_strip,
 
 bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {
   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);

   
   
   
  if (!web_contents)
    return false;

   GURL url = web_contents->GetLastCommittedURL();
 
    ",Multiple unspecified vulnerabilities in Google Chrome before 45.0.2454.85 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2901,CVE-2015-1271,"  CORE_EXPORT MediaControlElementType mediaControlElementType(const Node*);
 
  
 
 
 
 class MediaControlElement : public GarbageCollectedMixin {
  public:
    ","PDFium, as used in Google Chrome before 44.0.2403.89, does not properly handle certain out-of-memory conditions, which allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted PDF document that triggers a large memory allocation."
2902,CVE-2015-1273,"  AutoplayUmaHelper* AutoplayUmaHelper::create(HTMLMediaElement* element) {
 AutoplayUmaHelper::AutoplayUmaHelper(HTMLMediaElement* element)
     : EventListener(CPPEventListenerType),
       ContextLifecycleObserver(nullptr),
       m_element(element),
       m_mutedVideoPlayMethodVisibilityObserver(nullptr),
       m_mutedVideoAutoplayOffscreenStartTimeMS(0),
  bool AutoplayUmaHelper::operator==(const EventListener& other) const {
 void AutoplayUmaHelper::onAutoplayInitiated(AutoplaySource source) {
   DEFINE_STATIC_LOCAL(EnumerationHistogram, videoHistogram,
                       (""Media.Video.Autoplay"",
                       static_cast<int>(AutoplaySource::NumberOfUmaSources)));
   DEFINE_STATIC_LOCAL(EnumerationHistogram, mutedVideoHistogram,
                       (""Media.Video.Autoplay.Muted"",
                       static_cast<int>(AutoplaySource::NumberOfUmaSources)));
   DEFINE_STATIC_LOCAL(EnumerationHistogram, audioHistogram,
                       (""Media.Audio.Autoplay"",
                       static_cast<int>(AutoplaySource::NumberOfUmaSources)));
   DEFINE_STATIC_LOCAL(
       EnumerationHistogram, blockedMutedVideoHistogram,
       (""Media.Video.Autoplay.Muted.Blocked"", AutoplayBlockedReasonMax));
 
    
  if (m_sources.count(source))
     return;
 
  m_sources.insert(source);
 
    
   if (m_element->isHTMLVideoElement()) {
    videoHistogram.count(static_cast<int>(source));
     if (m_element->muted())
      mutedVideoHistogram.count(static_cast<int>(source));
   } else {
    audioHistogram.count(static_cast<int>(source));
  }

   
  if (m_sources.size() ==
      static_cast<size_t>(AutoplaySource::NumberOfSources)) {
    if (m_element->isHTMLVideoElement()) {
      videoHistogram.count(static_cast<int>(AutoplaySource::DualSource));
      if (m_element->muted())
        mutedVideoHistogram.count(static_cast<int>(AutoplaySource::DualSource));
    } else {
      audioHistogram.count(static_cast<int>(AutoplaySource::DualSource));
    }
   }
 
    
    
   if (m_element->isHTMLVideoElement() && m_element->muted()) {
    if (m_sources.size() ==
        static_cast<size_t>(AutoplaySource::NumberOfSources)) {
      Platform::current()->recordRapporURL(
          ""Media.Video.Autoplay.Muted.DualSource.Frame"",
          m_element->document().url());
    } else if (source == AutoplaySource::Attribute) {
       Platform::current()->recordRapporURL(
           ""Media.Video.Autoplay.Muted.Attribute.Frame"",
           m_element->document().url());
  void AutoplayUmaHelper::handleContextDestroyed() {
 }
 
 void AutoplayUmaHelper::maybeStartRecordingMutedVideoPlayMethodBecomeVisible() {
  if (!m_sources.count(AutoplaySource::Method) ||
      !m_element->isHTMLVideoElement() || !m_element->muted())
     return;
 
   m_mutedVideoPlayMethodVisibilityObserver = new ElementVisibilityObserver(
  void AutoplayUmaHelper::maybeStopRecordingMutedVideoPlayMethodBecomeVisible(
 }
 
 void AutoplayUmaHelper::maybeStartRecordingMutedVideoOffscreenDuration() {
  if (!m_element->isHTMLVideoElement() || !m_element->muted() ||
      !m_sources.count(AutoplaySource::Method))
     return;
 
    
  void AutoplayUmaHelper::maybeStopRecordingMutedVideoOffscreenDuration() {
       std::min<int64_t>(m_mutedVideoAutoplayOffscreenDurationMS,
                         std::numeric_limits<int32_t>::max()));
 
  DCHECK(m_sources.count(AutoplaySource::Method));

  DEFINE_STATIC_LOCAL(
      CustomCountHistogram, durationHistogram,
      (""Media.Video.Autoplay.Muted.PlayMethod.OffscreenDuration"", 1,
       maxOffscreenDurationUmaMS, offscreenDurationUmaBucketCount));
  durationHistogram.count(boundedTime);

   m_mutedVideoOffscreenDurationVisibilityObserver->stop();
   m_mutedVideoOffscreenDurationVisibilityObserver = nullptr;
   m_mutedVideoAutoplayOffscreenDurationMS = 0;
  bool AutoplayUmaHelper::shouldListenToContextDestroyed() const {
 bool AutoplayUmaHelper::shouldRecordUserPausedAutoplayingCrossOriginVideo()
     const {
   return m_element->isInCrossOriginFrame() && m_element->isHTMLVideoElement() &&
         !m_sources.empty() &&
          !m_recordedCrossOriginAutoplayResults.count(
              CrossOriginAutoplayResult::UserPaused);
 }","Heap-based buffer overflow in j2k.c in OpenJPEG before r3002, as used in PDFium in Google Chrome before 44.0.2403.89, allows remote attackers to cause a denial of service or possibly have unspecified other impact via invalid JPEG2000 data in a PDF document."
2903,CVE-2015-1274,"  AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,
 
 bool AXARIAGridCell::isAriaColumnHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringASCIICase(role, ""columnheader"");
 }
 
 bool AXARIAGridCell::isAriaRowHeader() const {
   const AtomicString& role = getAttribute(HTMLNames::roleAttr);
  return equalIgnoringASCIICase(role, ""rowheader"");
 }
 
 AXObject* AXARIAGridCell::parentTable() const {","Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc."
2904,CVE-2015-1280," 
 #include ""content/public/browser/render_frame_host.h""
 #include ""content/public/common/content_client.h""
 #include ""content/public/common/service_manager_connection.h""
 #include ""media/mojo/interfaces/constants.mojom.h""
 #include ""media/mojo/interfaces/media_service.mojom.h""
 #include ""media/mojo/services/media_interface_provider.h""
  void MediaInterfaceProxy::CreateRenderer(
 void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetCdmInterfaceFactory()->CreateCdm(std::move(request));
 }
 
 media::mojom::InterfaceFactory*
  MediaInterfaceProxy::GetMediaInterfaceFactory() {
   DCHECK(thread_checker_.CalledOnValidThread());
 
   if (!interface_factory_ptr_)
    ConnectToMediaService();
 
   DCHECK(interface_factory_ptr_);
 
   return interface_factory_ptr_.get();
 }
 
media::mojom::InterfaceFactory* MediaInterfaceProxy::GetCdmInterfaceFactory() {
  DVLOG(1) << __FUNCTION__;
  DCHECK(thread_checker_.CalledOnValidThread());
#if !BUILDFLAG(ENABLE_STANDALONE_CDM_SERVICE)
  return GetMediaInterfaceFactory();
#else
  if (!cdm_interface_factory_ptr_)
    ConnectToCdmService();

  DCHECK(cdm_interface_factory_ptr_);

  return cdm_interface_factory_ptr_.get();
#endif
}

void MediaInterfaceProxy::OnMediaServiceConnectionError() {
   DVLOG(1) << __FUNCTION__;
   DCHECK(thread_checker_.CalledOnValidThread());
 
   interface_factory_ptr_.reset();
 }
 
void MediaInterfaceProxy::OnCdmServiceConnectionError() {
   DVLOG(1) << __FUNCTION__;
   DCHECK(thread_checker_.CalledOnValidThread());
 
  cdm_interface_factory_ptr_.reset();
}

service_manager::mojom::InterfaceProviderPtr
MediaInterfaceProxy::GetFrameServices() {
    
   service_manager::mojom::InterfaceProviderPtr interfaces;

    
    
   auto provider = base::MakeUnique<media::MediaInterfaceProvider>(
       mojo::MakeRequest(&interfaces));

 #if BUILDFLAG(ENABLE_MOJO_CDM)
    
   net::URLRequestContextGetter* context_getter =
  void MediaInterfaceProxy::ConnectToService() {
   provider->registry()->AddInterface(base::Bind(
       &ProvisionFetcherImpl::Create, base::RetainedRef(context_getter)));
 #endif   

   GetContentClient()->browser()->ExposeInterfacesToMediaService(
       provider->registry(), render_frame_host_);
 
   media_registries_.push_back(std::move(provider));
 
  return interfaces;
}

void MediaInterfaceProxy::ConnectToMediaService() {
  DVLOG(1) << __FUNCTION__;

   media::mojom::MediaServicePtr media_service;

   
   service_manager::Connector* connector =
       ServiceManagerConnection::GetForProcess()->GetConnector();
   connector->BindInterface(media::mojom::kMediaServiceName, &media_service);

   media_service->CreateInterfaceFactory(MakeRequest(&interface_factory_ptr_),
                                        GetFrameServices());

  interface_factory_ptr_.set_connection_error_handler(
      base::Bind(&MediaInterfaceProxy::OnMediaServiceConnectionError,
                 base::Unretained(this)));
}

void MediaInterfaceProxy::ConnectToCdmService() {
  DVLOG(1) << __FUNCTION__;

  media::mojom::MediaServicePtr media_service;

   
  service_manager::Connector* connector =
      ServiceManagerConnection::GetForProcess()->GetConnector();
  connector->BindInterface(media::mojom::kCdmServiceName, &media_service);

  media_service->CreateInterfaceFactory(
      MakeRequest(&cdm_interface_factory_ptr_), GetFrameServices());

  cdm_interface_factory_ptr_.set_connection_error_handler(
      base::Bind(&MediaInterfaceProxy::OnCdmServiceConnectionError,
                 base::Unretained(this)));
 }
 
 }   ","SkPictureShader.cpp in Skia, as used in Google Chrome before 44.0.2403.89, allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging access to a renderer process and providing crafted serialized data."
2905,CVE-2015-1281,"  namespace blink {
 
 void V8RecursionScope::didLeaveScriptContext()
 {
    Microtask::performCheckpoint(m_isolate);
     V8PerIsolateData::from(m_isolate)->runEndOfScopeTasks();
 }
 ","core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source."
2906,CVE-2015-1283,"  class KeyboardUIImpl : public KeyboardUI, public AccessibilityObserver {
   }
 
   void ShowInDisplay(const int64_t display_id) override {
    keyboard::KeyboardController* controller =
        keyboard::KeyboardController::GetInstance();
     
    if (!controller)
      return;
    controller->ShowKeyboardInDisplay(display_id);
   }
   void Hide() override {
      ","Multiple integer overflows in the XML_GetBuffer function in Expat through 2.1.0, as used in Google Chrome before 44.0.2403.89 and other products, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted XML data, a related issue to CVE-2015-2716."
2907,CVE-2015-1286," 
 
 #include ""chrome/browser/extensions/api/permissions/permissions_api.h""
 #include ""chrome/browser/extensions/extension_apitest.h""
#include ""chrome/browser/net/url_request_mock_util.h""
 #include ""chrome/browser/ui/browser.h""
#include ""content/public/browser/browser_thread.h""
 #include ""content/public/test/browser_test_utils.h""
 #include ""extensions/browser/extension_host.h""
 #include ""extensions/browser/process_manager.h""
 
 namespace extensions {
 namespace {
 
class ExtensionBindingsApiTest : public ExtensionApiTest {
 public:
  void SetUpOnMainThread() override {
    content::BrowserThread::PostTask(
        content::BrowserThread::IO, FROM_HERE,
        base::Bind(&chrome_browser_net::SetUrlRequestMocksEnabled, true));
  }
};
 
 IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest,
                        UnavailableBindingsNeverRegistered) {
  IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ApiEnums) {
   ASSERT_TRUE(RunExtensionTest(""bindings/api_enums"")) << message_;
 };
 
 
 
IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ModuleSystem) {
  ASSERT_TRUE(RunExtensionTest(""bindings/module_system"")) << message_;
}

 }   
 }   ","Cross-site scripting (XSS) vulnerability in the V8ContextNativeHandler::GetModuleSystem function in extensions/renderer/v8_context_native_handler.cc in Google Chrome before 44.0.2403.89 allows remote attackers to inject arbitrary web script or HTML by leveraging the lack of a certain V8 context restriction, aka a Blink *Universal XSS (UXSS).*"
2908,CVE-2015-1272," 
  
  
 
#include ""chrome/browser/extensions/api/image_writer_private/write_from_url_operation.h""
 #include ""base/files/file_util.h""
 #include ""chrome/browser/extensions/api/image_writer_private/error_messages.h""
 #include ""chrome/browser/extensions/api/image_writer_private/operation_manager.h""
 #include ""content/public/browser/browser_thread.h""
#include ""net/traffic_annotation/network_traffic_annotation.h""
 #include ""net/url_request/url_fetcher.h""
 
 namespace extensions {
  void WriteFromUrlOperation::Download(const base::Closure& continuation) {
 
   SetStage(image_writer_api::STAGE_DOWNLOAD);
 
   
  net::NetworkTrafficAnnotationTag traffic_annotation =
      net::DefineNetworkTrafficAnnotation(""cros_recovery_image_download"", R""(
        semantics {
          sender: ""Chrome OS Recovery Utility""
          description:
            ""The Google Chrome OS recovery utility downloads the recovery ""
            ""image from Google Download Server.""
          trigger:
            ""User uses the Chrome OS Recovery Utility app/extension, selects ""
            ""a Chrome OS recovery image, and clicks the Create button to write ""
            ""the image to a USB or SD card.""
          data:
            ""URL of the image file to be downloaded. No other data or user ""
            ""identifier is sent.""
          destination: GOOGLE_OWNED_SERVICE
        }
        policy {
          cookies_allowed: true
          cookies_store: ""user""
          setting:
            ""This feature cannot be disabled by settings, it can only be used ""
            ""by whitelisted apps/extension.""
          policy_exception_justification:
            ""Not implemented, considered not useful.""
        })"");

    
    
  url_fetcher_ = net::URLFetcher::Create(url_, net::URLFetcher::GET, this,
                                         traffic_annotation);
 
   url_fetcher_->SetRequestContext(request_context_);
   url_fetcher_->SaveResponseToFileAtPath(","Use-after-free vulnerability in the GPU process implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging the continued availability of a GPUChannelHost data structure during Blink shutdown, related to content/browser/gpu/browser_gpu_channel_host_factory.cc and content/renderer/render_thread_impl.cc."
2909,CVE-2015-1277,"  void AXTreeSerializer<AXSourceNode>::SerializeChangedNodes(
 
    
    
  size_t serialized_node_index = out_update->nodes.size();
   out_update->nodes.push_back(AXNodeData());
  {
     
     
     
    AXNodeData* serialized_node = &out_update->nodes[serialized_node_index];

    tree_->SerializeNode(node, serialized_node);
     
     
    if (serialized_node->id == client_root_->id &&
        (serialized_node->role != AX_ROLE_ROOT_WEB_AREA &&
         serialized_node->role != AX_ROLE_DESKTOP)) {
      serialized_node->role = AX_ROLE_ROOT_WEB_AREA;
    }
   }
 
   
    
  std::vector<int32> actual_serialized_node_child_ids;
   client_node->children.reserve(children.size());
   for (size_t i = 0; i < children.size(); ++i) {
     AXSourceNode& child = children[i];
     int child_id = tree_->GetId(child);
 
     
    if (!tree_->IsValid(child))
      continue;

     
     if (new_child_ids.find(child_id) == new_child_ids.end())
       continue;
 
     new_child_ids.erase(child_id);
    actual_serialized_node_child_ids.push_back(child_id);
     if (client_child_id_map.find(child_id) != client_child_id_map.end()) {
       ClientTreeNode* reused_child = client_child_id_map[child_id];
       client_node->children.push_back(reused_child);
  void AXTreeSerializer<AXSourceNode>::SerializeChangedNodes(
       new_child->parent = client_node;
       client_node->children.push_back(new_child);
       client_id_map_[child_id] = new_child;
      SerializeChangedNodes(child, out_update);
     }
   }
 
   
   
  out_update->nodes[serialized_node_index].child_ids.swap(
      actual_serialized_node_child_ids);
 }
 
 }   ",Use-after-free vulnerability in the accessibility implementation in Google Chrome before 44.0.2403.89 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging lack of certain validity checks for accessibility-tree data structures.
2910,CVE-2015-1278,"  void NavigatorImpl::DidNavigate(
 
    
    
  if (!is_navigation_within_page)
     render_frame_host->ResetFeaturePolicy();
 
    ","content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document."
2911,CVE-2015-1285,"  class WallpaperManager::PendingWallpaper :
     started_load_at_ = base::Time::Now();
 
     if (default_) {
      manager->DoSetDefaultWallpaper(account_id_, true  ,
                                     std::move(on_finish_));
     } else if (!user_wallpaper_.isNull()) {
       SetWallpaper(user_wallpaper_, info_);
     } else if (!wallpaper_path_.empty()) {
  class WallpaperManager::PendingWallpaper :
                          base::Passed(std::move(on_finish_)),
                          manager->weak_factory_.GetWeakPtr()));
     } else if (!info_.location.empty()) {
      manager->LoadWallpaper(account_id_, info_, true  ,
                             std::move(on_finish_));
     } else {
        
       NOTREACHED();
  void WallpaperManager::SetDefaultWallpaperDelayed(const AccountId& account_id) {
 
 void WallpaperManager::DoSetDefaultWallpaper(
     const AccountId& account_id,
    bool update_wallpaper,
     MovableOnDestroyCallbackHolder on_finish) {
    
   if (user_manager::UserManager::Get()->IsLoggedInAsKioskApp())
  void WallpaperManager::DoSetDefaultWallpaper(
     default_wallpaper_image_.reset();
     if (!file->empty()) {
       loaded_wallpapers_for_test_++;
      StartLoadAndSetDefaultWallpaper(*file, layout, update_wallpaper,
                                      std::move(on_finish),
                                       &default_wallpaper_image_);
       return;
     }
 
     CreateSolidDefaultWallpaper();
   }

  if (update_wallpaper) {
     
    if (default_wallpaper_image_->image().width() == 1 &&
        default_wallpaper_image_->image().height() == 1) {
      layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;
    }

    WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,
                       wallpaper::DEFAULT, base::Time::Now().LocalMidnight());
    SetWallpaper(default_wallpaper_image_->image(), info);
  }
 }
 
 void WallpaperManager::SetUserWallpaperInfo(const AccountId& account_id,
  void WallpaperManager::OnWallpaperDecoded(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    DoSetDefaultWallpaper(account_id, update_wallpaper, std::move(on_finish));
     return;
   }
 
  void WallpaperManager::SetDefaultWallpaperPathsFromCommandLine(
 void WallpaperManager::OnDefaultWallpaperDecoded(
     const base::FilePath& path,
     const wallpaper::WallpaperLayout layout,
    bool update_wallpaper,
     std::unique_ptr<user_manager::UserImage>* result_out,
     MovableOnDestroyCallbackHolder on_finish,
     std::unique_ptr<user_manager::UserImage> user_image) {
  void WallpaperManager::OnDefaultWallpaperDecoded(
   }
 
   *result_out = std::move(user_image);
  if (update_wallpaper) {
    WallpaperInfo info(path.value(), layout, wallpaper::DEFAULT,
                       base::Time::Now().LocalMidnight());
    SetWallpaper((*result_out)->image(), info);
  }
 }
 
 void WallpaperManager::StartLoadAndSetDefaultWallpaper(
     const base::FilePath& path,
     const wallpaper::WallpaperLayout layout,
    bool update_wallpaper,
     MovableOnDestroyCallbackHolder on_finish,
     std::unique_ptr<user_manager::UserImage>* result_out) {
   user_image_loader::StartWithFilePath(
       task_runner_, path, ImageDecoder::ROBUST_JPEG_CODEC,
       0,   
       base::Bind(&WallpaperManager::OnDefaultWallpaperDecoded,
                 weak_factory_.GetWeakPtr(), path, layout, update_wallpaper,
                  base::Unretained(result_out),
                  base::Passed(std::move(on_finish))));
 }
  void WallpaperManager::SetDefaultWallpaperPath(
     }
   }
 
  DoSetDefaultWallpaper(EmptyAccountId(), need_update_screen,
                        MovableOnDestroyCallbackHolder());
 }
 
 void WallpaperManager::RecordWallpaperAppType() {","The XSSAuditor::canonicalize function in core/html/parser/XSSAuditor.cpp in the XSS auditor in Blink, as used in Google Chrome before 44.0.2403.89, does not properly choose a truncation point, which makes it easier for remote attackers to obtain sensitive information via an unspecified linear-time attack."
2912,CVE-2015-1265," 
 #include ""core/dom/Document.h""
 #include ""core/dom/Element.h""
 #include ""core/dom/IncrementLoadEventDelayCount.h""
#include ""core/dom/TaskRunnerHelper.h""
 #include ""core/events/Event.h""
 #include ""core/events/EventSender.h""
 #include ""core/fetch/FetchRequest.h""
  class ImageLoader::Task {
 
 ImageLoader::ImageLoader(Element* element)
     : m_element(element),
      m_derefElementTimer(TaskRunnerHelper::get(TaskType::Networking,
                                                element->document().frame()),
                          this,
                          &ImageLoader::timerFired),
       m_hasPendingLoadEvent(false),
       m_hasPendingErrorEvent(false),
       m_imageComplete(true),",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2913,CVE-2015-1265,"  class UsbDeviceHandleTest : public ::testing::Test {
 
 class TestOpenCallback {
  public:
  TestOpenCallback() {}
 
   scoped_refptr<UsbDeviceHandle> WaitForResult() {
     run_loop_.Run();
     return device_handle_;
   }
 
  UsbDevice::OpenCallback GetCallback() {
    return base::Bind(&TestOpenCallback::SetResult, base::Unretained(this));
  }
 
  private:
   void SetResult(scoped_refptr<UsbDeviceHandle> device_handle) {
     device_handle_ = device_handle;
     run_loop_.Quit();
   }
 
   base::RunLoop run_loop_;
   scoped_refptr<UsbDeviceHandle> device_handle_;
 };
 
 class TestResultCallback {
  public:
  TestResultCallback() {}
 
   bool WaitForResult() {
     run_loop_.Run();
     return success_;
   }
 
  UsbDeviceHandle::ResultCallback GetCallback() {
    return base::Bind(&TestResultCallback::SetResult, base::Unretained(this));
  }
 
  private:
   void SetResult(bool success) {
     success_ = success;
     run_loop_.Quit();
   }
 
   base::RunLoop run_loop_;
   bool success_;
 };
 
 class TestCompletionCallback {
  public:
  TestCompletionCallback() {}
 
   void WaitForResult() { run_loop_.Run(); }
 
  UsbDeviceHandle::TransferCallback GetCallback() {
    return base::Bind(&TestCompletionCallback::SetResult,
                      base::Unretained(this));
   }
   UsbTransferStatus status() const { return status_; }
   size_t transferred() const { return transferred_; }
  class TestCompletionCallback {
     run_loop_.Quit();
   }
 
   base::RunLoop run_loop_;
   UsbTransferStatus status_;
   size_t transferred_;
  TEST_F(UsbDeviceHandleTest, InterruptTransfer) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(0, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   const UsbInterfaceDescriptor* interface =
  TEST_F(UsbDeviceHandleTest, InterruptTransfer) {
   handle->GenericTransfer(UsbTransferDirection::INBOUND, 0x81, in_buffer.get(),
                           in_buffer->size(),
                           5000,   
                          in_completion.GetCallback());
 
   scoped_refptr<net::IOBufferWithSize> out_buffer(
       new net::IOBufferWithSize(in_buffer->size()));
  TEST_F(UsbDeviceHandleTest, InterruptTransfer) {
   handle->GenericTransfer(UsbTransferDirection::OUTBOUND, 0x01,
                           out_buffer.get(), out_buffer->size(),
                           5000,   
                          out_completion.GetCallback());
   out_completion.WaitForResult();
   ASSERT_EQ(UsbTransferStatus::COMPLETED, out_completion.status());
   EXPECT_EQ(static_cast<size_t>(out_buffer->size()),
  TEST_F(UsbDeviceHandleTest, InterruptTransfer) {
   }
 
   TestResultCallback release_interface;
  handle->ReleaseInterface(0, release_interface.GetCallback());
   ASSERT_TRUE(release_interface.WaitForResult());
 
   handle->Close();
  TEST_F(UsbDeviceHandleTest, BulkTransfer) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(1, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   EXPECT_FALSE(handle->FindInterfaceByEndpoint(0x81));
  TEST_F(UsbDeviceHandleTest, BulkTransfer) {
   handle->GenericTransfer(UsbTransferDirection::INBOUND, 0x82, in_buffer.get(),
                           in_buffer->size(),
                           5000,   
                          in_completion.GetCallback());
 
   scoped_refptr<net::IOBufferWithSize> out_buffer(
       new net::IOBufferWithSize(in_buffer->size()));
  TEST_F(UsbDeviceHandleTest, BulkTransfer) {
   handle->GenericTransfer(UsbTransferDirection::OUTBOUND, 0x02,
                           out_buffer.get(), out_buffer->size(),
                           5000,   
                          out_completion.GetCallback());
   out_completion.WaitForResult();
   ASSERT_EQ(UsbTransferStatus::COMPLETED, out_completion.status());
   EXPECT_EQ(static_cast<size_t>(out_buffer->size()),
  TEST_F(UsbDeviceHandleTest, BulkTransfer) {
   }
 
   TestResultCallback release_interface;
  handle->ReleaseInterface(1, release_interface.GetCallback());
   ASSERT_TRUE(release_interface.WaitForResult());
 
   handle->Close();
  TEST_F(UsbDeviceHandleTest, ControlTransfer) {
   ASSERT_TRUE(gadget.get());
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
  TEST_F(UsbDeviceHandleTest, ControlTransfer) {
   handle->ControlTransfer(
       UsbTransferDirection::INBOUND, UsbControlTransferType::STANDARD,
       UsbControlTransferRecipient::DEVICE, 0x06, 0x0301, 0x0409, buffer,
      buffer->size(), 0, completion.GetCallback());
   completion.WaitForResult();
   ASSERT_EQ(UsbTransferStatus::COMPLETED, completion.status());
   const char expected_str[] = ""\x18\x03G\0o\0o\0g\0l\0e\0 \0I\0n\0c\0.\0"";
  TEST_F(UsbDeviceHandleTest, SetInterfaceAlternateSetting) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(2, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   TestResultCallback set_interface;
  handle->SetInterfaceAlternateSetting(2, 1, set_interface.GetCallback());
   ASSERT_TRUE(set_interface.WaitForResult());
 
   TestResultCallback release_interface;
  handle->ReleaseInterface(2, release_interface.GetCallback());
   ASSERT_TRUE(release_interface.WaitForResult());
 
   handle->Close();
  TEST_F(UsbDeviceHandleTest, CancelOnClose) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(1, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   scoped_refptr<net::IOBufferWithSize> buffer(new net::IOBufferWithSize(512));
   TestCompletionCallback completion;
   handle->GenericTransfer(UsbTransferDirection::INBOUND, 0x82, buffer.get(),
                           buffer->size(),
                           5000,   
                          completion.GetCallback());
 
   handle->Close();
   completion.WaitForResult();
  TEST_F(UsbDeviceHandleTest, CancelOnDisconnect) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(1, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   scoped_refptr<net::IOBufferWithSize> buffer(new net::IOBufferWithSize(512));
   TestCompletionCallback completion;
   handle->GenericTransfer(UsbTransferDirection::INBOUND, 0x82, buffer.get(),
                           buffer->size(),
                           5000,   
                          completion.GetCallback());
 
   ASSERT_TRUE(gadget->Disconnect());
   completion.WaitForResult();
  TEST_F(UsbDeviceHandleTest, Timeout) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(1, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   scoped_refptr<net::IOBufferWithSize> buffer(new net::IOBufferWithSize(512));
   TestCompletionCallback completion;
   handle->GenericTransfer(UsbTransferDirection::INBOUND, 0x82, buffer.get(),
                           buffer->size(),
                           10,   
                          completion.GetCallback());
 
   completion.WaitForResult();
   ASSERT_EQ(UsbTransferStatus::TIMEOUT, completion.status());
  TEST_F(UsbDeviceHandleTest, CloseReentrancy) {
   ASSERT_TRUE(gadget->SetType(UsbTestGadget::ECHO));
 
   TestOpenCallback open_device;
  gadget->GetDevice()->Open(open_device.GetCallback());
   scoped_refptr<UsbDeviceHandle> handle = open_device.WaitForResult();
   ASSERT_TRUE(handle.get());
 
   TestResultCallback claim_interface;
  handle->ClaimInterface(1, claim_interface.GetCallback());
   ASSERT_TRUE(claim_interface.WaitForResult());
 
   base::RunLoop run_loop;",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2914,CVE-2015-1265,"  bool SVGFEColorMatrixElement::setFilterEffectAttribute(FilterEffect* effect, con
     FEColorMatrix* colorMatrix = static_cast<FEColorMatrix*>(effect);
     if (attrName == SVGNames::typeAttr)
         return colorMatrix->setType(m_type->currentValue()->enumValue());
    if (attrName == SVGNames::valuesAttr) {
        Vector<float> values = m_values->currentValue()->toFloatVector();
        if (values.size() == 20)
            return colorMatrix->setValues(m_values->currentValue()->toFloatVector());
        return false;
    }
 
     ASSERT_NOT_REACHED();
     return false;",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2915,CVE-2015-1265," 
 #include ""content/browser/renderer_host/media/audio_input_device_manager.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/media_device_id.h""
#include ""media/audio/audio_system.h""
 #include ""media/base/limits.h""
 
 namespace {
  media::AudioParameters TryToFixAudioParameters(
              : media::AudioParameters::UnavailableDeviceParams();
 }
 
 }   
 
 namespace content {
 
 AudioOutputAuthorizationHandler::AudioOutputAuthorizationHandler(
    media::AudioSystem* audio_system,
     MediaStreamManager* media_stream_manager,
     int render_process_id,
     const std::string& salt)
    : audio_system_(audio_system),
       media_stream_manager_(media_stream_manager),
       permission_checker_(base::MakeUnique<MediaDevicesPermissionChecker>()),
       render_process_id_(render_process_id),
  void AudioOutputAuthorizationHandler::GetDeviceParameters(
     const std::string& raw_device_id) const {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(!raw_device_id.empty());
  audio_system_->GetOutputStreamParameters(
      raw_device_id,
       base::Bind(&AudioOutputAuthorizationHandler::DeviceParametersReceived,
                  weak_factory_.GetWeakPtr(), std::move(cb), false,
                  raw_device_id));",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2916,CVE-2015-1265,"  VREyeParameters* VRDisplay::getEyeParameters(const String& which_eye) {
 }
 
 int VRDisplay::requestAnimationFrame(FrameRequestCallback* callback) {
  DVLOG(2) << __FUNCTION__;
   Document* doc = this->GetDocument();
   if (!doc)
     return 0;
  pending_vrdisplay_raf_ = true;
   if (!vr_v_sync_provider_.is_bound()) {
     ConnectVSyncProvider();
   } else if (!display_blurred_ && !pending_vsync_) {
  int VRDisplay::requestAnimationFrame(FrameRequestCallback* callback) {
 }
 
 void VRDisplay::cancelAnimationFrame(int id) {
  DVLOG(2) << __FUNCTION__;
   if (!scripted_animation_controller_)
     return;
   scripted_animation_controller_->CancelCallback(id);
 }
 
 void VRDisplay::OnBlur() {
  DVLOG(1) << __FUNCTION__;
   display_blurred_ = true;
   vr_v_sync_provider_.reset();
   navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
       EventTypeNames::vrdisplayblur, true, false, this, """"));
 }
 
 void VRDisplay::OnFocus() {
  DVLOG(1) << __FUNCTION__;
   display_blurred_ = false;
   ConnectVSyncProvider();
   navigator_vr_->EnqueueVREvent(VRDisplayEvent::Create(
  void ReportPresentationResult(PresentationResult result) {
 
 ScriptPromise VRDisplay::requestPresent(ScriptState* script_state,
                                         const HeapVector<VRLayer>& layers) {
  DVLOG(1) << __FUNCTION__;
   ExecutionContext* execution_context = ExecutionContext::From(script_state);
   UseCounter::Count(execution_context, UseCounter::kVRRequestPresent);
   if (!execution_context->IsSecureContext()) {
  void VRDisplay::OnPresentComplete(bool success) {
 }
 
 ScriptPromise VRDisplay::exitPresent(ScriptState* script_state) {
  DVLOG(1) << __FUNCTION__;
   ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);
   ScriptPromise promise = resolver->Promise();
 
  void VRDisplay::BeginPresent() {
     resolver->Resolve();
   }
   OnPresentChange();

   
   
   
  if (!pending_vrdisplay_raf_ && !capabilities_->hasExternalDisplay()) {
    double timestamp = WTF::MonotonicallyIncreasingTime();
    Platform::Current()->CurrentThread()->GetWebTaskRunner()->PostTask(
        BLINK_FROM_HERE, WTF::Bind(&VRDisplay::ProcessScheduledWindowAnimations,
                                   WrapWeakPersistent(this), timestamp));
  }
 }
 
  
  Document* VRDisplay::GetDocument() {
 }
 
 void VRDisplay::OnPresentChange() {
  DVLOG(1) << __FUNCTION__ << "": is_presenting_="" << is_presenting_;
   if (is_presenting_ && !is_valid_device_for_presenting_) {
     DVLOG(1) << __FUNCTION__ << "": device not valid, not sending event"";
     return;
  void VRDisplay::ProcessScheduledWindowAnimations(double timestamp) {
   auto page = doc->GetPage();
   if (!page)
     return;

  bool had_pending_vrdisplay_raf = pending_vrdisplay_raf_;
    
   page->Animator().ServiceScriptedAnimations(timestamp);

  if (had_pending_vrdisplay_raf != pending_vrdisplay_raf_) {
    DVLOG(1) << __FUNCTION__
             << "": window.rAF fallback successfully scheduled VRDisplay.rAF"";
  }

  if (!pending_vrdisplay_raf_) {
     
     
     
     
    DVLOG(1) << __FUNCTION__
             << "": no scheduled VRDisplay.requestAnimationFrame, presentation ""
                ""broken?"";
  }
 }
 
 void VRDisplay::ProcessScheduledAnimations(double timestamp) {
  DVLOG(2) << __FUNCTION__;
    
    
   Document* doc = this->GetDocument();
  if (!doc || display_blurred_) {
    DVLOG(2) << __FUNCTION__ << "": early exit, doc="" << doc
             << "" display_blurred_="" << display_blurred_;
     return;
  }
 
   TRACE_EVENT1(""gpu"", ""VRDisplay::OnVSync"", ""frame"", vr_frame_id_);
 
  if (pending_vrdisplay_raf_ && scripted_animation_controller_) {
     
     
     
    AutoReset<bool> animating(&in_animation_frame_, true);
    pending_vrdisplay_raf_ = false;
    scripted_animation_controller_->ServiceScriptedAnimations(timestamp);
  }
 
    
    
  void VRDisplay::OnVSync(device::mojom::blink::VRPosePtr pose,
                         mojo::common::mojom::blink::TimeDeltaPtr time,
                         int16_t frame_id,
                         device::mojom::blink::VRVSyncProvider::Status error) {
  DVLOG(2) << __FUNCTION__;
   v_sync_connection_failed_ = false;
   switch (error) {
     case device::mojom::blink::VRVSyncProvider::Status::SUCCESS:
  void VRDisplay::ConnectVSyncProvider() {
   display_->GetVRVSyncProvider(mojo::MakeRequest(&vr_v_sync_provider_));
   vr_v_sync_provider_.set_connection_error_handler(ConvertToBaseCallback(
       WTF::Bind(&VRDisplay::OnVSyncConnectionError, WrapWeakPersistent(this))));
  if (pending_vrdisplay_raf_ && !display_blurred_) {
     pending_vsync_ = true;
     vr_v_sync_provider_->GetVSync(ConvertToBaseCallback(
         WTF::Bind(&VRDisplay::OnVSync, WrapWeakPersistent(this))));
  bool VRDisplay::HasPendingActivity() const {
 
 void VRDisplay::FocusChanged() {
    
  DVLOG(1) << __FUNCTION__;
   vr_v_sync_provider_.reset();
   ConnectVSyncProvider();
 }",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2917,CVE-2015-1265,"  IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
             ExecuteJavascriptAndReturnResult(constraints_1_1));
 }
 
 
 
IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
                       AudioInIFrameAndCloseInSuccessCb) {
  ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

  GURL url(embedded_test_server()->GetURL(""/media/getusermedia.html""));
  NavigateToURL(shell(), url);

  std::string call =
      ""getUserMediaInIframeAndCloseInSuccessCb({audio: true});"";
  ExecuteJavascriptAndWaitForOk(call);
}

IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
                       VideoInIFrameAndCloseInSuccessCb) {
  ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

  GURL url(embedded_test_server()->GetURL(""/media/getusermedia.html""));
  NavigateToURL(shell(), url);

  std::string call =
      ""getUserMediaInIframeAndCloseInSuccessCb({video: true});"";
  ExecuteJavascriptAndWaitForOk(call);
}

 
 
IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
                       VideoWithBadConstraintsInIFrameAndCloseInFailureCb) {
  ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

  GURL url(embedded_test_server()->GetURL(""/media/getusermedia.html""));

  int large_value = 99999;
  std::string call =
      GenerateGetUserMediaCall(""getUserMediaInIframeAndCloseInFailureCb"",
                               large_value,
                               large_value,
                               large_value,
                               large_value,
                               large_value,
                               large_value);
  NavigateToURL(shell(), url);

  ExecuteJavascriptAndWaitForOk(call);
}

IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
                       InvalidSourceIdInIFrameAndCloseInFailureCb) {
  ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

  GURL url(embedded_test_server()->GetURL(""/media/getusermedia.html""));

  std::string call =
      GenerateGetUserMediaWithMandatorySourceID(
          ""getUserMediaInIframeAndCloseInFailureCb"", ""invalid"", ""invalid"");
  NavigateToURL(shell(), url);

  ExecuteJavascriptAndWaitForOk(call);
}

 namespace {
 
 struct UserMediaSizes {",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2918,CVE-2015-1265,"  void HostCache::Entry::GetStaleness(base::TimeTicks now,
 }
 
 HostCache::HostCache(size_t max_entries)
    : max_entries_(max_entries), network_changes_(0), delegate_(nullptr) {}
 
 HostCache::~HostCache() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  void HostCache::Set(const Key& key,
   if (caching_is_disabled())
     return;
 
  bool result_changed = false;
   auto it = entries_.find(key);
   if (it != entries_.end()) {
     bool is_stale = it->second.IsStale(now, network_changes_);
    AddressListDeltaType delta =
        FindAddressListDeltaType(it->second.addresses(), entry.addresses());
     RecordSet(is_stale ? SET_UPDATE_STALE : SET_UPDATE_VALID, now, &it->second,
              entry, delta);
      
      
    result_changed =
        entry.error() == OK &&
        (it->second.error() != entry.error() || delta != DELTA_IDENTICAL);
     entries_.erase(it);
   } else {
    result_changed = true;
     if (size() == max_entries_)
       EvictOneEntry(now);
    RecordSet(SET_INSERT, now, nullptr, entry, DELTA_DISJOINT);
   }
 
   AddEntry(Key(key), Entry(entry, now, ttl, network_changes_));

  if (delegate_ && result_changed)
    delegate_->ScheduleWrite();
 }
 
 void HostCache::AddEntry(const Key& key, const Entry& entry) {
  void HostCache::OnNetworkChange() {
 void HostCache::clear() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   RecordEraseAll(ERASE_CLEAR, base::TimeTicks::Now());

   
  if (size() == 0)
    return;

   entries_.clear();
  if (delegate_)
    delegate_->ScheduleWrite();
 }
 
 void HostCache::ClearForHosts(
  void HostCache::ClearForHosts(
     return;
   }
 
  bool changed = false;
   base::TimeTicks now = base::TimeTicks::Now();
   for (EntryMap::iterator it = entries_.begin(); it != entries_.end();) {
     EntryMap::iterator next_it = std::next(it);
 
     if (host_filter.Run(it->first.hostname)) {
       RecordErase(ERASE_CLEAR, now, it->second);
       entries_.erase(it);
      changed = true;
     }
 
     it = next_it;
   }

  if (delegate_ && changed)
    delegate_->ScheduleWrite();
 }
 
 std::unique_ptr<base::ListValue> HostCache::GetAsListValue(
  void HostCache::EvictOneEntry(base::TimeTicks now) {
 void HostCache::RecordSet(SetOutcome outcome,
                           base::TimeTicks now,
                           const Entry* old_entry,
                          const Entry& new_entry,
                          AddressListDeltaType delta) {
   CACHE_HISTOGRAM_ENUM(""Set"", outcome, MAX_SET_OUTCOME);
   switch (outcome) {
     case SET_INSERT:
  void HostCache::RecordSet(SetOutcome outcome,
                             stale.network_changes);
       CACHE_HISTOGRAM_COUNT(""UpdateStale.StaleHits"", stale.stale_hits);
       if (old_entry->error() == OK && new_entry.error() == OK) {
         RecordUpdateStale(delta, stale);
       }
       break;",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2919,CVE-2015-1265,"  void Editor::RevealSelectionAfterEditingOperation(
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
 
 
 
void Transpose(LocalFrame& frame) {
  Editor& editor = frame.GetEditor();
  if (!editor.CanEdit())
     return;
 
  Document* const document = frame.GetDocument();

    
    
  document->UpdateStyleAndLayoutIgnorePendingStylesheets();
 
  const EphemeralRange& range = ComputeRangeForTranspose(frame);
   if (range.IsNull())
     return;
 
  void Editor::Transpose() {
   const String& transposed = text.Right(1) + text.Left(1);
 
   if (DispatchBeforeInputInsertText(
          EventTargetNodeForDocument(document), transposed,
           InputEvent::InputType::kInsertTranspose,
           new StaticRangeVector(1, StaticRange::Create(range))) !=
       DispatchEventResult::kNotCanceled)
     return;
 
   
  if (frame.GetDocument() != document)
     return;
 
    
    
  document->UpdateStyleAndLayoutIgnorePendingStylesheets();
 
    
    
  const EphemeralRange& new_range = ComputeRangeForTranspose(frame);
   if (new_range.IsNull())
     return;
 
  void Editor::Transpose() {
 
    
   if (CreateVisibleSelection(new_selection) !=
      frame.Selection().ComputeVisibleSelectionInDOMTree())
    frame.Selection().SetSelection(new_selection);
 
    
  editor.ReplaceSelectionWithText(new_transposed, false, false,
                                  InputEvent::InputType::kInsertTranspose);
 }
 
 void Editor::AddToKillRing(const EphemeralRange& range) {",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2920,," 
 
 #include ""content/renderer/media/render_media_client.h""
 
#include ""base/command_line.h""
 #include ""base/logging.h""
 #include ""base/time/default_tick_clock.h""
 #include ""content/public/common/content_client.h""
 #include ""content/public/renderer/content_renderer_client.h""
#include ""media/base/media_switches.h""
#include ""media/base/video_color_space.h""
#include ""ui/base/ui_base_switches.h""
 
 namespace content {
 
  void RenderMediaClient::RecordRapporURL(const std::string& metric,
   GetContentClient()->renderer()->RecordRapporURL(metric, url);
 }
 
bool IsColorSpaceSupported(const media::VideoColorSpace& color_space) {
  bool color_management =
      base::CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableHDROutput) ||
      base::FeatureList::IsEnabled(media::kVideoColorManagement);
  switch (color_space.primaries) {
    case media::VideoColorSpace::PrimaryID::EBU_3213_E:
    case media::VideoColorSpace::PrimaryID::INVALID:
      return false;

      
    case media::VideoColorSpace::PrimaryID::BT709:
    case media::VideoColorSpace::PrimaryID::UNSPECIFIED:
    case media::VideoColorSpace::PrimaryID::BT470M:
    case media::VideoColorSpace::PrimaryID::BT470BG:
    case media::VideoColorSpace::PrimaryID::SMPTE170M:
      break;

     
    case media::VideoColorSpace::PrimaryID::SMPTE240M:
    case media::VideoColorSpace::PrimaryID::FILM:
    case media::VideoColorSpace::PrimaryID::BT2020:
    case media::VideoColorSpace::PrimaryID::SMPTEST428_1:
    case media::VideoColorSpace::PrimaryID::SMPTEST431_2:
    case media::VideoColorSpace::PrimaryID::SMPTEST432_1:
      if (!color_management)
        return false;
      break;
  }

  switch (color_space.transfer) {
     
    case media::VideoColorSpace::TransferID::UNSPECIFIED:
    case media::VideoColorSpace::TransferID::GAMMA22:
    case media::VideoColorSpace::TransferID::BT709:
    case media::VideoColorSpace::TransferID::SMPTE170M:
    case media::VideoColorSpace::TransferID::BT2020_10:
    case media::VideoColorSpace::TransferID::BT2020_12:
    case media::VideoColorSpace::TransferID::IEC61966_2_1:
      break;

     
    case media::VideoColorSpace::TransferID::GAMMA28:
    case media::VideoColorSpace::TransferID::SMPTE240M:
    case media::VideoColorSpace::TransferID::LINEAR:
    case media::VideoColorSpace::TransferID::LOG:
    case media::VideoColorSpace::TransferID::LOG_SQRT:
    case media::VideoColorSpace::TransferID::BT1361_ECG:
    case media::VideoColorSpace::TransferID::SMPTEST2084:
    case media::VideoColorSpace::TransferID::IEC61966_2_4:
    case media::VideoColorSpace::TransferID::SMPTEST428_1:
    case media::VideoColorSpace::TransferID::ARIB_STD_B67:
      if (!color_management)
        return false;
      break;

     
    case media::VideoColorSpace::TransferID::INVALID:
       return false;
   }

  switch (color_space.matrix) {
     
    case media::VideoColorSpace::MatrixID::BT709:
    case media::VideoColorSpace::MatrixID::UNSPECIFIED:
    case media::VideoColorSpace::MatrixID::BT470BG:
    case media::VideoColorSpace::MatrixID::SMPTE170M:
    case media::VideoColorSpace::MatrixID::BT2020_NCL:
      break;

     
    case media::VideoColorSpace::MatrixID::RGB:
    case media::VideoColorSpace::MatrixID::FCC:
    case media::VideoColorSpace::MatrixID::SMPTE240M:
    case media::VideoColorSpace::MatrixID::YCOCG:
    case media::VideoColorSpace::MatrixID::YDZDX:
    case media::VideoColorSpace::MatrixID::BT2020_CL:
      if (!color_management)
        return false;
      break;

     
    case media::VideoColorSpace::MatrixID::INVALID:
      return false;
  }

  if (color_space.range == gfx::ColorSpace::RangeID::INVALID)
    return false;

  return true;
 }
 
 bool RenderMediaClient::IsSupportedVideoConfig(
  bool RenderMediaClient::IsSupportedVideoConfig(
   switch (config.codec) {
     case media::kCodecVP9:
        
      return IsColorSpaceSupported(config.color_space);
 
     case media::kCodecH264:
     case media::kCodecVP8:",
2921,,"  void ResourceFetcher::RequestLoadStarted(unsigned long identifier,
                                          RevalidationPolicy policy,
                                          bool is_static_data) {
   if (policy == kUse && resource->GetStatus() == ResourceStatus::kCached &&
      !validated_urls_.Contains(resource->Url())) {
      
     DidLoadResourceFromMemoryCache(identifier, resource,
                                    request.GetResourceRequest());
  void ResourceFetcher::RequestLoadStarted(unsigned long identifier,
     return;
 
   if (policy == kUse && !resource->StillNeedsLoad() &&
      !validated_urls_.Contains(request.GetResourceRequest().Url())) {
      
      
     RefPtr<ResourceTimingInfo> info = ResourceTimingInfo::Create(
  void ResourceFetcher::RequestLoadStarted(unsigned long identifier,
       resource_timing_report_timer_.StartOneShot(0, BLINK_FROM_HERE);
   }
 
  if (validated_urls_.size() >= kMaxValidatedURLsSize) {
    validated_urls_.Clear();
   }
  validated_urls_.insert(request.GetResourceRequest().Url());
 }
 
 void ResourceFetcher::DidLoadResourceFromMemoryCache(
  ResourceFetcher::DetermineRevalidationPolicy(Resource::Type type,
    
   if (type != Resource::kRaw) {
     if (!Context().IsLoadComplete() &&
        validated_urls_.Contains(existing_resource->Url()))
       return kUse;
     if (existing_resource->IsLoading())
       return kUse;
  void ResourceFetcher::PreloadStarted(Resource* resource) {
     preloads_ = new HeapListHashSet<Member<Resource>>;
   preloads_->insert(resource);
 
  if (preloaded_urls_for_test_)
    preloaded_urls_for_test_->insert(resource->Url().GetString());
 }
 
 void ResourceFetcher::EnableIsPreloadedForTest() {
  if (preloaded_urls_for_test_)
     return;
  preloaded_urls_for_test_ = WTF::WrapUnique(new HashSet<String>);
 
   if (preloads_) {
     for (const auto& resource : *preloads_)
      preloaded_urls_for_test_->insert(resource->Url().GetString());
   }
 }
 
 bool ResourceFetcher::IsPreloadedForTest(const KURL& url) const {
  DCHECK(preloaded_urls_for_test_);
  return preloaded_urls_for_test_->Contains(url.GetString());
 }
 
 void ResourceFetcher::ClearPreloads(ClearPreloadsPolicy policy) {",
2922,,"  namespace content {
 
 OffscreenCanvasFrameReceiverImpl::OffscreenCanvasFrameReceiverImpl() {}
 
OffscreenCanvasFrameReceiverImpl::~OffscreenCanvasFrameReceiverImpl() {
  if (surface_factory_) {
    if (!GetSurfaceManager()) {
       
       
      surface_factory_->DidDestroySurfaceManager();
    } else {
      GetSurfaceManager()->InvalidateSurfaceClientId(surface_id_.client_id());
    }
    surface_factory_->Destroy(surface_id_);
  }
}
 
  
 void OffscreenCanvasFrameReceiverImpl::Create(
  void OffscreenCanvasFrameReceiverImpl::Create(
 void OffscreenCanvasFrameReceiverImpl::SubmitCompositorFrame(
     const cc::SurfaceId& surface_id,
     cc::CompositorFrame frame) {
  if (!surface_factory_) {
    cc::SurfaceManager* manager = GetSurfaceManager();
    surface_factory_ = base::MakeUnique<cc::SurfaceFactory>(manager, this);
    surface_factory_->Create(surface_id);

    GetSurfaceManager()->RegisterSurfaceClientId(surface_id.client_id());
  }
  if (surface_id_.is_null()) {
    surface_id_ = surface_id;
     }
    surface_factory_->SubmitCompositorFrame(surface_id, std::move(frame),
                                            base::Closure());
 }
 
 
 
void OffscreenCanvasFrameReceiverImpl::ReturnResources(
    const cc::ReturnedResourceArray& resources) {}

void OffscreenCanvasFrameReceiverImpl::WillDrawSurface(
    const cc::SurfaceId& id,
    const gfx::Rect& damage_rect) {}

void OffscreenCanvasFrameReceiverImpl::SetBeginFrameSource(
    cc::BeginFrameSource* begin_frame_source) {}

 }   ",
2923,,"  void OpenPDFInReaderView::Update(content::WebContents* web_contents) {
   }
 
   SetVisible(!!model_);

   
  if (!model_ && bubble_)
    bubble_->GetWidget()->Hide();
 }
 
 void OpenPDFInReaderView::ShowBubble() {",
2924,,"  void Shell::Init(const ShellInitParams& init_params) {
       display_manager_.get(), window_tree_host_manager_.get()));
 
 #if defined(OS_CHROMEOS)
   
   
   
   
  if (in_mus_)
    display_configurator_->set_configure_display(false);
   display_configurator_->Init(!gpu_support_->IsPanelFittingDisabled());
 
    ",
2925,CVE-2015-1249,"  const int kDefaultZeroSuggestRelevance = 100;
  
 constexpr char kArbitraryInsecureUrlString[] = ""http://www.google.com/"";
 
 
 
 
 
 
 
 
 
 
bool UseExperimentalSuggestService(const TemplateURLService& default_provider) {
  const TemplateURL& default_provider_url =
      *default_provider.GetDefaultSearchProvider();
  const SearchTermsData& search_terms_data =
      default_provider.search_terms_data();
  if ((default_provider_url.GetEngineType(search_terms_data) !=
       SEARCH_ENGINE_GOOGLE) ||
      !OmniboxFieldTrial::InZeroSuggestRedirectToChromeFieldTrial())
    return false;
   
  const GURL suggest_url(
      OmniboxFieldTrial::ZeroSuggestRedirectToChromeServerAddress());
  if (!suggest_url.is_valid())
    return false;
  return suggest_url.SchemeIsCryptographic();
}

 }   
 
  
  void ZeroSuggestProvider::Start(const AutocompleteInput& input,
   current_page_classification_ = input.current_page_classification();
   current_url_match_ = MatchForCurrentURL();
 
  GURL suggest_url(GetContextualSuggestionsUrl());
   if (!suggest_url.is_valid())
     return;
 
  void ZeroSuggestProvider::Start(const AutocompleteInput& input,
       !OmniboxFieldTrial::InZeroSuggestPersonalizedFieldTrial() &&
       !OmniboxFieldTrial::InZeroSuggestMostVisitedFieldTrial()) {
      
    if (UseExperimentalSuggestService(*template_url_service)) {
      suggest_url = GURL(
          OmniboxFieldTrial::ZeroSuggestRedirectToChromeServerAddress() +
           ""/url="" + net::EscapePath(current_query_) +
          OmniboxFieldTrial::ZeroSuggestRedirectToChromeAdditionalFields());
     } else {
       base::string16 prefix;
       TemplateURLRef::SearchTermsArgs search_term_args(prefix);
  bool ZeroSuggestProvider::ShouldShowNonContextualZeroSuggest(
 }
 
 std::string ZeroSuggestProvider::GetContextualSuggestionsUrl() const {
   const TemplateURLService* template_url_service =
       client()->GetTemplateURLService();
   const TemplateURL* default_provider =
       template_url_service->GetDefaultSearchProvider();
   if (default_provider == nullptr)
     return std::string();
 
   base::string16 prefix;
   TemplateURLRef::SearchTermsArgs search_term_args(prefix);
   return default_provider->suggestions_url_ref().ReplaceSearchTerms(",Multiple unspecified vulnerabilities in Google Chrome before 42.0.2311.90 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2926,CVE-2015-1232,"  void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client,
                                           uint32_t port_index,
                                           const std::vector<uint8>& data,
                                           double timestamp) {
  if (port_index >= output_streams_.size()) {
     
     
     
     
    return;
  }
   output_streams_[port_index]->Send(data);
   client->AccumulateMidiBytesSent(data.size());
 }","Array index error in the MidiManagerUsb::DispatchSendMidiData function in media/midi/midi_manager_usb.cc in Google Chrome before 41.0.2272.76 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging renderer access to provide an invalid port index that triggers an out-of-bounds write operation, a different vulnerability than CVE-2015-1212."
2927,CVE-2015-1213,"  bool MockContentSettingsClient::allowRunningInsecureContent(
 }
 
 bool MockContentSettingsClient::allowAutoplay(bool default_value) {
  return flags_->autoplay_allowed();
 }
 
 void MockContentSettingsClient::SetDelegate(WebTestDelegate* delegate) {","The SkBitmap::ReadRawPixels function in core/SkBitmap.cpp in the filters implementation in Skia, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an out-of-bounds write operation."
2928,CVE-2015-1215,"  ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptors(
 ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptorsImpl(
     ScriptState* scriptState,
     mojom::blink::WebBluetoothGATTQueryQuantity quantity,
    const String& descriptorsUUID) {
   if (!getGatt()->connected()) {
     return ScriptPromise::rejectWithDOMException(
         scriptState,
  ScriptPromise BluetoothRemoteGATTCharacteristic::getDescriptorsImpl(
   getGatt()->AddToActiveAlgorithms(resolver);
 
   mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();
   service->RemoteCharacteristicGetDescriptors(
      m_characteristic->instance_id, quantity, descriptorsUUID,
       convertToBaseCallback(
           WTF::bind(&BluetoothRemoteGATTCharacteristic::GetDescriptorsCallback,
                     wrapPersistent(this), m_characteristic->instance_id,","The filters implementation in Skia, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an out-of-bounds write operation."
2929,CVE-2015-1216,"  void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::Pro
     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())
         return;
 
     
    frame = window->frame();
     
    if (!frame)
        return;

      
     Document* doc = frame->document();
 ","Use-after-free vulnerability in the V8Window::namedPropertyGetterCustom function in bindings/core/v8/custom/V8WindowCustom.cpp in the V8 bindings in Blink, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a frame detachment."
2930,CVE-2015-1218,"  void Profile::RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterBooleanPref(prefs::kSafeBrowsingScoutReportingEnabled,
                                 false);
   registry->RegisterBooleanPref(prefs::kSafeBrowsingScoutGroupSelected, false);
  registry->RegisterBooleanPref(
      prefs::kSafeBrowsingSawInterstitialExtendedReporting, false);
  registry->RegisterBooleanPref(
      prefs::kSafeBrowsingSawInterstitialScoutReporting, false);
   registry->RegisterBooleanPref(prefs::kSafeBrowsingProceedAnywayDisabled,
                                 false);
   registry->RegisterBooleanPref(prefs::kSSLErrorOverrideAllowed, true);","Multiple use-after-free vulnerabilities in the DOM implementation in Blink, as used in Google Chrome before 41.0.2272.76, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger movement of a SCRIPT element to different documents, related to (1) the HTMLScriptElement::didMoveToNewDocument function in core/html/HTMLScriptElement.cpp and (2) the SVGScriptElement::didMoveToNewDocument function in core/svg/SVGScriptElement.cpp."
2931,CVE-2015-1220,"  using namespace blink;
 
 namespace {
 
const char decodersTestingDir[] = ""Source/platform/image-decoders/testing"";
const char layoutTestResourcesDir[] = ""LayoutTests/fast/images/resources"";
const char webTestsDataDir[] = ""Source/web/tests/data"";

PassRefPtr<SharedBuffer> readFile(const char* dir, const char* fileName)
 {
     String filePath = Platform::current()->unitTestSupport()->webKitRootDir();
    filePath.append(""/"");
    filePath.append(dir);
    filePath.append(""/"");
     filePath.append(fileName);
 
     return Platform::current()->unitTestSupport()->readFromFile(filePath);
  void createDecodingBaseline(SharedBuffer* data, Vector<unsigned>* baselineHashes
     }
 }
 
void testRandomFrameDecode(const char* dir, const char* gifFile)
 {
     SCOPED_TRACE(gifFile);
 
    RefPtr<SharedBuffer> fullData = readFile(dir, gifFile);
     ASSERT_TRUE(fullData.get());
     Vector<unsigned> baselineHashes;
     createDecodingBaseline(fullData.get(), &baselineHashes);
  void testRandomFrameDecode(const char* gifFile)
     }
 }
 
void testRandomDecodeAfterClearFrameBufferCache(const char* dir, const char* gifFile)
 {
     SCOPED_TRACE(gifFile);
 
    RefPtr<SharedBuffer> data = readFile(dir, gifFile);
     ASSERT_TRUE(data.get());
     Vector<unsigned> baselineHashes;
     createDecodingBaseline(data.get(), &baselineHashes);
  TEST(GIFImageDecoderTest, decodeTwoFrames)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated.gif"");
     ASSERT_TRUE(data.get());
     decoder->setData(data.get(), true);
     EXPECT_EQ(cAnimationLoopOnce, decoder->repetitionCount());
  TEST(GIFImageDecoderTest, parseAndDecode)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated.gif"");
     ASSERT_TRUE(data.get());
     decoder->setData(data.get(), true);
     EXPECT_EQ(cAnimationLoopOnce, decoder->repetitionCount());
  TEST(GIFImageDecoderTest, parseByteByByte)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated.gif"");
     ASSERT_TRUE(data.get());
 
     size_t frameCount = 0;
  TEST(GIFImageDecoderTest, parseAndDecodeByteByByte)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated-gif-with-offsets.gif"");
     ASSERT_TRUE(data.get());
 
     size_t frameCount = 0;
  TEST(GIFImageDecoderTest, brokenSecondFrame)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(webTestsDataDir, ""broken.gif"");
     ASSERT_TRUE(data.get());
     decoder->setData(data.get(), true);
 
  TEST(GIFImageDecoderTest, brokenSecondFrame)
 
 TEST(GIFImageDecoderTest, progressiveDecode)
 {
    RefPtr<SharedBuffer> fullData = readFile(webTestsDataDir, ""radient.gif"");
     ASSERT_TRUE(fullData.get());
     const size_t fullLength = fullData->size();
 
  TEST(GIFImageDecoderTest, allDataReceivedTruncation)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated.gif"");
     ASSERT_TRUE(data.get());
 
     ASSERT_GE(data->size(), 10u);
  TEST(GIFImageDecoderTest, frameIsComplete)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated.gif"");
     ASSERT_TRUE(data.get());
     decoder->setData(data.get(), true);
 
  TEST(GIFImageDecoderTest, frameIsCompleteLoading)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> data = readFile(layoutTestResourcesDir, ""animated.gif"");
     ASSERT_TRUE(data.get());
 
     ASSERT_GE(data->size(), 10u);
  TEST(GIFImageDecoderTest, frameIsCompleteLoading)
 
 TEST(GIFImageDecoderTest, badTerminator)
 {
    RefPtr<SharedBuffer> referenceData = readFile(webTestsDataDir, ""radient.gif"");
    RefPtr<SharedBuffer> testData = readFile(webTestsDataDir, ""radient-bad-terminator.gif"");
     ASSERT_TRUE(referenceData.get());
     ASSERT_TRUE(testData.get());
 
  TEST(GIFImageDecoderTest, updateRequiredPreviousFrameAfterFirstDecode)
 {
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
    RefPtr<SharedBuffer> fullData = readFile(layoutTestResourcesDir, ""animated-10color.gif"");
     ASSERT_TRUE(fullData.get());
 
      
  TEST(GIFImageDecoderTest, updateRequiredPreviousFrameAfterFirstDecode)
 TEST(GIFImageDecoderTest, randomFrameDecode)
 {
      
    testRandomFrameDecode(webTestsDataDir, ""radient.gif"");
      
    testRandomFrameDecode(layoutTestResourcesDir, ""animated-gif-with-offsets.gif"");
    testRandomFrameDecode(layoutTestResourcesDir, ""animated-10color.gif"");
 }
 
 TEST(GIFImageDecoderTest, randomDecodeAfterClearFrameBufferCache)
 {
      
    testRandomDecodeAfterClearFrameBufferCache(webTestsDataDir, ""radient.gif"");
      
    testRandomDecodeAfterClearFrameBufferCache(layoutTestResourcesDir, ""animated-gif-with-offsets.gif"");
    testRandomDecodeAfterClearFrameBufferCache(layoutTestResourcesDir, ""animated-10color.gif"");
 }
 
 TEST(GIFImageDecoderTest, resumePartialDecodeAfterClearFrameBufferCache)
 {
    RefPtr<SharedBuffer> fullData = readFile(layoutTestResourcesDir, ""animated-10color.gif"");
     ASSERT_TRUE(fullData.get());
     Vector<unsigned> baselineHashes;
     createDecodingBaseline(fullData.get(), &baselineHashes);
  TEST(GIFImageDecoderTest, resumePartialDecodeAfterClearFrameBufferCache)
  
 TEST(GIFImageDecoderTest, badInitialCode)
 {
    RefPtr<SharedBuffer> testData = readFile(decodersTestingDir, ""bad-initial-code.gif"");
     ASSERT_TRUE(testData.get());
 
     OwnPtr<GIFImageDecoder> testDecoder(createDecoder());
  TEST(GIFImageDecoderTest, badInitialCode)
  
 TEST(GIFImageDecoderTest, badCode)
 {
    RefPtr<SharedBuffer> testData = readFile(decodersTestingDir, ""bad-code.gif"");
     ASSERT_TRUE(testData.get());
 
     OwnPtr<GIFImageDecoder> testDecoder(createDecoder());
  TEST(GIFImageDecoderTest, invalidDisposalMethod)
     OwnPtr<GIFImageDecoder> decoder = createDecoder();
 
      
    RefPtr<SharedBuffer> data = readFile(webTestsDataDir, ""invalid-disposal-method.gif"");
     ASSERT_TRUE(data.get());
     decoder->setData(data.get(), true);
 
  TEST(GIFImageDecoderTest, invalidDisposalMethod)
      
     EXPECT_EQ(ImageFrame::DisposeNotSpecified, decoder->frameBufferAtIndex(1)->disposalMethod());
 }

TEST(GIFImageDecoderTest, firstFrameHasGreaterSizeThanScreenSize)
{
    RefPtr<SharedBuffer> fullData = readFile(decodersTestingDir, ""first-frame-has-greater-size-than-screen-size.gif"");
    ASSERT_TRUE(fullData.get());

    OwnPtr<GIFImageDecoder> decoder;
    IntSize frameSize;

     
    for (size_t i = 1; i <= fullData->size(); ++i) {
        decoder = createDecoder();
        RefPtr<SharedBuffer> data = SharedBuffer::create(fullData->data(), i);
        decoder->setData(data.get(), i == fullData->size());

        if (decoder->isSizeAvailable() && !frameSize.width() && !frameSize.height()) {
            frameSize = decoder->decodedSize();
            continue;
        }

        ASSERT_EQ(frameSize.width(), decoder->decodedSize().width());
        ASSERT_EQ(frameSize.height(), decoder->decodedSize().height());
    }
}","Use-after-free vulnerability in the GIFImageReader::parseData function in platform/image-decoders/gif/GIFImageReader.cpp in Blink, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted frame size in a GIF image."
2932,CVE-2015-1221,"  bool Editor::insertTextWithoutSendingTextEvent(const String& text,
 
    
   TypingCommand::insertText(
      *selection.start().document(), text, selection.asSelection(),
       selectInsertedText ? TypingCommand::SelectInsertedText : 0,
       triggeringEvent && triggeringEvent->isComposition()
           ? TypingCommand::TextCompositionConfirm","Use-after-free vulnerability in Blink, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect ordering of operations in the Web SQL Database thread relative to Blink's main thread, related to the shutdown function in web/WebKit.cpp."
2933,CVE-2015-1223,"  bool PermissionUtil::GetPermissionType(ContentSettingsType type,
     *out = PermissionType::NOTIFICATIONS;
   } else if (type == CONTENT_SETTINGS_TYPE_PUSH_MESSAGING) {
     *out = PermissionType::PUSH_MESSAGING;
  } else if (type == CONTENT_SETTINGS_TYPE_MIDI) {
    *out = PermissionType::MIDI;
   } else if (type == CONTENT_SETTINGS_TYPE_MIDI_SYSEX) {
     *out = PermissionType::MIDI_SYSEX;
   } else if (type == CONTENT_SETTINGS_TYPE_DURABLE_STORAGE) {","Multiple use-after-free vulnerabilities in core/html/HTMLInputElement.cpp in the DOM implementation in Blink, as used in Google Chrome before 41.0.2272.76, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger extraneous change events, as demonstrated by events for invalid input or input to read-only fields, related to the initializeTypeInParsing and updateType functions."
2934,CVE-2015-1227,"  bool ShouldNotifyInState(base::android::ApplicationState state) {
   return false;
 }
 
int DayAsYYYYMMDD() {
  base::Time::Exploded now{};
  base::Time::Now().LocalExplode(&now);
  return (now.year * 10000) + (now.month * 100) + now.day_of_month;
}

bool HaveQuotaForToday(PrefService* prefs) {
  int today = DayAsYYYYMMDD();
  int limit = variations::GetVariationParamByFeatureAsInt(
      kContentSuggestionsNotificationsFeature,
      kContentSuggestionsNotificationsDailyLimit,
      kContentSuggestionsNotificationsDefaultDailyLimit);
  int sent =
      prefs->GetInteger(prefs::kContentSuggestionsNotificationsSentDay) == today
          ? prefs->GetInteger(prefs::kContentSuggestionsNotificationsSentCount)
          : 0;
  return sent < limit;
}

void ConsumeQuota(PrefService* prefs) {
  int sent =
      prefs->GetInteger(prefs::kContentSuggestionsNotificationsSentCount);
  int today = DayAsYYYYMMDD();
  if (prefs->GetInteger(prefs::kContentSuggestionsNotificationsSentDay) !=
      today) {
    prefs->SetInteger(prefs::kContentSuggestionsNotificationsSentDay, today);
    sent = 0;   
  }
  prefs->SetInteger(prefs::kContentSuggestionsNotificationsSentCount, sent + 1);
}

 }   
 
 class ContentSuggestionsNotifierService::NotifyingObserver
  class ContentSuggestionsNotifierService::NotifyingObserver
                    profile_)) {
       DVLOG(1) << ""Suppressed notification due to opt-out"";
       return;
    } else if (!HaveQuotaForToday(profile_->GetPrefs())) {
      DVLOG(1) << ""Notification suppressed due to daily limit"";
      return;
     }
     const ContentSuggestion* suggestion = GetSuggestionToNotifyAbout(category);
     if (!suggestion) {
  class ContentSuggestionsNotifierService::NotifyingObserver
      
     DVLOG(1) << ""Fetched "" << image.Size().width() << ""x""
              << image.Size().height() << "" image for "" << url.spec();
    ConsumeQuota(profile_->GetPrefs());
     if (ContentSuggestionsNotificationHelper::SendNotification(
             id, url, title, text, CropSquare(image), timeout_at)) {
       RecordContentSuggestionsNotificationImpression(
  void ContentSuggestionsNotifierService::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterIntegerPref(
       prefs::kContentSuggestionsConsecutiveIgnoredPrefName, 0);
  registry->RegisterIntegerPref(prefs::kContentSuggestionsNotificationsSentDay,
                                0);
  registry->RegisterIntegerPref(
      prefs::kContentSuggestionsNotificationsSentCount, 0);
 
    
   registry->RegisterStringPref(kNotificationIDWithinCategory, std::string());","The DragImage::create function in platform/DragImage.cpp in Blink, as used in Google Chrome before 41.0.2272.76, does not initialize memory for image drawing, which allows remote attackers to have an unspecified impact by triggering a failed image decoding, as demonstrated by an image for which the default orientation cannot be used."
2935,CVE-2015-1229,"  TEST_P(HttpNetworkTransactionTest, BasicAuthProxyKeepAlive) {
       NetLog::PHASE_NONE);
 
   const HttpResponseInfo* response = trans->GetResponseInfo();
  ASSERT_TRUE(response);
  ASSERT_TRUE(response->headers);
   EXPECT_TRUE(response->headers->IsKeepAlive());
   EXPECT_EQ(407, response->headers->response_code());
  EXPECT_EQ(-1, response->headers->GetContentLength());
   EXPECT_TRUE(HttpVersion(1, 1) == response->headers->GetHttpVersion());
   EXPECT_TRUE(CheckBasicProxyAuth(response->auth_challenge.get()));
 
  TEST_P(HttpNetworkTransactionTest, BasicAuthProxyKeepAlive) {
   EXPECT_EQ(OK, rv);
 
   response = trans->GetResponseInfo();
  ASSERT_TRUE(response);
  ASSERT_TRUE(response->headers);
   EXPECT_TRUE(response->headers->IsKeepAlive());
   EXPECT_EQ(407, response->headers->response_code());
  EXPECT_EQ(-1, response->headers->GetContentLength());
   EXPECT_TRUE(HttpVersion(1, 1) == response->headers->GetHttpVersion());
   EXPECT_TRUE(CheckBasicProxyAuth(response->auth_challenge.get()));
 
  TEST_P(HttpNetworkTransactionTest, BasicAuthProxyCancelTunnel) {
 
    
   MockRead data_reads[] = {
      MockRead(""HTTP/1.1 407 Proxy Authentication Required\r\n""),
      MockRead(""Proxy-Authenticate: Basic realm=\""MyRealm1\""\r\n""),
      MockRead(""Content-Length: 10\r\n\r\n""),
      MockRead(""0123456789""),   
      MockRead(SYNCHRONOUS, ERR_UNEXPECTED),
   };
 
   StaticSocketDataProvider data(data_reads, arraysize(data_reads),
  TEST_P(HttpNetworkTransactionTest, BasicAuthProxyCancelTunnel) {
   EXPECT_EQ(OK, rv);
 
   const HttpResponseInfo* response = trans->GetResponseInfo();
  ASSERT_TRUE(response);
  ASSERT_TRUE(response->headers);
  EXPECT_TRUE(response->headers->IsKeepAlive());
  EXPECT_EQ(407, response->headers->response_code());
  EXPECT_TRUE(HttpVersion(1, 1) == response->headers->GetHttpVersion());

  std::string response_data;
  rv = ReadTransaction(trans.get(), &response_data);
  EXPECT_EQ(ERR_TUNNEL_CONNECTION_FAILED, rv);

   
  session->CloseAllConnections();
}

 
 
TEST_P(HttpNetworkTransactionTest, SanitizeProxyAuthHeaders) {
  HttpRequestInfo request;
  request.method = ""GET"";
  request.url = GURL(""https://www.google.com/"");
  request.load_flags = 0;

   
  session_deps_.proxy_service.reset(ProxyService::CreateFixed(""myproxy:70""));

  scoped_refptr<HttpNetworkSession> session(CreateSession(&session_deps_));

  scoped_ptr<HttpTransaction> trans(
      new HttpNetworkTransaction(DEFAULT_PRIORITY, session.get()));

   
  MockWrite data_writes[] = {
      MockWrite(
          ""CONNECT www.google.com:443 HTTP/1.1\r\n""
          ""Host: www.google.com\r\n""
          ""Proxy-Connection: keep-alive\r\n\r\n""),
  };

   
  MockRead data_reads[] = {
      MockRead(""HTTP/1.1 407 Proxy Authentication Required\r\n""),
      MockRead(""X-Foo: bar\r\n""),
      MockRead(""Set-Cookie: foo=bar\r\n""),
      MockRead(""Proxy-Authenticate: Basic realm=\""MyRealm1\""\r\n""),
      MockRead(""Content-Length: 10\r\n\r\n""),
      MockRead(SYNCHRONOUS, ERR_UNEXPECTED),   
  };

  StaticSocketDataProvider data(data_reads, arraysize(data_reads), data_writes,
                                arraysize(data_writes));
  session_deps_.socket_factory->AddSocketDataProvider(&data);

  TestCompletionCallback callback;
 
  int rv = trans->Start(&request, callback.callback(), BoundNetLog());
  EXPECT_EQ(ERR_IO_PENDING, rv);

  rv = callback.WaitForResult();
  EXPECT_EQ(OK, rv);

  const HttpResponseInfo* response = trans->GetResponseInfo();
  ASSERT_TRUE(response);
  ASSERT_TRUE(response->headers);
   EXPECT_TRUE(response->headers->IsKeepAlive());
   EXPECT_EQ(407, response->headers->response_code());
   EXPECT_TRUE(HttpVersion(1, 1) == response->headers->GetHttpVersion());
  EXPECT_FALSE(response->headers->HasHeader(""X-Foo""));
  EXPECT_FALSE(response->headers->HasHeader(""Set-Cookie""));
 
   std::string response_data;
   rv = ReadTransaction(trans.get(), &response_data);","net/http/proxy_client_socket.cc in Google Chrome before 41.0.2272.76 does not properly handle a 407 (aka Proxy Authentication Required) HTTP status code accompanied by a Set-Cookie header, which allows remote proxy servers to conduct cookie-injection attacks via a crafted response."
2936,CVE-2015-1302," 
 
 const int kNumberLoadTestParts = 10;
 
bool GetGuestCallback(content::WebContents** guest_out,
                      content::WebContents* guest) {
  EXPECT_FALSE(*guest_out);
  *guest_out = guest;
   
   
  return false;
}

 class PDFExtensionTest : public ExtensionApiTest,
                          public testing::WithParamInterface<int> {
  public:
  class PDFExtensionTest : public ExtensionApiTest,
      
     ASSERT_GE(count, 1u);
   }

  void TestGetSelectedTextReply(GURL url, bool expect_success) {
    ui_test_utils::NavigateToURL(browser(), url);
    content::WebContents* web_contents =
        browser()->tab_strip_model()->GetActiveWebContents();
    ASSERT_TRUE(pdf_extension_test_util::EnsurePDFHasLoaded(web_contents));

     
     
    content::BrowserPluginGuestManager* guest_manager =
        web_contents->GetBrowserContext()->GetGuestManager();
    content::WebContents* guest_contents = nullptr;
    ASSERT_NO_FATAL_FAILURE(guest_manager->ForEachGuest(
        web_contents, base::Bind(&GetGuestCallback, &guest_contents)));
    ASSERT_TRUE(guest_contents);
    ASSERT_TRUE(content::ExecuteScript(
        guest_contents,
        ""var oldSendScriptingMessage = ""
        ""    PDFViewer.prototype.sendScriptingMessage_;""
        ""PDFViewer.prototype.sendScriptingMessage_ = function(message) {""
        ""  oldSendScriptingMessage.bind(this)(message);""
        ""  if (message.type == 'getSelectedTextReply')""
        ""    this.parentWindow_.postMessage('flush', '*');""
        ""}""));

     
     
     
    bool success = false;
    ASSERT_TRUE(content::ExecuteScriptAndExtractBool(
        web_contents,
        ""window.addEventListener('message', function(event) {""
        ""  if (event.data == 'flush')""
        ""    window.domAutomationController.send(false);""
        ""  if (event.data.type == 'getSelectedTextReply')""
        ""    window.domAutomationController.send(true);""
        ""});""
        ""document.getElementsByTagName('embed')[0].postMessage(""
        ""    {type: 'getSelectedText'});"",
        &success));
    ASSERT_EQ(expect_success, success);
  }
 };
 
 IN_PROC_BROWSER_TEST_P(PDFExtensionTest, Load) {
  IN_PROC_BROWSER_TEST_F(PDFExtensionTest, ZoomManager) {
   RunTestsInFile(""zoom_manager_test.js"", ""test.pdf"");
 }
 
 
 
IN_PROC_BROWSER_TEST_F(PDFExtensionTest, EnsureInternalPluginDisabled) {
  std::string url = embedded_test_server()->GetURL(""/pdf/test.pdf"").spec();
  std::string data_url =
      ""data:text/html,""
      ""<html><body>""
      ""<embed type=\""application/x-google-chrome-pdf\"" src=\"""" +
      url +
      ""\"">""
      ""</body></html>"";
  ui_test_utils::NavigateToURL(browser(), GURL(data_url));
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();
  bool plugin_loaded = false;
  ASSERT_TRUE(content::ExecuteScriptAndExtractBool(
      web_contents,
      ""var plugin_loaded = ""
      ""    document.getElementsByTagName('embed')[0].postMessage !== undefined;""
      ""window.domAutomationController.send(plugin_loaded);"",
      &plugin_loaded));
  ASSERT_FALSE(plugin_loaded);
}

 
IN_PROC_BROWSER_TEST_F(PDFExtensionTest, EnsureCrossOriginRepliesBlocked) {
  std::string url = embedded_test_server()->GetURL(""/pdf/test.pdf"").spec();
  std::string data_url =
      ""data:text/html,""
      ""<html><body>""
      ""<embed type=\""application/pdf\"" src=\"""" +
      url +
      ""\"">""
      ""</body></html>"";
  TestGetSelectedTextReply(GURL(data_url), false);
}

 
IN_PROC_BROWSER_TEST_F(PDFExtensionTest, EnsureSameOriginRepliesAllowed) {
  TestGetSelectedTextReply(embedded_test_server()->GetURL(""/pdf/test.pdf""),
                           true);
}

 class MaterialPDFExtensionTest : public PDFExtensionTest {
   void SetUpCommandLine(base::CommandLine* command_line) override {
     command_line->AppendSwitch(switches::kEnablePdfMaterialUI);","The PDF viewer in Google Chrome before 46.0.2490.86 does not properly restrict scripting messages and API exposure, which allows remote attackers to bypass the Same Origin Policy via an unintended embedder or unintended plugin loading, related to pdf.js and out_of_process_instance.cc."
2937,CVE-2015-1233,"  bool ScreenLayoutObserver::GetDisplayMessageForNotification(
           GetDisplayName(iter.first), GetDisplaySize(iter.first));
       return true;
     }
     
     
    if (iter.second.active_rotation_source() !=
            display::Display::ROTATION_SOURCE_ACCELEROMETER &&
        iter.second.GetActiveRotation() !=
            old_iter->second.GetActiveRotation()) {
       int rotation_text_id = 0;
       switch (iter.second.GetActiveRotation()) {
         case display::Display::ROTATE_0:","Google Chrome before 41.0.2272.118 does not properly handle the interaction of IPC, the Gamepad API, and Google V8, which allows remote attackers to execute arbitrary code via unspecified vectors."
2938,,"  class GLES2DecoderImpl : public GLES2Decoder,
    
    
    
  bool GetUniformSetup(GLuint program,
                       GLint fake_location,
                       uint32 shm_id,
                       uint32 shm_offset,
                       error::Error* error,
                       GLint* real_location,
                       GLuint* service_id,
                       void** result,
                       GLenum* result_type,
                       GLsizei* result_size);
 
   void MaybeExitOnContextLost();
   bool WasContextLost() override;
  error::Error GLES2DecoderImpl::HandleGetVertexAttribPointerv(
   return error::kNoError;
 }
 
bool GLES2DecoderImpl::GetUniformSetup(GLuint program_id,
                                       GLint fake_location,
                                       uint32 shm_id,
                                       uint32 shm_offset,
                                       error::Error* error,
                                       GLint* real_location,
                                       GLuint* service_id,
                                       void** result_pointer,
                                       GLenum* result_type,
                                       GLsizei* result_size) {
   DCHECK(error);
   DCHECK(service_id);
   DCHECK(result_pointer);
  bool GLES2DecoderImpl::GetUniformSetup(
     return false;
   }
   result->size = size;
  *result_size = size;
   *result_type = type;
   return true;
 }
  error::Error GLES2DecoderImpl::HandleGetUniformiv(uint32 immediate_data_size,
   GLint fake_location = c.location;
   GLuint service_id;
   GLenum result_type;
  GLsizei result_size;
   GLint real_location = -1;
   Error error;
   void* result;
  if (GetUniformSetup(program, fake_location, c.params_shm_id,
                      c.params_shm_offset, &error, &real_location, &service_id,
                      &result, &result_type, &result_size)) {
     glGetUniformiv(
         service_id, real_location,
         static_cast<cmds::GetUniformiv::Result*>(result)->GetData());
  error::Error GLES2DecoderImpl::HandleGetUniformfv(uint32 immediate_data_size,
   typedef cmds::GetUniformfv::Result Result;
   Result* result;
   GLenum result_type;
  GLsizei result_size;
  if (GetUniformSetup(program, fake_location, c.params_shm_id,
                      c.params_shm_offset, &error, &real_location, &service_id,
                      reinterpret_cast<void**>(&result), &result_type,
                      &result_size)) {
     if (result_type == GL_BOOL || result_type == GL_BOOL_VEC2 ||
         result_type == GL_BOOL_VEC3 || result_type == GL_BOOL_VEC4) {
      GLsizei num_values = result_size / sizeof(Result::Type);
       scoped_ptr<GLint[]> temp(new GLint[num_values]);
       glGetUniformiv(service_id, real_location, temp.get());
       GLfloat* dst = result->GetData();",
2939,"CVE-2015-1210, CVE-2015-1211"," 
 #include ""config.h""
 #include ""bindings/core/v8/V8ThrowException.h""
 
#include ""bindings/core/v8/BindingSecurity.h""
 #include ""bindings/core/v8/V8Binding.h""
 #include ""bindings/core/v8/V8DOMException.h""
 #include ""core/dom/DOMException.h""
  v8::Handle<v8::Value> V8ThrowException::createDOMException(v8::Isolate* isolate,
     if (ec == V8ReferenceError)
         return V8ThrowException::createReferenceError(isolate, sanitizedMessage);
 
    v8::Handle<v8::Object> sanitizedCreationContext = creationContext;

     
    Frame* frame = toFrameIfNotDetached(creationContext->CreationContext());
    if (!frame || !BindingSecurity::shouldAllowAccessToFrame(isolate, frame, DoNotReportSecurityError))
        sanitizedCreationContext = isolate->GetCurrentContext()->Global();


     RefPtrWillBeRawPtr<DOMException> domException = DOMException::create(ec, sanitizedMessage, unsanitizedMessage);
    v8::Handle<v8::Value> exception = toV8(domException.get(), sanitizedCreationContext, isolate);
 
     if (exception.IsEmpty())
         return v8Undefined();",
2940,CVE-2015-1212,"  void PresentationConnectionProxy::DidChangeState(
     source_connection_->didChangeState(
         blink::WebPresentationConnectionState::Connected);
   } else if (state == content::PRESENTATION_CONNECTION_STATE_CLOSED) {
    source_connection_->didClose();
   } else {
     NOTREACHED();
   }
 }
 
 void PresentationConnectionProxy::OnClose() {
   DCHECK(target_connection_ptr_);
  source_connection_->didClose();
   target_connection_ptr_->DidChangeState(
       content::PRESENTATION_CONNECTION_STATE_CLOSED);
 }","Multiple unspecified vulnerabilities in Google Chrome before 40.0.2214.111 on Windows, OS X, and Linux and before 40.0.2214.109 on Android allow attackers to cause a denial of service or possibly have other impact via unknown vectors."
2941,CVE-2016-5170,"  bool Document::SetFocusedElement(Element* new_focused_element,
     if (IsRootEditableElement(*new_focused_element) &&
         !AcceptsEditingFocus(*new_focused_element)) {
        
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
      
     focused_element_ = new_focused_element;
  bool Document::SetFocusedElement(Element* new_focused_element,
 
      
     if (focused_element_ != new_focused_element) {
      UpdateStyleAndLayoutTree();
      if (LocalFrame* frame = GetFrame())
        frame->Selection().DidChangeFocus();
      return false;
     }
     CancelFocusAppearanceUpdate();
     EnsurePaintLocationDataValidForNode(focused_element_);
     focused_element_->UpdateFocusAppearanceWithOptions(
         params.selection_behavior, params.options);
 
  bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
          
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
        
       focused_element_->DispatchFocusInEvent(event_type_names::kFocusin,
  bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
          
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
 
        
  bool Document::SetFocusedElement(Element* new_focused_element,
 
       if (focused_element_ != new_focused_element) {
          
        UpdateStyleAndLayoutTree();
        if (LocalFrame* frame = GetFrame())
          frame->Selection().DidChangeFocus();
        return false;
       }
     }
   }
  bool Document::SetFocusedElement(Element* new_focused_element,
                                                     focused_element_.Get());
   }
 
   UpdateStyleAndLayoutTree();
   if (LocalFrame* frame = GetFrame())
     frame->Selection().DidChangeFocus();","WebKit/Source/bindings/modules/v8/V8BindingForModules.cpp in Blink, as used in Google Chrome before 53.0.2785.113, does not properly consider getter side effects during array key conversion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted Indexed Database (aka IndexedDB) API calls."
2942,CVE-2016-5171,"  void AccountReconcilor::FinishReconcileWithMultiloginEndpoint(
     const std::string& primary_account,
     const std::vector<std::string>& chrome_accounts,
     std::vector<gaia::ListedAccount>&& gaia_accounts) {
  DCHECK(IsMultiloginEndpointEnabled());
   DCHECK(!set_accounts_in_progress_);
 
   bool primary_has_error =","WebKit/Source/bindings/templates/interface.cpp in Blink, as used in Google Chrome before 53.0.2785.113, does not prevent certain constructor calls, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted JavaScript code."
2943,CVE-2016-5174,"  class Command;
    
   BOOL shouldShowFullscreenToolbar_;
 
   
   
  BOOL shouldExitAfterEnteringFullscreen_;

    
    
    ","browser/ui/cocoa/browser_window_controller_private.mm in Google Chrome before 53.0.2785.113 does not process fullscreen toggle requests during a fullscreen transition, which allows remote attackers to cause a denial of service (unsuppressed popup) via a crafted web site."
2944,CVE-2016-5175,"  void ScrollNode::AsValueInto(base::trace_event::TracedValue* value) const {
   value->SetBoolean(""user_scrollable_horizontal"", user_scrollable_horizontal);
   value->SetBoolean(""user_scrollable_vertical"", user_scrollable_vertical);
 
  value->SetBoolean(""scrolls_inner_viewport"", scrolls_inner_viewport);
  value->SetBoolean(""scrolls_outer_viewport"", scrolls_outer_viewport);

   element_id.AddToTracedValue(value);
   value->SetInteger(""transform_id"", transform_id);
   value->SetInteger(""overscroll_behavior_x"", overscroll_behavior.x);",Multiple unspecified vulnerabilities in Google Chrome before 53.0.2785.113 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2945,CVE-2016-5147,"  void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        (Layer()->IsRootLayer() ||
         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) &&
        scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {","Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, mishandles deferred page loads, which allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*"
2946,CVE-2016-5149," 
 
 #include ""chrome/browser/service_process/service_process_control.h""
 
#include ""base/barrier_closure.h""
 #include ""base/bind.h""
 #include ""base/bind_helpers.h""
 #include ""base/command_line.h""
  class ServiceProcessControlBrowserTest
   }
   ~ServiceProcessControlBrowserTest() override {}
 
  void HistogramsCallback(base::RepeatingClosure on_done) {
     MockHistogramsCallback();
    on_done.Run();
   }
 
   MOCK_METHOD0(MockHistogramsCallback, void());
 
  protected:
  void LaunchServiceProcessControl(base::RepeatingClosure on_launched) {
      
     ServiceProcessControl::GetInstance()->Launch(
        base::BindOnce(
            &ServiceProcessControlBrowserTest::ProcessControlLaunched,
            base::Unretained(this), on_launched),
        base::BindOnce(
             &ServiceProcessControlBrowserTest::ProcessControlLaunchFailed,
            base::Unretained(this), on_launched));
   }
 
  void LaunchServiceProcessControlAndWait() {
    base::RunLoop run_loop;
    LaunchServiceProcessControl(run_loop.QuitClosure());
    run_loop.Run();
   }
 
   void Disconnect() {
  class ServiceProcessControlBrowserTest
     InProcessBrowserTest::TearDown();
   }
 
  void ProcessControlLaunched(base::OnceClosure on_done) {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
  class ServiceProcessControlBrowserTest
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
    std::move(on_done).Run();
   }
 
  void ProcessControlLaunchFailed(base::OnceClosure on_done) {
     ADD_FAILURE();
    std::move(on_done).Run();
   }
 
  private:
  class RealServiceProcessControlBrowserTest
  
 IN_PROC_BROWSER_TEST_F(RealServiceProcessControlBrowserTest,
                        DISABLED_LaunchAndIPC) {
  LaunchServiceProcessControlAndWait();
 
    
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
  base::RunLoop run_loop;
   cloud_print_proxy->GetCloudPrintProxyInfo(
      base::BindOnce([](base::OnceClosure done, bool, const std::string&,
                        const std::string&) { std::move(done).Run(); },
                     run_loop.QuitClosure()));
  run_loop.Run();
 
    
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndIPC) {
  LaunchServiceProcessControlAndWait();
 
    
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
  base::RunLoop run_loop;
   cloud_print_proxy->GetCloudPrintProxyInfo(
      base::BindOnce([](base::OnceClosure done, bool, const std::string&,
                        const std::string&) { std::move(done).Run(); },
                     run_loop.QuitClosure()));
  run_loop.Run();
 
    
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
  LaunchServiceProcessControlAndWait();
 
    
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
 
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
  {
    base::RunLoop run_loop;
    cloud_print_proxy->GetCloudPrintProxyInfo(
        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
                          const std::string&) { std::move(done).Run(); },
                       run_loop.QuitClosure()));
    run_loop.Run();
    Disconnect();
  }
 
  {
    base::RunLoop run_loop;
    LaunchServiceProcessControl(run_loop.QuitClosure());
 
    ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
    run_loop.Run();
  }
 
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
  {
    base::RunLoop run_loop;
    cloud_print_proxy->GetCloudPrintProxyInfo(
        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
                          const std::string&) { std::move(done).Run(); },
                       run_loop.QuitClosure()));
    run_loop.Run();
  }
 
    
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, LaunchAndReconnect) {
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_LaunchTwice) {
    
  LaunchServiceProcessControlAndWait();
 
    
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   cloud_print::mojom::CloudPrintPtr cloud_print_proxy;
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
  {
    base::RunLoop run_loop;
    cloud_print_proxy->GetCloudPrintProxyInfo(
        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
                          const std::string&) { std::move(done).Run(); },
                       run_loop.QuitClosure()));
    run_loop.Run();
  }
 
    
  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   ServiceProcessControl::GetInstance()->remote_interfaces().GetInterface(
       &cloud_print_proxy);
  {
    base::RunLoop run_loop;
    cloud_print_proxy->GetCloudPrintProxyInfo(
        base::BindOnce([](base::OnceClosure done, bool, const std::string&,
                          const std::string&) { std::move(done).Run(); },
                       run_loop.QuitClosure()));
    run_loop.Run();
  }
 }
 
  
  static void DecrementUntilZero(int* count) {
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_MultipleLaunchTasks) {
   ServiceProcessControl* process = ServiceProcessControl::GetInstance();
  constexpr int kExpectedLaunchCount = 5;
  int success_count = 0;
  base::RunLoop run_loop;
  base::RepeatingClosure on_launch_attempted =
      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());
  for (int i = 0; i < kExpectedLaunchCount; i++) {
      
    process->Launch(base::BindOnce(
                        [](int* success_count, base::OnceClosure task) {
                          (*success_count)++;
                          std::move(task).Run();
                        },
                        &success_count, on_launch_attempted),
                    on_launch_attempted);
   }
  run_loop.Run();
  EXPECT_EQ(kExpectedLaunchCount, success_count);
 }
 
  
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
  
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {
   ServiceProcessControl* process = ServiceProcessControl::GetInstance();
  constexpr int kExpectedLaunchCount = 5;
  base::RunLoop run_loop;
  base::RepeatingClosure task =
      base::BarrierClosure(kExpectedLaunchCount, run_loop.QuitClosure());
  for (int i = 0; i < kExpectedLaunchCount; i++) {
      
     process->Launch(task, task);
   }
  run_loop.Run();
 }
 
  
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_SameLaunchTask) {
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_DieOnDisconnect) {
    
  LaunchServiceProcessControlAndWait();
    
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   Disconnect();
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_ForceShutdown) {
    
  LaunchServiceProcessControlAndWait();
    
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
   base::ProcessId service_pid;
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_CheckPid) {
   base::ScopedAllowBlockingForTesting allow_blocking;
   EXPECT_FALSE(GetServiceProcessData(NULL, &service_pid));
    
  LaunchServiceProcessControlAndWait();
   EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
   EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
    
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {
   ASSERT_FALSE(ServiceProcessControl::GetInstance()->IsConnected());
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
   EXPECT_FALSE(ServiceProcessControl::GetInstance()->GetHistograms(
      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
                          base::Unretained(this), base::DoNothing()),
       base::TimeDelta()));
 }
 
  IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, HistogramsNoService) {
 #endif
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest,
                        MAYBE_HistogramsTimeout) {
  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
    
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
  base::RunLoop run_loop;
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(
      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
                          base::Unretained(this), run_loop.QuitClosure()),
       base::TimeDelta::FromMilliseconds(100)));
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->Shutdown());
  run_loop.Run();
 }
 
 IN_PROC_BROWSER_TEST_F(ServiceProcessControlBrowserTest, MAYBE_Histograms) {
  LaunchServiceProcessControlAndWait();
   ASSERT_TRUE(ServiceProcessControl::GetInstance()->IsConnected());
    
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(0);
    
  base::RunLoop run_loop;
   EXPECT_TRUE(ServiceProcessControl::GetInstance()->GetHistograms(
      base::BindRepeating(&ServiceProcessControlBrowserTest::HistogramsCallback,
                          base::Unretained(this), run_loop.QuitClosure()),
       base::TimeDelta::FromHours(1)));
   EXPECT_CALL(*this, MockHistogramsCallback()).Times(1);
  run_loop.Run();
 }","The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL."
2947,CVE-2016-5152,"  ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,
     return {};
 
   std::vector<std::unique_ptr<Object>> results;
  content_settings::SettingInfo info;
   std::unique_ptr<base::DictionaryValue> setting =
      GetWebsiteSetting(requesting_origin, embedding_origin, &info);
   std::unique_ptr<base::Value> objects;
   if (!setting->Remove(kObjectListKey, &objects))
     return results;
  ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,
     base::DictionaryValue* object_dict;
     if (object.GetAsDictionary(&object_dict) && IsValidObject(*object_dict)) {
       results.push_back(std::make_unique<Object>(
          requesting_origin, embedding_origin, object_dict, info.source,
           host_content_settings_map_->is_incognito()));
     }
   }","Integer overflow in the opj_tcd_get_decoded_tile_size function in tcd.c in OpenJPEG, as used in PDFium in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted JPEG 2000 data."
2948,CVE-2016-5153,"  TracingControllerImpl::TracingControllerImpl()
   base::trace_event::TraceLog::GetInstance()->AddAsyncEnabledStateObserver(
       weak_ptr_factory_.GetWeakPtr());
   g_tracing_controller = this;

   
   
  ConnectToServiceIfNeeded();
 }
 
 TracingControllerImpl::~TracingControllerImpl() {
  bool TracingControllerImpl::StartTracing(
       std::make_unique<base::trace_event::TraceConfig>(trace_config);
 
   start_tracing_done_ = std::move(callback);
   coordinator_->StartTracing(trace_config.ToString());
 
   if (start_tracing_done_ &&","The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site."
2949,CVE-2016-5155," 
 #include ""chrome/browser/ui/android/tab_model/tab_model_list.h""
 #include ""chrome/common/pref_names.h""
 #include ""chrome/common/url_constants.h""
 #include ""components/prefs/pref_service.h""
 #include ""components/prefs/scoped_user_pref_update.h""
#include ""components/sync/driver/sync_service.h""
 #include ""components/sync_sessions/open_tabs_ui_delegate.h""
 #include ""components/sync_sessions/session_sync_service.h""
 #include ""content/public/browser/notification_details.h""
  jboolean ForeignSessionHelper::IsTabSyncEnabled(
 void ForeignSessionHelper::TriggerSessionSync(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj) {
  syncer::SyncService* service =
      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 
  service->TriggerRefresh({syncer::SESSIONS});
 }
 
 void ForeignSessionHelper::SetOnForeignSessionCallback(
  void ForeignSessionHelper::SetInvalidationsForSessionsEnabled(
     JNIEnv* env,
     const JavaParamRef<jobject>& obj,
     jboolean enabled) {
  syncer::SyncService* service =
      ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);
   if (!service)
     return;
 ","Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site."
2950,CVE-2016-5156,"  void EventBindings::AttachFilteredEvent(
     filter = base::DictionaryValue::From(std::move(filter_value));
   }
 
   int id = g_event_filter.Get().AddEventMatcher(
       event_name, ParseEventMatcher(std::move(filter)));
  if (id == -1) {
    args.GetReturnValue().Set(static_cast<int32_t>(-1));
    return;
  }
   attached_matcher_ids_.insert(id);
 
    
  const EventMatcher* matcher = g_event_filter.Get().GetEventMatcher(id);
  DCHECK(matcher);
  base::DictionaryValue* filter_weak = matcher->value();
   std::string extension_id = context()->GetExtensionID();
   if (AddFilter(event_name, extension_id, *filter_weak)) {
     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());","extensions/renderer/event_bindings.cc in the event bindings in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux attempts to process filtered events after failure to add an event matcher, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors."
2951,CVE-2016-5158,"  IN_PROC_BROWSER_TEST_F(DumpAccessibilityTreeTest, AccessibilityAriaSetsize) {
   RunAriaTest(FILE_PATH_LITERAL(""aria-setsize.html""));
 }
 
IN_PROC_BROWSER_TEST_F(DumpAccessibilityTreeTest,
                       AccessibilityAriaSetCountsWithHiddenItems) {
  RunAriaTest(FILE_PATH_LITERAL(""aria-set-counts-with-hidden-items.html""));
}
 IN_PROC_BROWSER_TEST_F(DumpAccessibilityTreeTest, AccessibilityAriaSlider) {
   RunAriaTest(FILE_PATH_LITERAL(""aria-slider.html""));
 }","Multiple integer overflows in the opj_tcd_init_tile function in tcd.c in OpenJPEG, as used in PDFium in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allow remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted JPEG 2000 data."
2952,CVE-2016-5165," 
 #include ""components/history/core/browser/history_service.h""
 #include ""components/metrics/call_stack_profile_metrics_provider.h""
 #include ""components/metrics/component_metrics_provider.h""
#include ""components/metrics/cpu_metrics_provider.h""
 #include ""components/metrics/drive_metrics_provider.h""
 #include ""components/metrics/field_trials_provider.h""
 #include ""components/metrics/gpu/gpu_metrics_provider.h""
  void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::GPUMetricsProvider>());
 
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CPUMetricsProvider>());

   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ScreenInfoMetricsProvider>());
 
  void ChromeMetricsServiceClient::RegisterUKMProviders() {
       std::make_unique<ChromeOSMetricsProvider>());
 #endif   
 
  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::GPUMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::CPUMetricsProvider>());

  metrics_service_->RegisterMetricsProvider(
      std::make_unique<metrics::ScreenInfoMetricsProvider>());

    
   ukm_service_->RegisterMetricsProvider(
       std::make_unique<variations::FieldTrialsProvider>(nullptr,",Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.
2953,CVE-2016-5181,"  static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Obj
     if (classObject->Get(scriptState->context(), v8String(isolate, ""initialize"")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {
         v8::TryCatch block(isolate);
         v8::Local<v8::Value> result;
        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {
             fprintf(stderr, ""Private script error: Object constructor threw an exception.\n"");
             dumpV8Message(context, block.Message());
             RELEASE_NOTREACHED();
  v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scr
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();
  bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, Script
     v8::Local<v8::Value> argv[] = { v8Value };
     v8::TryCatch block(isolate);
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);
         block.ReThrow();
         return false;
  v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState,
     initializeHolderIfNeeded(scriptState, classObject, holder);
     v8::TryCatch block(scriptState->isolate());
     v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
         block.ReThrow();
         return v8::Local<v8::Value>();","Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages."
2954,CVE-2016-5182," 
 
 #include <utility>
 
#include ""base/strings/string_util.h""
 #include ""third_party/blink/public/platform/web_string.h""
#include ""third_party/blink/public/web/web_element.h""
#include ""third_party/blink/public/web/web_input_element.h""
#include ""third_party/blink/public/web/web_node.h""
 
 namespace autofill {
 
  void PageFormAnalyserLogger::Flush() {
       text.clear();
       text += ""[DOM] "";
       text += entry.message;

      std::vector<blink::WebNode> nodesToLog;
      for (unsigned i = 0; i < entry.nodes.size(); ++i) {
        if (entry.nodes[i].IsElementNode()) {
          const blink::WebElement element =
              entry.nodes[i].ToConst<blink::WebElement>();
          const blink::WebInputElement* webInputElement =
              blink::ToWebInputElement(&element);

           
           
          const bool shouldObfuscate =
              webInputElement &&
              webInputElement->IsPasswordFieldForAutofill() &&
              !webInputElement->Value().IsEmpty();

          if (!shouldObfuscate) {
            text += "" %o"";
            nodesToLog.push_back(element);
          }
        }
      }
 
       blink::WebConsoleMessage message(level, blink::WebString::FromUTF8(text));
      message.nodes = std::move(nodesToLog);   
       frame_->AddMessageToConsole(message);
     }
   }","Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation in bitmap handling, which allowed a remote attacker to potentially exploit heap corruption via crafted HTML pages."
2955,CVE-2016-5185,"  const FeatureEntry kFeatureEntries[] = {
      kOsDesktop,
      FEATURE_VALUE_TYPE(
          autofill::features::kAutofillLocalCardMigrationShowFeedback)},
     {""enable-autofill-save-card-dialog-unlabeled-expiration-date"",
      flag_descriptions::
          kEnableAutofillSaveCardDialogUnlabeledExpirationDateName,","Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android incorrectly allowed reentrance of FrameView::updateLifecyclePhasesInternal(), which allowed a remote attacker to perform an out of bounds memory read via crafted HTML pages."
2956,CVE-2016-5187,"  class RepeatingCallback<R(Args...)> : public internal::CallbackBaseCopyable {
   RepeatingCallback(RepeatingCallback&&) noexcept = default;
   RepeatingCallback& operator=(RepeatingCallback&&) noexcept = default;
 
  bool operator==(const RepeatingCallback& other) const {
    return EqualsInternal(other);
  }

  bool operator!=(const RepeatingCallback& other) const {
    return !operator==(other);
  }

   
   bool Equals(const RepeatingCallback& other) const {
     return EqualsInternal(other);
   }","Google Chrome prior to 54.0.2840.85 for Android incorrectly handled rapid transition into and out of full screen mode, which allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via crafted HTML pages."
2957,CVE-2016-5189,"  base::string16 GetEmailDomains() {
 
  
  
 
 
 
 
 
 
 void MakeUsernameForAccount(const base::DictionaryValue* result,
                             base::string16* gaia_id,
                             wchar_t* username,
                             DWORD username_length,
                             wchar_t* domain,
                             DWORD domain_length,
                             wchar_t* sid,
                            DWORD sid_length,
                            bool* is_consumer_account) {
   DCHECK(gaia_id);
   DCHECK(username);
   DCHECK(domain);
   DCHECK(sid);
  DCHECK(is_consumer_account);

   
  base::string16 email = GetDictString(result, kKeyEmail);
  std::transform(email.begin(), email.end(), email.begin(), ::tolower);
  base::string16::size_type consumer_domain_pos = email.find(L""@gmail.com"");
  if (consumer_domain_pos == base::string16::npos)
    consumer_domain_pos = email.find(L""@googlemail.com"");

  *is_consumer_account = consumer_domain_pos != base::string16::npos;
 
   *gaia_id = GetDictString(result, kKeyId);
    
  void MakeUsernameForAccount(const base::DictionaryValue* result,
    
    
    
  base::string16 os_username = email;

   
  if (consumer_domain_pos != base::string16::npos) {
    os_username.resize(consumer_domain_pos);
   } else {
      
     std::string username_utf8 =
  HRESULT WaitForLoginUIAndGetResult(
                               &output_buffer[0], kBufferSize);
    
    
  LOGFN(INFO) << ""exit_code="" << *exit_code;
 
   if (*exit_code == kUiecAbort) {
     LOGFN(ERROR) << ""Aborted hr="" << putHR(hr);
  HRESULT CGaiaCredentialBase::ValidateOrCreateUser(
   wchar_t found_username[kWindowsUsernameBufferLength];
   wchar_t found_domain[kWindowsDomainBufferLength];
   wchar_t found_sid[kWindowsSidBufferLength];
  bool is_consumer_account = false;
   base::string16 gaia_id;
  MakeUsernameForAccount(result, &gaia_id, found_username,
                         base::size(found_username), found_domain,
                         base::size(found_domain), found_sid,
                         base::size(found_sid), &is_consumer_account);

   
   
  if (MdmEnrollmentEnabled() && is_consumer_account) {
    DWORD allow_consumer_accounts = 0;
    if (FAILED(GetGlobalFlag(kRegMdmAllowConsumerAccounts,
                             &allow_consumer_accounts)) ||
        allow_consumer_accounts == 0) {
      LOGFN(ERROR) << ""Consumer accounts are not allowed mdm_aca=""
                   << allow_consumer_accounts;
      *error_text = AllocErrorString(IDS_INVALID_EMAIL_DOMAIN_BASE);
      return E_FAIL;
    }
  }
 
    
    ","Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted navigation to blob URLs with non-canonical origins, which allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via crafted HTML pages."
2958,CVE-2016-5191,"  void ToggleBookmarkBarWhenVisible(content::BrowserContext* browser_context) {
 
 base::string16 FormatBookmarkURLForDisplay(const GURL& url) {
    
   
    
    
  url_formatter::FormatUrlTypes format_types =
      url_formatter::kFormatUrlOmitAll &
      ~url_formatter::kFormatUrlOmitUsernamePassword;

   
   
  if (url.has_username())
    format_types &= ~url_formatter::kFormatUrlOmitHTTP;

  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,
                                  nullptr, nullptr, nullptr);
 }
 
 bool IsAppsShortcutEnabled(Profile* profile) {","Bookmark handling in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation of supplied data, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages, as demonstrated by an interpretation conflict between userinfo and scheme in an http://javascript:"
2959,CVE-2016-5194,"  class TestVolume {
   DISALLOW_COPY_AND_ASSIGN(TestVolume);
 };
 
 base::Lock& GetLockForBlockingDefaultFileTaskRunner() {
   static base::NoDestructor<base::Lock> lock;
   return *lock;
  void FileManagerBrowserTestBase::SetUpCommandLine(
     command_line->AppendSwitch(switches::kIncognito);
   }
 
  if (IsOfflineTest()) {
    command_line->AppendSwitchASCII(chromeos::switches::kShillStub, ""clear=1"");
  }

   std::vector<base::Feature> enabled_features;
   std::vector<base::Feature> disabled_features;
 
  void FileManagerBrowserTestBase::SetUpOnMainThread() {
   display_service_ =
       std::make_unique<NotificationDisplayServiceTester>(profile());
 
   content::NetworkConnectionChangeSimulator network_change_simulator;
   network_change_simulator.SetConnectionType(
       IsOfflineTest() ? network::mojom::ConnectionType::CONNECTION_NONE",
2960,," 
 #include <string>
 
 #include ""base/logging.h""
#include ""base/stl_util.h""
 #include ""testing/gtest/include/gtest/gtest.h""
 
 namespace compression {
  const uint8_t kCompressedData[] = {
 }   
 
 TEST(CompressionUtilsTest, GzipCompression) {
  std::string data(reinterpret_cast<const char*>(kData), base::size(kData));
   std::string compressed_data;
   EXPECT_TRUE(GzipCompress(data, &compressed_data));
   std::string golden_compressed_data(
       reinterpret_cast<const char*>(kCompressedData),
      base::size(kCompressedData));
   EXPECT_EQ(golden_compressed_data, compressed_data);
 }
 
 TEST(CompressionUtilsTest, GzipUncompression) {
   std::string compressed_data(reinterpret_cast<const char*>(kCompressedData),
                              base::size(kCompressedData));
 
   std::string uncompressed_data;
   EXPECT_TRUE(GzipUncompress(compressed_data, &uncompressed_data));
 
   std::string golden_data(reinterpret_cast<const char*>(kData),
                          base::size(kData));
   EXPECT_EQ(golden_data, uncompressed_data);
 }
 
  TEST(CompressionUtilsTest, LargeInput) {
 
 TEST(CompressionUtilsTest, InPlace) {
   const std::string original_data(reinterpret_cast<const char*>(kData),
                                  base::size(kData));
   const std::string golden_compressed_data(
       reinterpret_cast<const char*>(kCompressedData),
      base::size(kCompressedData));
 
   std::string data(original_data);
   EXPECT_TRUE(GzipCompress(data, &data));",
2961,CVE-2016-5146,"  WRAPPED_INSTANTIATE_TEST_SUITE_P(
                       TestCase(""keyboardCopyDrive"").EnableDriveFs(),
                       TestCase(""keyboardSelectDriveDirectoryTree""),
                       TestCase(""keyboardDisableCopyWhenDialogDisplayed""),
                      TestCase(""keyboardOpenNewWindow""),
                      TestCase(""keyboardOpenNewWindow"").InGuestMode(),
                       TestCase(""renameFileDownloads"").InGuestMode(),
                       TestCase(""renameFileDownloads""),
                       TestCase(""renameFileDrive"").DisableDriveFs(),",Multiple unspecified vulnerabilities in Google Chrome before 52.0.2743.116 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2962,,"  enum ShelfBackgroundType {
    
   SHELF_BACKGROUND_DEFAULT,
 
   
   
   SHELF_BACKGROUND_MAXIMIZED,
 
    
   SHELF_BACKGROUND_APP_LIST,
 
    
   SHELF_BACKGROUND_OOBE,
 ",
2963,," 
2964,,"  class FlexItem {
 
   bool frozen;
 
  NGBlockNode ng_input_node;
   scoped_refptr<NGLayoutResult> layout_result;
 };
 ",
2965,,"  void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& loader)
     if (!loader)
         return;
 
    FrameNavigationDisabler navigationDisabler(*m_frame);
     loader->detachFromFrame();
     loader = nullptr;
 }
  bool FrameLoader::prepareForCommit()
      
      
     if (m_documentLoader) {
         TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);
         detachDocumentLoader(m_documentLoader);
     }
  void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType ty
         return;
 
     m_frame->document()->cancelParsing();
    detachDocumentLoader(m_provisionalDocumentLoader);
 
      
      ",
2966,,"  void getScriptableObjectProperty(PropertyType property, const v8::PropertyCallba
     if (instance.IsEmpty())
         return;
 
    if (!v8CallBoolean(instance->HasOwnProperty(info.GetIsolate()->GetCurrentContext(), property)))
         return;
 
    v8::Local<v8::Value> value;
    if (!instance->Get(info.GetIsolate()->GetCurrentContext(), property).ToLocal(&value))
         return;
 
     v8SetReturnValue(info, value);
  void setScriptableObjectProperty(PropertyType property, v8::Local<v8::Value> val
      
      
      
    v8CallBoolean(instance->CreateDataProperty(info.GetIsolate()->GetCurrentContext(), property, value));
 }
 }  
 ",
2967,,"  HTMLMediaElement::HTMLMediaElement(const QualifiedName& tag_name,
       muted_(false),
       paused_(true),
       seeking_(false),
      paused_by_context_paused_(false),
       sent_stalled_event_(false),
       ignore_preload_none_(false),
       text_tracks_visible_(false),
  void HTMLMediaElement::ClearMediaPlayer() {
     GetLayoutObject()->SetShouldDoFullPaintInvalidation();
 }
 
void HTMLMediaElement::ContextPaused(PauseState pause_state) {
  if (pause_state == PauseState::kFrozen && playing_) {
    paused_by_context_paused_ = true;
    pause();
  }
}

void HTMLMediaElement::ContextUnpaused() {
  if (paused_by_context_paused_) {
    paused_by_context_paused_ = false;
    Play();
  }
}

 void HTMLMediaElement::ContextDestroyed(ExecutionContext*) {
   BLINK_MEDIA_LOG << ""contextDestroyed("" << (void*)this << "")"";
 ",
2968,," 
 #include ""content/common/service_worker/service_worker_messages.h""
 #include ""content/common/service_worker/service_worker_utils.h""
 #include ""content/public/common/browser_side_navigation_policy.h""
#include ""third_party/WebKit/public/platform/WebSecurityOrigin.h""
 #include ""third_party/WebKit/public/web/WebLocalFrame.h""
 #include ""third_party/WebKit/public/web/WebSandboxFlags.h""
 
  int GetNextProviderId() {
   return sequence.GetNext();   
 }
 
 
 
 
 
bool IsFrameSecure(blink::WebFrame* frame) {
  while (frame) {
    if (!frame->getSecurityOrigin().isPotentiallyTrustworthy())
      return false;
    frame = frame->parent();
  }
  return true;
}

 }   
 
 void ServiceWorkerNetworkProvider::AttachToDocumentState(
  ServiceWorkerNetworkProvider::CreateForNavigation(
      
      
      
    const bool is_parent_frame_secure = IsFrameSecure(frame->parent());
 
     if (service_worker_provider_id == kInvalidServiceWorkerProviderId) {
       network_provider = std::unique_ptr<ServiceWorkerNetworkProvider>(",
2969,CVE-2016-1705,"  GLOutputSurfaceBufferQueueAndroid::GLOutputSurfaceBufferQueueAndroid(
 GLOutputSurfaceBufferQueueAndroid::~GLOutputSurfaceBufferQueueAndroid() =
     default;
 
 OverlayCandidateValidator*
 GLOutputSurfaceBufferQueueAndroid::GetOverlayCandidateValidator() const {
   return overlay_candidate_validator_.get();",Multiple unspecified vulnerabilities in Google Chrome before 52.0.2743.82 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2970,CVE-2016-1646,"  void OomInterventionTabHelper::StartDetectionInRenderer() {
     }
   }
 
  if (!renderer_pause_enabled && !navigate_ads_enabled)
    return;
   content::RenderFrameHost* main_frame = web_contents()->GetMainFrame();
   DCHECK(main_frame);
   content::RenderProcessHost* render_process_host = main_frame->GetProcess();","The Array.prototype.concat implementation in builtins.cc in Google V8, as used in Google Chrome before 49.0.2623.108, does not properly consider element data types, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via crafted JavaScript code."
2971,CVE-2016-1647,"  void RenderWidgetHostImpl::Destroy(bool also_delete) {
   if (delegate_)
     delegate_->RenderWidgetDeleted(this);
 
  if (also_delete) {
    CHECK(!owner_delegate_);
     delete this;
  }
 }
 
 void RenderWidgetHostImpl::RendererIsUnresponsive() {",Use-after-free vulnerability in the RenderWidgetHostImpl::Destroy function in content/browser/renderer_host/render_widget_host_impl.cc in the Navigation implementation in Google Chrome before 49.0.2623.108 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
2972,CVE-2016-1648,"  class LoadTimesExtensionWrapper : public v8::Extension {
   }
 
   static void GetLoadTimes(const v8::FunctionCallbackInfo<v8::Value>& args) {
    args.GetReturnValue().SetNull();
     WebLocalFrame* frame = WebLocalFrame::frameForCurrentContext();
     if (!frame) {
       return;
     }
     WebDataSource* data_source = frame->dataSource();
     if (!data_source) {
       return;
     }
     DocumentState* document_state = DocumentState::FromDataSource(data_source);
     if (!document_state) {
       return;
     }
     double request_time = document_state->request_time().ToDoubleT();
  class LoadTimesExtensionWrapper : public v8::Extension {
      
      
     v8::Isolate* isolate = args.GetIsolate();
    v8::Local<v8::Context> ctx = isolate->GetCurrentContext();
     v8::Local<v8::Object> load_times = v8::Object::New(isolate);
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""requestTime"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Number::New(isolate, request_time))
             .FromMaybe(false)) {
      return;
    }

    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""startLoadTime"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Number::New(isolate, start_load_time))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""commitLoadTime"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Number::New(isolate, commit_load_time))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx,
                   v8::String::NewFromUtf8(isolate, ""finishDocumentLoadTime"",
                                           v8::NewStringType::kNormal)
                       .ToLocalChecked(),
                   v8::Number::New(isolate, finish_document_load_time))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""finishLoadTime"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Number::New(isolate, finish_load_time))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""firstPaintTime"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Number::New(isolate, first_paint_time))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx,
                   v8::String::NewFromUtf8(isolate, ""firstPaintAfterLoadTime"",
                                           v8::NewStringType::kNormal)
                       .ToLocalChecked(),
                   v8::Number::New(isolate, first_paint_after_load_time))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""navigationType"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::String::NewFromUtf8(isolate, navigation_type.c_str(),
                                           v8::NewStringType::kNormal)
                       .ToLocalChecked())
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""wasFetchedViaSpdy"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Boolean::New(isolate, was_fetched_via_spdy))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""wasNpnNegotiated"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Boolean::New(isolate, was_npn_negotiated))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx,
                   v8::String::NewFromUtf8(isolate, ""npnNegotiatedProtocol"",
                                           v8::NewStringType::kNormal)
                       .ToLocalChecked(),
                   v8::String::NewFromUtf8(isolate,
                                           npn_negotiated_protocol.c_str(),
                                           v8::NewStringType::kNormal)
                       .ToLocalChecked())
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate,
                                                ""wasAlternateProtocolAvailable"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::Boolean::New(isolate, was_alternate_protocol_available))
             .FromMaybe(false)) {
      return;
    }
    if (!load_times
             ->Set(ctx, v8::String::NewFromUtf8(isolate, ""connectionInfo"",
                                                v8::NewStringType::kNormal)
                            .ToLocalChecked(),
                   v8::String::NewFromUtf8(isolate, connection_info.c_str(),
                                           v8::NewStringType::kNormal)
                       .ToLocalChecked())
             .FromMaybe(false)) {
      return;
    }
     args.GetReturnValue().Set(load_times);
   }
 
   static void GetCSI(const v8::FunctionCallbackInfo<v8::Value>& args) {
    args.GetReturnValue().SetNull();
     WebLocalFrame* frame = WebLocalFrame::frameForCurrentContext();
    if (!frame) {
      return;
     }
    WebDataSource* data_source = frame->dataSource();
    if (!data_source) {
      return;
    }
    DocumentState* document_state = DocumentState::FromDataSource(data_source);
    if (!document_state) {
      return;
    }
    base::Time now = base::Time::Now();
    base::Time start = document_state->request_time().is_null()
                           ? document_state->start_load_time()
                           : document_state->request_time();
    base::Time onload = document_state->finish_document_load_time();
    base::TimeDelta page = now - start;
    int navigation_type = GetCSITransitionType(data_source->navigationType());
     
     
     
    v8::Isolate* isolate = args.GetIsolate();
    v8::Local<v8::Context> ctx = isolate->GetCurrentContext();
    v8::Local<v8::Object> csi = v8::Object::New(isolate);
    if (!csi->Set(ctx, v8::String::NewFromUtf8(isolate, ""startE"",
                                               v8::NewStringType::kNormal)
                           .ToLocalChecked(),
                  v8::Number::New(isolate, floor(start.ToDoubleT() * 1000)))
             .FromMaybe(false)) {
      return;
    }
    if (!csi->Set(ctx, v8::String::NewFromUtf8(isolate, ""onloadT"",
                                               v8::NewStringType::kNormal)
                           .ToLocalChecked(),
                  v8::Number::New(isolate, floor(onload.ToDoubleT() * 1000)))
             .FromMaybe(false)) {
      return;
    }
    if (!csi->Set(ctx, v8::String::NewFromUtf8(isolate, ""pageT"",
                                               v8::NewStringType::kNormal)
                           .ToLocalChecked(),
                  v8::Number::New(isolate, page.InMillisecondsF()))
             .FromMaybe(false)) {
      return;
    }
    if (!csi->Set(ctx, v8::String::NewFromUtf8(isolate, ""tran"",
                                               v8::NewStringType::kNormal)
                           .ToLocalChecked(),
                  v8::Number::New(isolate, navigation_type))
             .FromMaybe(false)) {
      return;
    }
    args.GetReturnValue().Set(csi);
   }
 };
 ",Use-after-free vulnerability in the GetLoadTimes function in renderer/loadtimes_extension_bindings.cc in the Extensions implementation in Google Chrome before 49.0.2623.108 allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code.
2973,CVE-2016-1630,"  JNI_EXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
   base::android::InitVM(vm);
   if (!content::android::OnJNIOnLoadInit())
     return -1;
  content::SetContentMainDelegate(new content::ShellMainDelegate(true));
   return JNI_VERSION_1_4;
 }","The ContainerNode::parserRemoveChild function in WebKit/Source/core/dom/ContainerNode.cpp in Blink, as used in Google Chrome before 49.0.2623.75, mishandles widget updates, which makes it easier for remote attackers to bypass the Same Origin Policy via a crafted web site."
2974,CVE-2016-1631,"  IN_PROC_BROWSER_TEST_F(PPAPINaClPNaClNonSfiTest, MAYBE_PNACL_NONSFI(View)) {
   RunTest( \
       LIST_TEST(FlashMessageLoop_Basics) \
       LIST_TEST(FlashMessageLoop_RunWithoutQuit) \
      LIST_TEST(FlashMessageLoop_SuspendScriptCallbackWhileRunning) \
   )
 
 #if defined(OS_LINUX)   ","The PPB_Flash_MessageLoop_Impl::InternalRun function in content/renderer/pepper/ppb_flash_message_loop_impl.cc in the Pepper plugin in Google Chrome before 49.0.2623.75 mishandles nested message loops, which allows remote attackers to bypass the Same Origin Policy via a crafted web site."
2975,CVE-2016-1632,"  class HistogramTest : public testing::TestWithParam<bool> {
   }
 
   void CreatePersistentHistogramAllocator() {
     GlobalHistogramAllocator::CreateWithLocalMemory(
         kAllocatorMemorySize, 0, ""HistogramAllocatorTest"");
     allocator_ = GlobalHistogramAllocator::Get()->memory_allocator();","The Extensions subsystem in Google Chrome before 49.0.2623.75 does not properly maintain own properties, which allows remote attackers to bypass intended access restrictions via crafted JavaScript code that triggers an incorrect cast, related to extensions/renderer/v8_helpers.h and gin/converter.h."
2976,CVE-2016-1635,"  namespace {
  
 class LoadWatcher : public content::RenderFrameObserver {
  public:
  LoadWatcher(content::RenderFrame* frame,
              const base::Callback<void(bool)>& callback)
      : content::RenderFrameObserver(frame), callback_(callback) {}

  void DidCreateDocumentElement() override {
     
     
     
    base::Callback<void(bool)> callback = callback_;
    delete this;
    callback.Run(true);
   }
 
   void DidFailProvisionalLoad(const blink::WebURLError& error) override {
     
     
    base::MessageLoop::current()->PostTask(FROM_HERE,
                                           base::Bind(callback_, false));
     delete this;
   }
 
 private:
  base::Callback<void(bool)> callback_;
 
   DISALLOW_COPY_AND_ASSIGN(LoadWatcher);
 };
 
 }   
 
 RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }
 
RenderFrameObserverNatives::~RenderFrameObserverNatives() {}

void RenderFrameObserverNatives::Invalidate() {
  weak_ptr_factory_.InvalidateWeakPtrs();
  ObjectBackedNativeHandler::Invalidate();
}

 void RenderFrameObserverNatives::OnDocumentElementCreated(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   CHECK(args.Length() == 2);
  void RenderFrameObserverNatives::OnDocumentElementCreated(
     return;
   }
 
  v8::Global<v8::Function> v8_callback(context()->isolate(),
                                       args[1].As<v8::Function>());
  base::Callback<void(bool)> callback(
      base::Bind(&RenderFrameObserverNatives::InvokeCallback,
                 weak_ptr_factory_.GetWeakPtr(), base::Passed(&v8_callback)));
  if (ExtensionFrameHelper::Get(frame)->did_create_current_document_element()) {
     
     
     
    base::MessageLoop::current()->PostTask(FROM_HERE,
                                           base::Bind(callback, true));
  } else {
    new LoadWatcher(frame, callback);
  }
 
   args.GetReturnValue().Set(true);
 }
 
void RenderFrameObserverNatives::InvokeCallback(
    v8::Global<v8::Function> callback,
    bool succeeded) {
  v8::Isolate* isolate = context()->isolate();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
  context()->CallFunction(v8::Local<v8::Function>::New(isolate, callback),
                          arraysize(args), args);
}

 }   ","extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors."
2977,CVE-2016-1636," 
 
 #include ""content/common/sandbox_policy_fuchsia.h""
 
 #include <lib/fdio/spawn.h>
 #include <stdio.h>
 #include <zircon/processargs.h>
 
#include <fuchsia/fonts/cpp/fidl.h>
#include <memory>
#include <utility>

 #include ""base/base_paths_fuchsia.h""
 #include ""base/command_line.h""
 #include ""base/files/file_util.h""","The PendingScript::notifyFinished function in WebKit/Source/core/dom/PendingScript.cpp in Google Chrome before 49.0.2623.75 relies on memory-cache information about integrity-check occurrences instead of integrity-check successes, which allows remote attackers to bypass the Subresource Integrity (aka SRI) protection mechanism by triggering two loads of the same resource."
2978,CVE-2016-1638,"  const base::Feature kEnableVirtualKeyboardMdUi = {
     ""EnableVirtualKeyboardMdUi"", base::FEATURE_ENABLED_BY_DEFAULT};
 
 const base::Feature kEnableVirtualKeyboardUkm = {
    ""EnableVirtualKeyboardUkm"", base::FEATURE_ENABLED_BY_DEFAULT};
 
  
 const base::Feature kExperimentalUi{""ExperimentalUi"",","extensions/renderer/resources/platform_app.js in the Extensions subsystem in Google Chrome before 49.0.2623.75 does not properly restrict use of Web APIs, which allows remote attackers to bypass intended access restrictions via a crafted platform app."
2979,CVE-2016-1639,"  views::View* LockContentsView::TestApi::main_view() const {
   return view_->main_view_;
 }
 
LockContentsView::UserState::UserState(const mojom::LoginUserInfoPtr& user_info)
    : account_id(user_info->basic_user_info->account_id) {
  fingerprint_state = user_info->allow_fingerprint_unlock
                          ? mojom::FingerprintUnlockState::AVAILABLE
                          : mojom::FingerprintUnlockState::UNAVAILABLE;
  if (user_info->auth_type == proximity_auth::mojom::AuthType::ONLINE_SIGN_IN)
    force_online_sign_in = true;
}
 
 LockContentsView::UserState::UserState(UserState&&) = default;
 
  void LockContentsView::OnUsersChanged(
   }
 
    
  for (const mojom::LoginUserInfoPtr& user : users)
    users_.push_back(UserState(user));
 
   auto box_layout =
       std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal);",Use-after-free vulnerability in browser/extensions/api/webrtc_audio_private/webrtc_audio_private_api.cc in the WebRTC Audio Private API implementation in Google Chrome before 49.0.2623.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect reliance on the resource context pointer.
2980,CVE-2016-1640,"  bool ExtensionInstallPrompt::Prompt::ShouldShowPermissions() const {
          type_ == POST_INSTALL_PERMISSIONS_PROMPT;
 }
 
bool ExtensionInstallPrompt::Prompt::ShouldUseTabModalDialog() const {
   
   
   
  return type_ == INLINE_INSTALL_PROMPT;
}

 void ExtensionInstallPrompt::Prompt::AppendRatingStars(
     StarAppender appender, void* data) const {
   CHECK(appender);","The Web Store inline-installer implementation in the Extensions UI in Google Chrome before 49.0.2623.75 does not block installations upon deletion of an installation frame, which makes it easier for remote attackers to trick a user into believing that an installation request originated from the user's next navigation target via a crafted web site."
2981,CVE-2016-1641,"  const char kWebContentsAndroidKey[] = ""web_contents_android"";
 base::LazyInstance<std::vector<WebContentsImpl::CreatedCallback> >
 g_created_callbacks = LAZY_INSTANCE_INITIALIZER;
 
 void NotifyCacheOnIO(
     scoped_refptr<net::URLRequestContextGetter> request_context,
     const GURL& url,
  WebContentsImpl::WebContentsImpl(BrowserContext* browser_context)
       audio_stream_monitor_(this),
       virtual_keyboard_requested_(false),
       page_scale_factor_is_one_(true),
      loading_weak_factory_(this),
      weak_factory_(this) {
   frame_tree_.SetFrameRemoveListener(
       base::Bind(&WebContentsImpl::OnFrameRemoved,
                  base::Unretained(this)));
  int WebContentsImpl::DownloadImage(
      
      
      
    image_downloader::DownloadResultPtr result =
        image_downloader::DownloadResult::New();
    result->http_status_code = 400;
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContentsImpl::OnDidDownloadImage,
                   weak_factory_.GetWeakPtr(), callback, download_id, url,
                   base::Passed(&result)));
     return download_id;
   }
 
  int WebContentsImpl::DownloadImage(
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->DownloadImage(
      std::move(req), base::Bind(&WebContentsImpl::OnDidDownloadImage,
                                 weak_factory_.GetWeakPtr(), callback,
                                 download_id, url));
   return download_id;
 }
 
  bool WebContentsImpl::GetAllowOtherViews() {
 
 #endif
 
void WebContentsImpl::OnDidDownloadImage(
    const ImageDownloadCallback& callback,
    int id,
    const GURL& image_url,
    image_downloader::DownloadResultPtr result) {
  const std::vector<SkBitmap> images =
      result->images.To<std::vector<SkBitmap>>();
  const std::vector<gfx::Size> original_image_sizes =
      result->original_image_sizes.To<std::vector<gfx::Size>>();

  callback.Run(id, result->http_status_code, image_url, images,
               original_image_sizes);
}

 void WebContentsImpl::OnDialogClosed(int render_process_id,
                                      int render_frame_id,
                                      IPC::Message* reply_msg,","Use-after-free vulnerability in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 49.0.2623.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering an image download after a certain data structure is deleted, as demonstrated by a favicon.ico download."
2982,CVE-2016-1612,"  constexpr TaskService::InstanceId kInvalidInstanceId = -1;
 }   
 
 TaskService::TaskService()
    : no_tasks_in_flight_cv_(&tasks_in_flight_lock_),
      tasks_in_flight_(0),
      next_instance_id_(0),
      bound_instance_id_(kInvalidInstanceId) {}
 
 TaskService::~TaskService() {
   std::vector<std::unique_ptr<base::Thread>> threads;
  bool TaskService::UnbindInstance() {
     DCHECK(default_task_runner_);
     default_task_runner_ = nullptr;
   }

    
   
   
  base::AutoLock tasks_in_flight_auto_lock(tasks_in_flight_lock_);
  while (tasks_in_flight_ > 0)
    no_tasks_in_flight_cv_.Wait();

   return true;
 }
 
  scoped_refptr<base::SingleThreadTaskRunner> TaskService::GetTaskRunner(
 void TaskService::RunTask(InstanceId instance_id,
                           RunnerId runner_id,
                           base::OnceClosure task) {
   {
    base::AutoLock tasks_in_flight_auto_lock(tasks_in_flight_lock_);
    ++tasks_in_flight_;
   }

  if (IsInstanceIdStillBound(instance_id))
    std::move(task).Run();

  {
    base::AutoLock tasks_in_flight_auto_lock(tasks_in_flight_lock_);
    --tasks_in_flight_;
    DCHECK_GE(tasks_in_flight_, 0);
    if (tasks_in_flight_ == 0)
      no_tasks_in_flight_cv_.Signal();
  }
}

bool TaskService::IsInstanceIdStillBound(InstanceId instance_id) {
  base::AutoLock lock(lock_);
  return instance_id == bound_instance_id_;
 }
 
 }   ","The LoadIC::UpdateCaches function in ic/ic.cc in Google V8, as used in Google Chrome before 48.0.2564.82, does not ensure receiver compatibility before performing a cast of an unspecified variable, which allows remote attackers to cause a denial of service or possibly have unknown other impact via crafted JavaScript code."
2983,CVE-2016-1613,"  void LocalSiteCharacteristicsDataImpl::NotifyUsesNotificationsInBackground() {
       site_characteristics_.mutable_uses_notifications_in_background());
 }
 
void LocalSiteCharacteristicsDataImpl::ExpireAllObservationWindowsForTesting() {
  auto params = GetSiteCharacteristicsDatabaseParams();
  base::TimeDelta longest_observation_window =
      std::max({params.favicon_update_observation_window,
                params.title_update_observation_window,
                params.audio_usage_observation_window,
                params.notifications_usage_observation_window});
  for (auto* iter : GetAllFeaturesFromProto(&site_characteristics_))
    IncrementFeatureObservationDuration(iter, longest_observation_window);
}

 LocalSiteCharacteristicsDataImpl::LocalSiteCharacteristicsDataImpl(
     const url::Origin& origin,
     OnDestroyDelegate* delegate,","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
2984,CVE-2016-1614,"  class ScrollbarsTestWithVirtualTimer : public ScrollbarsTest {
     WebView().Scheduler()->EnableVirtualTime();
   }
 
  void TearDown() override {
    WebView().Scheduler()->DisableVirtualTimeForTesting();
    ScrollbarsTest::TearDown();
  }

   void TimeAdvance() {
     WebView().Scheduler()->SetVirtualTimePolicy(
         PageScheduler::VirtualTimePolicy::kAdvance);","The UnacceleratedImageBufferSurface class in WebKit/Source/platform/graphics/UnacceleratedImageBufferSurface.cpp in Blink, as used in Google Chrome before 48.0.2564.82, mishandles the initialization mode, which allows remote attackers to obtain sensitive information from process memory via a crafted web site."
2985,CVE-2016-1615,"  RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,
       is_guest_view_hack_(is_guest_view_hack),
       device_scale_factor_(0.0f),
       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),
      frame_sink_id_(host_->AllocateFrameSinkId(is_guest_view_hack_)),
       weak_ptr_factory_(this) {
   if (!is_guest_view_hack_)
     host_->SetView(this);
  void RenderWidgetHostViewAura::CreateDelegatedFrameHostClient() {
   if (IsMus())
     return;
 
    
   if (!delegated_frame_host_client_) {
     delegated_frame_host_client_ =
         base::MakeUnique<DelegatedFrameHostClientAura>(this);
   }
   delegated_frame_host_ = base::MakeUnique<DelegatedFrameHost>(
      frame_sink_id_, delegated_frame_host_client_.get());
   if (renderer_compositor_frame_sink_) {
     delegated_frame_host_->DidCreateNewRendererCompositorFrameSink(
         renderer_compositor_frame_sink_);
  void RenderWidgetHostViewAura::OnDidNavigateMainFrameToNewPage() {
 }
 
 cc::FrameSinkId RenderWidgetHostViewAura::GetFrameSinkId() {
  return frame_sink_id_;
 }
 
 cc::SurfaceId RenderWidgetHostViewAura::SurfaceIdForTesting() const {",The Omnibox implementation in Google Chrome before 48.0.2564.82 allows remote attackers to spoof a document's origin via unspecified vectors.
2986,CVE-2016-1616,"  void CustomButton::OnGestureEvent(ui::GestureEvent* event) {
 }
 
 bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {
   
   
   
  if ((IsChildWidget() && !FocusInChildWidget()) ||
      (!IsChildWidget() && !GetWidget()->IsActive())) {
    return false;
  }
   SetState(STATE_NORMAL);
    
   ui::MouseEvent synthetic_event(
  void CustomButton::OnBlur() {
     SetState(STATE_NORMAL);
 }
 
bool CustomButton::IsChildWidget() const {
  return GetWidget() && GetWidget()->GetTopLevelWidget() != GetWidget();
}

bool CustomButton::FocusInChildWidget() const {
  return GetWidget() &&
         GetWidget()->GetRootView()->Contains(
             GetFocusManager()->GetFocusedView());
}

 }   ",The CustomButton::AcceleratorPressed function in ui/views/controls/button/custom_button.cc in Google Chrome before 48.0.2564.82 allows remote attackers to spoof URLs via vectors involving an unfocused custom button.
2987,CVE-2016-1617,"  bool CSPSource::schemeMatches(const KURL& url) const
 {
     if (m_scheme.isEmpty())
         return m_policy->protocolMatchesSelf(url);
    if (equalIgnoringCase(m_scheme, ""http""))
        return equalIgnoringCase(url.protocol(), ""http"") || equalIgnoringCase(url.protocol(), ""https"");
    if (equalIgnoringCase(m_scheme, ""ws""))
        return equalIgnoringCase(url.protocol(), ""ws"") || equalIgnoringCase(url.protocol(), ""wss"");
     return equalIgnoringCase(url.protocol(), m_scheme);
 }
 ","The CSPSource::schemeMatches function in WebKit/Source/core/frame/csp/CSPSource.cpp in the Content Security Policy (CSP) implementation in Blink, as used in Google Chrome before 48.0.2564.82, does not apply http policies to https URLs and does not apply ws policies to wss URLs, which makes it easier for remote attackers to determine whether a specific HSTS web site has been visited by reading a CSP report."
2988,CVE-2016-1618," 
 
 #include ""base/lazy_instance.h""
 #include ""base/macros.h""
#include ""base/rand_util.h""
 #include ""third_party/WebKit/public/platform/Platform.h""
 #include ""third_party/WebKit/public/web/WebKit.h""
 
  class MockBlinkPlatform : NON_EXPORTED_BASE(public blink::Platform) {
   }
   ~MockBlinkPlatform() override {}
   void cryptographicallyRandomValues(unsigned char* buffer,
                                     size_t length) override {
    base::RandBytes(buffer, length);
  }

  private:
   DISALLOW_COPY_AND_ASSIGN(MockBlinkPlatform);
 };","Blink, as used in Google Chrome before 48.0.2564.82, does not ensure that a proper cryptographicallyRandomValues random number generator is used, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors."
2989,CVE-2016-1620,"  void GpuProcessHost::OnProcessCrashed(int exit_code) {
   int process_crash_exit_code = exit_code;
   base::debug::Alias(&process_crash_exit_code);
 
   
  RecordProcessCrash();

    
    
    
  void GpuProcessHost::OnProcessCrashed(int exit_code) {
     }
   }
   SendOutstandingReplies(EstablishChannelStatus::GPU_HOST_INVALID);
 
   ChildProcessTerminationInfo info =
       process_->GetTerminationInfo(true  );
  void GpuProcessHost::DidFailInitialize() {
   UMA_HISTOGRAM_BOOLEAN(""GPU.GPUProcessInitialized"", false);
   status_ = FAILURE;
   GpuDataManagerImpl* gpu_data_manager = GpuDataManagerImpl::GetInstance();
  if (kind_ == GPU_PROCESS_KIND_SANDBOXED)
    gpu_data_manager->FallBackToNextGpuMode();
   RunRequestGPUInfoCallbacks(gpu_data_manager->GetGPUInfo());
 }
 ",Multiple unspecified vulnerabilities in Google Chrome before 48.0.2564.82 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2990,CVE-2016-1696," 
 #include ""extensions/common/permissions/permissions_data.h""
 #include ""extensions/common/switches.h""
 #include ""extensions/renderer/dispatcher.h""
#include ""extensions/renderer/i18n_custom_bindings.h""
#include ""extensions/renderer/lazy_background_page_native_handler.h""
 #include ""extensions/renderer/native_handler.h""
 #include ""extensions/renderer/resource_bundle_source_map.h""
 #include ""extensions/renderer/script_context.h""
  void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(
       ""automationInternal"",
       std::unique_ptr<NativeHandler>(
           new extensions::AutomationInternalCustomBindings(context)));

   
   
   
   
   
  module_system->RegisterNativeHandler(
      ""i18n"",
      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));
  module_system->RegisterNativeHandler(
      ""lazy_background_page"",
      scoped_ptr<NativeHandler>(
          new extensions::LazyBackgroundPageNativeHandler(context)));
 }
 
 void ChromeExtensionsDispatcherDelegate::PopulateSourceMap(","The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors."
2991,CVE-2016-1700,"  void RuntimeCustomBindings::GetExtensionViews(
   std::vector<content::RenderFrame*> frames =
       ExtensionFrameHelper::GetExtensionFrames(extension_id, browser_window_id,
                                                view_type);
  v8::Local<v8::Context> v8_context = args.GetIsolate()->GetCurrentContext();
   v8::Local<v8::Array> v8_views = v8::Array::New(args.GetIsolate());
   int v8_index = 0;
   for (content::RenderFrame* frame : frames) {
  void RuntimeCustomBindings::GetExtensionViews(
     if (!context.IsEmpty()) {
       v8::Local<v8::Value> window = context->Global();
       DCHECK(!window.IsEmpty());
      v8::Maybe<bool> maybe =
        v8_views->CreateDataProperty(v8_context, v8_index++, window);
      DCHECK(maybe.IsJust() && maybe.FromJust());
     }
   }
 ","extensions/renderer/runtime_custom_bindings.cc in Google Chrome before 51.0.2704.79 does not consider side effects during creation of an array of extension views, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors related to extensions."
2992,CVE-2016-1667," 
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_PEERCONNECTION_ADAPTERS_P2P_QUIC_STREAM_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_PEERCONNECTION_ADAPTERS_P2P_QUIC_STREAM_H_
 
#include <stdint.h>
#include <vector>

 namespace blink {
 
  
  namespace blink {
  
  
  
 
 
 class P2PQuicStream {
  public:
    
  class P2PQuicStream {
      
      
     virtual void OnRemoteFinish() {}

     
     
     
     
     
     
    virtual void OnWriteDataConsumed(uint32_t amount) {}
   };
 
   virtual ~P2PQuicStream() = default;
  class P2PQuicStream {
    
   virtual void Reset() = 0;
 
   
   
   
   
   
   
   
  virtual void WriteData(std::vector<uint8_t> data, bool fin) = 0;
 
    
   virtual void SetDelegate(Delegate* delegate) = 0;
 };
 
 }   ","The TreeScope::adoptIfNeeded function in WebKit/Source/core/dom/TreeScope.cpp in the DOM implementation in Blink, as used in Google Chrome before 50.0.2661.102, does not prevent script execution during node-adoption operations, which allows remote attackers to bypass the Same Origin Policy via a crafted web site."
2993,CVE-2016-1670,"  enum BadMessageReason {
   BDH_DEVICE_NOT_ALLOWED_FOR_ORIGIN = 105,
   ACI_WRONG_STORAGE_PARTITION = 106,
   RDHI_WRONG_STORAGE_PARTITION = 107,
  RDH_INVALID_REQUEST_ID = 108,
 
    
    ",Race condition in the ResourceDispatcherHostImpl::BeginRequest function in content/browser/loader/resource_dispatcher_host_impl.cc in Google Chrome before 50.0.2661.102 allows remote attackers to make arbitrary HTTP requests by leveraging access to a renderer process and reusing a request ID.
2994,CVE-2016-1671,"  using EnableIfSpanCompatibleArray =
                      ContainerHasConvertibleData<Array, T>::value>;
 
  
template <typename Container, typename T>
using IsSpanCompatibleContainer =
    std::conditional_t<!IsSpan<Container>::value &&
                           !IsStdArray<Container>::value &&
                           !IsCArray<Container>::value &&
                           ContainerHasConvertibleData<Container, T>::value &&
                           ContainerHasIntegralSize<Container>::value,
                       std::true_type,
                       std::false_type>;

 template <typename Container, typename T>
 using EnableIfSpanCompatibleContainer =
    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value>;

template <typename Container, typename T, size_t Extent>
using EnableIfSpanCompatibleContainerAndSpanIsDynamic =
    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&
                         Extent == dynamic_extent,
                     bool>;

template <typename Container, typename T, size_t Extent>
using EnableIfSpanCompatibleContainerAndSpanIsStatic =
    std::enable_if_t<IsSpanCompatibleContainer<Container, T>::value &&
                         Extent != dynamic_extent,
                     bool>;
 
  
  
  struct ExtentStorage<dynamic_extent> {
  
  
  
 
 
 
 
  
  
  
  class span : public internal::ExtentStorage<Extent> {
 
    
    
  template <
      typename Container,
      internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<Container&,
                                                                T,
                                                                Extent> = false>
   constexpr span(Container& container) noexcept
       : span(base::data(container), base::size(container)) {}
 
   template <
       typename Container,
      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<Container&,
                                                               T,
                                                               Extent> = false>
  constexpr explicit span(Container& container) noexcept
      : span(base::data(container), base::size(container)) {}

  template <typename Container,
            internal::EnableIfSpanCompatibleContainerAndSpanIsDynamic<
                const Container&,
                T,
                Extent> = false>
  constexpr span(const Container& container) noexcept
      : span(base::data(container), base::size(container)) {}

  template <
      typename Container,
      internal::EnableIfSpanCompatibleContainerAndSpanIsStatic<const Container&,
                                                               T,
                                                               Extent> = false>
  constexpr explicit span(const Container& container) noexcept
       : span(base::data(container), base::size(container)) {}
 
   constexpr span(const span& other) noexcept = default;
  constexpr span<T> make_span(const Container& container) noexcept {
   return container;
 }
 
template <size_t N,
          typename Container,
          typename T = typename Container::value_type,
          typename = internal::EnableIfSpanCompatibleContainer<Container&, T>>
constexpr span<T, N> make_span(Container& container) noexcept {
  return span<T, N>(container);
}

template <
    size_t N,
    typename Container,
    typename T = const typename Container::value_type,
    typename = internal::EnableIfSpanCompatibleContainer<const Container&, T>>
constexpr span<T, N> make_span(const Container& container) noexcept {
  return span<T, N>(container);
}

 template <typename T, size_t X>
 constexpr span<T, X> make_span(const span<T, X>& span) noexcept {
   return span;","Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and  (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc."
2995,CVE-2016-1652," 
 
 #include ""base/callback_helpers.h""
 #include ""base/macros.h""
#include ""base/strings/stringprintf.h""
 #include ""base/strings/utf_string_conversions.h""
#include ""build/build_config.h""
 #include ""chrome/browser/browser_process.h""
 #include ""chrome/browser/profile_resetter/brandcoded_default_settings.h""
 #include ""libxml/parser.h""
 
 #include ""services/network/public/cpp/simple_url_loader.h""
 #include ""services/network/public/mojom/url_loader_factory.mojom.h""
 
#if defined(OS_WIN)
#include ""chrome/install_static/install_util.h""
#endif   

 namespace {
 
constexpr char kDefaultAppID[] = ""{8A69D345-D564-463C-AFF1-A69D9E530F96}"";
constexpr int kDownloadTimeoutSec = 10;
constexpr char kPostXml[] =
     ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>""
     ""<request""
     ""    version=\""chromeprofilereset-1.1\""""
     ""    protocol=\""3.0\""""
     ""    installsource=\""profilereset\"">""
    ""  <app appid=\""%s\"">""
    ""    <data name=\""install\"" index=\""%s\""/>""
     ""  </app>""
     ""</request>"";
 
  
  
 std::string GetUploadData(const std::string& brand) {
  std::string app_id(kDefaultAppID);
#if defined(OS_WIN)
  app_id = install_static::UTF16ToUTF8(install_static::GetAppGuid());
#endif   
   DCHECK(!brand.empty());
  return base::StringPrintf(kPostXml, app_id.c_str(), brand.c_str());
 }
 
  ","Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka *Universal XSS (UXSS).*"
2996,CVE-2016-1654,"  void NavigationRequest::OnStartChecksComplete(
           : frame_tree_node_->frame_tree()->root()->current_url();
 
    
   
    
    
    
  void NavigationRequest::OnStartChecksComplete(
     }
     current = current->parent();
   }

   const GURL& site_for_cookies =
      (ancestors_are_same_site || !base_url.is_empty())
           ? (frame_tree_node_->IsMainFrame() ? common_params_.url
                                              : top_document_url)
          : GURL(""data:,"");
   bool parent_is_main_frame = !frame_tree_node_->parent()
                                   ? false
                                   : frame_tree_node_->parent()->IsMainFrame();","The media subsystem in Google Chrome before 50.0.2661.75 does not initialize an unspecified data structure, which allows remote attackers to cause a denial of service (invalid read operation) via unknown vectors."
2997,CVE-2016-1658," 
 #include ""extensions/common/permissions/permissions_data.h""
 #include ""net/url_request/url_request.h""
 #include ""url/gurl.h""
#include ""url/origin.h""
 
 using content::ResourceRequestInfo;
 
  bool WebRequestPermissions::CanExtensionAccessURL(
     case REQUIRE_HOST_PERMISSION:
        
        
      if (!url.SchemeIs(url::kAboutScheme) &&
          !extension->permissions_data()->HasHostPermission(url) &&
          !url::IsSameOriginWith(url, extension->url())) {
         return false;
       }
       break;","The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension."
2998,CVE-2016-1643,"  TEST(HTMLInputElementTest, DefaultToolTip)
     EXPECT_EQ(String(), inputWithForm->defaultToolTip());
 }
 
 
TEST(HTMLInputElementTest, ImageTypeCrash)
{
    RefPtrWillBeRawPtr<Document> document = Document::create();
    RefPtrWillBeRawPtr<HTMLInputElement> input = HTMLInputElement::create(*document, nullptr, false);
    input->setAttribute(HTMLNames::typeAttr, ""image"");
    input->ensureFallbackContent();
     
     
    input->ensurePrimaryContent();
    input->setAttribute(HTMLNames::valueAttr, ""aaa"");
}

 }  ","The ImageInputType::ensurePrimaryContent function in WebKit/Source/core/html/forms/ImageInputType.cpp in Blink, as used in Google Chrome before 49.0.2623.87, does not properly maintain the user agent shadow DOM, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*"
2999,CVE-2016-1622," 
 #include ""chrome/browser/extensions/extension_apitest.h""
 #include ""chrome/browser/net/url_request_mock_util.h""
 #include ""chrome/browser/ui/browser.h""
#include ""chrome/browser/ui/tabs/tab_strip_model.h""
#include ""chrome/test/base/ui_test_utils.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/test/browser_test_utils.h""
 #include ""extensions/browser/extension_host.h""
 #include ""extensions/browser/process_manager.h""
 #include ""extensions/test/extension_test_message_listener.h""
 #include ""extensions/test/result_catcher.h""
#include ""net/test/embedded_test_server/embedded_test_server.h""
 
 namespace extensions {
 namespace {
  IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, ModuleSystem) {
   ASSERT_TRUE(RunExtensionTest(""bindings/module_system"")) << message_;
 }
 
IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, NoExportOverriding) {
  ASSERT_TRUE(embedded_test_server()->InitializeAndWaitUntilReady());

   
   
  ASSERT_TRUE(LoadExtension(
      test_data_dir_.AppendASCII(""bindings"")
                    .AppendASCII(""externally_connectable_everywhere"")));

  ui_test_utils::NavigateToURL(
      browser(),
      embedded_test_server()->GetURL(
          ""/extensions/api_test/bindings/override_exports.html""));

   
  std::string result;
  EXPECT_TRUE(content::ExecuteScriptAndExtractString(
      browser()->tab_strip_model()->GetActiveWebContents(),
      ""window.domAutomationController.send(""
          ""document.getElementById('status').textContent.trim());"",
      &result));
  EXPECT_EQ(""success"", result);
}

 }   
 }   ","The Extensions subsystem in Google Chrome before 48.0.2564.109 does not prevent use of the Object.defineProperty method to override intended extension behavior, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code."
3000,CVE-2016-1623,"  void Document::attach(const AttachContext& context)
 void Document::detach(const AttachContext& context)
 {
     TRACE_EVENT0(""blink"", ""Document::detach"");
    RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);
     if (!isActive())
         return;
 ","The DOM implementation in Google Chrome before 48.0.2564.109 does not properly restrict frame-attach operations from occurring during or after frame-detach operations, which allows remote attackers to bypass the Same Origin Policy via a crafted web site, related to FrameLoader.cpp, HTMLFrameOwnerElement.h, LocalFrame.cpp, and WebLocalFrameImpl.cpp."
3001,CVE-2016-1625," 
 #include ""base/files/file_path.h""
 #include ""base/unguessable_token.h""
 #include ""content/public/browser/browser_context.h""
 #include ""content/public/browser/resource_context.h""
 #include ""headless/lib/browser/headless_browser_context_options.h""
 #include ""headless/lib/browser/headless_network_conditions.h""","The Chrome Instant feature in Google Chrome before 48.0.2564.109 does not ensure that a New Tab Page (NTP) navigation target is on the most-visited or suggestions list, which allows remote attackers to bypass intended restrictions via unspecified vectors, related to instant_service.cc and search_tab_helper.cc."
3002,CVE-2017-5122," 
 
 #include ""ash/public/cpp/immersive/immersive_fullscreen_controller.h""
 
 #include ""ash/public/cpp/immersive/immersive_fullscreen_controller_delegate.h""
 #include ""ash/public/cpp/immersive/immersive_fullscreen_controller_test_api.h""
 #include ""ash/public/cpp/shelf_types.h""
  class ImmersiveFullscreenControllerTest : public AshTestBase {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, Delegate) {
    
   EXPECT_FALSE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
  TEST_F(ImmersiveFullscreenControllerTest, RevealedLock) {
 
  
 TEST_F(ImmersiveFullscreenControllerTest, OnMouseEvent) {
    
   SetEnabled(true);
   ASSERT_TRUE(controller()->IsEnabled());
  TEST_F(ImmersiveFullscreenControllerTest, OnMouseEvent) {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, Inactive) {
    
   views::Widget* popup_widget = views::Widget::CreateWindowWithContextAndBounds(
       nullptr, CurrentContext(), gfx::Rect(0, 0, 200, 200));
  TEST_F(ImmersiveFullscreenControllerTest, Inactive) {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, MouseEventsVerticalDisplayLayout) {
    
   UpdateDisplay(""800x600,800x600"");
   ash::Shell::Get()->display_manager()->SetLayoutForCurrentDisplays(
  TEST_F(ImmersiveFullscreenControllerTest, MouseEventsVerticalDisplayLayout) {
 
  
 TEST_F(ImmersiveFullscreenControllerTest, MouseHoveredWithoutMoving) {
   SetEnabled(true);
   std::unique_ptr<ImmersiveRevealedLock> lock;
 
  TEST_F(ImmersiveFullscreenControllerTest, MouseHoveredWithoutMoving) {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, DifferentModalityEnterExit) {
   SetEnabled(true);
   EXPECT_TRUE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
  TEST_F(ImmersiveFullscreenControllerTest, DifferentModalityEnterExit) {
 
  
 TEST_F(ImmersiveFullscreenControllerTest, EndRevealViaGesture) {
   SetEnabled(true);
   EXPECT_TRUE(controller()->IsEnabled());
   EXPECT_FALSE(controller()->IsRevealed());
  TEST_F(ImmersiveFullscreenControllerTest, EndRevealViaGesture) {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, RevealViaGestureChildConsumesEvents) {
    
   SetEnabled(true);
   EXPECT_TRUE(controller()->IsEnabled());
  TEST_F(ImmersiveFullscreenControllerTest, WindowStateImmersiveFullscreen) {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, Focus) {
    
    
   views::View* child_view = new views::View();
  TEST_F(ImmersiveFullscreenControllerTest, Focus) {
  
  
 TEST_F(ImmersiveFullscreenControllerTest, Transient) {
   views::Widget* top_container_widget = top_container()->GetWidget();
 
   SetEnabled(true);
  TEST_F(ImmersiveFullscreenControllerTest, Transient) {
 
  
 TEST_F(ImmersiveFullscreenControllerTest, Bubbles) {
   std::unique_ptr<ImmersiveRevealedLock> revealed_lock;
   views::Widget* top_container_widget = top_container()->GetWidget();
 ",Inappropriate use of table size handling in V8 in Google Chrome prior to 61.0.3163.100 for Windows allowed a remote attacker to trigger out-of-bounds access via a crafted HTML page.
3003,CVE-2017-5112,"  void WebGL2RenderingContextBase::
                           ObjectOrZero(bound_pixel_unpack_buffer_.Get()));
 }
 
void WebGL2RenderingContextBase::
    DrawingBufferClientRestorePixelPackBufferBinding() {
  if (!ContextGL())
    return;
  ContextGL()->BindBuffer(GL_PIXEL_PACK_BUFFER,
                          ObjectOrZero(bound_pixel_pack_buffer_.Get()));
}

void WebGL2RenderingContextBase::
    DrawingBufferClientRestorePixelPackParameters() {
  if (!ContextGL())
    return;

  ContextGL()->PixelStorei(GL_PACK_ROW_LENGTH, pack_row_length_);
  ContextGL()->PixelStorei(GL_PACK_SKIP_ROWS, pack_skip_rows_);
  ContextGL()->PixelStorei(GL_PACK_SKIP_PIXELS, pack_skip_pixels_);

  WebGLRenderingContextBase::DrawingBufferClientRestorePixelPackParameters();
}

 }   ",Heap buffer overflow in WebGL in Google Chrome prior to 61.0.3163.79 for Windows allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.
3004,CVE-2017-5116,"  class InternalPageInfoBubbleView : public views::BubbleDialogDelegateView {
   ~InternalPageInfoBubbleView() override;
 
    
   int GetDialogButtons() const override;
  base::string16 GetWindowTitle() const override;
  bool ShouldShowCloseButton() const override;
  gfx::ImageSkia GetWindowIcon() override;
  bool ShouldShowWindowIcon() const override;
  void OnWidgetDestroying(views::Widget* widget) override;
 
  private:
  base::string16 title_text_;
  gfx::ImageSkia* bubble_icon_;
 
   DISALLOW_COPY_AND_ASSIGN(InternalPageInfoBubbleView);
 };
  InternalPageInfoBubbleView::InternalPageInfoBubbleView(
   set_anchor_view_insets(gfx::Insets(
       GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));
 
   
   
  set_title_margins(
      ChromeLayoutProvider::Get()->GetInsetsMetric(views::INSETS_DIALOG));
   set_margins(gfx::Insets());
 
  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
  bubble_icon_ = rb.GetImageSkiaNamed(icon);
  title_text_ = l10n_util::GetStringUTF16(text);
 
   views::BubbleDialogDelegateView::CreateBubble(this);

   
  views::Label* title_label =
      static_cast<views::Label*>(GetBubbleFrameView()->title());
  title_label->SetFontList(views::Label::GetDefaultFontList());
  title_label->SetMultiLine(false);
  title_label->SetElideBehavior(gfx::NO_ELIDE);

  SizeToContents();
 }
 
 InternalPageInfoBubbleView::~InternalPageInfoBubbleView() {}
 
int InternalPageInfoBubbleView::GetDialogButtons() const {
  return ui::DIALOG_BUTTON_NONE;
}

base::string16 InternalPageInfoBubbleView::GetWindowTitle() const {
  return title_text_;
}

bool InternalPageInfoBubbleView::ShouldShowCloseButton() const {
   
   
  return ui::MaterialDesignController::IsSecondaryUiMaterial();
}

gfx::ImageSkia InternalPageInfoBubbleView::GetWindowIcon() {
  return *bubble_icon_;
}

bool InternalPageInfoBubbleView::ShouldShowWindowIcon() const {
  return ChromeLayoutProvider::Get()->ShouldShowWindowIcon();
}

 void InternalPageInfoBubbleView::OnWidgetDestroying(views::Widget* widget) {
   g_shown_bubble_type = PageInfoBubbleView::BUBBLE_NONE;
   g_page_info_bubble = nullptr;
 }
 
  
  
  ","Type confusion in V8 in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page."
3005,CVE-2017-5091,"  CursorImpl::IDBThreadHelper::IDBThreadHelper(
     std::unique_ptr<IndexedDBCursor> cursor)
     : cursor_(std::move(cursor)) {}
 
CursorImpl::IDBThreadHelper::~IDBThreadHelper() {}
 
 void CursorImpl::IDBThreadHelper::Advance(
     uint32_t count,","A use after free in IndexedDB in Google Chrome prior to 60.0.3112.78 for Linux, Android, Windows, and Mac allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
3006,CVE-2017-5092,"  bool BrowserPpapiHostImpl::IsPotentiallySecurePluginContext(
 void BrowserPpapiHostImpl::AddInstance(
     PP_Instance instance,
     const PepperRendererInstanceData& renderer_instance_data) {
   
   
   
   
  if (instance_map_.find(instance) == instance_map_.end()) {
    instance_map_[instance] =
        base::MakeUnique<InstanceData>(renderer_instance_data);
  } else {
    NOTREACHED();
  }
 }
 
 void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
   
   
   
   
   auto it = instance_map_.find(instance);
  if (it != instance_map_.end()) {
     
     
     
     
     
    for (auto& observer : it->second->observer_list)
      observer.OnHostDestroyed();
 
    instance_map_.erase(it);
  } else {
    NOTREACHED();
  }
 }
 
 void BrowserPpapiHostImpl::AddInstanceObserver(PP_Instance instance,",Insufficient validation of untrusted input in PPAPI Plugins in Google Chrome prior to 60.0.3112.78 for Windows allowed a remote attacker to potentially perform a sandbox escape via a crafted HTML page.
3007,CVE-2017-5093,"  void PrintJobWorker::GetSettingsWithUI(
     bool is_scripted) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
  PrintingContextDelegate* printing_context_delegate =
      static_cast<PrintingContextDelegate*>(printing_context_delegate_.get());
  content::WebContents* web_contents =
      printing_context_delegate->GetWebContents();

 #if defined(OS_ANDROID)
   if (is_scripted) {
     TabAndroid* tab =
         web_contents ? TabAndroid::FromWebContents(web_contents) : nullptr;
 
  void PrintJobWorker::GetSettingsWithUI(
   }
 #endif
 
   
   
  if (web_contents->IsFullscreenForCurrentTab())
    web_contents->ExitFullscreen(true);

    
   printing_context_->AskUserForSettings(
       document_page_count, has_selection, is_scripted,","Inappropriate implementation in modal dialog handling in Blink in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to prevent a full screen warning from being displayed via a crafted HTML page."
3008,CVE-2017-5094,"  void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_.reset();
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    sk_sp<SkColorSpace> sk_color_space = color_space.ToSkColorSpace();
    if (!SkColorSpace::Equals(characterization_.refColorSpace().get(),
                              sk_color_space.get())) {
      characterization_ = characterization_.createColorSpace(sk_color_space);
    }
    if (size.width() != characterization_.width() ||
        size.height() != characterization_.height()) {
      characterization_ =
          characterization_.createResized(size.width(), size.height());
    }
     
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
  void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
 
    
    
  auto task = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::Reshape,
                             base::Unretained(impl_on_gpu_.get()), size,
                             device_scale_factor, color_space, has_alpha,
                             use_stencil, pre_transform_, characterization,
                             initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(task), {});
 }
 
 void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(","Type confusion in extensions JavaScript bindings in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted HTML page."
3009,CVE-2017-5099,"  bool BrowserPpapiHostImpl::IsPotentiallySecurePluginContext(
 void BrowserPpapiHostImpl::AddInstance(
     PP_Instance instance,
     const PepperRendererInstanceData& renderer_instance_data) {
   
   
   
   
  if (instance_map_.find(instance) == instance_map_.end()) {
    instance_map_[instance] =
        base::MakeUnique<InstanceData>(renderer_instance_data);
  } else {
    NOTREACHED();
  }
 }
 
 void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
   
   
   
   
   auto it = instance_map_.find(instance);
  if (it != instance_map_.end()) {
     
     
     
     
     
    for (auto& observer : it->second->observer_list)
      observer.OnHostDestroyed();
 
    instance_map_.erase(it);
  } else {
    NOTREACHED();
  }
 }
 
 void BrowserPpapiHostImpl::AddInstanceObserver(PP_Instance instance,",Insufficient validation of untrusted input in PPAPI Plugins in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to potentially gain privilege elevation via a crafted HTML page.
3010,CVE-2017-5101,"  V4L2JpegEncodeAccelerator::JobRecord::JobRecord(
       output_frame(output_frame),
       quality(quality),
       task_id(task_id),
      output_shm(base::subtle::PlatformSharedMemoryRegion(), 0, true),   
       exif_shm(nullptr) {
   if (exif_buffer) {
     exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),","Inappropriate implementation in Omnibox in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to spoof the contents of the Omnibox via a crafted HTML page."
3011,CVE-2017-5104,"  const std::string& InterstitialPageImpl::GetUserAgentOverride() const {
   return base::EmptyString();
 }
 
bool InterstitialPageImpl::ShowingInterstitialPage() const {
   
  return false;
}

 RendererPreferences InterstitialPageImpl::GetRendererPrefs(
     BrowserContext* browser_context) const {
   delegate_->OverrideRendererPrefs(&renderer_preferences_);",Inappropriate implementation in interstitials in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to spoof the contents of the omnibox via a crafted HTML page.
3012,CVE-2017-5105,"  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
     
     
     dangerous_pattern = new icu::RegexMatcher(
         icu::UnicodeString(
             R""([^\p{scx=kana}\p{scx=hira}\p{scx=hani}])""
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""([\p{scx=armn}][og]+[\p{scx=armn}]|)""
             R""([\p{sc=cans}].*[a-z]|[a-z].*[\p{sc=cans}]|)""
             R""([\p{sc=tfng}].*[a-z]|[a-z].*[\p{sc=tfng}]|)""
            R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
            R""([^\p{scx=arab}][\u064b-\u0655\u0670]|)""
            R""([^\p{scx=hebr}]\u05b4)"",
             -1, US_INV),
         0, status);
     tls_index.Set(dangerous_pattern);","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
3013,CVE-2017-5107," 
 #include ""ash/strings/grit/ash_strings.h""
 #include ""components/media_message_center/media_controls_progress_view.h""
 #include ""components/media_message_center/media_notification_util.h""
 #include ""services/media_session/public/cpp/util.h""
 #include ""services/media_session/public/mojom/constants.mojom.h""
 #include ""services/media_session/public/mojom/media_session.mojom.h""
 
 #include ""ui/views/controls/button/image_button_factory.h""
 #include ""ui/views/controls/image_view.h""
 #include ""ui/views/layout/box_layout.h""
 
 namespace ash {
 
 using media_session::mojom::MediaSessionAction;
 
 namespace {
 
constexpr SkColor kMediaControlsBackground = SkColorSetA(SK_ColorDKGRAY, 150);
 constexpr SkColor kMediaButtonColor = SK_ColorWHITE;
 
  
 constexpr size_t kMaxActions = 5;
 
  
constexpr gfx::Insets kMediaControlsInsets = gfx::Insets(15, 15, 15, 15);
 constexpr int kMediaControlsCornerRadius = 8;
 constexpr int kMinimumIconSize = 16;
 constexpr int kDesiredIconSize = 20;
 constexpr int kIconSize = 20;
constexpr int kMinimumArtworkSize = 50;
constexpr int kDesiredArtworkSize = 80;
constexpr gfx::Size kArtworkSize = gfx::Size(80, 80);
constexpr gfx::Size kMediaButtonSize = gfx::Size(38, 38);
constexpr int kMediaButtonRowSeparator = 24;
constexpr gfx::Insets kButtonRowInsets = gfx::Insets(10, 0, 0, 0);
constexpr int kPlayPauseIconSize = 28;
constexpr int kChangeTrackIconSize = 14;
constexpr int kSeekingIconsSize = 26;
 constexpr gfx::Size kMediaControlsButtonRowSize =
    gfx::Size(300, kMediaButtonSize.height());
 
 constexpr int kDragVelocityThreshold = -6;
 constexpr int kHeightDismissalThreshold = 20;
  LockScreenMediaControlsView::LockScreenMediaControlsView(
 
   contents_view_ = AddChildView(std::make_unique<views::View>());
   contents_view_->SetLayoutManager(std::make_unique<views::BoxLayout>(
      views::BoxLayout::Orientation::kVertical, kMediaControlsInsets));
   contents_view_->SetBackground(views::CreateRoundedRectBackground(
       kMediaControlsBackground, kMediaControlsCornerRadius));
 
   contents_view_->SetPaintToLayer();   
   contents_view_->layer()->SetFillsBoundsOpaquely(false);
 
    
   
  header_row_ = contents_view_->AddChildView(
      std::make_unique<MediaControlsHeaderView>(base::BindOnce(
          &LockScreenMediaControlsView::Dismiss, base::Unretained(this))));
 
   auto session_artwork = std::make_unique<views::ImageView>();
  session_artwork->SetPreferredSize(kArtworkSize);
  session_artwork->SetHorizontalAlignment(
      views::ImageView::Alignment::kLeading);
   session_artwork_ = contents_view_->AddChildView(std::move(session_artwork));
 
   progress_ = contents_view_->AddChildView(
  const char* LockScreenMediaControlsView::GetClassName() const {
 }
 
 gfx::Size LockScreenMediaControlsView::CalculatePreferredSize() const {
  return contents_view_->GetPreferredSize();
 }
 
 void LockScreenMediaControlsView::Layout() {
  void LockScreenMediaControlsView::OnMouseEntered(const ui::MouseEvent& event) {
   if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())
     return;
 
  header_row_->SetCloseButtonVisibility(true);
 }
 
 void LockScreenMediaControlsView::OnMouseExited(const ui::MouseEvent& event) {
   if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())
     return;
 
  header_row_->SetCloseButtonVisibility(false);
 }
 
 views::View* LockScreenMediaControlsView::GetMiddleSpacingView() {
  void LockScreenMediaControlsView::OnImplicitAnimationsCompleted() {
 
 void LockScreenMediaControlsView::ButtonPressed(views::Button* sender,
                                                 const ui::Event& event) {
   if (!base::Contains(enabled_actions_,
                       media_message_center::GetActionFromButtonTag(*sender)) ||
       !media_session_id_.has_value()) {
  void LockScreenMediaControlsView::SetArtwork(
     return;
   }
 
  session_artwork_->SetImageSize(ScaleSizeToFitView(img->size(), kArtworkSize));
   session_artwork_->SetImage(*img);
 }
 ","A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page."
3014,CVE-2017-5108,"  static bool ShouldAutofocus(const HTMLFormControlElement* element) {
   Document& doc = element->GetDocument();
 
    
  if (!doc.GetFrame())
    return false;
 
    
    ","Type confusion in PDFium in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted PDF file."
3015,CVE-2017-5087,"  void DatabaseImpl::IDBThreadHelper::CreateTransaction(
   if (!connection_->IsConnected())
     return;
 
   
  if (connection_->GetTransaction(transaction_id))
    return;

   connection_->database()->CreateTransaction(transaction_id, connection_.get(),
                                              object_store_ids, mode);
 }","A use after free in Blink in Google Chrome prior to 59.0.3071.104 for Mac, Windows, and Linux, and 59.0.3071.117 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page, aka an IndexedDB sandbox escape."
3016,CVE-2017-5089," 
 #include ""content/public/browser/browser_thread.h""
 #include ""net/http/http_status_code.h""
 
using BrowserDMToken = policy::BrowserDMTokenStorage::BrowserDMToken;

 namespace safe_browsing {
 namespace {
 
  const int kScanningTimeoutSeconds = 5 * 60;            
  
 const char kSbBinaryUploadUrl[] = """";
 
const char** GetTestingDMTokenStorage() {
  static const char* dm_token = """";
   return &dm_token;
 }
 
BrowserDMToken GetTestingDMToken() {
  const char* dm_token = *GetTestingDMTokenStorage();
  return dm_token && dm_token[0] ? BrowserDMToken::CreateValidToken(dm_token)
                                 : BrowserDMToken::CreateEmptyToken();
}

policy::BrowserDMTokenStorage::BrowserDMToken GetDMToken() {
  auto dm_token = GetTestingDMToken();
 
 #if !defined(OS_CHROMEOS)
    
    
    
    
 
  if (dm_token.is_empty() &&
       policy::ChromeBrowserCloudManagementController::IsEnabled()) {
    dm_token = policy::BrowserDMTokenStorage::Get()->RetrieveBrowserDMToken();
   }
 #endif
 
  void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
   if (!can_upload_data_.has_value()) {
      
     if (!pending_validate_data_upload_request_) {
      auto dm_token = GetDMToken();
      if (!dm_token.is_valid()) {
         std::move(callback).Run(false);
         return;
       }
  void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
           &BinaryUploadService::ValidateDataUploadRequestCallback,
           weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(dm_token.value());
       UploadForDeepScanning(std::move(request));
     }
     authorization_callbacks_.push_back(std::move(callback));",Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 59.0.3071.104 for Mac allowed a remote attacker to perform domain spoofing via a crafted domain name.
3017,CVE-2017-5086,"  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
     
      
      
      
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""(^[og]+[\p{scx=armn}]|[\p{scx=armn}][og]+$|)""
             R""([\p{scx=armn}][og]+[\p{scx=armn}]|)""
             R""([\p{sc=cans}].*[a-z]|[a-z].*[\p{sc=cans}]|)""
            R""([\p{sc=tfng}].*[a-z]|[a-z].*[\p{sc=tfng}]|)""
             R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339])"",
             -1, US_INV),
         0, status);",Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 59.0.3071.86 for Windows and Mac allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name.
3018,CVE-2017-5076,"  void RequestSender::OnNetworkFetcherComplete(
   VLOG(1) << ""request completed from url: "" << original_url.spec();
 
   int error = -1;
  if (!net_error && response_code_ == 200)
     error = 0;
  else if (response_code_ != -1)
     error = response_code_;
  else
     error = net_error;
 
   int retry_after_sec = -1;
   if (original_url.SchemeIsCryptographic() && error > 0)","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 59.0.3071.86 for Mac, Windows, and Linux, and 59.0.3071.92 for Android, allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
3019,CVE-2017-5077,"  PageRequestSummary::PageRequestSummary(const PageRequestSummary& other) =
 
 void PageRequestSummary::UpdateOrAddToOrigins(
     const content::mojom::ResourceLoadInfo& resource_load_info) {
  for (const auto& redirect_info : resource_load_info.redirect_info_chain) {
    UpdateOrAddToOrigins(url::Origin::Create(redirect_info->url),
                         redirect_info->network_info);
  }
  UpdateOrAddToOrigins(url::Origin::Create(resource_load_info.url),
                       resource_load_info.network_info);
 }
 
 void PageRequestSummary::UpdateOrAddToOrigins(
    const url::Origin& origin,
     const content::mojom::CommonNetworkInfoPtr& network_info) {
  if (origin.opaque())
     return;
 
   auto it = origins.find(origin);","Insufficient validation of untrusted input in Skia in Google Chrome prior to 59.0.3071.86 for Linux, Windows, and Mac, and 59.0.3071.92 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
3020,CVE-2017-5078,"  ScrollAnchor::ExamineResult ScrollAnchor::Examine(
   LayoutRect visible_rect =
       ScrollerLayoutBox(scroller_)->OverflowClipRect(LayoutPoint());
 
  const ComputedStyle* style = ScrollerLayoutBox(scroller_)->Style();
  LayoutRectOutsets scroll_padding(
      MinimumValueForLength(style->ScrollPaddingTop(), visible_rect.Height()),
      MinimumValueForLength(style->ScrollPaddingRight(), visible_rect.Width()),
      MinimumValueForLength(style->ScrollPaddingBottom(),
                            visible_rect.Height()),
      MinimumValueForLength(style->ScrollPaddingLeft(), visible_rect.Width()));
  visible_rect.Contract(scroll_padding);

   bool occupies_space =
       candidate_rect.Width() > 0 && candidate_rect.Height() > 0;
   if (occupies_space && visible_rect.Intersects(candidate_rect)) {","Insufficient validation of untrusted input in Blink's mailto: handling in Google Chrome prior to 59.0.3071.86 for Linux, Windows, and Mac allowed a remote attacker to perform command injection via a crafted HTML page, a similar issue to CVE-2004-0121. For example, characters such as * have an incorrect interaction with xdg-email in xdg-utils, and a space character can be used in front of a command-line argument."
3021,CVE-2017-5080,"  SaveCardBubbleControllerImpl::~SaveCardBubbleControllerImpl() {
 void SaveCardBubbleControllerImpl::ShowBubbleForLocalSave(
     const CreditCard& card,
     const base::Closure& save_card_callback) {
   
  if (save_card_bubble_view_)
    return;

   is_uploading_ = false;
   is_reshow_ = false;
   should_cvc_be_requested_ = false;
  void SaveCardBubbleControllerImpl::ShowBubbleForUpload(
     std::unique_ptr<base::DictionaryValue> legal_message,
     bool should_cvc_be_requested,
     const base::Closure& save_card_callback) {
   
  if (save_card_bubble_view_)
    return;

   is_uploading_ = true;
   is_reshow_ = false;
   should_cvc_be_requested_ = should_cvc_be_requested;
  void SaveCardBubbleControllerImpl::HideBubble() {
 }
 
 void SaveCardBubbleControllerImpl::ReshowBubble() {
   
  if (save_card_bubble_view_)
    return;

   is_reshow_ = true;
   AutofillMetrics::LogSaveCardPromptMetric(
       AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,",A use after free in credit card autofill in Google Chrome prior to 59.0.3071.86 for Linux and Windows allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
3022,CVE-2017-5057,"  void FeatureInfo::EnableOESTextureHalfFloatLinear() {
     return;
   AddExtensionString(""GL_OES_texture_half_float_linear"");
   feature_flags_.enable_texture_half_float_linear = true;

   
   
  if (workarounds_.disable_half_float_for_gmb)
    return;
   feature_flags_.gpu_memory_buffer_formats.Add(gfx::BufferFormat::RGBA_F16);
 }
 ","Type confusion in PDFium in Google Chrome prior to 58.0.3029.81 for Mac, Windows, and Linux, and 58.0.3029.83 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted PDF file."
3023,CVE-2017-5060," 
 #include ""base/strings/utf_offset_string_conversions.h""
 #include ""base/strings/utf_string_conversions.h""
 #include ""base/threading/thread_local_storage.h""
#include ""third_party/icu/source/common/unicode/schriter.h""
 #include ""third_party/icu/source/common/unicode/uidna.h""
 #include ""third_party/icu/source/common/unicode/uniset.h""
 #include ""third_party/icu/source/common/unicode/uscript.h""
  base::string16 IDNToUnicodeWithAdjustments(
     base::OffsetAdjuster::Adjustments* adjustments);
 bool IDNToUnicodeOneComponent(const base::char16* comp,
                               size_t comp_len,
                              bool is_tld_ascii,
                               base::string16* out);
 
 class AppendComponentTransform {
  base::string16 IDNToUnicodeWithAdjustments(
   input16.reserve(host.length());
   input16.insert(input16.end(), host.begin(), host.end());
 
  bool is_tld_ascii = true;
  size_t last_dot = host.rfind('.');
  if (last_dot != base::StringPiece::npos &&
      host.substr(last_dot).starts_with("".xn--"")) {
    is_tld_ascii = false;
  }

    
    
   base::string16 out16;
  base::string16 IDNToUnicodeWithAdjustments(
        
       converted_idn =
           IDNToUnicodeOneComponent(input16.data() + component_start,
                                   component_length, is_tld_ascii, &out16);
     }
     size_t new_component_length = out16.length() - new_component_start;
 
  class IDNSpoofChecker {
  public:
   IDNSpoofChecker();
 
   
   
   
   
  bool Check(base::StringPiece16 label, bool is_tld_ascii);
 
  private:
   void SetAllowedUnicodeSet(UErrorCode* status);
  bool IsMadeOfLatinAlikeCyrillic(const icu::UnicodeString& label_string);
 
   USpoofChecker* checker_;
   icu::UnicodeSet deviation_characters_;
   icu::UnicodeSet non_ascii_latin_letters_;
   icu::UnicodeSet kana_letters_exceptions_;
  icu::UnicodeSet cyrillic_letters_;
  icu::UnicodeSet cyrillic_letters_latin_alike_;
 
   DISALLOW_COPY_AND_ASSIGN(IDNSpoofChecker);
 };
  IDNSpoofChecker::IDNSpoofChecker() {
       ""[\\u3078-\\u307a\\u30d8-\\u30da\\u30fb\\u30fc]""), status);
   kana_letters_exceptions_.freeze();
 
   
   
  cyrillic_letters_latin_alike_ =
      icu::UnicodeSet(icu::UnicodeString(""[]""), status);
  cyrillic_letters_latin_alike_.freeze();

  cyrillic_letters_ =
      icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Cyrl:]]""), status);
  cyrillic_letters_.freeze();

   DCHECK(U_SUCCESS(status));
 }
 
bool IDNSpoofChecker::Check(base::StringPiece16 label, bool is_tld_ascii) {
   UErrorCode status = U_ZERO_ERROR;
   int32_t result = uspoof_check(checker_, label.data(),
                                 base::checked_cast<int32_t>(label.size()),
  bool IDNSpoofChecker::Check(base::StringPiece16 label) {
     return false;
 
    
   
   
   
    
    
    
   result &= USPOOF_RESTRICTION_LEVEL_MASK;
  if (result == USPOOF_ASCII) return true;
  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&
      kana_letters_exceptions_.containsNone(label_string)) {
     
    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);
  }
 
    
    
  bool IDNSpoofChecker::Check(base::StringPiece16 label) {
   return !dangerous_pattern->find();
 }
 
bool IDNSpoofChecker::IsMadeOfLatinAlikeCyrillic(
    const icu::UnicodeString& label_string) {
   
   
   
   
   
   
  icu::UnicodeSet cyrillic_in_label;
  icu::StringCharacterIterator it(label_string);
  for (it.setToStart(); it.hasNext();) {
    const UChar32 c = it.next32PostInc();
    if (cyrillic_letters_.contains(c))
      cyrillic_in_label.add(c);
  }
  return !cyrillic_in_label.isEmpty() &&
         cyrillic_letters_latin_alike_.containsAll(cyrillic_in_label);
}

 void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {
   if (U_FAILURE(*status))
     return;
  void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {
  
  
  
bool IsIDNComponentSafe(base::StringPiece16 label, bool is_tld_ascii) {
  return g_idn_spoof_checker.Get().Check(label, is_tld_ascii);
 }
 
  
  base::LazyInstance<UIDNAWrapper>::Leaky g_uidna = LAZY_INSTANCE_INITIALIZER;
  
 bool IDNToUnicodeOneComponent(const base::char16* comp,
                               size_t comp_len,
                              bool is_tld_ascii,
                               base::string16* out) {
   DCHECK(out);
   if (comp_len == 0)
  bool IDNToUnicodeOneComponent(const base::char16* comp,
        
       out->resize(original_length + output_length);
       if (IsIDNComponentSafe(
              base::StringPiece16(out->data() + original_length,
                                  base::checked_cast<size_t>(output_length)),
              is_tld_ascii))
         return true;
     }
 ","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 58.0.3029.81 for Mac, Windows, and Linux, and 58.0.3029.83 for Android, allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
3024,CVE-2017-5061,"  IPC_STRUCT_TRAITS_BEGIN(cc::CompositorFrameMetadata)
   IPC_STRUCT_TRAITS_MEMBER(selection)
   IPC_STRUCT_TRAITS_MEMBER(latency_info)
   IPC_STRUCT_TRAITS_MEMBER(referenced_surfaces)
  IPC_STRUCT_TRAITS_MEMBER(content_source_id)
 IPC_STRUCT_TRAITS_END()
 
 #endif   ","A race condition in navigation in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page."
3025,CVE-2017-5067,"  scoped_refptr<VideoFrame> CloneVideoFrameWithLayout(
   LOG_ASSERT(dst_layout.planes().size() == num_planes);
   LOG_ASSERT(src_frame->layout().planes().size() == num_planes);
   for (size_t i = 0; i < num_planes; ++i) {
     
    gfx::Size plane_size = VideoFrame::PlaneSize(dst_frame->format(), i,
                                                 dst_frame->natural_size());
     libyuv::CopyPlane(
         src_frame->data(i), src_frame->layout().planes()[i].stride,
         dst_frame->data(i), dst_frame->layout().planes()[i].stride,
        plane_size.width(), plane_size.height());
   }
 
   return dst_frame;","An insufficient watchdog timer in navigation in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page."
3026,CVE-2017-5069,"  SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(
       pref.type = SessionStartupPref::LAST;
   }
 
  if (pref.type == SessionStartupPref::LAST && profile->IsOffTheRecord()) {
      
      
      ","Incorrect MIME type of XSS-Protection reports in Blink in Google Chrome prior to 58.0.3029.81 for Linux, Windows, and Mac, and 58.0.3029.83 for Android, allowed a remote attacker to circumvent Cross-Origin Resource Sharing checks via a crafted HTML page."
3027,CVE-2017-5068,"  aura::Window* TabletModeWindowManager::GetTopWindow() {
 }
 
 void TabletModeWindowManager::Init() {
   
   
   
  if (!IsClamshellSplitViewModeEnabled())
    Shell::Get()->overview_controller()->EndOverview();

   
   
    
    
    
  void TabletModeWindowManager::Init() {
 }
 
 void TabletModeWindowManager::Shutdown() {
  base::flat_map<aura::Window*, WindowStateType> carryover_windows_in_splitview;
  const bool was_in_overview =
      Shell::Get()->overview_controller()->InOverviewSession();
   
   
   
  if (!IsClamshellSplitViewModeEnabled()) {
    Shell::Get()->overview_controller()->EndOverview();
  } else {
     
     
     
     
     
     
     
     
     
     
     
     
     
     

     
     
    carryover_windows_in_splitview = GetCarryOverWindowsInSplitView();

     
     
     
     
    SplitViewController* split_view_controller =
        Shell::Get()->split_view_controller();
    if (split_view_controller->InSplitViewMode()) {
      OverviewController* overview_controller =
          Shell::Get()->overview_controller();
      if (!overview_controller->InOverviewSession() ||
          overview_controller->overview_session()->IsEmpty()) {
        Shell::Get()->split_view_controller()->EndSplitView(
            SplitViewController::EndReason::kExitTabletMode);
        overview_controller->EndOverview();
      }
     }
   }
 
  void TabletModeWindowManager::Shutdown() {
 
   ScopedObserveWindowAnimation scoped_observe(GetTopWindow(), this,
                                                true);
  ArrangeWindowsForClamshellMode(carryover_windows_in_splitview,
                                 was_in_overview);
 }
 
 int TabletModeWindowManager::GetNumberOfManagedWindows() {
  void TabletModeWindowManager::ArrangeWindowsForTabletMode() {
 }
 
 void TabletModeWindowManager::ArrangeWindowsForClamshellMode(
    base::flat_map<aura::Window*, WindowStateType> windows_in_splitview,
    bool was_in_overview) {
   int divider_position = CalculateCarryOverDividerPostion(windows_in_splitview);
 
   while (window_state_map_.size()) {
     aura::Window* window = window_state_map_.begin()->first;
    ForgetWindow(window,  false, was_in_overview);
   }
 
   if (IsClamshellSplitViewModeEnabled()) {
  void TabletModeWindowManager::TrackWindow(aura::Window* window,
 }
 
 void TabletModeWindowManager::ForgetWindow(aura::Window* window,
                                           bool destroyed,
                                           bool was_in_overview) {
   added_windows_.erase(window);
   window->RemoveObserver(this);
 
  void TabletModeWindowManager::ForgetWindow(aura::Window* window,
   } else {
      
      
    it->second->LeaveTabletMode(wm::GetWindowState(it->first), was_in_overview);
     DCHECK(!IsTrackingWindow(window));
   }
 }","Incorrect handling of picture ID in WebRTC in Google Chrome prior to 58.0.3029.96 for Mac, Windows, and Linux allowed a remote attacker to trigger a race condition via a crafted HTML page."
3028,CVE-2017-5055,"  void PrintViewManager::PrintPreviewForWebNode(content::RenderFrameHost* rfh) {
 
 void PrintViewManager::PrintPreviewDone() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
  if (print_preview_state_ == NOT_PREVIEWING)
    return;
 
   if (print_preview_state_ == SCRIPTED_PREVIEW) {
     auto& map = g_scripted_print_preview_closure_map.Get();
  void PrintViewManager::RenderFrameCreated(
 void PrintViewManager::RenderFrameDeleted(
     content::RenderFrameHost* render_frame_host) {
   if (render_frame_host == print_preview_rfh_)
    PrintPreviewDone();
   PrintViewManagerBase::RenderFrameDeleted(render_frame_host);
 }
 ",A use after free in printing in Google Chrome prior to 57.0.2987.133 for Linux and Windows allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
3029,CVE-2017-5056,"  class TestClientChannel : mojom::InputChannel {
   }
 
    
   MOCK_METHOD2(ProcessMessage,
                void(const std::vector<uint8_t>& message,
                     ProcessMessageCallback));","A use after free in Blink in Google Chrome prior to 57.0.2987.133 for Linux, Windows, and Mac, and 57.0.2987.132 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
3030,CVE-2017-5053,"  bool PasswordAutofillAgent::IsUsernameOrPasswordField(
 bool PasswordAutofillAgent::TryToShowTouchToFill(
     const WebFormControlElement& control_element) {
   const WebInputElement* element = ToWebInputElement(&control_element);
  WebInputElement username_element;
  WebInputElement password_element;
  PasswordInfo* password_info = nullptr;
  if (!element ||
      !FindPasswordInfoForElement(*element, &username_element,
                                  &password_element, &password_info)) {
     return false;
   }
   if (was_touch_to_fill_ui_shown_)","An out-of-bounds read in V8 in Google Chrome prior to 57.0.2987.133 for Linux, Windows, and Mac, and 57.0.2987.132 for Android, allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page, related to Array.prototype.indexOf."
3031,CVE-2017-5030," 
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_MEDIARECORDER_VIDEO_TRACK_RECORDER_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_MEDIARECORDER_VIDEO_TRACK_RECORDER_H_
 
#include <atomic>
 #include <memory>
 
 #include ""base/macros.h""
  class MODULES_EXPORT VideoTrackRecorder
 
      
      
     
     
    std::atomic_bool paused_;
 
      
     const OnEncodedVideoCB on_encoded_video_callback_;","Incorrect handling of complex species in V8 in Google Chrome prior to 57.0.2987.98 for Linux, Windows, and Mac and 57.0.2987.108 for Android allowed a remote attacker to execute arbitrary code via a crafted HTML page."
3032,CVE-2017-5032,"  void ClientControlledShellSurface::OnBoundsChangeEvent(
     int64_t display_id,
     const gfx::Rect& window_bounds,
     int bounds_change) {
  if (ignore_bounds_change_request_)
    return;
    
    
    
  bool ClientControlledShellSurface::OnPreWidgetCommit() {
 
   bool wasPip = window_state->IsPip();
 
   
   
  base::AutoReset<bool> resetter(&ignore_bounds_change_request_, true);
   if (client_controlled_state_->EnterNextState(window_state,
                                                pending_window_state_)) {
     client_controlled_state_->set_next_bounds_change_animation_type(","PDFium in Google Chrome prior to 57.0.2987.98 for Windows could be made to increment off the end of a buffer, which allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
3033,CVE-2017-5035," 
 
 #include ""base/bind.h""
 #include ""base/command_line.h""
#include ""base/debug/alias.h""
 #include ""base/debug/dump_without_crashing.h""
 #include ""base/logging.h""
 #include ""base/memory/ptr_util.h""
  bool ShouldTreatNavigationAsReload(const NavigationEntry* entry) {
   return false;
 }
 
 
 
void MaybeDumpCopiedNonSameOriginEntry(
    const std::string& navigation_description,
    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,
    bool is_in_page,
    NavigationEntry* entry) {
  if (!entry)
    return;
  if (url::Origin(entry->GetURL()).IsSameOriginWith(url::Origin(params.url)))
    return;

  std::string debug_info =
      navigation_description + "": "" +
      std::string(is_in_page ? ""Is in page, "" : ""Is not in page, "") +
      std::string(params.nav_entry_id ? ""has nav entry id, ""
                                      : ""does not have nav entry id, "") +
      std::string(params.did_create_new_entry ? ""did create new entry, ""
                                              : ""did not create new entry, "") +
      std::string(params.should_replace_current_entry
                      ? ""should replace current entry, ""
                      : ""should not replace current entry, "") +
      entry->GetURL().spec() + "" -> "" + params.url.spec();
  char debug_buf[2000];
  base::strlcpy(debug_buf, debug_info.c_str(), arraysize(debug_buf));
  base::debug::Alias(&debug_buf);
  base::debug::DumpWithoutCrashing();
}

 }   
 
  
  void NavigationControllerImpl::RendererDidNavigateToNewPage(
     CHECK(frame_entry->HasOneRef());
 
     update_virtual_url = new_entry->update_virtual_url_with_url();

    MaybeDumpCopiedNonSameOriginEntry(""New page navigation"", params, is_in_page,
                                      GetLastCommittedEntry());
   }
 
    
  void NavigationControllerImpl::RendererDidNavigateToExistingPage(
      
      
     entry = GetLastCommittedEntry();
    MaybeDumpCopiedNonSameOriginEntry(""Existing page navigation"", params,
                                      is_in_page, entry);
   } else if (params.nav_entry_id) {
      
     entry = GetEntryWithUniqueID(params.nav_entry_id);","Google Chrome prior to 57.0.2987.98 for Windows and Mac had a race condition, which could cause Chrome to display incorrect certificate information for a site."
3034,CVE-2017-5039,"  class DataReductionProxyBrowsertestBase : public InProcessBrowserTest {
     config_ = config;
   }
 
  void WaitForConfig() {
     
    if (data_reduction_proxy::params::IsIncludedInHoldbackFieldTrial())
      return;
    config_run_loop_->Run();
  }
 
   std::string expect_exp_value_in_request_header_;
 
  class DataReductionProxyBrowsertestBase : public InProcessBrowserTest {
  private:
   std::unique_ptr<net::test_server::HttpResponse> GetConfigResponse(
       const net::test_server::HttpRequest& request) {
     
    EXPECT_FALSE(
        data_reduction_proxy::params::IsIncludedInHoldbackFieldTrial());

     auto response = std::make_unique<net::test_server::BasicHttpResponse>();
     response->set_content(config_.SerializeAsString());
     response->set_content_type(""text/plain"");
  IN_PROC_BROWSER_TEST_F(DataReductionProxyBrowsertest, UMAMetricsRecorded) {
 }
 
  
 
 class DataReductionProxyWithHoldbackBrowsertest
     : public ::testing::WithParamInterface<bool>,
       public DataReductionProxyBrowsertest {
  public:
  DataReductionProxyWithHoldbackBrowsertest()
      : DataReductionProxyBrowsertest(),
        data_reduction_proxy_holdback_enabled_(GetParam()) {}

   void SetUp() override {
    if (data_reduction_proxy_holdback_enabled_) {
       scoped_feature_list_.InitWithFeatures(
           {features::kDataReductionProxyEnabledWithNetworkService,
            data_reduction_proxy::features::kDataReductionProxyHoldback},
  class DataReductionProxyWithHoldbackBrowsertest
     InProcessBrowserTest::SetUp();
   }
 
  const bool data_reduction_proxy_holdback_enabled_;

  private:
   base::test::ScopedFeatureList scoped_feature_list_;
 };
  IN_PROC_BROWSER_TEST_P(DataReductionProxyWithHoldbackBrowsertest,
   SetConfig(CreateConfigForServer(proxy_server));
    
   SimulateNetworkChange(network::mojom::ConnectionType::CONNECTION_3G);

   WaitForConfig();
 
   
   
   
   
   ui_test_utils::NavigateToURL(browser(), GURL(""http://does.not.resolve/foo""));
 
   if (GetParam()) {","A use after free in PDFium in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
3035,CVE-2017-5033," 
 #include ""base/run_loop.h""
 #include ""base/test/metrics/histogram_tester.h""
 #include ""base/test/scoped_feature_list.h""
 #include ""cc/base/switches.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture.h""
 #include ""content/browser/renderer_host/input/synthetic_gesture_controller.h""
 
 #include ""content/public/test/content_browser_test_utils.h""
 #include ""content/public/test/hit_test_region_observer.h""
 #include ""content/shell/browser/shell.h""
 #include ""ui/base/ui_base_features.h""
 
 namespace {
 
  class ScrollLatencyBrowserTest : public ContentBrowserTest {
   }
 
   void LoadURL() {
     const GURL data_url(kDataURL);
     NavigateToURL(shell(), data_url);
 
     RenderWidgetHostImpl* host = GetWidgetHost();
    host->GetView()->SetSize(gfx::Size(400, 400));
 
     HitTestRegionObserver observer(host->GetFrameSinkId());
 
  class ScrollLatencyBrowserTest : public ContentBrowserTest {
     }
   }
 
  void RunScrollbarButtonLatencyTest() {
     
     
    blink::WebFloatPoint scrollbar_forward_button(795, 595);
    blink::WebMouseEvent mouse_event = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_forward_button.x,
        scrollbar_forward_button.y, 0);
    mouse_event.button = blink::WebMouseEvent::Button::kLeft;
    mouse_event.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_event);

    mouse_event.SetType(blink::WebInputEvent::kMouseUp);
    GetWidgetHost()->ForwardMouseEvent(mouse_event);

    RunUntilInputProcessed(GetWidgetHost());

    FetchHistogramsFromChildProcesses();
    VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
    VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.RendererSwapToBrowserNotified2"");
    VerifyRecordedSamplesForHistogram(
        1,
        ""Event.Latency.ScrollBegin.Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
    VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.GpuSwap2"");
    VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToScrollUpdateSwapBegin4"");
    std::string thread_name =
        DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
    VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.TimeToHandled_"" + thread_name);
    VerifyRecordedSamplesForHistogram(
        1, ""Event.Latency.ScrollBegin.Scrollbar.HandledToRendererSwap2_"" +
               thread_name);
  }

  void RunScrollbarThumbDragLatencyTest() {
     
     
    blink::WebFloatPoint scrollbar_thumb(795, 30);
    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
        0);
    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
    mouse_down.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_down);

    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
        scrollbar_thumb.y + 10, 0);
    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
    mouse_move.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    GetWidgetHost()->ForwardMouseEvent(mouse_move);

    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
        scrollbar_thumb.y + 20, 0);
    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
    mouse_up.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_up);

    RunUntilInputProcessed(GetWidgetHost());

    FetchHistogramsFromChildProcesses();
    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
    for (const std::string& scroll_type : scroll_types) {
      VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
      VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.RendererSwapToBrowserNotified2"");
      VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2"");
      VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2"");
      VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.TimeToScrollUpdateSwapBegin4"");
      std::string thread_name =
          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
      VerifyRecordedSamplesForHistogram(1, ""Event.Latency."" + scroll_type +
                                               "".Scrollbar.TimeToHandled_"" +
                                               thread_name);
      VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name);
    }
  }

    
    
  bool VerifyRecordedSamplesForHistogram(
       const size_t num_samples,
       const std::string& histogram_name) const {
     return num_samples ==
            histogram_tester_.GetAllSamples(histogram_name).size();
   }
 
  virtual bool DoesScrollbarScrollOnMainThread() const { return true; }

   std::unique_ptr<base::RunLoop> run_loop_;
   bool disable_threaded_scrolling_ = false;
 
 private:
   base::HistogramTester histogram_tester_;
   uint32_t visual_state_callback_count_ = 0;
 
  IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest,
       0, ""Event.Latency.ScrollBegin.Touch.TimeToScrollUpdateSwapBegin4""));
 }
 
IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();
 }
 
IN_PROC_BROWSER_TEST_F(ScrollLatencyBrowserTest, ScrollbarThumbDragLatency) {
   LoadURL();
 
   RunScrollbarThumbDragLatencyTest();
 }
 
 class ScrollLatencyCompositedScrollbarBrowserTest
    : public ScrollLatencyBrowserTest {
  public:
  ScrollLatencyCompositedScrollbarBrowserTest() {
     scoped_feature_list_.InitAndEnableFeature(
         features::kCompositorThreadedScrollbarScrolling);
   }
   ~ScrollLatencyCompositedScrollbarBrowserTest() override {}
 
  class ScrollLatencyCompositedScrollbarBrowserTest
 };
 
 IN_PROC_BROWSER_TEST_F(ScrollLatencyCompositedScrollbarBrowserTest,
                       ScrollbarButtonLatency) {
   LoadURL();
 
   RunScrollbarButtonLatencyTest();","Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android failed to correctly propagate CSP restrictions to local scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page, related to the unsafe-inline keyword."
3036,CVE-2017-5042,"  void PageInfo::OnChangePasswordButtonPressed(
     content::WebContents* web_contents) {
 #if defined(FULL_SAFE_BROWSING)
   DCHECK(password_protection_service_);
  DCHECK(site_identity_status_ == SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE ||
         site_identity_status_ ==
             SITE_IDENTITY_STATUS_ENTERPRISE_PASSWORD_REUSE);
   password_protection_service_->OnUserAction(
       web_contents,
      site_identity_status_ == SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE
           ? PasswordReuseEvent::SIGN_IN_PASSWORD
           : PasswordReuseEvent::ENTERPRISE_PASSWORD,
       safe_browsing::WarningUIType::PAGE_INFO,
  void PageInfo::OnWhitelistPasswordReuseButtonPressed(
     content::WebContents* web_contents) {
 #if defined(FULL_SAFE_BROWSING)
   DCHECK(password_protection_service_);
  DCHECK(site_identity_status_ == SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE ||
         site_identity_status_ ==
             SITE_IDENTITY_STATUS_ENTERPRISE_PASSWORD_REUSE);
   password_protection_service_->OnUserAction(
       web_contents,
      site_identity_status_ == SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE
           ? PasswordReuseEvent::SIGN_IN_PASSWORD
           : PasswordReuseEvent::ENTERPRISE_PASSWORD,
       safe_browsing::WarningUIType::PAGE_INFO,
  void PageInfo::ComputeUIInputs(
      
     DCHECK_EQ(url::kAboutBlankURL, url.spec());
     site_identity_status_ = SITE_IDENTITY_STATUS_NO_CERT;
    site_identity_details_ =
         l10n_util::GetStringUTF16(IDS_PAGE_INFO_SECURITY_TAB_INSECURE_IDENTITY);
     site_connection_status_ = SITE_CONNECTION_STATUS_UNENCRYPTED;
     site_connection_details_ = l10n_util::GetStringFUTF16(
  void PageInfo::ComputeUIInputs(
 
   if (url.SchemeIs(content::kChromeUIScheme) || is_chrome_ui_native_scheme) {
     site_identity_status_ = SITE_IDENTITY_STATUS_INTERNAL_PAGE;
    site_identity_details_ =
         l10n_util::GetStringUTF16(IDS_PAGE_INFO_INTERNAL_PAGE);
     site_connection_status_ = SITE_CONNECTION_STATUS_INTERNAL_PAGE;
     return;
  void PageInfo::ComputeUIInputs(
    
   certificate_ = visible_security_state.certificate;
 
  if (visible_security_state.malicious_content_status !=
      security_state::MALICIOUS_CONTENT_STATUS_NONE) {
     
    GetSiteIdentityByMaliciousContentStatus(
        visible_security_state.malicious_content_status, &site_identity_status_,
        &site_identity_details_);
#if defined(FULL_SAFE_BROWSING)
    bool old_show_change_pw_buttons = show_change_password_buttons_;
#endif
    show_change_password_buttons_ =
        (visible_security_state.malicious_content_status ==
             security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE ||
         visible_security_state.malicious_content_status ==
             security_state::
                 MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE);
#if defined(FULL_SAFE_BROWSING)
     
    if (show_change_password_buttons_ && !old_show_change_pw_buttons) {
      RecordPasswordReuseEvent();
    }
#endif
  } else if (certificate_ &&
             (!net::IsCertStatusError(visible_security_state.cert_status) ||
              net::IsCertStatusMinorError(
                  visible_security_state.cert_status))) {
      
     if (security_level == security_state::SECURE_WITH_POLICY_INSTALLED_CERT) {
 #if defined(OS_CHROMEOS)
       site_identity_status_ = SITE_IDENTITY_STATUS_ADMIN_PROVIDED_CERT;
      site_identity_details_ = l10n_util::GetStringFUTF16(
           IDS_CERT_POLICY_PROVIDED_CERT_MESSAGE, UTF8ToUTF16(url.host()));
 #else
       DCHECK(false) << ""Policy certificates exist only on ChromeOS"";
  void PageInfo::ComputeUIInputs(
             IDS_PAGE_INFO_SECURITY_TAB_UNKNOWN_PARTY));
       }
 
      site_identity_details_.assign(l10n_util::GetStringFUTF16(
           IDS_PAGE_INFO_SECURITY_TAB_SECURE_IDENTITY_VERIFIED, issuer_name));
 
      site_identity_details_ += ASCIIToUTF16(""\n\n"");
       if (visible_security_state.cert_status &
           net::CERT_STATUS_UNABLE_TO_CHECK_REVOCATION) {
        site_identity_details_ += l10n_util::GetStringUTF16(
             IDS_PAGE_INFO_SECURITY_TAB_UNABLE_TO_CHECK_REVOCATION);
       } else if (visible_security_state.cert_status &
                  net::CERT_STATUS_NO_REVOCATION_MECHANISM) {
        site_identity_details_ += l10n_util::GetStringUTF16(
             IDS_PAGE_INFO_SECURITY_TAB_NO_REVOCATION_MECHANISM);
       } else {
         NOTREACHED() << ""Need to specify string for this warning"";
  void PageInfo::ComputeUIInputs(
          
         DCHECK(!certificate_->subject().locality_name.empty());
         DCHECK(!certificate_->subject().country_name.empty());
        site_identity_details_.assign(l10n_util::GetStringFUTF16(
             IDS_PAGE_INFO_SECURITY_TAB_SECURE_IDENTITY_EV_VERIFIED,
             organization_name_,
             UTF8ToUTF16(certificate_->subject().country_name)));
  void PageInfo::ComputeUIInputs(
               IDS_PAGE_INFO_SECURITY_TAB_UNKNOWN_PARTY));
         }
 
        site_identity_details_.assign(l10n_util::GetStringFUTF16(
             IDS_PAGE_INFO_SECURITY_TAB_SECURE_IDENTITY_VERIFIED, issuer_name));
       }
       if (security_state::IsSHA1InChain(visible_security_state)) {
         site_identity_status_ =
             SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM;
        site_identity_details_ +=
             UTF8ToUTF16(""\n\n"") +
             l10n_util::GetStringUTF16(
                 IDS_PAGE_INFO_SECURITY_TAB_DEPRECATED_SIGNATURE_ALGORITHM);
       }
     }
   } else {
      
    site_identity_details_.assign(l10n_util::GetStringUTF16(
         IDS_PAGE_INFO_SECURITY_TAB_INSECURE_IDENTITY));
     if (!security_state::IsSchemeCryptographic(visible_security_state.url) ||
         !visible_security_state.certificate) {
  void PageInfo::ComputeUIInputs(
     ssl_errors::ErrorInfo::GetErrorsForCertStatus(
         certificate_, visible_security_state.cert_status, url, &errors);
     for (size_t i = 0; i < errors.size(); ++i) {
      site_identity_details_ += bullet;
      site_identity_details_ += errors[i].short_description();
     }
 
     if (visible_security_state.cert_status & net::CERT_STATUS_NON_UNIQUE_NAME) {
      site_identity_details_ += ASCIIToUTF16(""\n\n"");
      site_identity_details_ +=
           l10n_util::GetStringUTF16(IDS_PAGE_INFO_SECURITY_TAB_NON_UNIQUE_NAME);
     }
   }
 
    
    
    
  void PageInfo::ComputeUIInputs(
       ChromeSSLHostStateDelegateFactory::GetForProfile(profile_);
   DCHECK(delegate);
    
   
  show_ssl_decision_revoke_button_ = delegate->HasAllowException(url.host());
 }
 
 void PageInfo::PresentSitePermissions() {
  void PageInfo::PresentSiteIdentity() {
   info.connection_status = site_connection_status_;
   info.connection_status_description = UTF16ToUTF8(site_connection_details_);
   info.identity_status = site_identity_status_;
  info.identity_status_description = UTF16ToUTF8(site_identity_details_);
   info.certificate = certificate_;
   info.show_ssl_decision_revoke_button = show_ssl_decision_revoke_button_;
   info.show_change_password_buttons = show_change_password_buttons_;
  void PageInfo::RecordPasswordReuseEvent() {
     return;
   }
 
  if (site_identity_status_ == SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE) {
     safe_browsing::LogWarningAction(
         safe_browsing::WarningUIType::PAGE_INFO,
         safe_browsing::WarningAction::SHOWN,
  std::vector<ContentSettingsType> PageInfo::GetAllPermissionsForTesting() {
   return permission_list;
 }
 
void PageInfo::GetSiteIdentityByMaliciousContentStatus(
     security_state::MaliciousContentStatus malicious_content_status,
    PageInfo::SiteIdentityStatus* status,
     base::string16* details) {
   switch (malicious_content_status) {
     case security_state::MALICIOUS_CONTENT_STATUS_NONE:
       NOTREACHED();
       break;
     case security_state::MALICIOUS_CONTENT_STATUS_MALWARE:
      *status = PageInfo::SITE_IDENTITY_STATUS_MALWARE;
       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_MALWARE_DETAILS);
       break;
     case security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING:
      *status = PageInfo::SITE_IDENTITY_STATUS_SOCIAL_ENGINEERING;
       *details =
           l10n_util::GetStringUTF16(IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);
       break;
     case security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE:
      *status = PageInfo::SITE_IDENTITY_STATUS_UNWANTED_SOFTWARE;
       *details =
           l10n_util::GetStringUTF16(IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);
       break;
     case security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE:
 #if defined(FULL_SAFE_BROWSING)
      *status = PageInfo::SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE;
        
       *details = password_protection_service_
                      ? password_protection_service_->GetWarningDetailText(
  void PageInfo::GetSafeBrowsingStatusByMaliciousContentStatus(
       break;
     case security_state::MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE:
 #if defined(FULL_SAFE_BROWSING)
      *status = PageInfo::SITE_IDENTITY_STATUS_ENTERPRISE_PASSWORD_REUSE;
        
       *details = password_protection_service_
                      ? password_protection_service_->GetWarningDetailText(
  void PageInfo::GetSafeBrowsingStatusByMaliciousContentStatus(
 #endif
       break;
     case security_state::MALICIOUS_CONTENT_STATUS_BILLING:
      *status = PageInfo::SITE_IDENTITY_STATUS_BILLING;
       *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_BILLING_DETAILS);
       break;
   }","Cast in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android sent cookies to sites discovered via SSDP, which allowed an attacker on the local network segment to initiate connections to arbitrary URLs and observe any plaintext cookies sent."
3037,CVE-2017-5044," 
 
 using device::BluetoothUUID;
 using UUIDSet = device::BluetoothDevice::UUIDSet;
using blink::mojom::WebBluetoothResult;
 
 namespace {
 
  BluetoothDeviceChooserController::~BluetoothDeviceChooserController() {
 
   if (chooser_) {
     DCHECK(!error_callback_.is_null());
    error_callback_.Run(WebBluetoothResult::CHOOSER_CANCELLED);
   }
 }
 
  void BluetoothDeviceChooserController::GetDevice(
       BluetoothBlocklist::Get().IsExcluded(options_->filters.value())) {
     RecordRequestDeviceOutcome(
         UMARequestDeviceOutcome::BLOCKLISTED_SERVICE_IN_FILTER);
    PostErrorCallback(WebBluetoothResult::REQUEST_DEVICE_WITH_BLOCKLISTED_UUID);
     return;
   }
   BluetoothBlocklist::Get().RemoveExcludedUUIDs(options_.get());
 
  WebBluetoothResult allow_result =
      web_bluetooth_service_->GetBluetoothAllowed();
  if (allow_result != WebBluetoothResult::SUCCESS) {
    switch (allow_result) {
      case WebBluetoothResult::CHOOSER_NOT_SHOWN_API_LOCALLY_DISABLED: {
        RecordRequestDeviceOutcome(
            UMARequestDeviceOutcome::BLUETOOTH_CHOOSER_POLICY_DISABLED);
        break;
      }
      case WebBluetoothResult::CHOOSER_NOT_SHOWN_API_GLOBALLY_DISABLED: {
         
        web_contents_->GetMainFrame()->AddMessageToConsole(
            blink::mojom::ConsoleMessageLevel::kInfo,
            ""Bluetooth permission has been blocked."");
         
        RecordRequestDeviceOutcome(
            UMARequestDeviceOutcome::BLUETOOTH_GLOBALLY_DISABLED);
        break;
      }
      default:
        break;
    }
    PostErrorCallback(allow_result);
     return;
   }
 
   if (!adapter_->IsPresent()) {
     DVLOG(1) << ""Bluetooth Adapter not present. Can't serve requestDevice."";
     RecordRequestDeviceOutcome(
         UMARequestDeviceOutcome::BLUETOOTH_ADAPTER_NOT_PRESENT);
    PostErrorCallback(WebBluetoothResult::NO_BLUETOOTH_ADAPTER);
     return;
   }
 
   BluetoothChooser::EventHandler chooser_event_handler =
       base::Bind(&BluetoothDeviceChooserController::OnBluetoothChooserEvent,
                  base::Unretained(this));
  void BluetoothDeviceChooserController::GetDevice(
   }
 
   if (!chooser_.get()) {
    PostErrorCallback(WebBluetoothResult::WEB_BLUETOOTH_NOT_SUPPORTED);
     return;
   }
 
  void BluetoothDeviceChooserController::OnBluetoothChooserEvent(
       return;
     case BluetoothChooser::Event::DENIED_PERMISSION:
       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));
      PostErrorCallback(
          WebBluetoothResult::CHOOSER_NOT_SHOWN_USER_DENIED_PERMISSION_TO_SCAN);
       break;
     case BluetoothChooser::Event::CANCELLED:
       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));
      PostErrorCallback(WebBluetoothResult::CHOOSER_CANCELLED);
       break;
     case BluetoothChooser::Event::SHOW_OVERVIEW_HELP:
       DVLOG(1) << ""Overview Help link pressed."";
       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));
      PostErrorCallback(WebBluetoothResult::CHOOSER_CANCELLED);
       break;
     case BluetoothChooser::Event::SHOW_ADAPTER_OFF_HELP:
       DVLOG(1) << ""Adapter Off Help link pressed."";
       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));
      PostErrorCallback(WebBluetoothResult::CHOOSER_CANCELLED);
       break;
     case BluetoothChooser::Event::SHOW_NEED_LOCATION_HELP:
       DVLOG(1) << ""Need Location Help link pressed."";
       RecordRequestDeviceOutcome(OutcomeFromChooserEvent(event));
      PostErrorCallback(WebBluetoothResult::CHOOSER_CANCELLED);
       break;
     case BluetoothChooser::Event::SELECTED:
       RecordNumOfDevices(options_->accept_all_devices, device_ids_.size());
  void BluetoothDeviceChooserController::PostSuccessCallback(
 }
 
 void BluetoothDeviceChooserController::PostErrorCallback(
    WebBluetoothResult error) {
   if (!base::ThreadTaskRunnerHandle::Get()->PostTask(
           FROM_HERE, base::BindOnce(error_callback_, error))) {
     LOG(WARNING) << ""No TaskRunner."";","Heap buffer overflow in filter processing in Skia in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
3038,CVE-2017-5012," 
 #include ""chrome/browser/payments/ssl_validity_checker.h""
 #include ""chrome/browser/profiles/profile.h""
 #include ""chrome/browser/signin/signin_manager_factory.h""
#include ""chrome/browser/ui/browser.h""
 #include ""chrome/browser/ui/browser_dialogs.h""
#include ""chrome/browser/ui/browser_finder.h""
#include ""chrome/browser/ui/browser_window.h""
 #include ""components/autofill/core/browser/personal_data_manager.h""
 #include ""components/autofill/core/browser/region_combobox_model.h""
 #include ""components/autofill/core/browser/region_data_loader_impl.h""
  PrefService* ChromePaymentRequestDelegate::GetPrefService() {
       ->GetPrefs();
 }
 
bool ChromePaymentRequestDelegate::IsBrowserWindowActive() const {
  Browser* browser = chrome::FindBrowserWithWebContents(web_contents_);
  return browser && browser->window() && browser->window()->IsActive();
}

 }   ","A heap buffer overflow in V8 in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
3039,CVE-2017-5013,"  void Browser::BeforeUnloadFired(WebContents* web_contents,
 }
 
 bool Browser::ShouldFocusLocationBarByDefault(WebContents* source) {
   
   
  if (source != tab_strip_model_->GetActiveWebContents())
    return false;

   const content::NavigationEntry* entry =
       source->GetController().GetActiveEntry();
   if (entry) {","Google Chrome prior to 56.0.2924.76 for Linux incorrectly handled new tab page navigations in non-selected tabs, which allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page."
3040,CVE-2017-5014,"  void RecordOffliningPreviewsUMA(const ClientId& client_id,
       is_previews_enabled);
 }
 
 void HandleLoadTerminationCancel(
     Offliner::CompletionCallback completion_callback,
     const SavePageRequest& canceled_request) {
  bool BackgroundLoaderOffliner::LoadAndSave(
        IsNetworkPredictionDisabled(browser_context_))) {
     DVLOG(1) << ""WARNING: Unable to load when 3rd party cookies blocked or ""
              << ""prediction disabled"";
     return false;
   }
 
   if (!OfflinePageModel::CanSaveURL(request.url())) {
     DVLOG(1) << ""Not able to save page for requested url: "" << request.url();
     return false;
  void BackgroundLoaderOffliner::StartSnapshot() {
   RequestStats& image_stats = stats_[ResourceDataType::IMAGE];
   RequestStats& css_stats = stats_[ResourceDataType::TEXT_CSS];
   RequestStats& xhr_stats = stats_[ResourceDataType::XHR];
 
    
    ","Heap buffer overflow during image processing in Skia in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
3041,CVE-2017-5015," 
 #include ""chrome/grit/chromium_strings.h""
 #include ""chrome/test/base/testing_profile_manager.h""
 #include ""components/version_info/channel.h""
#include ""content/public/test/test_service_manager_context.h""
 #include ""ui/base/accelerators/accelerator.h""
 #include ""ui/base/l10n/l10n_util.h""
 #include ""ui/views/controls/webview/webview.h""
  base::string16 SubBrowserName(const char* fmt) {
 
 }   
 
class BrowserViewTest : public TestWithBrowserView {
 public:
  BrowserViewTest() = default;
  ~BrowserViewTest() override = default;

  void SetUp() override {
    TestWithBrowserView::SetUp();
    test_service_manager_context_ =
        std::make_unique<content::TestServiceManagerContext>();
  }

  void TearDown() override {
     
    test_service_manager_context_.reset();
    TestWithBrowserView::TearDown();
  }

 private:
   
   
   
  std::unique_ptr<content::TestServiceManagerContext>
      test_service_manager_context_;

  DISALLOW_COPY_AND_ASSIGN(BrowserViewTest);
};
 
  
 TEST_F(BrowserViewTest, BrowserView) {","Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, incorrectly handled Unicode glyphs, which allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
3042,CVE-2017-5019,"  bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {
 
   handled = true;
   IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)
     IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)
     IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,
  void RenderFrameHostImpl::OnAudibleStateChanged(bool is_audible) {
   is_audible_ = is_audible;
 }
 
void RenderFrameHostImpl::DidAddMessageToConsole(
    blink::mojom::ConsoleMessageLevel log_level,
     const base::string16& message,
     int32_t line_no,
     const base::string16& source_id) {
   
   
  logging::LogSeverity log_severity = logging::LOG_VERBOSE;
  switch (log_level) {
    case blink::mojom::ConsoleMessageLevel::kVerbose:
      log_severity = logging::LOG_VERBOSE;
      break;
    case blink::mojom::ConsoleMessageLevel::kInfo:
      log_severity = logging::LOG_INFO;
      break;
    case blink::mojom::ConsoleMessageLevel::kWarning:
      log_severity = logging::LOG_WARNING;
      break;
    case blink::mojom::ConsoleMessageLevel::kError:
      log_severity = logging::LOG_ERROR;
      break;
   }
 
  if (delegate_->DidAddMessageToConsole(log_severity, message, line_no,
                                        source_id)) {
     return;
  }
 
   
    
   const bool is_builtin_component =
       HasWebUIScheme(delegate_->GetMainFrameLastCommittedURL()) ||
  void RenderFrameHostImpl::OnDidAddMessageToConsole(
   const bool is_off_the_record =
       GetSiteInstance()->GetBrowserContext()->IsOffTheRecord();
 
  LogConsoleMessage(log_severity, message, line_no, is_builtin_component,
                     is_off_the_record, source_id);
 }
 ","A use after free in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
3043,CVE-2017-5016,"  void HTMLFormControlElement::findCustomValidationMessageTextDirection(
 
 void HTMLFormControlElement::updateVisibleValidationMessage() {
   Page* page = document().page();
  if (!page || !page->isPageVisible())
     return;
   String message;
   if (layoutObject() && willValidate())","Blink in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, failed to prevent certain UI elements from being displayed by non-visible pages, which allowed a remote attacker to show certain UI elements on a page they don't control via a crafted HTML page."
3044,CVE-2017-5017,"  const char kSoftwareRenderingListJson[] = LONG_STRING_CONST(
 {
   ""name"": ""software rendering list"",
    
  ""version"": ""12.08"",
   ""entries"": [
     {
       ""id"": 1,
  LONG_STRING_CONST(
       ""features"": [
         ""all""
       ]
    },
    {
      ""id"": 130,
      ""description"": ""Older NVIDIA GPUs on macOS render incorrectly"",
      ""cr_bugs"": [676975],
      ""os"": {
        ""type"": ""macosx""
      },
      ""vendor_id"": ""0x10de"",
      ""device_id"": [""0x0407""],
      ""features"": [
        ""all""
      ]
     }
   ]
 }","Interactions with the OS in Google Chrome prior to 56.0.2924.76 for Mac insufficiently cleared video memory, which allowed a remote attacker to possibly extract image fragments on systems with GeForce 8600M graphics chips via a crafted HTML page."
3045,CVE-2017-5023,"  HistogramBase* Histogram::Factory::Build() {
     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);
   }
 
  CHECK_EQ(histogram_type_, histogram->GetHistogramType()) << name_;
   if (bucket_count_ != 0 &&
       !histogram->HasConstructionArguments(minimum_, maximum_, bucket_count_)) {
      ","Type confusion in Histogram in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit a near null dereference via a crafted HTML page."
3046,,"  inline bool NeedsColumnBalancing(LayoutUnit block_size,
          style.GetColumnFill() == EColumnFill::kBalance;
 }
 
LayoutUnit CalculateColumnContentBlockSize(
    const NGPhysicalContainerFragment& fragment,
    bool multicol_is_horizontal_writing_mode) {
   
   
   
  LayoutUnit total_size;
  for (const auto& child : fragment.Children()) {
    LayoutUnit size;
    LayoutUnit offset;
    if (multicol_is_horizontal_writing_mode) {
      offset = child.Offset().top;
      size = child->Size().height;
    } else {
      offset = child.Offset().left;
      size = child->Size().width;
    }
    if (child->IsContainer()) {
      LayoutUnit children_size = CalculateColumnContentBlockSize(
          To<NGPhysicalContainerFragment>(*child),
          multicol_is_horizontal_writing_mode);
      if (size < children_size)
        size = children_size;
    }
    LayoutUnit block_end = offset + size;
    if (total_size < block_end)
      total_size = block_end;
  }
  return total_size;
}

 }   
 
 NGColumnLayoutAlgorithm::NGColumnLayoutAlgorithm(
  LayoutUnit NGColumnLayoutAlgorithm::CalculateBalancedColumnBlockSize(
       {Node(), fragment_geometry, space});
   scoped_refptr<const NGLayoutResult> result = balancing_algorithm.Layout();
 
  LayoutUnit single_strip_block_size = CalculateColumnContentBlockSize(
      result->PhysicalFragment(),
      IsHorizontalWritingMode(space.GetWritingMode()));
 
    
    ",
3047,CVE-2016-5206,"  TEST_P(WebLayerListSimTest, DirectTransformPropertyUpdate) {
   EXPECT_FALSE(transform_node->transform_changed);
 }
 
 
 
 
 
 
TEST_P(WebLayerListSimTest, DirectTransformOriginPropertyUpdate) {
   
   
   
  if (RuntimeEnabledFeatures::CompositeAfterPaintEnabled())
    return;

  InitializeWithHTML(R""HTML(
      <!DOCTYPE html>
      <style>
        html { overflow: hidden; }
        #box {
          width: 100px;
          height: 100px;
          transform: rotate3d(3, 2, 1, 45deg);
          transform-origin: 10px 10px 100px;
        }
      </style>
      <div id='box'></div>
  )HTML"");

  Compositor().BeginFrame();

  auto* box_element = GetElementById(""box"");
  auto* box_element_layer = ContentLayerAt(ContentLayerCount() - 1);
  DCHECK_EQ(box_element_layer->element_id(),
            CompositorElementIdFromUniqueObjectId(
                box_element->GetLayoutObject()->UniqueId(),
                CompositorElementIdNamespace::kPrimary));
  auto transform_tree_index = box_element_layer->transform_tree_index();
  auto* transform_node =
      GetPropertyTrees()->transform_tree.Node(transform_tree_index);

   
  EXPECT_FALSE(transform_node->transform_changed);
  EXPECT_FALSE(paint_artifact_compositor()->NeedsUpdate());

   
  box_element->setAttribute(html_names::kStyleAttr,
                            ""transform-origin: -10px -10px -100px"");
  UpdateAllLifecyclePhasesExceptPaint();
  EXPECT_TRUE(transform_node->transform_changed);
  EXPECT_FALSE(paint_artifact_compositor()->NeedsUpdate());

   
  Compositor().BeginFrame();
  EXPECT_FALSE(transform_node->transform_changed);
}

  
  
 TEST_P(WebLayerListSimTest, LayerSubtreeEffectPropertyChanged) {","The PDF plugin in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly followed redirects, which allowed a remote attacker to bypass the Same Origin Policy via a crafted HTML page."
3048,CVE-2016-5205,"  class FlexLayoutAlgorithm {
 
   bool ShouldApplyMinSizeAutoForChild(const LayoutBox& child) const;
 
   
   
   
   
   
   
   
   LayoutUnit IntrinsicContentBlockSize() const;
 
   static TransformedWritingMode GetTransformedWritingMode(const ComputedStyle&);","Blink in Google Chrome prior to 55.0.2883.75 for Linux, Windows and Mac, incorrectly handles deferred page loads, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page."
3049,CVE-2016-5204,"  UserInitiatedInfo CreateUserInitiatedInfo(
     return UserInitiatedInfo::BrowserInitiated();
 
   return UserInitiatedInfo::RenderInitiated(
      navigation_handle->HasUserGesture(),
      !navigation_handle->NavigationInputStart().is_null());
 }
 
 }   ","Leaking of an SVG shadow tree leading to corruption of the DOM tree in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page."
3050,CVE-2016-5212,"  GURL DecorateFrontendURL(const GURL& base_url) {
     url_string += ""&experiments=true"";
 
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    url_string += ""&"" + command_line->GetSwitchValueASCII(
        switches::kDevToolsFlags);
   }
 
 #if defined(DEBUG_DEVTOOLS)
  GURL DevToolsWindow::GetDevToolsURL(Profile* profile,
   }
   if (can_dock)
     url_string += ""&can_dock=true"";
  return DevToolsUI::SanitizeFrontendURL(GURL(url_string));
 }
 
  ","Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android insufficiently sanitized DevTools URLs, which allowed a remote attacker to read local files via a crafted HTML page."
3051,CVE-2016-5216,"  int PDFiumEngine::GetMostVisiblePage() {
   if (in_flight_visible_page_)
     return *in_flight_visible_page_;
 
   
   
   
   
  defer_page_unload_ = true;
   CalculateVisiblePages();
  defer_page_unload_ = false;
   return most_visible_page_;
 }
 ","A use after free in PDFium in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to perform an out of bounds memory read via a crafted PDF file."
3052,CVE-2016-5217,"  Compositor::Compositor(
 
   host_->SetHasGpuRasterizationTrigger(features::IsUiGpuRasterizationEnabled());
   host_->SetRootLayer(root_web_layer_);

   
   
   host_->SetVisible(true);
 
   if (command_line->HasSwitch(switches::kUISlowAnimations)) {","The extensions API in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly permitted access to privileged plugins, which allowed a remote attacker to bypass site isolation via a crafted HTML page."
3053,CVE-2016-5218,"  TabGroupData::TabGroupData() {
   ++next_placeholder_title_number;
 
   static SkRandom rand;
  color_ = rand.nextU() | 0xff000000;
 }","The extensions API in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled navigation within PDFs, which allowed a remote attacker to temporarily spoof the contents of the Omnibox (URL bar) via a crafted HTML page containing PDF data."
3054,CVE-2016-5220,"  void OmniboxViewViews::ExecuteTextEditCommand(ui::TextEditCommand command) {
 }
 
 bool OmniboxViewViews::ShouldShowPlaceholderText() const {
  bool show_with_caret = base::FeatureList::IsEnabled(
      omnibox::kUIExperimentShowPlaceholderWhenCaretShowing);
   return Textfield::ShouldShowPlaceholderText() &&
         (show_with_caret || !model()->is_caret_visible()) &&
         !model()->is_keyword_selected();
 }
 
 #if defined(OS_CHROMEOS)","PDFium in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled navigation within PDFs, which allowed a remote attacker to read local files via a crafted PDF file."
3055,CVE-2016-5222," 
  
  
 
#include ""base/command_line.h""
#include ""chrome/app/chrome_command_ids.h""
 #include ""chrome/browser/chrome_notification_types.h""
#include ""chrome/browser/renderer_context_menu/render_view_context_menu_test_util.h""
 #include ""chrome/browser/ui/browser.h""
 #include ""chrome/browser/ui/tabs/tab_strip_model.h""
 #include ""chrome/test/base/in_process_browser_test.h""
 #include ""chrome/test/base/ui_test_utils.h""
 #include ""content/public/browser/navigation_handle.h""
 #include ""content/public/browser/notification_service.h""
 #include ""content/public/browser/web_contents_observer.h""
#include ""content/public/common/context_menu_params.h""
 #include ""content/public/test/browser_test_utils.h""
 #include ""content/public/test/test_navigation_observer.h""
#include ""net/dns/mock_host_resolver.h""
 
 class ChromeNavigationBrowserTest : public InProcessBrowserTest {
  public:
  IN_PROC_BROWSER_TEST_F(
     EXPECT_FALSE(new_web_contents->IsLoading());
   }
 }

class ChromeNavigationPortMappedBrowserTest : public InProcessBrowserTest {
 public:
  ChromeNavigationPortMappedBrowserTest() {}
  ~ChromeNavigationPortMappedBrowserTest() override {}

  void SetUpCommandLine(base::CommandLine* command_line) override {
    ASSERT_TRUE(embedded_test_server()->Start());

     
     
     
     
    std::string port =
        base::IntToString(embedded_test_server()->host_port_pair().port());
    command_line->AppendSwitchASCII(
        ""host-resolver-rules"",
        ""MAP * 127.0.0.1:"" + port + "", EXCLUDE 127.0.0.1*"");
  }

 private:
  DISALLOW_COPY_AND_ASSIGN(ChromeNavigationPortMappedBrowserTest);
};

 
 
 
IN_PROC_BROWSER_TEST_F(ChromeNavigationPortMappedBrowserTest,
                       ContextMenuNavigationToInvalidUrl) {
  GURL initial_url = embedded_test_server()->GetURL(""/title1.html"");
  GURL new_tab_url(
      ""www.foo.com::/server-redirect?http%3A%2F%2Fbar.com%2Ftitle2.html"");

   
   
  ui_test_utils::NavigateToURL(browser(), initial_url);
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();

   
  content::ContextMenuParams params;
  params.is_editable = false;
  params.media_type = blink::WebContextMenuData::MediaTypeNone;
  params.page_url = initial_url;
  params.link_url = new_tab_url;

  content::WindowedNotificationObserver tab_added_observer(
      chrome::NOTIFICATION_TAB_ADDED,
      content::NotificationService::AllSources());

  TestRenderViewContextMenu menu(web_contents->GetMainFrame(), params);
  menu.Init();
  menu.ExecuteCommand(IDC_CONTENT_CONTEXT_OPENLINKNEWTAB, 0);

   
   
   
  tab_added_observer.Wait();
  content::WebContents* new_web_contents =
      browser()->tab_strip_model()->GetWebContentsAt(
          browser()->tab_strip_model()->count() - 1);
  WaitForLoadStop(new_web_contents);

   
   
   
   
  EXPECT_EQ(GURL(), new_web_contents->GetLastCommittedURL());
}","Incorrect handling of invalid URLs in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page."
3056,CVE-2016-5199,"  const gfx::ImageSkia* ChromeContentBrowserClient::GetDefaultFavicon() {
 
 bool ChromeContentBrowserClient::IsDataSaverEnabled(
     content::BrowserContext* browser_context) {
  Profile* profile = Profile::FromBrowserContext(browser_context);
  return profile && data_reduction_proxy::DataReductionProxySettings::
                        IsDataSaverEnabledByUser(profile->GetPrefs());
 }
 
 void ChromeContentBrowserClient::UpdateRendererPreferencesForWorker(","An off by one error resulting in an allocation of zero size in FFmpeg in Google Chrome prior to 54.0.2840.98 for Mac, and 54.0.2840.99 for Windows, and 54.0.2840.100 for Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted video file."
3057,CVE-2016-5200,"  base::string16 GetRelyingPartyIdString(
   const auto& rp_id = dialog_model->relying_party_id();
   DCHECK(!rp_id.empty());
   GURL rp_id_url(kRpIdUrlPrefix + rp_id);
  return url_formatter::ElideHost(rp_id_url, gfx::FontList(), kDialogWidth);
 }
 
  ","V8 in Google Chrome prior to 54.0.2840.98 for Mac, and 54.0.2840.99 for Windows, and 54.0.2840.100 for Linux, and 55.0.2883.84 for Android incorrectly applied type rules, which allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
3058,CVE-2016-5202,"  void TestGamepadMinimumDataImpl(WebXrVrBrowserTestBase* t) {
       t->GetFileUrlForHtmlTestFile(""test_webxr_gamepad_support""));
   t->EnterSessionWithUserGestureOrFail();
 
   
   
   
  std::string button_count = ""2"";
  if (t->GetRuntimeType() == XrBrowserTestBase::RuntimeType::RUNTIME_WMR)
    button_count = ""4"";

  t->PollJavaScriptBooleanOrFail(""isButtonCountEqualTo("" + button_count + "")"",
                                 WebXrVrBrowserTestBase::kPollTimeoutShort);

    
    
   my_mock.TogglePrimaryTrigger(controller_index);
  IN_PROC_BROWSER_TEST_F(WebXrVrBrowserTestWMR, TestGamepadMinimumData) {
 void TestGamepadCompleteDataImpl(WebXrVrBrowserTestBase* t) {
   WebXrControllerInputMock my_mock;
 
   
   uint64_t supported_buttons =
       device::XrButtonMaskFromId(device::XrButtonId::kAxisTrigger) |
       device::XrButtonMaskFromId(device::XrButtonId::kAxisPrimary) |
  void TestGamepadCompleteDataImpl(WebXrVrBrowserTestBase* t) {
   t->PollJavaScriptBooleanOrFail(""isMappingEqualTo('xr-standard')"",
                                  WebVrBrowserTestBase::kPollTimeoutShort);
 
   
  t->PollJavaScriptBooleanOrFail(""isButtonCountEqualTo(4)"",
                                 WebXrVrBrowserTestBase::kPollTimeoutShort);

    
   t->PollJavaScriptBooleanOrFail(""areAxesValuesEqualTo(1, 0.25, -0.25)"",
                                  WebVrBrowserTestBase::kPollTimeoutShort);
  IN_PROC_BROWSER_TEST_F(WebXrVrBrowserTestStandard, TestGamepadReservedData) {
    
   PollJavaScriptBooleanOrFail(""isMappingEqualTo('xr-standard')"",
                               kPollTimeoutShort);
  PollJavaScriptBooleanOrFail(""isButtonCountEqualTo(5)"", kPollTimeoutShort);
   PollJavaScriptBooleanOrFail(""isButtonPressedEqualTo(0, true)"",
                               kPollTimeoutShort);
   PollJavaScriptBooleanOrFail(""isButtonPressedEqualTo(1, true)"",
  IN_PROC_BROWSER_TEST_F(WebXrVrBrowserTestStandard, TestGamepadReservedData) {
   EndTest();
 }
 
 
 
 
 
 
 
IN_PROC_BROWSER_TEST_F(WebXrVrBrowserTestStandard, TestGamepadOptionalData) {
  WebXrControllerInputMock my_mock;

   
  uint64_t supported_buttons =
      device::XrButtonMaskFromId(device::XrButtonId::kAxisTrigger) |
      device::XrButtonMaskFromId(device::XrButtonId::kAxisPrimary) |
      device::XrButtonMaskFromId(device::XrButtonId::kGrip);

  std::map<device::XrButtonId, unsigned int> axis_types = {
      {device::XrButtonId::kAxisPrimary, GetPrimaryAxisType()},
      {device::XrButtonId::kAxisTrigger, device::XrAxisType::kTrigger},
  };

  my_mock.CreateAndConnectController(
      device::ControllerRole::kControllerRoleRight, axis_types,
      supported_buttons);

  LoadUrlAndAwaitInitialization(
      GetFileUrlForHtmlTestFile(""test_webxr_gamepad_support""));
  EnterSessionWithUserGestureOrFail();

   
   
  PollJavaScriptBooleanOrFail(""isMappingEqualTo('xr-standard')"",
                              kPollTimeoutShort);
  PollJavaScriptBooleanOrFail(""isButtonCountEqualTo(3)"", kPollTimeoutShort);

  RunJavaScriptOrFail(""done()"");
  EndTest();
}

 void TestControllerInputRegisteredImpl(WebXrVrBrowserTestBase* t) {
   WebXrControllerInputMock my_mock;
 ",
3059,CVE-2016-5198,"  class PLATFORM_EXPORT ImageFrameGenerator final
   SkISize GetSupportedDecodeSize(const SkISize& requested_size) const;
 
   bool IsMultiFrame() const { return is_multi_frame_; }
  bool DecodeFailed() const {
    MutexLocker lock(generator_mutex_);
    return decode_failed_;
  }
 
   bool HasAlpha(size_t index);
 
  class PLATFORM_EXPORT ImageFrameGenerator final
   const std::vector<SkISize> supported_sizes_;
 
    
  mutable Mutex generator_mutex_;
 
   bool decode_failed_ = false;
   bool yuv_decoding_failed_ = false;","V8 in Google Chrome prior to 54.0.2840.90 for Linux, and 54.0.2840.85 for Android, and 54.0.2840.87 for Windows and Mac included incorrect optimisation assumptions, which allowed a remote attacker to perform arbitrary read/write operations, leading to code execution, via a crafted HTML page."
3060,CVE-2016-1661,"  Compositor::Compositor(const viz::FrameSinkId& frame_sink_id,
     auto* host_frame_sink_manager =
         context_factory_private_->GetHostFrameSinkManager();
     host_frame_sink_manager->RegisterFrameSinkId(
        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kNo);
     host_frame_sink_manager->SetFrameSinkDebugLabel(frame_sink_id_,
                                                     ""Compositor"");
   }
  void Compositor::DidSubmitCompositorFrame() {
 
 void Compositor::OnFirstSurfaceActivation(
     const viz::SurfaceInfo& surface_info) {
  NOTREACHED();
 }
 
 void Compositor::OnFrameTokenChanged(uint32_t frame_token) {","Blink, as used in Google Chrome before 50.0.2661.94, does not ensure that frames satisfy a check for the same renderer process in addition to a Same Origin Policy check, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted web site, related to BindingSecurity.cpp and DOMWindow.cpp."
3061,CVE-2016-1662,"  class DriveFsHost::MountState
     token_fetch_attempted_ = true;
   }
 
  void OnHeartbeat() override {
    DCHECK_CALLED_ON_VALID_SEQUENCE(host_->sequence_checker_);
    if (host_->timer_->IsRunning()) {
      host_->timer_->Reset();
    }
  }

   void OnMounted() override {
     DCHECK_CALLED_ON_VALID_SEQUENCE(host_->sequence_checker_);
     drivefs_has_mounted_ = true;","extensions/renderer/gc_callback.cc in Google Chrome before 50.0.2661.94 does not prevent fallback execution once the Garbage Collection callback has started, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors."
3062,CVE-2016-1663,"  void SerializedScriptValue::transferArrayBuffers(v8::Isolate* isolate, const Arr
 
             DOMArrayBufferBase* toTransfer = arrayBuffers[i];
             if (!isNeuterable)
                toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer()->data(), arrayBuffers[i]->buffer()->byteLength());
             bool result = toTransfer->transfer(contents->at(i));
             if (!result) {
                 exceptionState.throwDOMException(DataCloneError, ""ArrayBuffer at index "" + String::number(i) + "" could not be transferred."");","The SerializedScriptValue::transferArrayBuffers function in WebKit/Source/bindings/core/v8/SerializedScriptValue.cpp in the V8 bindings in Blink, as used in Google Chrome before 50.0.2661.94, mishandles certain array-buffer data structures, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site."
3063,CVE-2016-1664,"  void HistoryController::UpdateForCommit(RenderFrameImpl* frame,
     case blink::WebBackForwardCommit:
       if (!provisional_entry_)
         return;
       
       
       
      if (HistoryEntry::HistoryNode* node =
              provisional_entry_->GetHistoryNodeForFrame(frame)) {
        if (node->item().itemSequenceNumber() == item.itemSequenceNumber())
          current_entry_.reset(provisional_entry_.release());
      }
       if (HistoryEntry::HistoryNode* node =
               current_entry_->GetHistoryNodeForFrame(frame)) {
         node->set_item(item);","The HistoryController::UpdateForCommit function in content/renderer/history_controller.cc in Google Chrome before 50.0.2661.94 mishandles the interaction between subframe forward navigations and other forward navigations, which allows remote attackers to spoof the address bar via a crafted web site."
3064,CVE-2016-1665,"  void DiceResponseHandler::ProcessDiceSignoutHeader(
          
         token_service_->UpdateCredentials(
             primary_account,
            MutableProfileOAuth2TokenServiceDelegate::kInvalidRefreshToken,
            signin_metrics::SourceForRefreshTokenOperation::
                kDiceResponseHandler_Signout);
       } else {
          
          
         continue;
       }
     } else {
      token_service_->RevokeCredentials(
          signed_out_account, signin_metrics::SourceForRefreshTokenOperation::
                                  kDiceResponseHandler_Signout);
     }
 
      
  void DiceResponseHandler::OnTokenExchangeSuccess(
       account_tracker_service_->SeedAccountInfo(gaia_id, email);
   account_tracker_service_->SetIsAdvancedProtectionAccount(
       account_id, is_under_advanced_protection);
  token_service_->UpdateCredentials(
      account_id, refresh_token,
      signin_metrics::SourceForRefreshTokenOperation::
          kDiceResponseHandler_Signin);
   about_signin_internals_->OnRefreshTokenReceived(
       base::StringPrintf(""Successful (%s)"", account_id.c_str()));
   if (should_enable_sync)","The JSGenericLowering class in compiler/js-generic-lowering.cc in Google V8, as used in Google Chrome before 50.0.2661.94, mishandles comparison operators, which allows remote attackers to obtain sensitive information via crafted JavaScript code."
3065,,"  void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {
     TogglePlayPause();
     event->SetHandled();
   }
 }
 
 void OverlayWindowViews::ButtonPressed(views::Button* sender,",
3066,CVE-2016-1666," 
 #include ""base/stl_util.h""
 #include ""base/strings/string_util.h""
 #include ""base/task/post_task.h""
#include ""base/test/bind_test_util.h""
 #include ""base/test/scoped_command_line.h""
 #include ""build/buildflag.h""
 #include ""chrome/browser/browser_process.h""
#include ""chrome/browser/chrome_content_browser_client.h""
 #include ""chrome/browser/download/download_browsertest.h""
 #include ""chrome/browser/loader/chrome_navigation_data.h""
 #include ""chrome/browser/policy/cloud/policy_header_service_factory.h""
 
 #include ""chrome/test/base/in_process_browser_test.h""
 #include ""chrome/test/base/ui_test_utils.h""
 #include ""components/data_reduction_proxy/core/browser/data_reduction_proxy_data.h""
#include ""components/google/core/common/google_util.h""
#include ""components/network_session_configurator/common/network_switches.h""
 #include ""components/policy/core/common/cloud/cloud_policy_constants.h""
 #include ""components/policy/core/common/cloud/policy_header_service.h""
 #include ""components/policy/core/common/policy_switches.h""
 
 #include ""content/public/browser/resource_dispatcher_host.h""
 #include ""content/public/browser/resource_dispatcher_host_delegate.h""
 #include ""content/public/browser/web_contents_observer.h""
#include ""content/public/common/url_loader_throttle.h""
 #include ""content/public/test/browser_test_utils.h""
#include ""net/dns/mock_host_resolver.h""
 #include ""net/http/http_request_headers.h""
 #include ""net/test/embedded_test_server/embedded_test_server.h""
 #include ""net/test/embedded_test_server/http_request.h""
 #include ""net/test/embedded_test_server/http_response.h""
#include ""net/test/embedded_test_server/request_handler_util.h""
 #include ""net/test/url_request/url_request_mock_http_job.h""
 #include ""net/url_request/url_request.h""
 #include ""net/url_request/url_request_filter.h""
 
 #endif
 
 using content::ResourceType;
 
 namespace {
 
  class TestDispatcherHostDelegate : public ChromeResourceDispatcherHostDelegate {
   ~TestDispatcherHostDelegate() override {}
 
    
   content::NavigationData* GetNavigationData(
       net::URLRequest* request) const override {
     if (request && should_add_data_reduction_proxy_data_) {
  class TestDispatcherHostDelegate : public ChromeResourceDispatcherHostDelegate {
         should_add_data_reduction_proxy_data;
   }
 
    
    
   void GetTimesStandardThrottlesAddedForURL(const GURL& url, int* count) {
  class TestDispatcherHostDelegate : public ChromeResourceDispatcherHostDelegate {
 
  private:
   bool should_add_data_reduction_proxy_data_;
 
   std::map<GURL, int> times_stardard_throttles_added_for_url_;
 
  IN_PROC_BROWSER_TEST_F(ChromeResourceDispatcherHostDelegateBrowserTest,
  
 #if !BUILDFLAG(ENABLE_DICE_SUPPORT)
 
 
 
class HeaderModifyingThrottle : public content::URLLoaderThrottle {
  public:
  HeaderModifyingThrottle() = default;
  ~HeaderModifyingThrottle() override = default;
 
  void WillStartRequest(network::ResourceRequest* request,
                        bool* defer) override {
    request->headers.SetHeader(signin::kChromeConnectedHeader, ""User Data"");
   }
 
  private:
  DISALLOW_COPY_AND_ASSIGN(HeaderModifyingThrottle);
 };
 
class ThrottleContentBrowserClient : public ChromeContentBrowserClient {
  public:
  explicit ThrottleContentBrowserClient(const GURL& watch_url)
       : watch_url_(watch_url) {}
  ~ThrottleContentBrowserClient() override = default;

   
  std::vector<std::unique_ptr<content::URLLoaderThrottle>>
  CreateURLLoaderThrottles(
      const network::ResourceRequest& request,
      content::ResourceContext* resource_context,
      const base::RepeatingCallback<content::WebContents*()>& wc_getter,
      content::NavigationUIData* navigation_ui_data,
      int frame_tree_node_id) override {
    std::vector<std::unique_ptr<content::URLLoaderThrottle>> throttles;
    if (request.url == watch_url_)
      throttles.push_back(std::make_unique<HeaderModifyingThrottle>());
    return throttles;
   }
 
  private:
   const GURL watch_url_;
 
  DISALLOW_COPY_AND_ASSIGN(ThrottleContentBrowserClient);
 };
 
  
  
 class ChromeResourceDispatcherHostDelegateMirrorBrowserTest
     : public ChromeResourceDispatcherHostDelegateBrowserTest {
  private:
  void SetUpOnMainThread() override {
     
     
    host_resolver()->AddRule(""*"", ""127.0.0.1"");

     
     
    google_util::IgnorePortNumbersForGoogleURLChecksForTesting();
  }

  void SetUpCommandLine(base::CommandLine* command_line) override {
     
     
    command_line->AppendSwitch(switches::kIgnoreCertificateErrors);
  }

   ScopedAccountConsistencyMirror scoped_mirror_;
 };
 
  IN_PROC_BROWSER_TEST_F(ChromeResourceDispatcherHostDelegateMirrorBrowserTest,
   browser()->profile()->GetPrefs()->SetString(
       prefs::kGoogleServicesUserAccountId, ""account_id"");
 
  base::Lock lock;
   
   
   
  std::map<std::string, net::test_server::HttpRequest::HeaderMap> header_map;
  embedded_test_server()->RegisterRequestMonitor(base::BindLambdaForTesting(
      [&](const net::test_server::HttpRequest& request) {
        base::AutoLock auto_lock(lock);
        header_map[request.GetURL().path()] = request.headers;
      }));
  ASSERT_TRUE(embedded_test_server()->Start());

  net::EmbeddedTestServer https_server(net::EmbeddedTestServer::TYPE_HTTPS);
  https_server.AddDefaultHandlers(
      base::FilePath(FILE_PATH_LITERAL(""chrome/test/data"")));
  https_server.RegisterRequestMonitor(base::BindLambdaForTesting(
      [&](const net::test_server::HttpRequest& request) {
        base::AutoLock auto_lock(lock);
        header_map[request.GetURL().path()] = request.headers;
      }));
  ASSERT_TRUE(https_server.Start());

   base::FilePath root_http;
   base::PathService::Get(chrome::DIR_TEST_DATA, &root_http);
   root_http = root_http.AppendASCII(""mirror_request_header"");
 
   struct TestCase {
     GURL original_url;        
     
    std::string redirected_to_path;
     bool inject_header;   
                           
     bool original_url_expects_header;        
                                              
     bool redirected_to_url_expects_header;   
                                              
  };

  std::vector<TestCase> all_tests;

   
   
  base::StringPairs replacement_text;
  std::string replacement_path;
  replacement_text.push_back(std::make_pair(
      ""{{PORT}}"", base::UintToString(embedded_test_server()->port())));
  net::test_server::GetFilePathWithReplacements(
      ""/mirror_request_header/http.www.google.com.html"", replacement_text,
      &replacement_path);
  all_tests.push_back(
      {embedded_test_server()->GetURL(""www.google.com"", replacement_path),
       ""/simple.html"", false, false, false});

   
  net::test_server::GetFilePathWithReplacements(
      ""/mirror_request_header/http.www.header_adder.com.html"", replacement_text,
      &replacement_path);
  all_tests.push_back(
      {embedded_test_server()->GetURL(""www.header_adder.com"", replacement_path),
       ""/simple.html"", true, true, true});

   
  replacement_text.clear();
  replacement_text.push_back(
      std::make_pair(""{{PORT}}"", base::UintToString(https_server.port())));
  net::test_server::GetFilePathWithReplacements(
      ""/mirror_request_header/https.www.google.com.html"", replacement_text,
      &replacement_path);
  all_tests.push_back({https_server.GetURL(""www.google.com"", replacement_path),
                       ""/simple.html"", false, true, false});
 
   for (const auto& test_case : all_tests) {
     SCOPED_TRACE(test_case.original_url);
 
     
    ThrottleContentBrowserClient browser_client(test_case.original_url);
    content::ContentBrowserClient* old_browser_client = nullptr;
    if (test_case.inject_header)
      old_browser_client = content::SetBrowserClientForTesting(&browser_client);
 
      
     ui_test_utils::NavigateToURL(browser(), test_case.original_url);
 
    if (test_case.inject_header)
      content::SetBrowserClientForTesting(old_browser_client);
 
    base::AutoLock auto_lock(lock);
 
      
    ASSERT_EQ(1u, header_map.count(test_case.original_url.path()));
     if (test_case.original_url_expects_header) {
      ASSERT_TRUE(!!header_map[test_case.original_url.path()].count(
          signin::kChromeConnectedHeader));
     } else {
      ASSERT_FALSE(!!header_map[test_case.original_url.path()].count(
          signin::kChromeConnectedHeader));
     }
 
    ASSERT_EQ(1u, header_map.count(test_case.redirected_to_path));
     if (test_case.redirected_to_url_expects_header) {
      ASSERT_TRUE(!!header_map[test_case.redirected_to_path].count(
          signin::kChromeConnectedHeader));
     } else {
      ASSERT_FALSE(!!header_map[test_case.redirected_to_path].count(
          signin::kChromeConnectedHeader));
     }

    header_map.clear();
   }
 }
 ",Multiple unspecified vulnerabilities in Google Chrome before 50.0.2661.94 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
3067,CVE-2018-18338,"  AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(
   CHECK(image && image->isTextureBacked());
   texture_holder_ = std::make_unique<SkiaTextureHolder>(
       std::move(image), std::move(context_provider_wrapper));
 }
 
 AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(
  AcceleratedStaticBitmapImage::AcceleratedStaticBitmapImage(
   texture_holder_ = std::make_unique<MailboxTextureHolder>(
       mailbox, sync_token, texture_id, std::move(context_provider_wrapper),
       mailbox_size);
 }
 
 namespace {
  void DestroySkImageOnOriginalThread(
      
     image->getTexture()->textureParamsModified();
   }
  image.reset();
 }
 
 }   
 
 AcceleratedStaticBitmapImage::~AcceleratedStaticBitmapImage() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

    
    
    
   if (original_skia_image_) {
     std::unique_ptr<gpu::SyncToken> sync_token =
         base::WrapUnique(new gpu::SyncToken(texture_holder_->GetSyncToken()));
    if (!original_skia_image_task_runner_->BelongsToCurrentThread()) {
       PostCrossThreadTask(
           *original_skia_image_task_runner_, FROM_HERE,
           CrossThreadBind(
  AcceleratedStaticBitmapImage::~AcceleratedStaticBitmapImage() {
 }
 
 void AcceleratedStaticBitmapImage::RetainOriginalSkImage() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);

   DCHECK(texture_holder_->IsSkiaTextureHolder());
   original_skia_image_ = texture_holder_->GetSkImage();
   original_skia_image_context_provider_wrapper_ = ContextProviderWrapper();
   DCHECK(original_skia_image_);

   Thread* thread = Platform::Current()->CurrentThread();
   original_skia_image_task_runner_ = thread->GetTaskRunner();
 }
 
  bool AcceleratedStaticBitmapImage::CopyToTexture(
     bool unpack_flip_y,
     const IntPoint& dest_point,
     const IntRect& source_sub_rectangle) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!IsValid())
     return false;
    
  bool AcceleratedStaticBitmapImage::CopyToTexture(
 PaintImage AcceleratedStaticBitmapImage::PaintImageForCurrentFrame() {
    
    
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!IsValid())
     return PaintImage();
 
   sk_sp<SkImage> image;
   if (original_skia_image_ &&
      original_skia_image_task_runner_->BelongsToCurrentThread()) {
      
      
      
  void AcceleratedStaticBitmapImage::Draw(cc::PaintCanvas* canvas,
                                         RespectImageOrientationEnum,
                                         ImageClampingMode image_clamping_mode,
                                         ImageDecodingMode decode_mode) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   auto paint_image = PaintImageForCurrentFrame();
   if (!paint_image)
     return;
  AcceleratedStaticBitmapImage::ContextProviderWrapper() const {
 }
 
 void AcceleratedStaticBitmapImage::CreateImageFromMailboxIfNeeded() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (texture_holder_->IsSkiaTextureHolder())
     return;
   texture_holder_ =
  void AcceleratedStaticBitmapImage::CreateImageFromMailboxIfNeeded() {
 
 void AcceleratedStaticBitmapImage::EnsureMailbox(MailboxSyncMode mode,
                                                  GLenum filter) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (!texture_holder_->IsMailboxTextureHolder()) {
     TRACE_EVENT0(""blink"", ""AcceleratedStaticBitmapImage::EnsureMailbox"");
 
  void AcceleratedStaticBitmapImage::EnsureMailbox(MailboxSyncMode mode,
 }
 
 void AcceleratedStaticBitmapImage::Transfer() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   EnsureMailbox(kVerifiedSyncToken, GL_NEAREST);
  DETACH_FROM_THREAD(thread_checker_);
 }
 
 bool AcceleratedStaticBitmapImage::CurrentFrameKnownToBeOpaque() {
   return texture_holder_->CurrentFrameKnownToBeOpaque();
 }
 
 void AcceleratedStaticBitmapImage::Abandon() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   texture_holder_->Abandon();
 }
 ","Incorrect, thread-unsafe use of SkImage in Canvas in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
3068,CVE-2018-18339,"  void RendererSchedulerImpl::OnShutdownTaskQueue(
       case MainThreadTaskQueue::QueueClass::kTimer:
         task_queue->RemoveTaskObserver(
             &main_thread_only().timer_task_cost_estimator);
        break;
       case MainThreadTaskQueue::QueueClass::kLoading:
         task_queue->RemoveTaskObserver(
             &main_thread_only().loading_task_cost_estimator);
        break;
       default:
         break;
     }",Incorrect object lifecycle in WebAudio in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3069,CVE-2018-18340,"  MediaRecorderHandler::MediaRecorderHandler(
 MediaRecorderHandler::~MediaRecorderHandler() {
   DCHECK(main_render_thread_checker_.CalledOnValidThread());
    
  if (client_) {
     client_->WriteData(
         nullptr, 0u, true,
         (TimeTicks::Now() - TimeTicks::UnixEpoch()).InMillisecondsF());
  }
 }
 
 bool MediaRecorderHandler::CanSupportMimeType(",Incorrect object lifecycle in MediaRecorder in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3070,CVE-2018-18341," 
 
 #include <memory>
 #include ""base/memory/ptr_util.h""
#include ""base/numerics/checked_math.h""
 #include ""third_party/blink/renderer/platform/wtf/text/character_names.h""
 #include ""third_party/blink/renderer/platform/wtf/text/cstring.h""
 #include ""third_party/blink/renderer/platform/wtf/text/string_buffer.h""
  String TextCodecUTF8::Decode(const char* bytes,
    
    
    
  StringBuffer<LChar> buffer(
      base::CheckAdd(partial_sequence_size_, length).ValueOrDie());
 
   const uint8_t* source = reinterpret_cast<const uint8_t*>(bytes);
   const uint8_t* end = source + length;
  String TextCodecUTF8::Decode(const char* bytes,
   return String::Adopt(buffer);
 
 upConvertTo16Bit:
  StringBuffer<UChar> buffer16(
      base::CheckAdd(partial_sequence_size_, length).ValueOrDie());
 
   UChar* destination16 = buffer16.Characters();
 ",An integer overflow leading to a heap buffer overflow in Blink in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3071,CVE-2018-18344,"  class ExtensionDevToolsClientHost : public content::DevToolsAgentHostClient,
                            bool is_webui) override;
   bool MayAttachToBrowser() override;
   bool MayDiscoverTargets() override;
  bool MayAffectLocalFiles() override;
 
  private:
   using PendingRequests =
  bool ExtensionDevToolsClientHost::MayDiscoverTargets() {
   return false;
 }
 
bool ExtensionDevToolsClientHost::MayAffectLocalFiles() {
  return false;
}

  
 
 DebuggerFunction::DebuggerFunction()",Inappropriate allowance of the setDownloadBehavior devtools protocol feature in Extensions in Google Chrome prior to 71.0.3578.80 allowed a remote attacker with control of an installed extension to access files on the local file system via a crafted Chrome Extension.
3072,,"  bool SQLiteDatabase::Open(const String& filename) {
     return false;
   }
 
   
   
   
  open_error_ = sqlite3_db_config(db_, SQLITE_DBCONFIG_DEFENSIVE, 1, nullptr);
  if (open_error_ != SQLITE_OK) {
    open_error_message_ = sqlite3_errmsg(db_);
    DLOG(ERROR) << ""SQLite database error when enabling defensive mode - ""
                << open_error_message_.data();
    sqlite3_close(db_);
    db_ = nullptr;
    return false;
  }

   if (IsOpen())
     opening_thread_ = CurrentThread();
   else",
3073,CVE-2018-18345,"  bool ChildProcessSecurityPolicyImpl::CanRedirectToURL(const GURL& url) {
 }
 
 bool ChildProcessSecurityPolicyImpl::CanCommitURL(int child_id,
                                                  const GURL& url,
                                                  bool check_origin_locks) {
   if (!url.is_valid())
     return false;   
 
  bool ChildProcessSecurityPolicyImpl::CanCommitURL(int child_id,
       return false;
 
     url::Origin origin = url::Origin::Create(url);
    return origin.unique() ||
           CanCommitURL(child_id, GURL(origin.Serialize()), check_origin_locks);
   }
 
   
   
   
   
   
   
  if (check_origin_locks && !CanAccessDataForOrigin(child_id, url))
    return false;

   {
     base::AutoLock lock(lock_);
 
      
      
      
      
     
      
     if (base::ContainsKey(schemes_okay_to_commit_in_any_process_, scheme))
       return true;
  bool ChildProcessSecurityPolicyImpl::CanCommitURL(int child_id,
   }
 }
 
bool ChildProcessSecurityPolicyImpl::CanCommitURL(int child_id,
                                                  const GURL& url) {
  return CanCommitURL(child_id, url, true  );
}

 bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
  bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
 
    
    
   
   
   
   
   
  if (CanCommitURL(child_id, url, false  ))
     return true;
 
    ",Incorrect handling of blob URLS in Site Isolation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker who had compromised the renderer process to bypass site isolation protections via a crafted HTML page.
3074,CVE-2018-18346," 
 #include ""base/metrics/histogram_macros.h""
 #include ""base/pickle.h""
 #include ""base/strings/stringprintf.h""
#include ""base/trace_event/trace_event.h""
 #include ""components/sync/base/time.h""
 #include ""components/sync/device_info/device_info.h""
 #include ""components/sync/device_info/device_info_util.h""
  class FactoryImpl : public base::SupportsWeakPtr<FactoryImpl> {
       std::unique_ptr<ModelTypeStore::RecordList> record_list,
       const base::Optional<syncer::ModelError>& error,
       std::unique_ptr<syncer::MetadataBatch> metadata_batch) {
     
    TRACE_EVENT0(""browser"", ""FactoryImpl::OnReadAllMetadata"");
     if (error) {
       std::move(callback).Run(error,  nullptr,
                                nullptr);",Incorrect handling of alert box display in Blink in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to present confusing browser UI via a crafted HTML page.
3075,CVE-2018-18347,"  IN_PROC_BROWSER_TEST_F(ChromeNavigationPortMappedBrowserTest,
   EXPECT_EQ(GURL(), new_web_contents->GetLastCommittedURL());
 }
 
 
 
 
IN_PROC_BROWSER_TEST_F(ChromeNavigationBrowserTest,
                       ClearInvalidPendingURLOnFail) {
  GURL initial_url = embedded_test_server()->GetURL(
      ""/frame_tree/invalid_link_to_new_window.html"");

   
  ui_test_utils::NavigateToURL(browser(), initial_url);
  content::WebContents* main_contents =
      browser()->tab_strip_model()->GetActiveWebContents();

   
  content::WebContentsAddedObserver new_tab_observer;
  EXPECT_TRUE(ExecuteScript(main_contents, ""simulateClick()""));
  content::WebContents* new_contents = new_tab_observer.GetWebContents();

   
  EXPECT_FALSE(WaitForLoadStop(new_contents));

   
  EXPECT_EQ(nullptr, new_contents->GetController().GetPendingEntry());
  EXPECT_EQ(GURL(), new_contents->GetVisibleURL());
}

  
  
  ",Incorrect handling of failed navigations with invalid URLs in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to trick a user into executing javascript in an arbitrary origin via a crafted HTML page.
3076,CVE-2018-18349," 
 #include ""content/browser/dom_storage/session_storage_namespace_impl.h""
 #include ""content/browser/frame_host/navigator.h""
 #include ""content/browser/frame_host/render_frame_host_impl.h""
#include ""content/browser/frame_host/render_frame_proxy_host.h""
 #include ""content/browser/renderer_host/render_process_host_impl.h""
 #include ""content/browser/renderer_host/render_view_host_factory.h""
 #include ""content/browser/renderer_host/render_view_host_impl.h""
  IN_PROC_BROWSER_TEST_F(SecurityExploitBrowserTest,
       << "" body="" << body;
 }
 
 
 
IN_PROC_BROWSER_TEST_F(SecurityExploitBrowserTest,
                       BlockIllegalOpenURLFromRemoteFrame) {
   
   
  if (!AreAllSitesIsolatedForTesting())
    return;

  GURL main_url(embedded_test_server()->GetURL(
      ""a.com"", ""/cross_site_iframe_factory.html?a(b)""));
  EXPECT_TRUE(NavigateToURL(shell(), main_url));
  FrameTreeNode* root = static_cast<WebContentsImpl*>(shell()->web_contents())
                            ->GetFrameTree()
                            ->root();
  FrameTreeNode* child = root->child_at(0);

   
   
  GURL file_url(""file:///"");
  FrameHostMsg_OpenURL_Params params;
  params.url = file_url;
  params.uses_post = false;
  params.disposition = WindowOpenDisposition::CURRENT_TAB;
  params.should_replace_current_entry = false;
  params.user_gesture = true;
  params.is_history_navigation_in_new_child = false;

  SiteInstance* a_com_instance = root->current_frame_host()->GetSiteInstance();
  RenderFrameProxyHost* proxy =
      child->render_manager()->GetRenderFrameProxyHost(a_com_instance);
  EXPECT_TRUE(proxy);

  {
    FrameHostMsg_OpenURL msg(proxy->GetRoutingID(), params);
    IPC::IpcSecurityTestUtil::PwnMessageReceived(
        proxy->GetProcess()->GetChannel(), msg);
  }

   
   
   
   
   
  EXPECT_TRUE(WaitForLoadStop(shell()->web_contents()));
  EXPECT_EQ(GURL(url::kAboutBlankURL),
            child->current_frame_host()->GetLastCommittedURL());

   
   
  EXPECT_TRUE(NavigateToURL(shell(), main_url));
  child = root->child_at(0);
  proxy = child->render_manager()->GetRenderFrameProxyHost(a_com_instance);
  EXPECT_TRUE(proxy);

  GURL chrome_url(std::string(kChromeUIScheme) + ""://"" +
                  std::string(kChromeUIGpuHost));
  params.url = chrome_url;
  {
    FrameHostMsg_OpenURL msg(proxy->GetRoutingID(), params);
    IPC::IpcSecurityTestUtil::PwnMessageReceived(
        proxy->GetProcess()->GetChannel(), msg);
  }
  EXPECT_TRUE(WaitForLoadStop(shell()->web_contents()));
  EXPECT_EQ(GURL(url::kAboutBlankURL),
            child->current_frame_host()->GetLastCommittedURL());
}

 }   ",Remote frame navigations was incorrectly permitted to local resources in Blink in Google Chrome prior to 71.0.3578.80 allowed an attacker who convinced a user to install a malicious extension to access files on the local file system via a crafted Chrome Extension.
3077,CVE-2018-18351,"  void NavigationRequest::OnStartChecksComplete(
       !base_url.is_empty()
           ? base_url
           : frame_tree_node_->frame_tree()->root()->current_url();

   
   
   
    
   
   
  const FrameTreeNode* current = frame_tree_node_->parent();
  bool ancestors_are_same_site = true;
  while (current && ancestors_are_same_site) {
    if (!net::registry_controlled_domains::SameDomainOrHost(
            top_document_url, current->current_url(),
            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
      ancestors_are_same_site = false;
    }
    current = current->parent();
  }
   const GURL& site_for_cookies =
      ancestors_are_same_site
          ? (frame_tree_node_->IsMainFrame() ? common_params_.url
                                             : top_document_url)
          : GURL::EmptyGURL();
   bool parent_is_main_frame = !frame_tree_node_->parent()
? false:frame_tree_node_->parent()->IsMainFrame();",Lack of proper validation of ancestor frames site when sending lax cookies in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass SameSite cookie policy via a crafted HTML page.
3078,CVE-2018-18352," void WebMediaPlayerMS::Paint(cc::PaintCanvas* canvas,context_3d, context_support);}
bool WebMediaPlayerMS::WouldTaintOrigin() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return false;
 }
 
 double WebMediaPlayerMS::MediaTimeForTimeValue(double timeValue) const {
   return base::TimeDelta::FromSecondsD(timeValue).InSecondsF();
 }",Service works could inappropriately gain access to cross origin audio in Media in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to bypass same origin policy for audio content via a crafted HTML page.
3079,CVE-2018-18354,"  void MigrateTaskbarPinsCallback() {
   win::MigrateShortcutsInPathInternal(chrome_exe, pins_path);
 }
 
 
 
 
bool IsValidCustomProtocol(const base::string16& scheme) {
  if (scheme.empty())
    return false;
  base::win::RegKey cmd_key(HKEY_CLASSES_ROOT, scheme.c_str(), KEY_QUERY_VALUE);
  return cmd_key.Valid() && cmd_key.HasValue(L""URL Protocol"");
}

  
  
  
 base::string16 GetAppForProtocolUsingAssocQuery(const GURL& url) {
  const base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());
  if (!IsValidCustomProtocol(url_scheme))
     return base::string16();
 
    
  base::string16 GetAppForProtocolUsingAssocQuery(const GURL& url) {
    
   wchar_t out_buffer[1024];
   DWORD buffer_size = arraysize(out_buffer);
  HRESULT hr =
      AssocQueryString(ASSOCF_IS_PROTOCOL, ASSOCSTR_FRIENDLYAPPNAME,
                       url_scheme.c_str(), NULL, out_buffer, &buffer_size);
   if (FAILED(hr)) {
     DLOG(WARNING) << ""AssocQueryString failed!"";
     return base::string16();
  base::string16 GetAppForProtocolUsingAssocQuery(const GURL& url) {
 }
 
 base::string16 GetAppForProtocolUsingRegistry(const GURL& url) {
  const base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());
  if (!IsValidCustomProtocol(url_scheme))
    return base::string16();
 
    
  base::string16 command_to_launch;
  base::win::RegKey cmd_key_name(HKEY_CLASSES_ROOT, url_scheme.c_str(),KEY_READ);
   if (cmd_key_name.ReadValue(NULL, &command_to_launch) == ERROR_SUCCESS &&
       !command_to_launch.empty()) {
  base::string16 GetAppForProtocolUsingRegistry(const GURL& url) {
 
    
    
  const base::string16 cmd_key_path = url_scheme + L""\\shell\\open\\command"";
   base::win::RegKey cmd_key_exe(HKEY_CLASSES_ROOT, cmd_key_path.c_str(),KEY_READ);
   if (cmd_key_exe.ReadValue(NULL, &command_to_launch) == ERROR_SUCCESS) {
  bool IsElevationNeededForSettingDefaultProtocolClient() {
 }
 
 base::string16 GetApplicationNameForProtocol(const GURL& url) {
    
   if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
    base::string16 application_name = GetAppForProtocolUsingAssocQuery(url);
     if (!application_name.empty())
       return application_name;
   }",Insufficient validate of external protocols in Shell Integration in Google Chrome on Windows prior to 71.0.3578.80 allowed a remote attacker to launch external programs via a crafted HTML page.
3080,CVE-2018-18355,"  void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {
    
   allowed_set.remove(0x2bbu);   
   allowed_set.remove(0x2bcu);   

   
  allowed_set.remove(0x2ecu);

    
    
 ",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3081,CVE-2018-18357,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
  IDNSpoofChecker::IDNSpoofChecker() {
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
           ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3; [] > u""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3082,CVE-2018-18358,"  class ProxyBrowserTest : public InProcessBrowserTest {
   void SetUpCommandLine(base::CommandLine* command_line) override {
     command_line->AppendSwitchASCII(switches::kProxyServer,
                                     proxy_server_.host_port_pair().ToString());

     
     
    command_line->AppendSwitchASCII(
        switches::kProxyBypassList,
        net::ProxyBypassRules::GetRulesToSubtractImplicit());
   }
 
  protected:",Lack of special casing of localhost in WPAD files in Google Chrome prior to 71.0.3578.80 allowed an attacker on the local network segment to proxy resources on localhost via a crafted WPAD file.
3083,CVE-2018-20065," 
 #include ""chrome/browser/extensions/extension_function_test_utils.h""
 #include ""chrome/browser/extensions/extension_tab_util.h""
 #include ""chrome/browser/extensions/window_controller.h""
#include ""chrome/browser/pdf/pdf_extension_test_util.h""
 #include ""chrome/browser/prefs/incognito_mode_prefs.h""
 #include ""chrome/browser/profiles/profile.h""
 #include ""chrome/browser/resource_coordinator/tab_lifecycle_unit_external.h""
  IN_PROC_BROWSER_TEST_F(ExtensionApiTest, MAYBE_TemporaryAddressSpoof) {
   ui_test_utils::NavigateToURLWithDisposition(
       browser(), url, WindowOpenDisposition::CURRENT_TAB,
       ui_test_utils::BROWSER_TEST_WAIT_FOR_NAVIGATION);

  bool load_success =
      pdf_extension_test_util::EnsurePDFHasLoaded(second_web_contents);
  EXPECT_TRUE(load_success);

   
   
   
  content::SimulateMouseClickAt(second_web_contents, 0,
                                blink::WebMouseEvent::Button::kLeft,
                                gfx::Point(400, 400));

   EXPECT_TRUE(navigation_manager.WaitForRequestStart());
 
   browser()->tab_strip_model()->ActivateTabAt(0, true);",Handling of URI action in PDFium in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to initiate potentially unsafe navigations without a user gesture via a crafted PDF file.
3084,CVE-2018-20066,"  InputImeEventRouterFactory::~InputImeEventRouterFactory() {
 InputImeEventRouter* InputImeEventRouterFactory::GetRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   
   
  profile = profile->GetOriginalProfile();
   InputImeEventRouter* router = router_map_[profile];
   if (!router) {
     
     
     
     
    router = new InputImeEventRouter(profile->HasOffTheRecordProfile()
                                         ? profile->GetOffTheRecordProfile()
                                         : profile);
     router_map_[profile] = router;
   }
   return router;
  InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile);
 }
 
 }   ",Incorrect object lifecycle in Extensions in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3085,CVE-2018-20067,"  TEST_F(NavigationControllerTest, HistoryNavigate) {
   process()->sink().ClearMessages();
 
    
  contents()->OnGoToEntryAtOffset(test_rvh(), -1, false);
   EXPECT_EQ(0, controller.GetPendingEntryIndex());
 
    
  TEST_F(NavigationControllerTest, HistoryNavigate) {
   process()->sink().ClearMessages();
 
    
  contents()->OnGoToEntryAtOffset(test_rvh(), 2, false);
   EXPECT_EQ(2, controller.GetPendingEntryIndex());
 
   nav_url = GetLastNavigationURL();
  TEST_F(NavigationControllerTest, HistoryNavigate) {
   controller.DiscardNonCommittedEntries();
 
    
  contents()->OnGoToEntryAtOffset(test_rvh(), 120, false);   
   EXPECT_EQ(-1, controller.GetPendingEntryIndex());
   EXPECT_FALSE(HasNavigationRequest());
 }",A renderer initiated back navigation was incorrectly allowed to cancel a browser initiated one in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to confuse the user about the origin of the current page via a crafted HTML page.
3086,CVE-2018-20068,"  IN_PROC_BROWSER_TEST_F(NavigationControllerBrowserTest,
   EXPECT_EQ(0, controller.GetCurrentEntryIndex());
 }
 
 
IN_PROC_BROWSER_TEST_F(NavigationControllerBrowserTest, NavigateTo304) {
   
  GURL initial_url = embedded_test_server()->GetURL(""/set-header"");
   
  GURL not_modified_url = embedded_test_server()->GetURL(""/echo?status=304"");

  EXPECT_TRUE(NavigateToURL(shell(), initial_url));
  EXPECT_EQ(initial_url, shell()->web_contents()->GetVisibleURL());

   
  EXPECT_FALSE(NavigateToURL(shell(), not_modified_url));
  EXPECT_EQ(initial_url, shell()->web_contents()->GetVisibleURL());
}

  
  
 IN_PROC_BROWSER_TEST_F(NavigationControllerBrowserTest,",Incorrect handling of 304 status codes in Navigation in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to confuse the user about the origin of the current page via a crafted HTML page.
3087,CVE-2018-20070,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
  IDNSpoofChecker::IDNSpoofChecker() {
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
           ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3; [] > u""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3088,CVE-2018-20071," 
 #include ""content/public/browser/permission_type.h""
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/common/console_message_level.h""
#include ""net/base/registry_controlled_domains/registry_controlled_domain.h""
 #include ""third_party/blink/public/common/manifest/manifest.h""
 #include ""third_party/blink/public/common/manifest/manifest_icon_selector.h""
 #include ""ui/gfx/geometry/size.h""
  void InstallablePaymentAppCrawler::OnPaymentMethodManifestParsed(
       continue;
     }
 
    if (!net::registry_controlled_domains::SameDomainOrHost(
            method_manifest_url, url,
            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
      WarnIfPossible(""Installable payment app from "" + url.spec() +
                     "" is not allowed for the method "" +
                     method_manifest_url.spec());
      continue;
    }

     if (permission_manager->GetPermissionStatus(
             content::PermissionType::PAYMENT_HANDLER, url.GetOrigin(),
             url.GetOrigin()) != blink::mojom::PermissionStatus::GRANTED) {
  bool InstallablePaymentAppCrawler::CompleteAndStorePaymentWebAppInfoIfValid(
           app_info->sw_js_url + "")."");
       return false;
     }
    if (!net::registry_controlled_domains::SameDomainOrHost(
            method_manifest_url, absolute_url,
            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
      WarnIfPossible(""Installable payment app's js url "" + absolute_url.spec() +
                     "" is not allowed for the method "" +
                     method_manifest_url.spec());
      return false;
    }
     app_info->sw_js_url = absolute_url.spec();
   }
 
  bool InstallablePaymentAppCrawler::CompleteAndStorePaymentWebAppInfoIfValid(
           app_info->sw_scope + "")."");
       return false;
     }
    if (!net::registry_controlled_domains::SameDomainOrHost(
            method_manifest_url, absolute_scope,
            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
      WarnIfPossible(""Installable payment app's registration scope "" +
                     absolute_scope.spec() + "" is not allowed for the method "" +
                     method_manifest_url.spec());
      return false;
    }
     app_info->sw_scope = absolute_scope.spec();
   }
 ",Insufficiently strict origin checks during JIT payment app installation in Payments in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to install a service worker for a domain that can host attacker controled files via a crafted HTML page.
3089,CVE-2018-17462,"  void AppCacheGroup::AddCache(AppCache* complete_cache) {
 void AppCacheGroup::RemoveCache(AppCache* cache) {
   DCHECK(cache->associated_hosts().empty());
   if (cache == newest_complete_cache_) {
     AppCache* tmp_cache = newest_complete_cache_;
     newest_complete_cache_ = nullptr;
    CancelUpdate();
     tmp_cache->set_owning_group(nullptr);   
   } else {
     scoped_refptr<AppCacheGroup> protect(this);",Incorrect refcounting in AppCache in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to perform a sandbox escape via a crafted HTML page.
3090,CVE-2018-17467,"  void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {
      
      
     visual_properties_ack_pending_ = false;
     if (view_)
       view_->DidNavigate();
   } else {
      
      ",Insufficiently quick clearing of stale rendered content in Navigation in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3091,CVE-2018-17470,"  void GLES2DecoderImpl::GetTexParameterImpl(
         return;
       }
       break;
     case GL_TEXTURE_BASE_LEVEL:
       
       
      if (fparams) {
        fparams[0] = static_cast<GLfloat>(texture->unclamped_base_level());
      } else {
        iparams[0] = texture->unclamped_base_level();
       }
      return;
     case GL_TEXTURE_MAX_LEVEL:
       
       
      if (fparams) {
        fparams[0] = static_cast<GLfloat>(texture->unclamped_max_level());
      } else {
        iparams[0] = texture->unclamped_max_level();
       }
      return;
     case GL_TEXTURE_SWIZZLE_R:
       if (fparams) {
         fparams[0] = static_cast<GLfloat>(texture->swizzle_r());
  void GLES2DecoderImpl::TexStorageImpl(GLenum target,
     compatibility_internal_format = format_info->decompressed_internal_format;
   }
 
   {
     GLsizei level_width = width;
     GLsizei level_height = height;
  void GLES2DecoderImpl::TexStorageImpl(GLenum target,
     texture->ApplyFormatWorkarounds(feature_info_.get());
     texture->SetImmutable(true);
   }

  if (workarounds().reset_base_mipmap_level_before_texstorage &&
      texture->base_level() > 0)
    api()->glTexParameteriFn(target, GL_TEXTURE_BASE_LEVEL, 0);

   
   
   
  if (dimension == ContextState::k2D) {
    api()->glTexStorage2DEXTFn(target, levels, compatibility_internal_format,
                               width, height);
  } else {
    api()->glTexStorage3DFn(target, levels, compatibility_internal_format,
                            width, height, depth);
  }
  if (workarounds().reset_base_mipmap_level_before_texstorage &&
      texture->base_level() > 0) {
     
     
     
    api()->glTexParameteriFn(target, GL_TEXTURE_BASE_LEVEL,
                             texture->base_level());
  }
 }
 
 void GLES2DecoderImpl::DoTexStorage2DEXT(GLenum target,",A heap buffer overflow in GPU in Google Chrome prior to 70.0.3538.67 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.
3092,CVE-2018-17471,"  void WebContentsImpl::CreateNewWindow(
 
    
    
  ForSecurityDropFullscreen();
 
   if (params.opener_suppressed) {
      
  void WebContentsImpl::ViewSource(RenderFrameHostImpl* frame) {
 
    
    
  ForSecurityDropFullscreen();
 
    
    
  void WebContentsImpl::RunJavaScriptDialog(RenderFrameHost* render_frame_host,
 
    
    
  ForSecurityDropFullscreen();
 
   auto callback =
       base::BindOnce(&WebContentsImpl::OnDialogClosed, base::Unretained(this),
  void WebContentsImpl::RunBeforeUnloadConfirm(
 
    
    
  ForSecurityDropFullscreen();
 
   RenderFrameHostImpl* rfhi =
       static_cast<RenderFrameHostImpl*>(render_frame_host);
  void WebContentsImpl::EnsureOpenerProxiesExist(RenderFrameHost* source_rfh) {
   }
 }
 
void WebContentsImpl::ForSecurityDropFullscreen() {
  WebContentsImpl* web_contents = this;
  while (web_contents) {
    if (web_contents->IsFullscreenForCurrentTab())
      web_contents->ExitFullscreen(true);
    web_contents = web_contents->GetOuterWebContents();
  }
}

 void WebContentsImpl::SetAsFocusedWebContentsIfNecessary() {
    
   WebContentsImpl* old_contents = GetFocusedWebContents();
  void WebContentsImpl::SetFocusedFrame(FrameTreeNode* node,
 void WebContentsImpl::DidCallFocus() {
    
    
  ForSecurityDropFullscreen();
 }
 
 RenderFrameHost* WebContentsImpl::GetFocusedFrameIncludingInnerWebContents() {",Incorrect dialog placement in WebContents in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to obscure the full screen warning via a crafted HTML page.
3093,CVE-2018-17473,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(
           ""[] > ae; [] > p; [] > h;""
          ""[] > k; [] > n;  > ce;""
           ""[] > t; [] > b;  [] > w;""
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""",Incorrect handling of confusable characters in Omnibox in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3094,CVE-2018-17474,"  HTMLImportsController::HTMLImportsController(Document& master)
     : root_(HTMLImportTreeRoot::Create(&master)) {}
 
 void HTMLImportsController::Dispose() {
   
   
   
   
  LoaderList list;
  list.swap(loaders_);
  for (const auto& loader : list) {
    if (loader)
      loader->Dispose();
  }
 
   if (root_) {
     root_->Dispose();",Use after free in HTMLImportsController in Blink in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3095,CVE-2018-17476,"  void Browser::SetWebContentsBlocked(content::WebContents* web_contents,
      
     return;
   }

   
   
   
  if (web_contents->IsFullscreenForCurrentTab())
    web_contents->ExitFullscreen(true);

   tab_strip_model_->SetTabBlocked(index, blocked);
 
   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;",Incorrect dialog placement in Cast UI in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to obscure the full screen warning via a crafted HTML page.
3096,CVE-2018-6031,"  bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {
 
   DCHECK(defer_page_unload_);
   defer_page_unload_ = false;

   
   
   
  std::vector<int> pages_to_unload;
  std::swap(pages_to_unload, deferred_page_unloads_);
  for (int page_index : pages_to_unload)
     pages_[page_index]->Unload();

   return rv;
 }
 ",Use after free in PDFium in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file.
3097,CVE-2018-6032," 
 
 BrowsingDataSharedWorkerHelper::SharedWorkerInfo::SharedWorkerInfo(
     const GURL& worker,
    const std::string& name,
    const url::Origin& constructor_origin)
    : worker(worker), name(name), constructor_origin(constructor_origin) {}
 
 BrowsingDataSharedWorkerHelper::SharedWorkerInfo::SharedWorkerInfo(
     const SharedWorkerInfo& other) = default;
  BrowsingDataSharedWorkerHelper::SharedWorkerInfo::~SharedWorkerInfo() = default;
 
 bool BrowsingDataSharedWorkerHelper::SharedWorkerInfo::operator<(
     const SharedWorkerInfo& other) const {
  return std::tie(worker, name, constructor_origin) <
         std::tie(other.worker, other.name, other.constructor_origin);
 }
 
 BrowsingDataSharedWorkerHelper::BrowsingDataSharedWorkerHelper(
  void BrowsingDataSharedWorkerHelper::StartFetching(FetchCallback callback) {
 }
 void BrowsingDataSharedWorkerHelper::DeleteSharedWorker(
     const GURL& worker,
    const std::string& name,
    const url::Origin& constructor_origin) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   content::SharedWorkerService::GetInstance()->TerminateWorker(
      worker, name, constructor_origin, storage_partition_, resource_context_);
 }
 
 CannedBrowsingDataSharedWorkerHelper::CannedBrowsingDataSharedWorkerHelper(
  CannedBrowsingDataSharedWorkerHelper::~CannedBrowsingDataSharedWorkerHelper() =
 
 void CannedBrowsingDataSharedWorkerHelper::AddSharedWorker(
     const GURL& worker,
    const std::string& name,
    const url::Origin& constructor_origin) {
   if (!BrowsingDataHelper::HasWebScheme(worker))
     return;   
 
  pending_shared_worker_info_.insert(
      SharedWorkerInfo(worker, name, constructor_origin));
 }
 
 void CannedBrowsingDataSharedWorkerHelper::Reset() {
  void CannedBrowsingDataSharedWorkerHelper::StartFetching(
 
 void CannedBrowsingDataSharedWorkerHelper::DeleteSharedWorker(
     const GURL& worker,
    const std::string& name,
    const url::Origin& constructor_origin) {
   for (auto it = pending_shared_worker_info_.begin();
        it != pending_shared_worker_info_.end();) {
    if (it->worker == worker && it->name == name &&
        it->constructor_origin == constructor_origin) {
      BrowsingDataSharedWorkerHelper::DeleteSharedWorker(
          it->worker, it->name, it->constructor_origin);
       it = pending_shared_worker_info_.erase(it);
     } else {
       ++it;",Insufficient policy enforcement in Blink in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially leak user cross-origin data via a crafted HTML page.
3098,CVE-2018-6033,"  void ChromeDownloadManagerDelegate::OpenDownload(DownloadItem* download) {
 #endif
 }
 
bool ChromeDownloadManagerDelegate::IsMostRecentDownloadItemAtFilePath(
    DownloadItem* download) {
  Profile* profile = Profile::FromBrowserContext(download->GetBrowserContext());
  std::vector<Profile*> profiles_to_check = {profile->GetOriginalProfile()};
  if (profile->HasOffTheRecordProfile()) {
    profiles_to_check.push_back(profile->GetOffTheRecordProfile());
  }

  std::vector<DownloadItem*> all_downloads;
  for (auto* profile : profiles_to_check) {
    content::DownloadManager* manager =
        content::BrowserContext::GetDownloadManager(profile);
    if (manager)
      manager->GetAllDownloads(&all_downloads);
  }

  for (const auto* item : all_downloads) {
    if (item->GetGuid() == download->GetGuid() ||
        item->GetTargetFilePath() != download->GetTargetFilePath())
      continue;

    if (item->GetState() == DownloadItem::IN_PROGRESS)
      return false;
  }

  return true;
}

 void ChromeDownloadManagerDelegate::ShowDownloadInShell(
     DownloadItem* download) {
   if (!download->CanShowInFolder())",Insufficient data validation in Downloads in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially run arbitrary code outside sandbox via a crafted Chrome Extension.
3099,CVE-2018-6034,"  void WebGLRenderingContextBase::TexImageImpl(
   Vector<uint8_t> data;
 
   IntRect sub_rect = source_image_rect;
  if (sub_rect.IsValid() && sub_rect == SentinelEmptyRect()) {
      
     sub_rect = SafeGetImageSize(image);
   }
  void WebGLRenderingContextBase::TexImageHelperHTMLVideoElement(
     frame_metadata_ptr = &frame_metadata;
   }
 
  if (!source_image_rect.IsValid()) {
    SynthesizeGLError(GL_INVALID_OPERATION, func_name,
                      ""source sub-rectangle specified via pixel unpack ""
                      ""parameters is invalid"");
    return;
  }
   bool source_image_rect_is_default =
       source_image_rect == SentinelEmptyRect() ||
       source_image_rect ==",Insufficient data validation in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
3100,CVE-2018-6035," 
 #include ""chrome/browser/guest_view/web_view/chrome_web_view_guest_delegate.h""
 #include ""chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h""
 #include ""chrome/browser/ui/pdf/chrome_pdf_web_contents_helper_client.h""
#include ""chrome/browser/ui/webui/devtools_ui.h""
 #include ""components/pdf/browser/pdf_web_contents_helper.h""
 #include ""components/signin/core/browser/signin_header_helper.h""
 #include ""content/public/browser/browser_context.h""
  bool ChromeExtensionsAPIClient::ShouldHideResponseHeader(
                                          signin::kDiceResponseHeader) == 0));
 }
 
bool ChromeExtensionsAPIClient::ShouldHideBrowserNetworkRequest(
    const GURL& url) const {
  return DevToolsUI::IsFrontendResourceURL(url);
}

 AppViewGuestDelegate* ChromeExtensionsAPIClient::CreateAppViewGuestDelegate()
     const {
   return new ChromeAppViewGuestDelegate();",Insufficient policy enforcement in DevTools in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially leak user local file data via a crafted Chrome Extension.
3101,CVE-2018-6038,"  void WebGL2RenderingContextBase::texImage2D(GLenum target,
                       ""no bound PIXEL_UNPACK_BUFFER"");
     return;
   }
  if (unpack_flip_y_ || unpack_premultiply_alpha_) {
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texImage2D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO"");
    return;
  }
   if (!ValidateTexFunc(""texImage2D"", kTexImage, kSourceUnpackBuffer, target,
                        level, internalformat, width, height, 1, border, format,
                        type, 0, 0, 0))
  void WebGL2RenderingContextBase::texSubImage2D(GLenum target,
                       ""no bound PIXEL_UNPACK_BUFFER"");
     return;
   }
  if (unpack_flip_y_ || unpack_premultiply_alpha_) {
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texSubImage2D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO"");
    return;
  }
   if (!ValidateTexFunc(""texSubImage2D"", kTexSubImage, kSourceUnpackBuffer,
                        target, level, 0, width, height, 1, 0, format, type,
                        xoffset, yoffset, 0))
  void WebGL2RenderingContextBase::texImage3D(
     GLenum format,
     GLenum type,
     MaybeShared<DOMArrayBufferView> pixels) {
  if ((unpack_flip_y_ || unpack_premultiply_alpha_) && pixels) {
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texImage3D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
    return;
  }
   TexImageHelperDOMArrayBufferView(kTexImage3D, target, level, internalformat,
                                    width, height, depth, border, format, type,
                                    0, 0, 0, pixels.View(), kNullAllowed, 0);
  void WebGL2RenderingContextBase::texImage3D(
                       ""a buffer is bound to PIXEL_UNPACK_BUFFER"");
     return;
   }
  if (unpack_flip_y_ || unpack_premultiply_alpha_) {
    DCHECK(pixels);
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texImage3D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
    return;
  }
   TexImageHelperDOMArrayBufferView(
       kTexImage3D, target, level, internalformat, width, height, depth, border,
       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);
  void WebGL2RenderingContextBase::texImage3D(GLenum target,
                       ""no bound PIXEL_UNPACK_BUFFER"");
     return;
   }
  if (unpack_flip_y_ || unpack_premultiply_alpha_) {
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texImage3D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
    return;
  }
   if (!ValidateTexFunc(""texImage3D"", kTexImage, kSourceUnpackBuffer, target,
                        level, internalformat, width, height, depth, border,
                        format, type, 0, 0, 0))
  void WebGL2RenderingContextBase::texSubImage3D(
                       ""a buffer is bound to PIXEL_UNPACK_BUFFER"");
     return;
   }
  if (unpack_flip_y_ || unpack_premultiply_alpha_) {
    DCHECK(pixels);
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texSubImage3D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
    return;
  }

   TexImageHelperDOMArrayBufferView(
       kTexSubImage3D, target, level, 0, width, height, depth, 0, format, type,
       xoffset, yoffset, zoffset, pixels.View(), kNullNotReachable, src_offset);
  void WebGL2RenderingContextBase::texSubImage3D(GLenum target,
                       ""no bound PIXEL_UNPACK_BUFFER"");
     return;
   }
  if (unpack_flip_y_ || unpack_premultiply_alpha_) {
    SynthesizeGLError(
        GL_INVALID_OPERATION, ""texSubImage3D"",
        ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
    return;
  }
   if (!ValidateTexFunc(""texSubImage3D"", kTexSubImage, kSourceUnpackBuffer,
                        target, level, 0, width, height, depth, 0, format, type,
                        xoffset, yoffset, zoffset))",Heap buffer overflow in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
3102,CVE-2018-6041,"  RenderFrameHostImpl* RenderFrameHostManager::GetFrameHostForNavigation(
     if (speculative_render_frame_host_) {
        
        
       
       
       
       
      if (speculative_render_frame_host_->navigation_handle() &&
          request.from_begin_navigation()) {
         frame_tree_node_->navigator()->DiscardPendingEntryIfNeeded(
             speculative_render_frame_host_->navigation_handle()
                 ->pending_nav_entry_id());",Incorrect security UI in navigation in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3103,CVE-2018-6042,"  IDNSpoofChecker::IDNSpoofChecker() {
 
    
    
   
    
   UParseError parse_error;
  diacritic_remover_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""DropAcc""),
       icu::UnicodeString(""::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;""
                         ""  > l;  > o;  > d;""),
      UTRANS_FORWARD, parse_error, status));

   
   
   
   
   
   
   
   
   
   
   
  extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
      UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString(
          "" > l; [] > k;  > n; [] > b;  > b;  > m;  > h; ""
          "" > t; [] > w;  > s;""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: ""
  bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {
    
   if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==
       ustr_host.length())
    diacritic_remover_.get()->transliterate(ustr_host);
  extra_confusable_mapper_.get()->transliterate(ustr_host);
 
   UErrorCode status = U_ZERO_ERROR;
   icu::UnicodeString ustr_skeleton;
  bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {
   if (U_FAILURE(status))
     return false;
   std::string skeleton;
  return LookupMatchInTopDomains(ustr_skeleton.toUTF8String(skeleton));
 }
 
 bool IDNSpoofChecker::IsMadeOfLatinAlikeCyrillic(",Incorrect security UI in Omnibox in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3104,CVE-2018-6043,"  void ExternalProtocolHandler::LaunchUrlWithDelegate(
 
    
    
   
   
   
   
   std::string escaped_url_string = net::EscapeExternalHandlerValue(url.spec());
   GURL escaped_url(escaped_url_string);
 
  void ExternalProtocolHandler::LaunchUrlWithDelegate(
    
    
   shell_integration::DefaultWebClientWorkerCallback callback = base::Bind(
      &OnDefaultProtocolClientWorkerFinished, escaped_url,
      render_process_host_id, render_view_routing_id, block_state == UNKNOWN,
      page_transition, has_user_gesture, delegate);
 
    
    ",Insufficient data validation in External Protocol Handler in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially execute arbitrary programs on user machine via a crafted HTML page.
3105,CVE-2018-6045," 
 #include ""chrome/browser/guest_view/web_view/chrome_web_view_guest_delegate.h""
 #include ""chrome/browser/guest_view/web_view/chrome_web_view_permission_helper_delegate.h""
 #include ""chrome/browser/ui/pdf/chrome_pdf_web_contents_helper_client.h""
#include ""chrome/browser/ui/webui/devtools_ui.h""
 #include ""components/pdf/browser/pdf_web_contents_helper.h""
 #include ""components/signin/core/browser/signin_header_helper.h""
 #include ""content/public/browser/browser_context.h""
  bool ChromeExtensionsAPIClient::ShouldHideResponseHeader(
                                          signin::kDiceResponseHeader) == 0));
 }
 
bool ChromeExtensionsAPIClient::ShouldHideBrowserNetworkRequest(
    const GURL& url) const {
  return DevToolsUI::IsFrontendResourceURL(url);
}

 AppViewGuestDelegate* ChromeExtensionsAPIClient::CreateAppViewGuestDelegate()
     const {
   return new ChromeAppViewGuestDelegate();",Insufficient policy enforcement in DevTools in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially leak user local file data via a crafted Chrome Extension.
3106,CVE-2018-6046,"  GURL SanitizeFrontendURL(const GURL& url,
             base::StringPrintf(""%s=%s"", it.GetKey().c_str(), value.c_str()));
       }
     }
    if (url.has_ref() && url.ref_piece().find('\'') == base::StringPiece::npos)
       fragment = '#' + url.ref();
   }
   std::string query =",Insufficient data validation in DevTools in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially leak user cross-origin data via a crafted Chrome Extension.
3107,CVE-2018-6049," 
 #include ""chrome/browser/ui/views/permission_bubble/permission_prompt_impl.h""
 
 #include <stddef.h>
#include <memory>
#include <utility>
 
 #include ""base/strings/string16.h""
 #include ""build/build_config.h""
  class PermissionsBubbleDialogDelegateView
   bool Cancel() override;
   bool Accept() override;
   bool Close() override;
  void AddedToWidget() override;
   int GetDefaultDialogButton() const override;
   int GetDialogButtons() const override;
   base::string16 GetDialogButtonLabel(ui::DialogButton button) const override;
  void PermissionsBubbleDialogDelegateView::CloseBubble() {
   GetWidget()->Close();
 }
 
void PermissionsBubbleDialogDelegateView::AddedToWidget() {
  std::unique_ptr<views::Label> title =
      views::BubbleFrameView::CreateDefaultTitleLabel(GetWindowTitle());

   
   
   
   
   
   
   
  title->SetElideBehavior(gfx::ELIDE_HEAD);

   
   
  title->SetMultiLine(false);
  GetBubbleFrameView()->SetTitleView(std::move(title));
}

 ui::AXRole PermissionsBubbleDialogDelegateView::GetAccessibleWindowRole()
     const {
   return ui::AX_ROLE_ALERT_DIALOG;",Incorrect security UI in permissions prompt in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to spoof the origin to which permission is granted via a crafted HTML page.
3108,CVE-2018-6050,"  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
     
      
      
     dangerous_pattern = new icu::RegexMatcher(
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""(^[\p{scx=hira}]+[\u30d8-\u30da][\p{scx=hira}]+$|)""
             R""([a-z]\u30fb|\u30fb[a-z]|)""
             R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
            R""(\u0131[\u0300-\u0339]|)""
            R""([ijl]\u0307)"",
             -1, US_INV),
         0, status);
     tls_index.Set(dangerous_pattern);",Incorrect security UI in Omnibox in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3109,CVE-2018-6053,"  void TopSitesCache::SetThumbnails(const URLToImagesMap& images) {
   images_ = images;
 }
 
void TopSitesCache::ClearUnreferencedThumbnails() {
  URLToImagesMap images_to_keep;
  for (const std::pair<GURL, Images>& entry : images_) {
    if (IsKnownURL(entry.first)) {
      images_to_keep.insert(entry);
    }
  }
  images_ = std::move(images_to_keep);
}

 Images* TopSitesCache::GetImage(const GURL& url) {
   return &images_[GetCanonicalURL(url)];
 }",Inappropriate implementation in New Tab Page in Google Chrome prior to 64.0.3282.119 allowed a local attacker to view website thumbnail images after clearing browser data via a crafted HTML page.
3110,CVE-2018-6054,"  void WebUIExtension::Send(gin::Arguments* args) {
     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(
         obj, frame->MainWorldScriptContext()));
     DCHECK(content);
     
     
     
    if (frame != blink::WebLocalFrame::FrameForCurrentContext()) {
      NOTREACHED();
      return;
    }
   }
 
    ",Use after free in WebUI in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially exploit heap corruption via a crafted Chrome Extension.
3111,CVE-2018-6085,"  TEST_F(DiskCacheBackendTest, SimpleFdLimit) {
   histogram_tester.ExpectBucketCount(""SimpleCache.FileDescriptorLimiterAction"",
                                      disk_cache::FD_LIMIT_FAIL_REOPEN_FILE, 0);
 }

TEST_F(DiskCacheBackendTest, SparseEvict) {
  const int kMaxSize = 512;

  SetMaxSize(kMaxSize);
  InitCache();

  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(64));

  disk_cache::Entry* entry0 = nullptr;
  ASSERT_THAT(CreateEntry(""http://www.0.com/"", &entry0), IsOk());

  disk_cache::Entry* entry1 = nullptr;
  ASSERT_THAT(CreateEntry(""http://www.1.com/"", &entry1), IsOk());

  disk_cache::Entry* entry2 = nullptr;
   
   
  ASSERT_THAT(CreateEntry(""http://www.15360.com/"", &entry2), IsOk());

   
  ASSERT_EQ(64, WriteSparseData(entry0, 0, buffer.get(), 64));
  ASSERT_EQ(1, WriteSparseData(entry0, 67108923, buffer.get(), 1));
  ASSERT_EQ(1, WriteSparseData(entry1, 53, buffer.get(), 1));
  ASSERT_EQ(1, WriteSparseData(entry2, 0, buffer.get(), 1));

   
   
  entry1->Close();
  entry2->Close();
  entry0->Close();
}",Re-entry of a destructor in Networking Disk Cache in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page.
3112,CVE-2018-6086,"  TEST_F(DiskCacheBackendTest, DoomAllSparse) {
   EXPECT_EQ(0, cache_->GetEntryCount());
 }
 
 
TEST_F(DiskCacheBackendTest, InMemorySparseEvict) {
  const int kMaxSize = 512;

  SetMaxSize(kMaxSize);
  SetMemoryOnlyMode();
  InitCache();

  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(64));
  CacheTestFillBuffer(buffer->data(), 64, false  );

  std::vector<disk_cache::ScopedEntryPtr> entries;

  disk_cache::Entry* entry = nullptr;
   
  for (size_t i = 0; i < 14; i++) {
    std::string name = ""http://www."" + std::to_string(i) + "".com/"";
    ASSERT_THAT(CreateEntry(name, &entry), IsOk());
    entries.push_back(disk_cache::ScopedEntryPtr(entry));
  }

   
   
  ASSERT_EQ(64, WriteSparseData(entries[0].get(), 0, buffer.get(), 64));
  ASSERT_EQ(net::ERR_FAILED,
            WriteSparseData(entries[0].get(), 10000, buffer.get(), 4));
  ASSERT_EQ(63, WriteSparseData(entries[1].get(), 0, buffer.get(), 63));
  ASSERT_EQ(64, WriteSparseData(entries[2].get(), 0, buffer.get(), 64));
  ASSERT_EQ(64, WriteSparseData(entries[3].get(), 0, buffer.get(), 64));

   
   
  entries.clear();

   
  ASSERT_THAT(CreateEntry(""http://www.14.com/"", &entry), IsOk());
  entry->Close();
}

 void DiskCacheBackendTest::BackendDoomBetween() {
   InitCache();
 ",A double-eviction in the Incognito mode cache that lead to a user-after-free in Networking Disk Cache in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page.
3113,CVE-2018-6088,"  void PDFiumEngine::DeviceToPage(int page_index,
 }
 
 int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {
   
   
  std::vector<int> visible_pages_copy(visible_pages_);
  for (int page_index : visible_pages_copy) {
     if (pages_[page_index]->GetPage() == page)
       return page_index;
   }",An iterator-invalidation bug in PDFium in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted PDF file.
3114,CVE-2018-6089,"  class ChromeServiceWorkerFetchTest : public ChromeServiceWorkerTest {
   DISALLOW_COPY_AND_ASSIGN(ChromeServiceWorkerFetchTest);
 };
 
 class ChromeServiceWorkerManifestFetchTest
     : public ChromeServiceWorkerFetchTest {
  protected:","A lack of CORS checks, after a Service Worker redirected to a cross-origin PDF, in Service Worker in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to leak limited cross-origin data via a crafted HTML page."
3115,CVE-2018-6094,"  class TraceWrapperMember : public Member<T> {
  public:
   TraceWrapperMember(void* parent, T* raw) : Member<T>(raw), m_parent(parent) {
 #if DCHECK_IS_ON()
    if (m_parent) {
      HeapObjectHeader::fromPayload(m_parent)->checkHeader();
    }
 #endif
      
      ",Inline metadata in GarbageCollection in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3116,CVE-2018-6096,"  class CONTENT_EXPORT RenderFrameHostDelegate {
    
   virtual void SetFocusedFrame(FrameTreeNode* node, SiteInstance* source) {}
 
   
  virtual void DidCallFocus() {}

    
    
    ",A JavaScript focused window could overlap the fullscreen notification in Fullscreen in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to obscure the full screen warning via a crafted HTML page.
3117,CVE-2018-6098,"  IDNSpoofChecker::IDNSpoofChecker() {
 
    
    
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(
          ""[] > ae; [] > p; [] > h;""
           ""[] > k; [] > n;  > ce;""
           ""[] > t; [] > b;  [] > w;""
           ""[] > m; [] > e;  > r; [] > f;""
  IDNSpoofChecker::~IDNSpoofChecker() {
   uspoof_close(checker_);
 }
 
bool IDNSpoofChecker::SafeToDisplayAsUnicode(
    base::StringPiece16 label,
    base::StringPiece top_level_domain) {
   UErrorCode status = U_ZERO_ERROR;
   int32_t result =
       uspoof_check(checker_, label.data(),
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
   if (deviation_characters_.containsSome(label_string))
     return false;
 
   
   
   
  if (label_string.length() > 1 && label_string.indexOf("""") != -1 &&
      top_level_domain != "".is"") {
    return false;
  }

    
    
    
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
   if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&
       kana_letters_exceptions_.containsNone(label_string) &&
       combining_diacritics_exceptions_.containsNone(label_string)) {
    bool is_tld_ascii = !top_level_domain.starts_with("".xn--"");
      
     return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);
   }",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3118,CVE-2018-6100,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
    
    
   
    
    
   
    
    
    
    
   
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                   ""[] > k; [] > n; [] > t;""
                                    ""[] > b;  [] > w; [] > m;""
                                   ""[] > e;  > r;  > f; [] > c;""
                                    "" > y; [] > x;""
 #if defined(OS_WIN)
                                    "" > i;""
 #else
                                    "" > l;""
 #endif
                                   ""  > d; [] > g;  > s;  > j""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome on macOS prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3119,CVE-2018-6101," 
 #include ""net/base/io_buffer.h""
 #include ""net/base/ip_endpoint.h""
 #include ""net/base/net_errors.h""
#include ""net/base/url_util.h""
 #include ""net/server/http_server.h""
 #include ""net/server/http_server_request_info.h""
 #include ""net/server/http_server_response_info.h""
  constexpr net::NetworkTrafficAnnotationTag
           ""Not implemented, only used in Devtools and is behind a switch.""
       })"");
 
bool RequestIsSafeToServe(const net::HttpServerRequestInfo& info) {
  // For browser-originating requests, serve only those that are coming from
  // pages loaded off localhost or fixed IPs.
  std::string header = info.headers[""host""];
  if (header.empty())
    return true;
  GURL url = GURL(""http: 
  return url.HostIsIPAddress() || net::IsLocalHostname(url.host(), nullptr);
}

 }   
 
  
  static std::string GetMimeType(const std::string& filename) {
 
 void ServerWrapper::OnHttpRequest(int connection_id,
                                   const net::HttpServerRequestInfo& info) {
  if (!RequestIsSafeToServe(info)) {
    Send500(connection_id,
            ""Host header is specified and is not an IP address or localhost."");
    return;
  }

   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);
 
   if (base::StartsWith(info.path, ""/json"", base::CompareCase::SENSITIVE)) {","A lack of host validation in DevTools in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page, if the user is running a remote DevTools debugging server."
3120,CVE-2018-6102,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
    
    
    
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                    ""[] > k; [] > n; [] > t;""
                                   ""[] > b;  [] > w; [] > m;""
                                    ""[] > e;  > r;  > f; [] > c;""
                                    "" > y; [] > x;""
 #if defined(OS_WIN)
                                    "" > i;""
 #else
                                    "" > l;""
 #endif
                                   ""  > d; [] > g; [] > s;  > j""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Missing confusable characters in Internationalization in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3121,CVE-2018-6103,"  class MediaStreamManager::DeviceRequest {
     if (!media_observer)
       return;
 
    if (stream_type == NUM_MEDIA_TYPES) {
      for (int i = MEDIA_NO_SERVICE + 1; i < NUM_MEDIA_TYPES; ++i) {
        media_observer->OnMediaRequestStateChanged(
            target_process_id_, target_frame_id_, page_request_id,
            security_origin.GetURL(), static_cast<MediaStreamType>(i),
            new_state);
      }
    } else {
      media_observer->OnMediaRequestStateChanged(
          target_process_id_, target_frame_id_, page_request_id,
          security_origin.GetURL(), stream_type, new_state);
    }
   }
 
   MediaRequestState state(MediaStreamType stream_type) const {",A stagnant permission prompt in Prompts in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to bypass permission policy via a crafted HTML page.
3122,CVE-2018-6104,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
    
   
    
    
    
    
    
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                   ""[] > k; [] > n; [] > t;""
                                    ""[] > b;  [] > w; [] > m;""
                                   ""[] > e;  > r; [] > f; [] > c;""
                                    "" > y; [] > x;""
 #if defined(OS_WIN)
                                    "" > i;""
 #else
                                    "" > l;""
 #endif
                                   ""  > d; [] > g; [] > s;  > j;""
                                   ""[] > 3""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3123,CVE-2018-6105,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   
    
    
    
    
    
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
       icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                    ""[] > k; [] > t;""
                                    ""[] > b;  [] > w; [] > m;""
                                   "" > n; [] > e;  > r;  > f;  > c;""
                                   "" > y; [] > x;""
 #if defined(OS_WIN)
                                    "" > i;""
 #else",Incorrect handling of confusable characters in Omnibox in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3124,CVE-2018-6107,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
    
    
   
    
    
   
    
    
    
    
   
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                   ""[] > k; [] > n; [] > t;""
                                    ""[] > b;  [] > w; [] > m;""
                                   ""[] > e;  > r;  > f; [] > c;""
                                    "" > y; [] > x;""
 #if defined(OS_WIN)
                                    "" > i;""
 #else
                                    "" > l;""
 #endif
                                   ""  > d; [] > g;  > s;  > j""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3125,CVE-2018-6108,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
    
   
    
    
    
    
    
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                   ""[] > k; [] > n; [] > t;""
                                    ""[] > b;  [] > w; [] > m;""
                                   ""[] > e;  > r; [] > f; [] > c;""
                                    "" > y; [] > x;""
 #if defined(OS_WIN)
                                    "" > i;""
 #else
                                    "" > l;""
 #endif
                                   ""  > d; [] > g; [] > s;  > j;""
                                   ""[] > 3""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted HTML page.
3126,CVE-2018-6109,"  const FeatureEntry kFeatureEntries[] = {
     {""enable-cros-ime-native-decoder"", flag_descriptions::kImeNativeDecoderName,
      flag_descriptions::kImeNativeDecoderDescription, kOsCrOS,
      FEATURE_VALUE_TYPE(chromeos::features::kImeDecoderWithSandbox)},
    {""enable-cros-virtual-keyboard-bordered-key"",
     flag_descriptions::kVirtualKeyboardBorderedKeyName,
     flag_descriptions::kVirtualKeyboardBorderedKeyDescription, kOsCrOS,
     FEATURE_VALUE_TYPE(chromeos::features::kVirtualKeyboardBorderedKey)},
     {""enable-experimental-accessibility-switch-access"",
      flag_descriptions::kExperimentalAccessibilitySwitchAccessName,
      flag_descriptions::kExperimentalAccessibilitySwitchAccessDescription,","readAsText() can indefinitely read the file picked by the user, rather than only once at the time the file is picked in File API in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to access data on the user file system without explicit consent via a crafted HTML page."
3127,CVE-2018-6110," 
 #include ""chrome/test/base/ui_test_utils.h""
 #include ""content/public/browser/navigation_details.h""
 #include ""content/public/test/browser_test_utils.h""
 #include ""testing/gtest/include/gtest/gtest.h""
 #include ""ui/base/resource/resource_bundle.h""
 #include ""ui/base/resource/scale_factor.h""
 
 
 namespace {
 
GURL CreateResource(const std::string& content) {
   base::FilePath path;
   EXPECT_TRUE(base::CreateTemporaryFile(&path));
   EXPECT_EQ(static_cast<int>(content.size()),
             base::WriteFile(path, content.c_str(), content.size()));
  return GURL(""file:///"" + path.AsUTF8Unsafe());
 }
 
  
  class ResourceLoaderBrowserTest : public InProcessBrowserTest {
         ""<div id=\""root\""></div>""
         ""</body>""
         ""</html>"";
    ui_test_utils::NavigateToURL(browser(), CreateResource(root_page));
     JSExpect(""!!document.querySelector('#root')"");
 
      
  IN_PROC_BROWSER_TEST_F(ResourceLoaderBrowserTest, LoadAssetsTest) {
   JSEval(""stuff = {}"");
 
    
  std::string html_url = CreateResource(""<h1 id=\""bar\"">foo</h1>"").spec();
  std::string css_url = CreateResource(""h1 { color: red; }"").spec();
  std::string js_url = CreateResource(""stuff.loaded = true;"").spec();
 
    
    ",Parsing documents as HTML in Downloads in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to cause Chrome to execute scripts via a local non-HTML page.
3128,CVE-2018-6111," 
 #include ""content/browser/devtools/render_frame_devtools_agent_host.h""
 #include ""content/browser/frame_host/render_frame_host_impl.h""
 #include ""content/public/browser/devtools_manager_delegate.h""
#include ""content/public/common/child_process_host.h""
 
 namespace content {
 
  DevToolsSession::DevToolsSession(DevToolsAgentHostImpl* agent_host,
     : binding_(this),
       agent_host_(agent_host),
       client_(client),
      process_host_id_(ChildProcessHost::kInvalidUniqueID),
       host_(nullptr),
       dispatcher_(new protocol::UberDispatcher(this)),
       weak_factory_(this) {
  DevToolsSession::~DevToolsSession() {
 void DevToolsSession::AddHandler(
     std::unique_ptr<protocol::DevToolsDomainHandler> handler) {
   handler->Wire(dispatcher_.get());
  handler->SetRenderer(process_host_id_, host_);
   handlers_[handler->name()] = std::move(handler);
 }
 
void DevToolsSession::SetRenderer(int process_host_id,
                                   RenderFrameHostImpl* frame_host) {
  process_host_id_ = process_host_id;
   host_ = frame_host;
   for (auto& pair : handlers_)
    pair.second->SetRenderer(process_host_id_, host_);
 }
 
 void DevToolsSession::SetBrowserOnly(bool browser_only) {
  void DevToolsSession::DispatchProtocolMessage(
 
 void DevToolsSession::ReceivedBadMessage() {
   MojoConnectionDestroyed();
  RenderProcessHost* process = RenderProcessHost::FromID(process_host_id_);
  if (process) {
     bad_message::ReceivedBadMessage(
        process, bad_message::RFH_INCONSISTENT_DEVTOOLS_MESSAGE);
   }
 }
 ",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
3129,CVE-2018-6113,"  class NavigationManagerImpl : public NavigationManager {
   void Reload(ReloadType reload_type, bool check_for_reposts) final;
   void LoadIfNecessary() final;
 
   
  virtual NavigationItemImpl* GetPendingItemImpl() const = 0;
  virtual NavigationItemImpl* GetTransientItemImpl() const = 0;
  virtual NavigationItemImpl* GetLastCommittedItemImpl() const = 0;

   
   
  virtual NavigationItemImpl* GetNavigationItemImplAtIndex(
      size_t index) const = 0;

  protected:
    
    
  class NavigationManagerImpl : public NavigationManager {
    
   NavigationItem* GetLastCommittedNonAppSpecificItem() const;
 
    
   virtual void FinishGoToIndex(int index, NavigationInitiationType type) = 0;
 ",Improper handling of pending navigation entries in Navigation in Google Chrome on iOS prior to 66.0.3359.117 allowed a remote attacker to perform domain spoofing via a crafted HTML page.
3130,CVE-2018-6115,"  base::string16 GetUninstallSurveyUrl() {
 bool NavigateToUrlWithEdge(const base::string16& url) {
   base::string16 protocol_url = L""microsoft-edge:"" + url;
   SHELLEXECUTEINFO info = { sizeof(info) };
  info.fMask = SEE_MASK_NOASYNC;
   info.lpVerb = L""open"";
   info.lpFile = protocol_url.c_str();
   info.nShow = SW_SHOWNORMAL;",Inappropriate setting of the SEE_MASK_FLAG_NO_UI flag in file downloads in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to potentially bypass OS malware checks via a crafted HTML page.
3131,CVE-2017-11215,"  class MAYBE_WebRtcBrowserTest : public WebRtcContentBrowserTestBase {
   }
 };
 
IN_PROC_BROWSER_TEST_F(MAYBE_WebRtcBrowserTest, CanSetupAudioAndVideoCall) {
  MakeTypicalPeerConnectionCall(""call({video: true, audio: true});"");
}

IN_PROC_BROWSER_TEST_F(MAYBE_WebRtcBrowserTest,
                       CanSetupDefaultVideoCallWithOldGetUserMedia) {
  MakeTypicalPeerConnectionCall(""oldStyleCall();"");
}

  
  
 IN_PROC_BROWSER_TEST_F(MAYBE_WebRtcBrowserTest,
  IN_PROC_BROWSER_TEST_F(MAYBE_WebRtcBrowserTest,
   MakeTypicalPeerConnectionCall(javascript);
 }
 
 
 #if defined(OS_WIN) && !defined(NVALGRIND)
  ","An issue was discovered in Adobe Flash Player 27.0.0.183 and earlier versions. This vulnerability is an instance of a use after free vulnerability in the Primetime SDK. The mismatch between an old and a new object can provide an attacker with unintended memory access -- potentially leading to code corruption, control-flow hijack, or an information leak attack. Successful exploitation could lead to arbitrary code execution."
3132,CVE-2018-6060,"  void AudioNode::Dispose() {
 #endif
   BaseAudioContext::GraphAutoLocker locker(context());
   Handler().Dispose();
  if (context()->ContextState() == BaseAudioContext::kRunning) {
     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(
         std::move(handler_));
   }
 }
 ",Use after free in WebAudio in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3133,CVE-2018-6061,"  class VaapiH264Picture;
 
  
  
class MEDIA_GPU_EXPORT H264Picture
    : public base::RefCountedThreadSafe<H264Picture> {
  public:
   using Vector = std::vector<scoped_refptr<H264Picture>>;
 
  class MEDIA_GPU_EXPORT H264Picture : public base::RefCounted<H264Picture> {
   gfx::Rect visible_rect;
 
  protected:
  friend class base::RefCountedThreadSafe<H264Picture>;
   virtual ~H264Picture();
 
  private:",A race in the handling of SharedArrayBuffers in WebAssembly in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3134,CVE-2018-6057,"  using ::testing::_;
 
 namespace device {
 
FakePlatformSensor::FakePlatformSensor(
    mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
    PlatformSensorProvider* provider)
    : PlatformSensor(type, reading_buffer, provider) {
   ON_CALL(*this, StartSensor(_))
       .WillByDefault(
           Invoke([this](const PlatformSensorConfiguration& configuration) {
  FakePlatformSensorProvider::FakePlatformSensorProvider() {
 
 FakePlatformSensorProvider::~FakePlatformSensorProvider() = default;
 
SensorReadingSharedBuffer* FakePlatformSensorProvider::GetSensorReadingBuffer(
     mojom::SensorType type) {
  return CreateSharedBufferIfNeeded()
             ? GetSensorReadingSharedBufferForType(type)
             : nullptr;
 }
 
 void FakePlatformSensorProvider::CreateSensorInternal(
     mojom::SensorType type,
    SensorReadingSharedBuffer* reading_buffer,
     const CreateSensorCallback& callback) {
   DCHECK(type >= mojom::SensorType::FIRST && type <= mojom::SensorType::LAST);
   auto sensor =
      base::MakeRefCounted<FakePlatformSensor>(type, reading_buffer, this);
   DoCreateSensorInternal(type, std::move(sensor), callback);
 }
 ",Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.
3135,CVE-2018-6063,"  void ClientDiscardableSharedMemoryManager::AllocateCompletedOnIO(
     base::SharedMemoryHandle* handle,
     base::ScopedClosureRunner closure_runner,
     mojo::ScopedSharedBufferHandle mojo_handle) {
   if (!mojo_handle.is_valid())
     return;
   auto result = mojo::UnwrapSharedMemoryHandle(std::move(mojo_handle), handle,
                                               nullptr, nullptr);
   DCHECK_EQ(result, MOJO_RESULT_OK);
 }
 ",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
3136,CVE-2018-6067," 
 #include <string>
 
 #include ""base/pickle.h""
#include ""ipc/ipc_message_utils.h""
 #include ""third_party/skia/include/core/SkBitmap.h""
 #include ""third_party/skia/include/core/SkImageInfo.h""
#include ""ui/gfx/ipc/skia/gfx_skia_param_traits_macros.h""
 #include ""ui/gfx/transform.h""
 
 
#include ""ipc/param_traits_write_macros.h""
namespace IPC {
#undef UI_GFX_IPC_SKIA_GFX_SKIA_PARAM_TRAITS_MACROS_H_
#include ""ui/gfx/ipc/skia/gfx_skia_param_traits_macros.h""
}   
 
 
#include ""ipc/param_traits_read_macros.h""
namespace IPC {
#undef UI_GFX_IPC_SKIA_GFX_SKIA_PARAM_TRAITS_MACROS_H_
#include ""ui/gfx/ipc/skia/gfx_skia_param_traits_macros.h""
}   
 
 
#include ""ipc/param_traits_log_macros.h""
namespace IPC {
#undef UI_GFX_IPC_SKIA_GFX_SKIA_PARAM_TRAITS_MACROS_H_
#include ""ui/gfx/ipc/skia/gfx_skia_param_traits_macros.h""
}   
 
namespace IPC {
 
void ParamTraits<SkImageInfo>::Write(base::Pickle* m, const SkImageInfo& p) {
  WriteParam(m, p.colorType());
  WriteParam(m, p.alphaType());
  WriteParam(m, p.width());
  WriteParam(m, p.height());
}
 
bool ParamTraits<SkImageInfo>::Read(const base::Pickle* m,
                                    base::PickleIterator* iter,
                                    SkImageInfo* r) {
  SkColorType color_type;
  SkAlphaType alpha_type;
  uint32_t width;
  uint32_t height;
  if (!ReadParam(m, iter, &color_type) || !ReadParam(m, iter, &alpha_type) ||
      !ReadParam(m, iter, &width) || !ReadParam(m, iter, &height)) {
    return false;
   }
 
  *r = SkImageInfo::Make(width, height, color_type, alpha_type);
  return true;
}
 
void ParamTraits<SkImageInfo>::Log(const SkImageInfo& p, std::string* l) {
  l->append(""<SkImageInfo>"");
}
 
 void ParamTraits<SkBitmap>::Write(base::Pickle* m, const SkBitmap& p) {
  WriteParam(m, p.info());
   size_t pixel_size = p.computeByteSize();
   m->WriteData(reinterpret_cast<const char*>(p.getPixels()),
                static_cast<int>(pixel_size));
  void ParamTraits<SkBitmap>::Write(base::Pickle* m, const SkBitmap& p) {
 bool ParamTraits<SkBitmap>::Read(const base::Pickle* m,
                                  base::PickleIterator* iter,
                                  SkBitmap* r) {
  SkImageInfo image_info;
  if (!ReadParam(m, iter, &image_info))
     return false;
 
  const char* bitmap_data;
  int bitmap_data_size = 0;
  if (!iter->ReadData(&bitmap_data, &bitmap_data_size))
     return false;
   

  if (!r->tryAllocPixels(image_info))
    return false;

  if (static_cast<size_t>(bitmap_data_size) != r->computeByteSize())
    return false;
  memcpy(r->getPixels(), bitmap_data, bitmap_data_size);
  return true;
 }
 
 void ParamTraits<SkBitmap>::Log(const SkBitmap& p, std::string* l) {
   l->append(""<SkBitmap>"");
  LogParam(p.info(), l);
 }
 
 void ParamTraits<gfx::Transform>::Write(base::Pickle* m, const param_type& p) {",Incorrect IPC serialization in Skia in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3137,CVE-2018-6074,"  PrintMsg_Print_Params::PrintMsg_Print_Params()
       display_header_footer(false),
       title(),
       url(),
      header_template(),
      footer_template(),
       should_print_backgrounds(false),
       printed_doc_type(printing::SkiaDocumentType::PDF) {}
 
  void PrintMsg_Print_Params::Reset() {
   display_header_footer = false;
   title = base::string16();
   url = base::string16();
  header_template = base::string16();
  footer_template = base::string16();
   should_print_backgrounds = false;
   printed_doc_type = printing::SkiaDocumentType::PDF;
 }",Failure to apply Mark-of-the-Web in Downloads in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to bypass OS level controls via a crafted HTML page.
3138,CVE-2018-6076,"  TEST(TextEliderTest, TestElisionSpecialCases) {
 
        
       {""http://www/%E4%BD%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\xe4\xbd\xa0"",
       ""www/\xe4\xbd\xa0\xe5\xa5\xbd?q=\xe4\xbd\xa0\xe5\xa5\xbd#"" +
           kEllipsisStr},
 
        
        
        
       {""http://www/%E4%A0%E5%A5%BD?q=%E4%BD%A0%E5%A5%BD#\xe4\xbd\xa0"",
       ""www/%E4%A0%E5%A5%BD?q=\xe4\xbd\xa0\xe5\xa5\xbd#"" + kEllipsisStr},
   };
 
   RunElisionTest(testcases);",Insufficient encoding of URL fragment identifiers in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to perform a DOM based XSS attack via a crafted HTML page.
3139,CVE-2018-6078,"  IDNSpoofChecker::IDNSpoofChecker() {
       UTRANS_FORWARD, parse_error, status));
 
    
   
   
   
   
   
   
   
   
   
    
   
   
   
   
   
   
   
   
   
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(""[] > p; [] > h;""
                                   ""[] > k; [] > t;""
                                   ""[] > b;  [] > w; [] > m;""
                                   "" > n;  > h;  > r;  > f;  > c;""
                                   "" > y; [] > x; [] > e;  > l;""
                                   ""  > d;  > g;  > s""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in Omnibox in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3140,CVE-2018-6079,"  GLuint Get2dServiceId(const TextureUnit& unit) {
       ? unit.bound_texture_2d->service_id() : 0;
 }
 
GLuint Get2dArrayServiceId(const TextureUnit& unit) {
  return unit.bound_texture_2d_array.get()
             ? unit.bound_texture_2d_array->service_id()
             : 0;
}

GLuint Get3dServiceId(const TextureUnit& unit) {
  return unit.bound_texture_3d.get() ? unit.bound_texture_3d->service_id() : 0;
}

 GLuint GetCubeServiceId(const TextureUnit& unit) {
   return unit.bound_texture_cube_map.get()
       ? unit.bound_texture_cube_map->service_id() : 0;
  void ContextState::RestoreTextureUnitBindings(
   DCHECK_LT(unit, texture_units.size());
   const TextureUnit& texture_unit = texture_units[unit];
   GLuint service_id_2d = Get2dServiceId(texture_unit);
  GLuint service_id_2d_array = Get2dArrayServiceId(texture_unit);
  GLuint service_id_3d = Get3dServiceId(texture_unit);
   GLuint service_id_cube = GetCubeServiceId(texture_unit);
   GLuint service_id_oes = GetOesServiceId(texture_unit);
   GLuint service_id_arb = GetArbServiceId(texture_unit);
  void ContextState::RestoreTextureUnitBindings(
       feature_info_->feature_flags().oes_egl_image_external ||
       feature_info_->feature_flags().nv_egl_stream_consumer_external;
   bool bind_texture_arb = feature_info_->feature_flags().arb_texture_rectangle;
   
   
  bool bind_texture_2d_array = false;
  bool bind_texture_3d = false;
   
  if (feature_info_->IsES3Capable()) {
    bind_texture_2d_array = true;
    bind_texture_3d = true;
  }
 
   if (prev_state) {
     const TextureUnit& prev_unit = prev_state->texture_units[unit];
     bind_texture_2d = service_id_2d != Get2dServiceId(prev_unit);
    bind_texture_2d_array =
        service_id_2d_array != Get2dArrayServiceId(prev_unit);
    bind_texture_3d = service_id_3d != Get3dServiceId(prev_unit);
     bind_texture_cube = service_id_cube != GetCubeServiceId(prev_unit);
     bind_texture_oes =
         bind_texture_oes && service_id_oes != GetOesServiceId(prev_unit);
  void ContextState::RestoreTextureUnitBindings(
   }
 
    
  if (!bind_texture_2d && !bind_texture_2d_array && !bind_texture_3d &&
      !bind_texture_cube && !bind_texture_oes && !bind_texture_arb) {
     return;
   }
 
  void ContextState::RestoreTextureUnitBindings(
   if (bind_texture_arb) {
     api()->glBindTextureFn(GL_TEXTURE_RECTANGLE_ARB, service_id_arb);
   }
  if (bind_texture_2d_array) {
    api()->glBindTextureFn(GL_TEXTURE_2D_ARRAY, service_id_2d_array);
  }
  if (bind_texture_3d) {
    api()->glBindTextureFn(GL_TEXTURE_3D, service_id_3d);
  }
 }
 
 void ContextState::RestoreSamplerBinding(GLuint unit,",Inappropriate sharing of TEXTURE_2D_ARRAY/TEXTURE_3D data between tabs in WebGL in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
3141,CVE-2018-6082,"  const int kRestrictedPorts[] = {
               
 };
 
 
 const int kAllowedFtpPorts[] = {
     21,   
 };
 
 base::LazyInstance<std::multiset<int>>::Leaky g_explicitly_allowed_ports =",Including port 22 in the list of allowed FTP ports in Networking in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially enumerate internal host services via a crafted HTML page.
3142,CVE-2018-6083,"  IN_PROC_BROWSER_TEST_F(ManifestBrowserTest, NoUseCredentialsNoCookies) {
   EXPECT_TRUE(base::EqualsASCII(manifest().name.string(), ""no cookies""));
 }
 
 
 
 
IN_PROC_BROWSER_TEST_F(ManifestBrowserTest, UniqueOrigin) {
  GURL test_url = embedded_test_server()->GetURL(""/manifest/sandboxed.html"");

  ASSERT_TRUE(NavigateToURL(shell(), test_url));
  std::string manifest_link =
      embedded_test_server()->GetURL(""/manifest/dummy-manifest.json"").spec();
  ASSERT_TRUE(ExecuteScript(shell(), ""setManifestTo('"" + manifest_link + ""')""));

   
   
  GetManifestAndWait();
  EXPECT_TRUE(manifest().IsEmpty());
  EXPECT_TRUE(manifest_url().is_empty());
  EXPECT_EQ(0, GetConsoleErrorCount());
  EXPECT_EQ(0u, reported_manifest_urls().size());

  manifest_link =
      embedded_test_server()->GetURL(""/manifest/manifest-cors.json"").spec();
  ASSERT_TRUE(ExecuteScript(shell(), ""setManifestTo('"" + manifest_link + ""')""));

  GetManifestAndWait();
  EXPECT_TRUE(manifest().IsEmpty());
  EXPECT_TRUE(manifest_url().is_empty());
  EXPECT_EQ(0, GetConsoleErrorCount());
  EXPECT_EQ(0u, reported_manifest_urls().size());
}

 }  ",Failure to disallow PWA installation from CSP sandboxed pages in AppManifest in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to access privileged APIs via a crafted HTML page.
3143,CVE-2017-15407,"  QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
     ++current_gap;
   }
 
  if (current_gap == gaps_.end()) {
    *error_details = ""Received stream data outside of maximum range."";
    return QUIC_INTERNAL_ERROR;
  }
 
    
    
  QuicErrorCode QuicStreamSequencerBuffer::OnStreamData(
   }
 
    
  if (offset + size > total_bytes_read_ + max_buffer_capacity_bytes_ ||
      offset + size < offset) {
     *error_details = ""Received data beyond available range."";
     return QUIC_INTERNAL_ERROR;
   }",Out-of-bounds Write in the QUIC networking stack in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to gain code execution via a malicious server.
3144,CVE-2017-15412,"  TEST(VideoFrameMac, CheckWrapperFrame) {
       {PIXEL_FORMAT_NV12, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange},
   };
 
   for (const auto& format_pair : format_pairs) {
     base::ScopedCFTypeRef<CVPixelBufferRef> pb;
     CVPixelBufferCreate(nullptr, kWidth, kHeight, format_pair.corevideo,","Use after free in libxml2 before 2.9.5, as used in Google Chrome prior to 63.0.3239.84 and other products, allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
3145,CVE-2017-15415," 
 #include ""ui/gfx/font_fallback_linux.h""
 #include ""ui/gfx/font_render_params.h""
 
namespace {

void WriteTimeStruct(base::Pickle* pickle, const struct tm* time) {
  pickle->WriteInt(time->tm_sec);
  pickle->WriteInt(time->tm_min);
  pickle->WriteInt(time->tm_hour);
  pickle->WriteInt(time->tm_mday);
  pickle->WriteInt(time->tm_mon);
  pickle->WriteInt(time->tm_year);
  pickle->WriteInt(time->tm_wday);
  pickle->WriteInt(time->tm_yday);
  pickle->WriteInt(time->tm_isdst);
  pickle->WriteInt(time->tm_gmtoff);
  pickle->WriteString(time->tm_zone);
}

}   

 namespace content {
 
 namespace {
  void SandboxIPCHandler::HandleLocaltime(
     int fd,
     base::PickleIterator iter,
     const std::vector<base::ScopedFD>& fds) {
   
   
 
   std::string time_string;
   if (!iter.ReadString(&time_string) || time_string.size() != sizeof(time_t))
     return;
 
   time_t time;
   memcpy(&time, time_string.data(), sizeof(time));
   
    
   const struct tm* expanded_time = localtime(&time);
 
  base::Pickle reply;
   if (expanded_time) {
    WriteTimeStruct(&reply, expanded_time);
  } else {
     
    struct tm zeroed_time = {};
    WriteTimeStruct(&reply, &zeroed_time);
   }
   SendRendererReply(fds, reply, -1);
 }
 ",Incorrect serialization in IPC in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to leak the value of a pointer via a crafted HTML page.
3146,CVE-2017-15416,"  BlobStorageContext::BlobFlattener::BlobFlattener(
       }
 
        
      uint64_t end_byte;
      if (!base::CheckAdd(input_element.offset(), length)
               .AssignIfValid(&end_byte) ||
          end_byte > ref_entry->total_size()) {
         status = BlobStatus::ERR_INVALID_CONSTRUCTION_ARGUMENTS;
         return;
       }","Heap buffer overflow in Blob API in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page, aka a Blink out-of-bounds read."
3147,CVE-2017-15420,"  void NavigationObserver::PromptToEnableExtensionIfNecessary(
   if (!nav_entry)
     return;
 
  const GURL& url = nav_entry->GetURL();
 
    
    ",Incorrect handling of back navigations in error pages in Navigation in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3148,CVE-2017-15424,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
 
   
   
   
   
   
   
    
  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
    
   SetAllowedUnicodeSet(&status);
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
      
      
      
      
      
     dangerous_pattern = new icu::RegexMatcher(
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""(^[\p{scx=kana}]+[\u3078-\u307a][\p{scx=kana}]+$|)""
             R""(^[\p{scx=hira}]+[\u30d8-\u30da][\p{scx=hira}]+$|)""
             R""([a-z]\u30fb|\u30fb[a-z]|)""
             R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
             R""([ijl\u0131]\u0307)"",
             -1, US_INV),
         0, status);",Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name.
3149,CVE-2017-15425,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
 
   
   
   
   
   
   
    
  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
    
   SetAllowedUnicodeSet(&status);
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
      
      
      
      
      
     dangerous_pattern = new icu::RegexMatcher(
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""(^[\p{scx=kana}]+[\u3078-\u307a][\p{scx=kana}]+$|)""
             R""(^[\p{scx=hira}]+[\u30d8-\u30da][\p{scx=hira}]+$|)""
             R""([a-z]\u30fb|\u30fb[a-z]|)""
             R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
             R""([ijl\u0131]\u0307)"",
             -1, US_INV),
         0, status);",Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name.
3150,CVE-2017-15426,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
 
   
   
   
   
   
   
    
  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
    
   SetAllowedUnicodeSet(&status);
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
      
      
      
      
      
     dangerous_pattern = new icu::RegexMatcher(
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""(^[\p{scx=kana}]+[\u3078-\u307a][\p{scx=kana}]+$|)""
             R""(^[\p{scx=hira}]+[\u30d8-\u30da][\p{scx=hira}]+$|)""
             R""([a-z]\u30fb|\u30fb[a-z]|)""
             R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
             R""([ijl\u0131]\u0307)"",
             -1, US_INV),
         0, status);",Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name.
3151,CVE-2017-15427,"  int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {
   } else if (data.HasString()) {
     base::string16 text;
     if (data.GetString(&text)) {
      base::string16 collapsed_text(
          StripJavascriptSchemas(base::CollapseWhitespace(text, true)));
       if (model()->CanPasteAndGo(collapsed_text))
         model()->PasteAndGo(collapsed_text);
       return ui::DragDropTypes::DRAG_COPY;",Insufficient policy enforcement in Omnibox in Google Chrome prior to 63.0.3239.84 allowed a socially engineered user to XSS themselves by dragging and dropping a javascript: URL into the URL bar.
3152,CVE-2017-15398,"  void QuicClientPromisedInfo::OnPromiseHeaders(const SpdyHeaderBlock& headers) {
    
    
   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);
  if (it == headers.end()) {
    QUIC_DVLOG(1) << ""Promise for stream "" << id_ << "" has no method"";
    Reset(QUIC_INVALID_PROMISE_METHOD);
    return;
  }
   if (!(it->second == ""GET"" || it->second == ""HEAD"")) {
     QUIC_DVLOG(1) << ""Promise for stream "" << id_ << "" has invalid method ""
                   << it->second;",A stack buffer overflow in the QUIC networking stack in Google Chrome prior to 62.0.3202.89 allowed a remote attacker to gain code execution via a malicious server.
3153,CVE-2017-5129,"  void ScriptProcessorHandler::Process(size_t frames_to_process) {
          
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::FireProcessEvent,
                                WrapRefPtr(this), double_buffer_index_));
       } else {
          
          
  void ScriptProcessorHandler::Process(size_t frames_to_process) {
 
         TaskRunnerHelper::Get(TaskType::kMediaElementEvent,
                               Context()->GetExecutionContext())
            ->PostTask(
                BLINK_FROM_HERE,
                CrossThreadBind(&ScriptProcessorHandler::
                                    FireProcessEventForOfflineAudioContext,
                                WrapRefPtr(this), double_buffer_index_,
                                CrossThreadUnretained(waitable_event.get())));
 
          
          ",A use after free in WebAudio in Blink in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
3154,CVE-2017-15386,"  void WebContentsImpl::CreateNewWindow(
     }
   }
 
   
   
  if (IsFullscreenForCurrentTab())
    ExitFullscreen(true);

   if (params.opener_suppressed) {
      
      ",Incorrect implementation in Blink in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3155,CVE-2017-15389,"  class BrowserCompositorMacClient {
  
  
  
class CONTENT_EXPORT BrowserCompositorMac : public DelegatedFrameHostClient {
  public:
   BrowserCompositorMac(
       ui::AcceleratedWidgetMacNSView* accelerated_widget_mac_ns_view,
  class BrowserCompositorMac : public DelegatedFrameHostClient {
    
   DelegatedFrameHost* GetDelegatedFrameHost();
 
   
   
  void ClearCompositorFrame();

    
    
   ui::AcceleratedWidgetMac* GetAcceleratedWidgetMac();
  class BrowserCompositorMac : public DelegatedFrameHostClient {
   void OnBeginFrame() override;
   bool IsAutoResizeEnabled() const override;
 
   
  ui::Compositor* CompositorForTesting() const;

  private:
    
    ",An insufficient watchdog timer in navigation in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3156,CVE-2017-15390,"  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
     
     
     dangerous_pattern = new icu::RegexMatcher(
         icu::UnicodeString(
             R""([^\p{scx=kana}\p{scx=hira}\p{scx=hani}])""
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
             R""([\p{sc=tfng}].*[a-z]|[a-z].*[\p{sc=tfng}]|)""
             R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
             R""([^\p{scx=arab}][\u064b-\u0655\u0670]|)""
            R""([^\p{scx=hebr}]\u05b4|)""
            R""([ijl\u0131]\u0307)"",
             -1, US_INV),
         0, status);
     tls_index.Set(dangerous_pattern);",Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name.
3157,CVE-2017-15391,"  class AppApiTest : public ExtensionApiTest {
      
      
     ASSERT_EQ(1u, chrome::GetBrowserCount(browser()->profile()));
    OpenWindow(tab1, base_url.Resolve(""path1/empty.html""), true, true, NULL);
     LOG(INFO) << ""WindowOpenHelper 1."";
    OpenWindow(tab2, base_url.Resolve(""path2/empty.html""), true, true, NULL);
     LOG(INFO) << ""End of test."";
     UnloadExtension(extension->id());
   }
  IN_PROC_BROWSER_TEST_F(AppApiTest, DISABLED_AppProcess) {
 
    
   ASSERT_EQ(1u, chrome::GetBrowserCount(browser()->profile()));
  OpenWindow(tab, base_url.Resolve(""path1/empty.html""), true, true, NULL);
   LOG(INFO) << ""WindowOpenHelper 1."";
  OpenWindow(tab, base_url.Resolve(""path2/empty.html""), true, true, NULL);
   LOG(INFO) << ""WindowOpenHelper 2."";
    
    
    
    
    
  OpenWindow(tab, base_url.Resolve(""path3/empty.html""), true, true, NULL);
   LOG(INFO) << ""WindowOpenHelper 3."";
 
    
  IN_PROC_BROWSER_TEST_F(AppApiTest, MAYBE_BookmarkAppGetsNormalProcess) {
 
    
   ASSERT_EQ(1u, chrome::GetBrowserCount(browser()->profile()));
  OpenWindow(tab, base_url.Resolve(""path1/empty.html""), true, true, NULL);
  OpenWindow(tab, base_url.Resolve(""path2/empty.html""), true, true, NULL);
 
    
    ",Insufficient Policy Enforcement in Extensions in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to access Extension pages without authorisation via a crafted HTML page.
3158,CVE-2017-15393,"  WebContents* DevToolsWindow::OpenURLFromTab(
   DCHECK(source == main_web_contents_);
   if (!params.url.SchemeIs(content::kChromeDevToolsScheme)) {
     WebContents* inspected_web_contents = GetInspectedWebContents();
    if (!inspected_web_contents)
      return nullptr;
    content::OpenURLParams modified = params;
    modified.referrer = content::Referrer();
    return inspected_web_contents->OpenURL(modified);
   }
   bindings_->Reload();
   return main_web_contents_;","Insufficient Policy Enforcement in Devtools remote debugging in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to obtain access to remote debugging functionality via a crafted HTML page, aka a Referer leak."
3159,CVE-2017-15394," 
 
 #include ""base/macros.h""
 #include ""base/strings/string16.h""
#include ""base/strings/utf_string_conversions.h""
 #include ""base/values.h""
 #include ""chrome/grit/generated_resources.h""
 #include ""extensions/common/permissions/permission_set.h""
  class ChromePermissionMessageProviderUnittest : public testing::Test {
         Manifest::TYPE_EXTENSION);
   }
 
  ChromePermissionMessageProvider* message_provider() {
    return message_provider_.get();
  }

  private:
   std::unique_ptr<ChromePermissionMessageProvider> message_provider_;
 
  TEST_F(ChromePermissionMessageProviderUnittest,
   EXPECT_TRUE(IsPrivilegeIncrease(APIPermissionSet(), actual_permissions));
 }
 
 
 
TEST_F(ChromePermissionMessageProviderUnittest,
       IDNDomainsInHostPermissionsArePunycoded) {
  extensions::URLPatternSet explicit_hosts;

  explicit_hosts.AddPattern(
      URLPattern(URLPattern::SCHEME_ALL, ""https://oogle.com/""));
  explicit_hosts.AddPattern(
      URLPattern(URLPattern::SCHEME_ALL, ""https://*.oogle.com/""));
  extensions::PermissionSet permissions(APIPermissionSet(),
                                        ManifestPermissionSet(), explicit_hosts,
                                        URLPatternSet());

  PermissionMessages messages = message_provider()->GetPermissionMessages(
      message_provider()->GetAllPermissionIDs(permissions,
                                              Manifest::TYPE_EXTENSION));

  ASSERT_EQ(1U, messages.size());
  EXPECT_EQ(l10n_util::GetStringFUTF16(
                IDS_EXTENSION_PROMPT_WARNING_2_HOSTS,
                base::ASCIIToUTF16(""all xn--oogle-qmc.com sites""),
                base::ASCIIToUTF16(""xn--oogle-qmc.com"")),
            messages.front().message());
}

 }   ",Insufficient Policy Enforcement in Extensions in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to perform domain spoofing in permission dialogs via IDN homographs in a crafted Chrome Extension.
3160,,"  InlineBoxPosition ComputeInlineBoxPositionTemplate(
                                                affinity, primary_direction);
   }
 
  if (layout_object->IsAtomicInlineLevel()) {
     
    if (!layout_object->IsBox())
      return InlineBoxPosition();
    InlineBox* const inline_box =
        ToLayoutBox(layout_object)->InlineBoxWrapper();
    if (!inline_box)
      return InlineBoxPosition();
    if ((caret_offset > inline_box->CaretMinOffset() &&
         caret_offset < inline_box->CaretMaxOffset()))
      return InlineBoxPosition(inline_box, caret_offset);
    return AdjustInlineBoxPositionForTextDirection(
        inline_box, caret_offset, layout_object->Style()->GetUnicodeBidi(),
        primary_direction);
   }
 
  if (!layout_object->IsLayoutBlockFlow())
     return InlineBoxPosition();
   
  if (!CanHaveChildrenForEditing(anchor_node) ||
      !HasRenderedNonAnonymousDescendantsWithHeight(layout_object))
     return InlineBoxPosition();
   
   
   
   
   
  const PositionTemplate<Strategy>& downstream_equivalent =
      DownstreamIgnoringEditingBoundaries(position);
  if (downstream_equivalent != position) {
    return ComputeInlineBoxPosition(downstream_equivalent,
                                    TextAffinity::kUpstream, primary_direction);
  }
  const PositionTemplate<Strategy>& upstream_equivalent =
      UpstreamIgnoringEditingBoundaries(position);
  if (upstream_equivalent == position ||
      DownstreamIgnoringEditingBoundaries(upstream_equivalent) == position)
     return InlineBoxPosition();

  return ComputeInlineBoxPosition(upstream_equivalent, TextAffinity::kUpstream,
                                  primary_direction);
 }
 
 template <typename Strategy>",
3161,CVE-2019-5828,"  PaymentHandlerWebFlowViewController::PaymentHandlerWebFlowViewController(
       ui::NativeTheme::kColorId_SeparatorColor));
 }
 
PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {
  state()->OnPaymentAppWindowClosed();
}
 
 base::string16 PaymentHandlerWebFlowViewController::GetSheetTitle() {
   return GetPaymentHandlerDialogTitle(web_contents(), https_prefix_);",Object lifecycle issue in ServiceWorker in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.
3162,CVE-2019-5829,"  download::DownloadItemImpl* DownloadManagerImpl::CreateActiveItem(
     uint32_t id,
     const download::DownloadCreateInfo& info) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);

  if (base::ContainsKey(downloads_, id))
    return nullptr;

   download::DownloadItemImpl* download =
       item_factory_->CreateActiveItem(this, id, info);
 
  void DownloadManagerImpl::CreateNewDownloadItemToStart(
   download::DownloadItemImpl* download = CreateActiveItem(id, *info);
   std::move(callback).Run(std::move(info), download,
                           should_persist_new_download_);
  if (download) {
     
     
     
    for (auto& observer : observers_)
      observer.OnDownloadCreated(this, download);
    OnNewDownloadCreated(download);
  }
 
   OnDownloadStarted(download, on_started);
 }",Integer overflow in download manager in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.
3163,CVE-2019-5830,"  IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, ListTest) {
   LoadFile(base::FilePath(FILE_PATH_LITERAL(""list_test.html"")));
 }
 
#if defined(OS_CHROMEOS)
 IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, GridTest) {
   AddLibrary(IDR_WEBUI_JS_CR);
   AddLibrary(IDR_WEBUI_JS_CR_EVENT_TARGET);
  IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, GridTest) {
   AddLibrary(IDR_WEBUI_JS_CR_UI_GRID);
   LoadFile(base::FilePath(FILE_PATH_LITERAL(""grid_test.html"")));
 }
#endif
 
 IN_PROC_BROWSER_TEST_F(WebUIResourceBrowserTest, ListSelectionModelTest) {
   AddLibrary(IDR_WEBUI_JS_CR);",Insufficient policy enforcement in CORS in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
3164,CVE-2019-5832,"  void XMLHttpRequest::CreateRequest(scoped_refptr<EncodedFormData> http_body,
     }
   }
 
  const bool same_origin_request = GetSecurityOrigin()->CanRequest(url_);
 
  if (!same_origin_request && with_credentials_) {
     UseCounter::Count(&execution_context,
                       WebFeature::kXMLHttpRequestCrossOriginWithCredentials);
   }
 
    
    
   upload_events_allowed_ =
      same_origin_request || upload_events ||
       !cors::IsCorsSafelistedMethod(method_) ||
       !cors::ContainsOnlyCorsSafelistedHeaders(request_headers_);
 
  String XMLHttpRequest::getAllResponseHeaders() const {
         !GetSecurityOrigin()->CanLoadLocalResources())
       continue;
 
    if (response_.GetType() == network::mojom::FetchResponseType::kCors &&
         !cors::IsCorsSafelistedResponseHeader(it->key) &&
         access_control_expose_header_set.find(it->key.Ascii().data()) ==
            access_control_expose_header_set.end()) {
       continue;
    }
 
     string_builder.Append(it->key.LowerASCII());
     string_builder.Append(':');
  const AtomicString& XMLHttpRequest::getResponseHeader(
                             : network::mojom::FetchCredentialsMode::kSameOrigin,
           response_);
 
  if (response_.GetType() == network::mojom::FetchResponseType::kCors &&
      !cors::IsCorsSafelistedResponseHeader(name) &&
       access_control_expose_header_set.find(name.Ascii().data()) ==
           access_control_expose_header_set.end()) {
     LogConsoleError(GetExecutionContext(),",Insufficient policy enforcement in XMLHttpRequest in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
3165,CVE-2019-5838,"  class ActiveTabTest : public ChromeRenderViewHostTestHarness {
     bool script =
         permissions_data->CanAccessPage(url, tab_id, nullptr) &&
         permissions_data->CanRunContentScriptOnPage(url, tab_id, nullptr);
    bool capture = permissions_data->CanCaptureVisiblePage(
        url, tab_id, NULL, extensions::CaptureRequirement::kActiveTabOrAllUrls);
     switch (feature) {
       case PERMITTED_SCRIPT_ONLY:
         return script && !capture;
  TEST_F(ActiveTabTest, CapturingPagesWithActiveTab) {
     EXPECT_EQ(url, web_contents()->GetLastCommittedURL());
      
     EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
        url, tab_id(), nullptr  ,
        extensions::CaptureRequirement::kActiveTabOrAllUrls));
      
     active_tab_permission_granter()->GrantIfRequested(extension.get());
     EXPECT_TRUE(extension->permissions_data()->CanCaptureVisiblePage(
        url, tab_id(), nullptr  ,
        extensions::CaptureRequirement::kActiveTabOrAllUrls));
      
     NavigateAndCommit(kAboutBlank);
     EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
        url, tab_id(), nullptr  ,
        extensions::CaptureRequirement::kActiveTabOrAllUrls));
   }
 }
 
  TEST_F(ActiveTabWithServiceTest, FileURLs) {
   EXPECT_NE(extension_misc::kUnknownTabId, tab_id);
 
   EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), tab_id, nullptr,
      extensions::CaptureRequirement::kActiveTabOrAllUrls));
 
   permission_granter->GrantIfRequested(extension.get());
   EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), tab_id, nullptr,
      extensions::CaptureRequirement::kActiveTabOrAllUrls));
 
   permission_granter->RevokeForTesting();
   TestExtensionRegistryObserver observer(registry(), id);
  TEST_F(ActiveTabWithServiceTest, FileURLs) {
   ASSERT_TRUE(extension);
 
   EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), tab_id, nullptr,
      extensions::CaptureRequirement::kActiveTabOrAllUrls));
   permission_granter->GrantIfRequested(extension.get());
   EXPECT_TRUE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), tab_id, nullptr,
      extensions::CaptureRequirement::kActiveTabOrAllUrls));
 }
 
 }   ",Insufficient policy enforcement in extensions API in Google Chrome prior to 75.0.3770.80 allowed an attacker who convinced a user to install a malicious extension to bypass restrictions on file URIs via a crafted Chrome Extension.
3166,CVE-2019-5827,"  SQLITE_PRIVATE VList *sqlite3VListAdd(
   assert( pIn==0 || pIn[0]>=3 );   
   if( pIn==0 || pIn[1]+nInt > pIn[0] ){
      
    sqlite3_int64 nAlloc = (pIn ? 2*(sqlite3_int64)pIn[0] : 10) + nInt;
     VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));
     if( pOut==0 ) return pIn;
     if( pIn==0 ) pOut[1] = 2;
  static int growOpArray(Vdbe *v, int nOp){
   ** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current
   ** size of the op array or add 1KB of space, whichever is smaller. */
 #ifdef SQLITE_TEST_REALLOC_STRESS
  sqlite3_int64 nNew = (v->nOpAlloc>=512 ? 2*(sqlite3_int64)v->nOpAlloc
                      : (sqlite3_int64)v->nOpAlloc+nOp);
 #else
  sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc
                      : (sqlite3_int64)1024/sizeof(Op));
   UNUSED_PARAMETER(nOp);
 #endif
 
  SQLITE_PRIVATE void sqlite3VdbeScanStatus(
   LogEst nEst,                     
   const char *zName                
 ){
  sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);
   ScanStatus *aNew;
   aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);
   if( aNew ){
  static int vdbePmaReadBlob(
      
     if( p->nAlloc<nByte ){
       u8 *aNew;
      sqlite3_int64 nNew = MAX(128, 2*(sqlite3_int64)p->nAlloc);
       while( nByte>nNew ) nNew = nNew*2;
       aNew = sqlite3Realloc(p->aAlloc, nNew);
       if( !aNew ) return SQLITE_NOMEM_BKPT;
  SQLITE_PRIVATE int sqlite3VdbeSorterWrite(
     if( nMin>pSorter->nMemory ){
       u8 *aNew;
       int iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;
      sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;
       while( nNew < nMin ) nNew = nNew*2;
       if( nNew > pSorter->mxPmaSize ) nNew = pSorter->mxPmaSize;
       if( nNew < nMin ) nNew = nMin;
  SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(
   }else if( (pList->nExpr & (pList->nExpr-1))==0 ){
     ExprList *pNew;
     pNew = sqlite3DbRealloc(db, pList,
         sizeof(*pList)+(2*(sqlite3_int64)pList->nExpr-1)*sizeof(pList->a[0]));
     if( pNew==0 ){
       goto no_mem;
     }
  SQLITE_PRIVATE void *sqlite3ArrayAllocate(
   int *pIdx          
 ){
   char *z;
  sqlite3_int64 n = *pnEntry;
   if( (n & (n-1))==0 ){
    sqlite3_int64 sz = (n==0) ? 1 : 2*n;
     void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);
     if( pNew==0 ){
       *pIdx = -1;
  SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(
    
   if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
     SrcList *pNew;
    sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;
     sqlite3 *db = pParse->db;
 
     if( pSrc->nSrc+nExtra>=SQLITE_MAX_SRCLIST ){
  SQLITE_PRIVATE With *sqlite3WithAdd(
   }
 
   if( pWith ){
    sqlite3_int64 nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);
     pNew = sqlite3DbRealloc(db, pWith, nByte);
   }else{
     pNew = sqlite3DbMallocZero(db, sizeof(*pWith));
  SQLITE_PRIVATE void sqlite3VtabClear(sqlite3 *db, Table *p){
 ** string will be freed automatically when the table is
 ** deleted.
 */
static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){
  sqlite3_int64 nBytes = sizeof(char *)*(2+pTable->nModuleArg);
   char **azModuleArg;
  sqlite3 *db = pParse->db;
  if( pTable->nModuleArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){
    sqlite3ErrorMsg(pParse, ""too many columns on %s"", pTable->zName);
  }
   azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);
   if( azModuleArg==0 ){
     sqlite3DbFree(db, zArg);
  SQLITE_PRIVATE void sqlite3VtabBeginParse(
   db = pParse->db;
 
   assert( pTable->nModuleArg==0 );
  addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
  addModuleArgument(pParse, pTable, 0);
  addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable->zName));
   assert( (pParse->sNameToken.z==pName2->z && pName2->z!=0)
        || (pParse->sNameToken.z==pName1->z && pName2->z==0)
   );
  static void addArgumentToVtab(Parse *pParse){
     const char *z = (const char*)pParse->sArg.z;
     int n = pParse->sArg.n;
     sqlite3 *db = pParse->db;
    addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
   }
 }
 
  static int growVTrans(sqlite3 *db){
    
   if( (db->nVTrans%ARRAY_INCR)==0 ){
     VTable **aVTrans;
    sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*
                                 ((sqlite3_int64)db->nVTrans + ARRAY_INCR);
     aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
     if( !aVTrans ){
       return SQLITE_NOMEM_BKPT;
  SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){
   pTab->pSchema = db->aDb[0].pSchema;
   assert( pTab->nModuleArg==0 );
   pTab->iPKey = -1;
  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));
  addModuleArgument(pParse, pTab, 0);
  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));
   rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);
   if( rc ){
     sqlite3ErrorMsg(pParse, ""%s"", zErr);
  static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
     pStart = 0;
   }else if( pBuf==0 ){
     sqlite3BeginBenignMalloc();
    pStart = sqlite3Malloc( sz*(sqlite3_int64)cnt );   
     sqlite3EndBenignMalloc();
     if( pStart ) cnt = sqlite3MallocSize(pStart)/sz;
   }else{
  SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(
     int iArg = 0;
     z = &z[n+1];
     while( z<zEnd && (NULL!=(z = (char *)sqlite3Fts3NextToken(z, &n))) ){
      sqlite3_int64 nNew = sizeof(char *)*(iArg+1);
      char const **aNew = (const char **)sqlite3_realloc64((void *)aArg, nNew);
       if( !aNew ){
         sqlite3_free(zCopy);
         sqlite3_free((void *)aArg);
  static int fts3tokFilterMethod(
   if( idxNum==1 ){
     const char *zByte = (const char *)sqlite3_value_text(apVal[0]);
     int nByte = sqlite3_value_bytes(apVal[0]);
    pCsr->zInput = sqlite3_malloc64(nByte+1);
     if( pCsr->zInput==0 ){
       rc = SQLITE_NOMEM;
     }else{
  SQLITE_PRIVATE int sqlite3Fts3SegReaderPending(
   }
 
   if( nElem>0 ){
    sqlite3_int64 nByte;
    nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);
    pReader = (Fts3SegReader *)sqlite3_malloc64(nByte);
     if( !pReader ){
       rc = SQLITE_NOMEM;
     }else{
  static void fts3InsertDocsize(
   int rc;                   
 
   if( *pRC ) return;
  pBlob = sqlite3_malloc64( 10*(sqlite3_int64)p->nColumn );
   if( pBlob==0 ){
     *pRC = SQLITE_NOMEM;
     return;
  static void fts3UpdateDocTotals(
   const int nStat = p->nColumn+2;
 
   if( *pRC ) return;
  a = sqlite3_malloc64( (sizeof(u32)+10)*(sqlite3_int64)nStat );
   if( a==0 ){
     *pRC = SQLITE_NOMEM;
     return;
  static int fts3DoRebuild(Fts3Table *p){
     }
 
     if( rc==SQLITE_OK ){
      sqlite3_int64 nByte = sizeof(u32) * ((sqlite3_int64)p->nColumn+1)*3;
      aSz = (u32 *)sqlite3_malloc64(nByte);
       if( aSz==0 ){
         rc = SQLITE_NOMEM;
       }else{
  static int fts3IncrmergeCsr(
 ){
   int rc;                          
   sqlite3_stmt *pStmt = 0;         
  sqlite3_int64 nByte;             
 
    
   memset(pCsr, 0, sizeof(*pCsr));
   nByte = sizeof(Fts3SegReader *) * nSeg;
  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc64(nByte);
 
   if( pCsr->apSegment==0 ){
     rc = SQLITE_NOMEM;
  SQLITE_PRIVATE int sqlite3Fts3UpdateMethod(
   }
 
    
  aSzDel = sqlite3_malloc64(sizeof(aSzDel[0])*((sqlite3_int64)p->nColumn+1)*2);
   if( aSzDel==0 ){
     rc = SQLITE_NOMEM;
     goto update_out;
  struct StrBuffer {
 */
 static MatchinfoBuffer *fts3MIBufferNew(int nElem, const char *zMatchinfo){
   MatchinfoBuffer *pRet;
  sqlite3_int64 nByte = sizeof(u32) * (2*(sqlite3_int64)nElem + 1)
                           + sizeof(MatchinfoBuffer);
  sqlite3_int64 nStr = strlen(zMatchinfo);
 
  pRet = sqlite3_malloc64(nByte + nStr+1);
   if( pRet ){
     memset(pRet, 0, nByte);
     pRet->aMatchinfo[0] = (u8*)(&pRet->aMatchinfo[1]) - (u8*)pRet;
  static GeoPoly *geopolyParseJson(const unsigned char *z, int *pRc){
       GeoPoly *pOut;
       int x = 1;
       s.nVertex--;   
      pOut = sqlite3_malloc64( GEOPOLY_SZ((sqlite3_int64)s.nVertex) );
       x = 1;
       if( pOut==0 ) goto parse_json_err;
       pOut->nVertex = s.nVertex;
  static GeoPoly *geopolyBBox(
     if( pRc ) *pRc = SQLITE_OK;
     if( aCoord==0 ){
       geopolyBboxFill:
      pOut = sqlite3_realloc64(p, GEOPOLY_SZ(4));
       if( pOut==0 ){
         sqlite3_free(p);
         if( context ) sqlite3_result_error_nomem(context);
  static GeoSegment *geopolySortSegmentsByYAndC(GeoSegment *pList){
 ** Determine the overlap between two polygons
 */
 static int geopolyOverlap(GeoPoly *p1, GeoPoly *p2){
  sqlite3_int64 nVertex = p1->nVertex + p2->nVertex + 2;
   GeoOverlap *p;
  sqlite3_int64 nByte;
   GeoEvent *pThisEvent;
   double rX;
   int rc = 0;
  static int geopolyOverlap(GeoPoly *p1, GeoPoly *p2){
   nByte = sizeof(GeoEvent)*nVertex*2
            + sizeof(GeoSegment)*nVertex
            + sizeof(GeoOverlap);
  p = sqlite3_malloc64( nByte );
   if( p==0 ) return -1;
   p->aEvent = (GeoEvent*)&p[1];
   p->aSegment = (GeoSegment*)&p->aEvent[nVertex*2];
  static int geopolyInit(
 ){
   int rc = SQLITE_OK;
   Rtree *pRtree;
  sqlite3_int64 nDb;               
  sqlite3_int64 nName;             
   sqlite3_str *pSql;
   char *zSql;
   int ii;
 
   sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);
 
    
  nDb = strlen(argv[1]);
  nName = strlen(argv[2]);
  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName+2);
   if( !pRtree ){
     return SQLITE_NOMEM;
   }
  static int fts5UnicodeCreate(
 
       p->eRemoveDiacritic = FTS5_REMOVE_DIACRITICS_SIMPLE;
       p->nFold = 64;
      p->aFold = sqlite3_malloc64(p->nFold * sizeof(char));
       if( p->aFold==0 ){
         rc = SQLITE_NOMEM;
       }
  SQLITE_API int sqlite3_stmt_init(
 #endif  
 
  
#if __LINE__!=221446
 #undef SQLITE_SOURCE_ID
 #define SQLITE_SOURCE_ID      ""2019-02-25 16:06:06 bd49a8271d650fa89e446b42e513b595a717b9212c91dd384aab871fc1d0alt2""
 #endif",Integer overflow in SQLite via WebSQL in Google Chrome prior to 74.0.3729.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3167,CVE-2019-5824,"  void MediaStreamDispatcherHost::DoOpenDevice(
   }
 
   media_stream_manager_->OpenDevice(
      render_process_id_, render_frame_id_, requester_id_, page_request_id,
       device_id, type, std::move(salt_and_origin), std::move(callback),
       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,
                           weak_factory_.GetWeakPtr()));",Parameter passing error in media in Google Chrome prior to 74.0.3729.131 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3168,CVE-2019-5826,"  void IndexedDBDatabase::ForceClose() {
     request->AbortForForceClose();
   }
 
  while (!connections_.empty()) {
    IndexedDBConnection* connection = *connections_.begin();
     connection->ForceClose();
    connections_.erase(connection);
   }
   DCHECK(connections_.empty());
   DCHECK(!active_request_);",
3169,CVE-2019-5808,"  class CORE_EXPORT ElementResolveContext {
   Element* GetElement() const { return element_; }
   const ContainerNode* ParentNode() const { return parent_node_; }
   const ContainerNode* LayoutParent() const { return layout_parent_; }
  const ComputedStyle* RootElementStyle() const {
    return root_element_style_.get();
  }
   const ComputedStyle* ParentStyle() const {
     return ParentNode() && ParentNode()->IsElementNode()
                ? ParentNode()->GetComputedStyle()
  class CORE_EXPORT ElementResolveContext {
   Member<Element> element_;
   Member<ContainerNode> parent_node_;
   Member<ContainerNode> layout_parent_;
  scoped_refptr<const ComputedStyle> root_element_style_;
   EInsideLink element_link_state_;
   bool distributed_to_insertion_point_;
 };",Use after free in Blink in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3170,CVE-2019-5809,"  class FileChooserImpl : public blink::mojom::FileChooser,
 
   void OpenFileChooser(blink::mojom::FileChooserParamsPtr params,
                        OpenFileChooserCallback callback) override {
    if (proxy_) {
      std::move(callback).Run(nullptr);
      return;
    }
     callback_ = std::move(callback);
     auto listener = std::make_unique<ListenerProxy>(this);
     proxy_ = listener.get();
  class FileChooserImpl : public blink::mojom::FileChooser,
   void EnumerateChosenDirectory(
       const base::FilePath& directory_path,
       EnumerateChosenDirectoryCallback callback) override {
    if (proxy_) {
      std::move(callback).Run(nullptr);
      return;
    }
     callback_ = std::move(callback);
     auto listener = std::make_unique<ListenerProxy>(this);
     proxy_ = listener.get();",Use after free in file chooser in Google Chrome prior to 74.0.3729.108 allowed a remote attacker who had compromised the renderer process to perform privilege escalation via a crafted HTML page.
3171,CVE-2019-5810," 
 #include ""base/strings/stringprintf.h""
 #include ""base/strings/utf_string_conversions.h""
 #include ""base/test/scoped_feature_list.h""
#include ""build/build_config.h""
 #include ""chrome/test/base/chrome_render_view_test.h""
 #include ""components/autofill/content/renderer/form_autofill_util.h""
 #include ""components/autofill/content/renderer/form_cache.h""
 
 #include ""third_party/blink/public/web/web_script_source.h""
 #include ""third_party/blink/public/web/web_select_element.h""
 
#if defined(OS_WIN)
#include ""third_party/blink/public/web/win/web_font_rendering.h""
#endif

 using autofill::features::kAutofillEnforceMinRequiredFieldsForHeuristics;
 using autofill::features::kAutofillEnforceMinRequiredFieldsForQuery;
 using autofill::features::kAutofillEnforceMinRequiredFieldsForUpload;
  class FormAutofillTest : public ChromeRenderViewTest {
   }
   ~FormAutofillTest() override {}
 
#if defined(OS_WIN)
  void SetUp() override {
    ChromeRenderViewTest::SetUp();

     
     
    blink::WebFontRendering::SetMenuFontMetrics(
        base::ASCIIToUTF16(""Arial"").c_str(), 12);
  }
#endif

   void ExpectLabels(const char* html,
                     const std::vector<base::string16>& id_attributes,
                     const std::vector<base::string16>& name_attributes,",Information leak in autofill in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.
3172,CVE-2019-5816,"  ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(
   if (!java_peer_avaiable_on_client_thread_)
     return info;
 
  Java_ChildProcessLauncherHelperImpl_getTerminationInfoAndStop(
       AttachCurrentThread(), java_peer_, reinterpret_cast<intptr_t>(&info));
 
   base::android::ApplicationState app_state =",Process lifetime issue in Chrome in Google Chrome on Android prior to 74.0.3729.108 allowed a remote attacker to potentially persist an exploited process via a crafted HTML page.
3173,CVE-2019-5818,"  bool BitReaderCore::ReadBitsInternal(int num_bits, uint64_t* out) {
      
     nbits_ = 0;
     reg_ = 0;
    *out = 0;
     return false;
   }
 ",Uninitialized data in media in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted video file.
3174,CVE-2019-5822,"  IN_PROC_BROWSER_TEST_F(DownloadTest, FileExistenceCheckOpeningDownloadsPage) {
       .WaitForEvent();
 }
 
 
 
IN_PROC_BROWSER_TEST_F(DownloadTest, CrossOriginDownloadNavigatesIframe) {
  EmbeddedTestServer origin_one;
  EmbeddedTestServer origin_two;
  EmbeddedTestServer origin_three;

  origin_one.ServeFilesFromDirectory(GetTestDataDirectory());
  origin_two.ServeFilesFromDirectory(GetTestDataDirectory());
  origin_three.ServeFilesFromDirectory(GetTestDataDirectory());
  ASSERT_TRUE(origin_one.InitializeAndListen());
  ASSERT_TRUE(origin_two.InitializeAndListen());
  ASSERT_TRUE(origin_three.InitializeAndListen());

   
   
  GURL download_url =
      origin_two.GetURL(std::string(""/redirect?"") +
                        origin_three.GetURL(""/downloads/message.html"").spec());
  GURL referrer_url = origin_two.GetURL(
      std::string(""/downloads/download-attribute.html?target="") +
      download_url.spec());
  GURL main_url =
      origin_one.GetURL(std::string(""/downloads/page-with-frame.html?url="") +
                        referrer_url.spec());

  origin_two.RegisterRequestHandler(
      base::BindRepeating(&ServerRedirectRequestHandler));

  origin_one.StartAcceptingConnections();
  origin_two.StartAcceptingConnections();
  origin_three.StartAcceptingConnections();

  ui_test_utils::NavigateToURL(browser(), main_url);

  WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();
  ASSERT_TRUE(web_contents != NULL);
  content::RenderFrameHost* render_frame_host = web_contents->GetMainFrame();
  ASSERT_TRUE(render_frame_host != NULL);

   
   
  base::string16 expected_title(base::UTF8ToUTF16(""Loaded as iframe""));
  base::string16 failed_title(base::UTF8ToUTF16(""Loaded as main frame""));
  content::TitleWatcher title_watcher(web_contents, expected_title);
  title_watcher.AlsoWaitForTitle(failed_title);
  render_frame_host->ExecuteJavaScriptForTests(
      base::ASCIIToUTF16(""runTest();""));
  ASSERT_EQ(expected_title, title_watcher.WaitAndGetTitle());

   
  std::vector<DownloadItem*> downloads;
  DownloadManagerForBrowser(browser())->GetAllDownloads(&downloads);
  ASSERT_EQ(0u, downloads.size());

  ASSERT_TRUE(origin_one.ShutdownAndWaitUntilComplete());
  ASSERT_TRUE(origin_two.ShutdownAndWaitUntilComplete());
  ASSERT_TRUE(origin_three.ShutdownAndWaitUntilComplete());
}

 #if defined(FULL_SAFE_BROWSING)
 
 namespace {",Inappropriate implementation in Blink in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to bypass same origin policy via a crafted HTML page.
3175,CVE-2019-5823,"  void NavigateClientOnUI(const GURL& url,
     return;
   }
 
   
   
   
  NavigationRequest* ongoing_navigation_request =
      rfhi->frame_tree_node()->frame_tree()->root()->navigation_request();
  if (ongoing_navigation_request &&
      ongoing_navigation_request->browser_initiated()) {
    base::PostTaskWithTraits(
        FROM_HERE, {BrowserThread::IO},
        base::BindOnce(std::move(callback), ChildProcessHost::kInvalidUniqueID,
                       MSG_ROUTING_NONE));
    return;
  }
 
  int frame_tree_node_id = rfhi->frame_tree_node()->frame_tree_node_id();
   Navigator* navigator = rfhi->frame_tree_node()->navigator();
   navigator->RequestOpenURL(
       rfhi, url, url::Origin::Create(script_url), false  ,",Insufficient policy enforcement in service workers in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to bypass navigation restrictions via a crafted HTML page.
3176,CVE-2019-5787,"  void HTMLCanvasElement::Dispose() {
   if (PlaceholderFrame())
     ReleasePlaceholderFrame();
 
   
  frame_dispatcher_ = nullptr;

   if (context_) {
     context_->DetachHost();
     context_ = nullptr;",Use-after-garbage-collection in Blink in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3177,CVE-2019-5788,"  OperationID FileSystemOperationRunner::BeginOperation(
     std::unique_ptr<FileSystemOperation> operation) {
   OperationID id = next_operation_id_++;
 
   DCHECK(operations_.find(id) == operations_.end());
  operations_[id] = std::move(operation);
   return id;
 }
 ",An integer overflow that leads to a use-after-free in Blink Storage in Google Chrome on Linux prior to 73.0.3683.75 allowed a remote attacker who had compromised the renderer process to execute arbitrary code via a crafted HTML page.
3178,CVE-2019-5789,"  MidiManagerAlsa::~MidiManagerAlsa() {
      
     out_client_.reset();
   }
    
  if (!service()->task_service()->UnbindInstance())
    return;

   
   
   
 }
 
 void MidiManagerAlsa::StartInitialization() {
  if (!service()->task_service()->BindInstance())
     return CompleteInitialization(Result::INITIALIZATION_ERROR);
 
    
   int err;",An integer overflow that leads to a use-after-free in WebMIDI in Google Chrome on Windows prior to 73.0.3683.75 allowed a remote attacker who had compromised the renderer process to execute arbitrary code via a crafted HTML page.
3179,CVE-2019-5790,"  void RemoteFrame::Navigate(const FrameLoadRequest& passed_request) {
   FrameLoader::UpgradeInsecureRequest(frame_request.GetResourceRequest(),
                                       frame_request.OriginDocument());
 
   Client()->Navigate(frame_request.GetResourceRequest(),
                      frame_request.ReplacesCurrentItem());
 }",An integer overflow leading to an incorrect capacity of a buffer in JavaScript in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to execute arbitrary code inside a sandbox via a crafted HTML page.
3180,CVE-2019-5792,"  void ArcVoiceInteractionFrameworkService::
   framework_instance->StartVoiceInteractionSetupWizard();
 }
 
std::unique_ptr<ui::LayerTreeOwner>
ArcVoiceInteractionFrameworkService::CreateLayerTreeForSnapshotForTesting(
    aura::Window* root_window) const {
  return CreateLayerTreeForSnapshot(root_window);
}

 }   ",Integer overflow in PDFium in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to potentially perform out of bounds memory access via a crafted PDF file.
3181,CVE-2019-5794,"  IN_PROC_BROWSER_TEST_F(ChromeNavigationBrowserTest,
   content::WaitForLoadStop(web_contents);
   EXPECT_EQ(url, web_contents->GetLastCommittedURL());
 
    
   EXPECT_TRUE(ExecuteScript(web_contents,
                             ""var frame = document.createElement('iframe');\n""
  IN_PROC_BROWSER_TEST_F(ChromeNavigationBrowserTest,
       ChildFrameAt(web_contents->GetMainFrame(), 0);
    
   EXPECT_TRUE(subframe_host->GetLastCommittedURL().is_empty());

   
   
   
   
   
  GURL redirect_to_error_url(
      embedded_test_server()->GetURL(""/server-redirect?"" + error_url.spec()));
  content::TestNavigationObserver observer(web_contents);
  EXPECT_TRUE(ExecuteScript(
      web_contents, ""location.href = '"" + redirect_to_error_url.spec() + ""';""));
  observer.Wait();
  EXPECT_EQ(redirect_to_error_url, web_contents->GetLastCommittedURL());
  EXPECT_EQ(
      content::PAGE_TYPE_ERROR,
      web_contents->GetController().GetLastCommittedEntry()->GetPageType());
 }
 
  ",Incorrect handling of cancelled requests in Navigation in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to perform domain spoofing via a crafted HTML page.
3182,CVE-2019-5796," 
 #include ""extensions/browser/extension_registry.h""
 #include ""extensions/browser/extension_system.h""
 #include ""extensions/browser/extension_util.h""
#include ""extensions/browser/guest_view/mime_handler_view/mime_handler_view_attach_helper.h""
 #include ""extensions/browser/guest_view/web_view/web_view_guest.h""
 #include ""extensions/browser/guest_view/web_view/web_view_permission_helper.h""
 #include ""extensions/browser/guest_view/web_view/web_view_renderer_state.h""
  ChromeContentBrowserClient::CreateThrottlesForNavigation(
   if (base::FeatureList::IsEnabled(
           features::kMimeHandlerViewInCrossProcessFrame)) {
     auto plugin_frame_attach_throttle =
        extensions::MimeHandlerViewAttachHelper::MaybeCreateThrottle(handle);
     if (plugin_frame_attach_throttle)
       throttles.push_back(std::move(plugin_frame_attach_throttle));
   }",Data race in extensions guest view in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3183,CVE-2019-5797," 
  
 
 #include ""content/browser/dom_storage/dom_storage_context_impl.h""

 #include ""base/bind.h""
 #include ""base/files/file_util.h""
 #include ""base/files/scoped_temp_dir.h""",
3184,CVE-2019-5799,"  void Document::InitSecurityContext(const DocumentInit& initializer) {
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
  Document* origin_document =
      frame_ ? frame_->Loader().GetLastOriginDocument() : nullptr;
 
   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
  void Document::InitSecurityContext(const DocumentInit& initializer) {
         security_origin->SetOpaqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         security_origin->GrantLoadLocalResources();
      if (url_.IsEmpty())
        origin_document = owner;
     }
     SetSecurityOrigin(std::move(security_origin));
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
      
      
     SetSecurityOrigin(owner->GetMutableSecurityOrigin());
    if (url_.IsEmpty())
      origin_document = owner;
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
  void Document::InitSecurityContext(const DocumentInit& initializer) {
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
    InitContentSecurityPolicy(nullptr, origin_document);
   }
 
   if (Settings* settings = initializer.GetSettings()) {
  void Document::InitSecureContextState() {
  
  
  
void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp,
                                         const Document* origin_document) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 
  ContentSecurityPolicy* policy_to_inherit = nullptr;
  if (origin_document)
    policy_to_inherit = origin_document->GetContentSecurityPolicy();

   
   
  if (policy_to_inherit &&
      (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
       url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem""))) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }

  if (IsPluginDocument()) {
     
     
     
    if (origin_document) {
      GetContentSecurityPolicy()->CopyPluginTypesFrom(
          origin_document->GetContentSecurityPolicy());
    } else if (frame_) {
       Frame* inherit_from = frame_->Tree().Parent()
                                 ? frame_->Tree().Parent()
                                 : frame_->Client()->Opener();
       if (inherit_from && frame_ != inherit_from) {
         DCHECK(inherit_from->GetSecurityContext() &&
                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        GetContentSecurityPolicy()->CopyPluginTypesFrom(
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
       }
     }
  }
 }
 
 bool Document::IsSecureTransitionTo(const KURL& url) const {",Incorrect inheritance of a new document's policy in Content Security Policy in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to bypass content security policy via a crafted HTML page.
3185,CVE-2019-5800,"  void Document::InitSecurityContext(const DocumentInit& initializer) {
       AddInsecureNavigationUpgrade(to_upgrade);
   }
 
  Document* origin_document =
      frame_ ? frame_->Loader().GetLastOriginDocument() : nullptr;
 
   if (IsSandboxed(kSandboxOrigin)) {
     cookie_url_ = url_;
  void Document::InitSecurityContext(const DocumentInit& initializer) {
         security_origin->SetOpaqueOriginIsPotentiallyTrustworthy(true);
       if (owner->GetSecurityOrigin()->CanLoadLocalResources())
         security_origin->GrantLoadLocalResources();
      if (url_.IsEmpty())
        origin_document = owner;
     }
     SetSecurityOrigin(std::move(security_origin));
   } else if (Document* owner = initializer.OwnerDocument()) {
     cookie_url_ = owner->CookieURL();
      
      
     SetSecurityOrigin(owner->GetMutableSecurityOrigin());
    if (url_.IsEmpty())
      origin_document = owner;
   } else {
     cookie_url_ = url_;
     SetSecurityOrigin(SecurityOrigin::Create(url_));
  void Document::InitSecurityContext(const DocumentInit& initializer) {
     SetContentSecurityPolicy(
         ImportsController()->Master()->GetContentSecurityPolicy());
   } else {
    InitContentSecurityPolicy(nullptr, origin_document);
   }
 
   if (Settings* settings = initializer.GetSettings()) {
  void Document::InitSecureContextState() {
  
  
  
void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp,
                                         const Document* origin_document) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 
  ContentSecurityPolicy* policy_to_inherit = nullptr;
  if (origin_document)
    policy_to_inherit = origin_document->GetContentSecurityPolicy();

   
   
  if (policy_to_inherit &&
      (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
       url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem""))) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }

  if (IsPluginDocument()) {
     
     
     
    if (origin_document) {
      GetContentSecurityPolicy()->CopyPluginTypesFrom(
          origin_document->GetContentSecurityPolicy());
    } else if (frame_) {
       Frame* inherit_from = frame_->Tree().Parent()
                                 ? frame_->Tree().Parent()
                                 : frame_->Client()->Opener();
       if (inherit_from && frame_ != inherit_from) {
         DCHECK(inherit_from->GetSecurityContext() &&
                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        GetContentSecurityPolicy()->CopyPluginTypesFrom(
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
       }
     }
  }
 }
 
 bool Document::IsSecureTransitionTo(const KURL& url) const {",Insufficient policy enforcement in Blink in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to bypass content security policy via a crafted HTML page.
3186,CVE-2019-5802,"  UseCounterPageLoadMetricsObserver::GetAllowedUkmFeatures() {
           WebFeature::kDownloadInAdFrameWithoutUserGesture,
           WebFeature::kOpenWebDatabase,
           WebFeature::kV8MediaCapabilities_DecodingInfo_Method,
          WebFeature::kOpenerNavigationDownloadCrossOriginNoGesture,
       }));
   return *opt_in_features;
 }",Incorrect handling of download origins in Navigation in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to perform domain spoofing via a crafted HTML page.
3187,CVE-2019-5803," 
 #include ""third_party/blink/renderer/bindings/core/v8/binding_security.h""
 #include ""third_party/blink/renderer/bindings/core/v8/usv_string_or_trusted_url.h""
 #include ""third_party/blink/renderer/core/dom/document.h""
#include ""third_party/blink/renderer/core/frame/csp/content_security_policy.h""
 #include ""third_party/blink/renderer/core/frame/dom_window.h""
 #include ""third_party/blink/renderer/core/frame/local_dom_window.h""
 #include ""third_party/blink/renderer/core/frame/local_frame.h""
  void Location::SetLocation(const String& url,
   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))
     return;
 
   
   
   
   
   
  Document* current_document = current_window->document();
  if (current_document && completed_url.ProtocolIsJavaScript() &&
      !ContentSecurityPolicy::ShouldBypassMainWorld(current_document)) {
    String script_source = DecodeURLEscapeSequences(completed_url.GetString());
    if (!current_document->GetContentSecurityPolicy()->AllowJavaScriptURLs(
            nullptr, script_source, current_document->Url(), OrdinalNumber())) {
      return;
    }
  }

   V8DOMActivityLogger* activity_logger =
       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();
   if (activity_logger) {",Insufficient policy enforcement in Content Security Policy in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to bypass content security policy via a crafted HTML page.
3188,CVE-2019-5804,"  std::vector<std::wstring> TokenizeCommandLineToArray(
 
 std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
  static constexpr wchar_t kSwitchTerminator[] = L""--"";
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
  for (auto scan = as_array.cbegin(); scan != end; ++scan) {
    const std::wstring& arg = *scan;
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }",Incorrect command line processing in Chrome in Google Chrome prior to 73.0.3683.75 allowed a local attacker to perform domain spoofing via a crafted domain name.
3189,CVE-2019-5786,"  DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  if (!finished_loading_) {
    return DOMArrayBuffer::Create(
        ArrayBuffer::Create(raw_data_->Data(), raw_data_->ByteLength()));
   }

  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  AdjustReportedMemoryUsageToV8(-1 *
                                static_cast<int64_t>(raw_data_->ByteLength()));
  raw_data_.reset();
  return array_buffer_result_;
 }
 
 String FileReaderLoader::StringResult() {",Object lifetime issue in Blink in Google Chrome prior to 72.0.3626.121 allowed a remote attacker to potentially perform out of bounds memory access via a crafted HTML page.
3190,CVE-2019-5754,"  void ConfigureQuicParams(base::StringPiece quic_trial_group,
   if (params->enable_quic) {
     params->enable_quic_proxies_for_https_urls =
         ShouldEnableQuicProxiesForHttpsUrls(quic_trial_params);
     params->quic_connection_options =
         GetQuicConnectionOptions(quic_trial_params);
     params->quic_client_connection_options =",Implementation error in QUIC Networking in Google Chrome prior to 72.0.3626.81 allowed an attacker running or able to cause use of a proxy server to obtain cleartext of transport encryption via malicious network proxy.
3191,CVE-2019-5757," 
 #include ""third_party/blink/renderer/core/dom/document.h""
 #include ""third_party/blink/renderer/core/dom/element_traversal.h""
 #include ""third_party/blink/renderer/core/dom/events/event.h""
#include ""third_party/blink/renderer/core/dom/flat_tree_traversal.h""
 #include ""third_party/blink/renderer/core/dom/node_computed_style.h""
 #include ""third_party/blink/renderer/core/dom/shadow_root.h""
 #include ""third_party/blink/renderer/core/frame/csp/content_security_policy.h""
  bool SVGElement::LayoutObjectIsNeeded(const ComputedStyle& style) const {
 }
 
 bool SVGElement::HasSVGParent() const {
  Element* parent = FlatTreeTraversal::ParentElement(*this);
  return parent && parent->IsSVGElement();
 }
 
 MutableCSSPropertyValueSet* SVGElement::AnimatedSMILStyleProperties() const {",An incorrect object type assumption in SVG in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit object corruption via a crafted HTML page.
3192,CVE-2019-5758,"  void ImageBitmapFactories::DidFinishLoading(ImageBitmapLoader* loader) {
   pending_loaders_.erase(loader);
 }
 
void ImageBitmapFactories::Trace(blink::Visitor* visitor) {
  visitor->Trace(pending_loaders_);
  Supplement<LocalDOMWindow>::Trace(visitor);
  Supplement<WorkerGlobalScope>::Trace(visitor);
}

 ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(
     ImageBitmapFactories& factory,
     base::Optional<IntRect> crop_rect,
     ScriptState* script_state,
     const ImageBitmapOptions* options)
    : ContextLifecycleObserver(ExecutionContext::From(script_state)),
      loader_(
           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),
       factory_(&factory),
       resolver_(ScriptPromiseResolver::Create(script_state)),
       crop_rect_(crop_rect),
       options_(options) {}
 
void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(Blob* blob) {
   loader_->Start(blob->GetBlobDataHandle());
 }
 
ImageBitmapFactories::ImageBitmapLoader::~ImageBitmapLoader() {
  DCHECK(!loader_);
 }
 
 void ImageBitmapFactories::ImageBitmapLoader::RejectPromise(
  void ImageBitmapFactories::ImageBitmapLoader::RejectPromise(
     default:
       NOTREACHED();
   }
  loader_.reset();
   factory_->DidFinishLoading(this);
 }
 
void ImageBitmapFactories::ImageBitmapLoader::ContextDestroyed(
    ExecutionContext*) {
  if (loader_)
    factory_->DidFinishLoading(this);
  loader_.reset();
}

 void ImageBitmapFactories::ImageBitmapLoader::DidFinishLoading() {
   DOMArrayBuffer* array_buffer = loader_->ArrayBufferResult();
  loader_.reset();
   if (!array_buffer) {
     RejectPromise(kAllocationFailureImageBitmapRejectionReason);
     return;
  void ImageBitmapFactories::ImageBitmapLoader::ResolvePromiseOnOriginalThread(
 }
 
 void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {
  ContextLifecycleObserver::Trace(visitor);
   visitor->Trace(factory_);
   visitor->Trace(resolver_);
   visitor->Trace(options_);",Incorrect object lifecycle management in Blink in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3193,CVE-2019-5759," 
 #include ""content/renderer/render_view_impl.h""
 #include ""testing/gtest/include/gtest/gtest.h""
 #include ""third_party/blink/public/platform/web_size.h""
#include ""third_party/blink/public/web/web_local_frame.h""
 #include ""third_party/blink/public/web/web_view.h""
 
  
  TEST_F(ExternalPopupMenuRemoveTest, RemoveOnChange) {
   EXPECT_FALSE(SimulateElementClick(kSelectID));
 }
 
 
TEST_F(ExternalPopupMenuRemoveTest, RemoveFrameOnChange) {
  LoadHTML(
      ""<style>* { margin: 0; } iframe { border: 0; }</style>""
      ""<body><iframe srcdoc=\""""
      ""<style>* { margin: 0; }</style><select><option>opt1<option>opt2""
      ""\""></iframe>""
      ""<script>""
      ""onload = function() {""
      ""  const frame = document.querySelector('iframe');""
      ""  frame.contentDocument.querySelector('select').onchange = ""
      ""      () => { frame.remove(); };""
      ""};""
      ""</script>"");
   
  SimulatePointClick(gfx::Point(8, 8));
   
   
  auto* child_web_frame =
      static_cast<blink::WebLocalFrame*>(frame()->GetWebFrame()->FirstChild());
  static_cast<RenderFrameImpl*>(RenderFrame::FromWebFrame(child_web_frame))
      ->OnSelectPopupMenuItem(1);
   
}

 class ExternalPopupMenuDisplayNoneTest : public ExternalPopupMenuTest {
   public:
   ExternalPopupMenuDisplayNoneTest() {}",Incorrect lifetime handling in HTML select elements in Google Chrome on Android and Mac prior to 72.0.3626.81 allowed a remote attacker to potentially perform a sandbox escape via a crafted HTML page.
3194,CVE-2019-5760,"  class RTCPeerConnectionHandler::WebRtcSetDescriptionObserverImpl
     }
 
     if (handler_) {
       
       handler_->OnSignalingChange(states.signaling_state);
 
        
  class RTCPeerConnectionHandler::WebRtcSetDescriptionObserverImpl
         ProcessStateChangesUnifiedPlan(std::move(states));
       }
 
      if (tracker_ && handler_) {
         tracker_->TrackSessionDescriptionCallback(handler_.get(), action_,
                                                   ""OnSuccess"", """");
       }
  class RTCPeerConnectionHandler::WebRtcSetDescriptionObserverImpl
 
   void ProcessStateChangesPlanB(WebRtcSetDescriptionObserver::States states) {
     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kPlanB);
    if (!handler_)
      return;

      
      
     std::vector<RTCRtpReceiver*> removed_receivers;
  class RTCPeerConnectionHandler::WebRtcSetDescriptionObserverImpl
 
      
     for (auto& transceiver_state : states.transceiver_states) {
      if (handler_ && ReceiverWasAdded(transceiver_state)) {
         
         handler_->OnAddReceiverPlanB(transceiver_state.MoveReceiverState());
       }
     }
      
     for (auto* removed_receiver : removed_receivers) {
      if (handler_) {
         
        handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(
            removed_receiver->state().webrtc_receiver().get()));
      }
     }
   }
 
   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
    DCHECK(handler_);
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
  class RTCPeerConnectionHandler::WebRtcSetDescriptionObserverImpl
   void ProcessStateChangesUnifiedPlan(
       WebRtcSetDescriptionObserver::States states) {
     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kUnifiedPlan);
    if (handler_) {
      handler_->OnModifyTransceivers(
          std::move(states.transceiver_states),
          action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);
    }
   }
 
   base::WeakPtr<RTCPeerConnectionHandler> handler_;",Insufficient checks of pointer validity in WebRTC in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3195,CVE-2019-5755,"  void FileSystemManagerImpl::CreateWriter(const GURL& file_path,
                                          CreateWriterCallback callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
  if (!base::FeatureList::IsEnabled(blink::features::kWritableFilesAPI)) {
    bindings_.ReportBadMessage(""FileSystemManager.CreateWriter"");
    return;
  }

   FileSystemURL url(context_->CrackURL(file_path));
   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);
   if (opt_error) {",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
3196,CVE-2019-5755,"  PaymentRequest::PaymentRequest(
     mojo::InterfaceRequest<mojom::PaymentRequest> request,
     ObserverForTest* observer_for_testing)
     : web_contents_(web_contents),
      log_(web_contents_),
       delegate_(std::move(delegate)),
       manager_(manager),
       display_manager_(display_manager),
  void PaymentRequest::Init(mojom::PaymentRequestClientPtr client,
                           mojom::PaymentDetailsPtr details,
                           mojom::PaymentOptionsPtr options) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (is_initialized_) {
    log_.Error(""Attempted initialization twice"");
    OnConnectionTerminated();
    return;
  }

  is_initialized_ = true;
   client_ = std::move(client);
 
   const GURL last_committed_url = delegate_->GetLastCommittedURL();
   if (!OriginSecurityChecker::IsOriginSecure(last_committed_url)) {
    log_.Error(""Not in a secure origin"");
     OnConnectionTerminated();
     return;
   }
  void PaymentRequest::Init(mojom::PaymentRequestClientPtr client,
       OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) ||
       OriginSecurityChecker::IsOriginLocalhostOrFile(last_committed_url);
   if (!allowed_origin) {
    log_.Error(
        ""Only localhost, file://, and cryptographic scheme origins allowed"");
   }
 
   bool invalid_ssl =
       OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) &&
       !delegate_->IsSslCertificateValid();
  if (invalid_ssl) {
    log_.Error(""SSL certificate is not valid."");
  }
 
   if (!allowed_origin || invalid_ssl) {
     
    log_.Error(
        ""No UI will be shown. CanMakePayment will always return false. ""
        ""Show will be rejected with NotSupportedError."");
     return;
   }
 
   std::string error;
   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {
    log_.Error(error);
     OnConnectionTerminated();
     return;
   }
 
   if (!details->total) {
    log_.Error(""Missing total"");
     OnConnectionTerminated();
     return;
   }
  void PaymentRequest::Init(mojom::PaymentRequestClientPtr client,
 }
 
 void PaymentRequest::Show(bool is_user_gesture) {
  if (!IsInitialized()) {
    log_.Error(""Attempted show without initialization"");
    OnConnectionTerminated();
    return;
  }

  if (is_show_called_) {
    log_.Error(""Attempted show twice"");
     OnConnectionTerminated();
     return;
   }
 
  is_show_called_ = true;

    
   display_handle_ = display_manager_->TryShow(delegate_.get());
   if (!display_handle_) {
    log_.Error(""A PaymentRequest UI is already showing"");
     journey_logger_.SetNotShown(
         JourneyLogger::NOT_SHOWN_REASON_CONCURRENT_REQUESTS);
     client_->OnError(mojom::PaymentErrorReason::ALREADY_SHOWING);
  void PaymentRequest::Show(bool is_user_gesture) {
   }
 
   if (!delegate_->IsBrowserWindowActive()) {
    log_.Error(""Cannot show PaymentRequest UI in a background tab"");
     journey_logger_.SetNotShown(JourneyLogger::NOT_SHOWN_REASON_OTHER);
     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);
     OnConnectionTerminated();
     return;
   }
 
   if (!state_) {
     
     
     AreRequestedMethodsSupportedCallback(false);
     return;
   }
  void PaymentRequest::Show(bool is_user_gesture) {
 }
 
 void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {
  if (!IsInitialized()) {
    log_.Error(""Attempted retry without initialization"");
     OnConnectionTerminated();
     return;
   }
 
  if (!IsThisPaymentRequestShowing()) {
    log_.Error(""Attempted retry without show"");
     OnConnectionTerminated();
     return;
   }
 
   std::string error;
   if (!PaymentsValidators::IsValidPaymentValidationErrorsFormat(errors,
                                                                 &error)) {
    log_.Error(error);
     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);
     OnConnectionTerminated();
     return;
  void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {
   display_handle_->Retry();
 }
 
void PaymentRequest::UpdateWith(mojom::PaymentDetailsPtr details) {
  if (!IsInitialized()) {
    log_.Error(""Attempted updateWith without initialization"");
     OnConnectionTerminated();
    return;
   }
 
  if (!IsThisPaymentRequestShowing()) {
    log_.Error(""Attempted updateWith without show"");
    OnConnectionTerminated();
    return;
  }
 
   std::string error;
   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {
    log_.Error(error);
     OnConnectionTerminated();
     return;
   }
 
   if (details->shipping_address_errors &&
       !PaymentsValidators::IsValidAddressErrorsFormat(
           details->shipping_address_errors, &error)) {
    log_.Error(error);
     OnConnectionTerminated();
     return;
   }
 
   if (!details->total) {
    log_.Error(""Missing total"");
     OnConnectionTerminated();
     return;
   }
  void PaymentRequest::UpdateWith(mojom::PaymentDetailsPtr details) {
 }
 
 void PaymentRequest::NoUpdatedPaymentDetails() {
   
   
   
  if (!IsInitialized()) {
    log_.Error(""Not initialized"");
    OnConnectionTerminated();
    return;
  }

  if (!IsThisPaymentRequestShowing()) {
    log_.Error(""Not shown"");
    OnConnectionTerminated();
    return;
  }

   spec_->RecomputeSpecForDetails();
 }
 
 void PaymentRequest::Abort() {
  if (!IsInitialized()) {
    log_.Error(""Attempted abort without initialization"");
    OnConnectionTerminated();
    return;
  }

  if (!IsThisPaymentRequestShowing()) {
    log_.Error(""Attempted abort without show"");
    OnConnectionTerminated();
    return;
  }

    
    
    
  void PaymentRequest::Abort() {
 }
 
 void PaymentRequest::Complete(mojom::PaymentComplete result) {
  if (!IsInitialized()) {
    log_.Error(""Attempted complete without initialization"");
    OnConnectionTerminated();
     return;
  }

  if (!IsThisPaymentRequestShowing()) {
    log_.Error(""Attempted complete without show"");
    OnConnectionTerminated();
    return;
  }
 
    
    
  void PaymentRequest::Complete(mojom::PaymentComplete result) {
 }
 
 void PaymentRequest::CanMakePayment() {
  if (!IsInitialized()) {
    log_.Error(""Attempted canMakePayment without initialization"");
    OnConnectionTerminated();
    return;
  }

   

   if (observer_for_testing_)
     observer_for_testing_->OnCanMakePaymentCalled();
 
  void PaymentRequest::CanMakePayment() {
   }
 }
 
void PaymentRequest::AreRequestedMethodsSupportedCallback(
    bool methods_supported) {
  if (methods_supported) {
    if (SatisfiesSkipUIConstraints()) {
      skipped_payment_request_ui_ = true;
      Pay();
    }
  } else {
    journey_logger_.SetNotShown(
        JourneyLogger::NOT_SHOWN_REASON_NO_SUPPORTED_PAYMENT_METHOD);
    client_->OnError(mojom::PaymentErrorReason::NOT_SUPPORTED);
    if (observer_for_testing_)
      observer_for_testing_->OnNotSupportedError();
    OnConnectionTerminated();
  }
}

bool PaymentRequest::IsInitialized() const {
  return is_initialized_ && client_ && client_.is_bound() &&
         binding_.is_bound();
}

bool PaymentRequest::IsThisPaymentRequestShowing() const {
  return is_show_called_ && display_handle_ && spec_ && state_;
}

bool PaymentRequest::SatisfiesSkipUIConstraints() const {
  return base::FeatureList::IsEnabled(features::kWebPaymentsSingleAppUiSkip) &&
         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&
         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&
         state()->available_instruments().size() == 1 &&
         spec()->stringified_method_data().size() == 1 &&
         !spec()->request_shipping() && !spec()->request_payer_name() &&
         !spec()->request_payer_phone() &&
         !spec()->request_payer_email()
          
         && spec()->url_payment_method_identifiers().size() == 1;
}

 void PaymentRequest::OnPaymentResponseAvailable(
     mojom::PaymentResponsePtr response) {
   journey_logger_.SetEventOccurred(",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
3197,CVE-2019-5755,"  void RenderFrameHostImpl::RegisterMojoInterfaces() {
         base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));
 
     registry_->AddInterface(
        base::BindRepeating(&MediaStreamDispatcherHost::Create,
                            GetProcess()->GetID(), GetRoutingID(),
                            base::Unretained(media_stream_manager)),
         base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));
   }
 
  void RenderFrameHostImpl::CreateAudioOutputStreamFactory(
   }
 }
 
 void RenderFrameHostImpl::BindMediaInterfaceFactoryRequest(
     media::mojom::InterfaceFactoryRequest request) {
   DCHECK(!media_interface_proxy_);",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
3198,CVE-2019-5785,"  SK_API void SkDebugf_FileLine(const char* file, int line, bool fatal,
 #define SK_USE_LEGACY_DISTANCE_FIELDS
 #endif
 
  
  
 #ifndef SK_DISABLE_EXPLICIT_GPU_RESOURCE_ALLOCATION",Incorrect convexity calculations in Skia in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform an out of bounds memory write via a crafted HTML page.
3199,CVE-2019-5768," 
 namespace content {
 namespace protocol {
 
DOMHandler::DOMHandler(bool allow_file_access)
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr),
      allow_file_access_(allow_file_access) {}
 
 DOMHandler::~DOMHandler() {
 }
  Response DOMHandler::SetFileInputFiles(
     Maybe<DOM::NodeId> node_id,
     Maybe<DOM::BackendNodeId> backend_node_id,
     Maybe<String> in_object_id) {
  if (!allow_file_access_)
    return Response::Error(""Not allowed"");
   if (host_) {
     for (size_t i = 0; i < files->length(); i++) {
 #if defined(OS_WIN)",DevTools API not correctly gating on extension capability in DevTools in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to read local files via a crafted Chrome Extension.
3200,CVE-2019-5769,"  void ShapeResult::RunInfo::CharacterIndexForXPosition(
    
    
    
  if (break_glyphs_option == BreakGlyphs &&
      glyph_sequence_end > glyph_sequence_start) {
     int graphemes = NumGraphemes(glyph_sequence_start, glyph_sequence_end);
     if (graphemes > 1) {
       float unit_size = result->advance / graphemes;",Incorrect handling of invalid end character position when front rendering in Blink in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3201,CVE-2019-5775,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   
   
   
   
   
    
   
    
   
   
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(
  IDNSpoofChecker::IDNSpoofChecker() {
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
           ""  > d; [] > g; [] > s;  > j;""
          ""[] > o;""
          ""[] > q;""
          ""[] > u;""
          ""[] > 2;""
          ""[] > 3;""
          ""[] > 4;""
          ""[] > 8;""
          ""[] > 9;""
      ),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of a confusable character in Omnibox in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3202,CVE-2019-5776,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
   cyrillic_letters_latin_alike_ = icu::UnicodeSet(
      icu::UnicodeString::fromUTF8(""[]""), status);
   cyrillic_letters_latin_alike_.freeze();
 
   cyrillic_letters_ =",Incorrect handling of a confusable character in Omnibox in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3203,CVE-2019-5777,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   
   
   
   
   
    
   
    
   
   
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(
  IDNSpoofChecker::IDNSpoofChecker() {
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
           ""  > d; [] > g; [] > s;  > j;""
          ""[] > o;""
          ""[] > q;""
          ""[] > u;""
          ""[] > 2;""
          ""[] > 3;""
          ""[] > 4;""
          ""[] > 8;""
          ""[] > 9;""
      ),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of a confusable character in Omnibox in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3204,CVE-2018-20073,"  IN_PROC_BROWSER_TEST_F(DownloadTest, DownloadMimeType) {
   CheckDownload(browser(), file, file);
 }
 
#if defined(OS_WIN) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
  
  
  ",Use of extended attributes in downloads in Google Chrome prior to 72.0.3626.81 allowed a local attacker to read download URLs via the filesystem.
3205,CVE-2019-5778," 
 #include ""base/json/json_writer.h""
 #include ""base/values.h""
 #include ""chrome/common/extensions/api/permissions.h""
#include ""content/public/common/url_constants.h""
 #include ""extensions/common/error_utils.h""
 #include ""extensions/common/extension.h""
 #include ""extensions/common/permissions/permission_set.h""
  bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
     explicit_schemes &= ~URLPattern::SCHEME_FILE;
   }
 
  auto filter_chrome_scheme = [](URLPattern* pattern) {
     
     
     
     
     
     
     
     
    if (pattern->scheme() != content::kChromeUIScheme) {
       
       
       
       
      pattern->SetValidSchemes(pattern->valid_schemes() &
                               ~URLPattern::SCHEME_CHROMEUI);
    }
  };

   for (const auto& origin_str : origins_input) {
     URLPattern explicit_origin(explicit_schemes);
     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);
  bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
       return false;
     }
 
    filter_chrome_scheme(&explicit_origin);

     bool used_origin = false;
     if (required_permissions.explicit_hosts().ContainsPattern(
             explicit_origin)) {
  bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
 
     URLPattern scriptable_origin(user_script_schemes);
     if (scriptable_origin.Parse(origin_str) ==
        URLPattern::ParseResult::kSuccess) {
      filter_chrome_scheme(&scriptable_origin);
      if (required_permissions.scriptable_hosts().ContainsPattern(
              scriptable_origin)) {
        used_origin = true;
        result->required_scriptable_hosts.AddPattern(scriptable_origin);
      }
     }
 
     if (!used_origin)",A missing case for handling special schemes in permission request checks in Extensions in Google Chrome prior to 72.0.3626.81 allowed an attacker who convinced a user to install a malicious extension to bypass extension permission checks for privileged pages via a crafted Chrome Extension.
3206,CVE-2019-5779,"  std::vector<std::string> ChromeContentBrowserClient::GetStartupServices() {
 }
 
 void ChromeContentBrowserClient::OpenURL(
    content::SiteInstance* site_instance,
     const content::OpenURLParams& params,
    const base::RepeatingCallback<void(content::WebContents*)>& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
  DCHECK(ShouldAllowOpenURL(site_instance, params.url));

  content::BrowserContext* browser_context = site_instance->GetBrowserContext();
 
 #if defined(OS_ANDROID)
   ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,",Insufficient policy validation in ServiceWorker in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to bypass navigation restrictions via a crafted HTML page.
3207,CVE-2019-5781,"  class CORE_EXPORT HTMLSlotElement final : public HTMLElement {
   const HeapVector<Member<Node>> FlattenedAssignedNodes();
 
   Node* FirstAssignedNode() const {
    auto& nodes = AssignedNodes();
    return nodes.IsEmpty() ? nullptr : nodes.front().Get();
   }
   Node* LastAssignedNode() const {
    auto& nodes = AssignedNodes();
    return nodes.IsEmpty() ? nullptr : nodes.back().Get();
   }
 
   Node* FirstDistributedNode() const {",Incorrect handling of a confusable character in Omnibox in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
3208,CVE-2018-17479," 
 #include <string.h>
 
 #include ""base/atomicops.h""
#include ""base/numerics/checked_math.h""
 #include ""gpu/command_buffer/common/cmd_buffer_common.h""
 
 namespace gpu {
  struct SizedResult {
 
    
    
  static uint32_t ComputeSize(base::CheckedNumeric<uint32_t> num_results) {
    base::CheckedNumeric<uint32_t> size = num_results;
    size *= sizeof(T);
    size += sizeof(uint32_t);
    return size.ValueOrDie();
   }
 
    
   static uint32_t ComputeMaxResults(size_t size_of_buffer) {
    base::CheckedNumeric<uint32_t> max_results = 0;
    if (size_of_buffer >= sizeof(uint32_t)) {
      max_results = size_of_buffer;
      max_results -= sizeof(uint32_t);
      max_results /= sizeof(T);
    }
    return max_results.ValueOrDefault(0);
   }
 
    
  void SetNumResults(base::CheckedNumeric<uint32_t> num_results) {
    base::CheckedNumeric<uint32_t> bytes = num_results;
    bytes *= sizeof(T);
    size = bytes.ValueOrDie();
   }
 
    
   int32_t GetNumResults() const {
     
     
    base::CheckedNumeric<uint32_t> num_results = size;
    num_results /= sizeof(T);
    return num_results.ValueOrDie<int32_t>();
   }
 
    ",Incorrect object lifetime calculations in GPU code in Google Chrome prior to 70.0.3538.110 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3209,CVE-2018-6154,"  void WebGL2RenderingContextBase::framebufferTextureLayer(GLenum target,
                              ""framebufferTextureLayer"", target, attachment))
     return;
   if (texture && !texture->Validate(ContextGroup(), this)) {
    SynthesizeGLError(GL_INVALID_OPERATION, ""framebufferTextureLayer"",
                      ""texture does not belong to this context"");
     return;
   }
   GLenum textarget = texture ? texture->GetTarget() : 0;
  GLboolean WebGL2RenderingContextBase::isSampler(WebGLSampler* sampler) {
 
 void WebGL2RenderingContextBase::bindSampler(GLuint unit,
                                              WebGLSampler* sampler) {
   bool deleted;
   if (!CheckObjectToBeBound(""bindSampler"", sampler, deleted))
     return;
  void WebGL2RenderingContextBase::deleteTransformFeedback(
 
 GLboolean WebGL2RenderingContextBase::isTransformFeedback(
     WebGLTransformFeedback* feedback) {
  if (isContextLost() || !feedback || !feedback->Validate(ContextGroup(), this))
     return 0;
 
   if (!feedback->HasEverBeenBound())
  WebGLVertexArrayObject* WebGL2RenderingContextBase::createVertexArray() {
 
 void WebGL2RenderingContextBase::deleteVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  if (isContextLost() || !vertex_array ||
      !ValidateWebGLObject(""deleteVertexArray"", vertex_array))
     return;
 
   if (!vertex_array->IsDefaultObject() &&
  void WebGL2RenderingContextBase::deleteVertexArray(
 
 GLboolean WebGL2RenderingContextBase::isVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  if (isContextLost() || !vertex_array ||
      !vertex_array->Validate(ContextGroup(), this))
     return 0;
 
   if (!vertex_array->HasEverBeenBound())
  GLboolean WebGL2RenderingContextBase::isVertexArray(
 
 void WebGL2RenderingContextBase::bindVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  bool deleted;
  if (!CheckObjectToBeBound(""bindVertexArray"", vertex_array, deleted))
     return;
  if (deleted) {
     SynthesizeGLError(GL_INVALID_OPERATION, ""bindVertexArray"",
                      ""attempt to bind a deleted vertex array"");
     return;
   }
 ",Insufficient data validation in WebGL in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3210,CVE-2018-6156,"  WRAPPED_INSTANTIATE_TEST_CASE_P(
     ::testing::Values(
         TestParameter(NOT_IN_GUEST_MODE, ""showHiddenFilesOnDownloads""),
         TestParameter(NOT_IN_GUEST_MODE, ""showHiddenFilesOnDrive""),
        TestParameter(NOT_IN_GUEST_MODE, ""hideGoogleDocs""),
        TestParameter(NOT_IN_GUEST_MODE, ""showPasteInGearMenu"")));
 
  
 struct TestAccountInfo {",Incorect derivation of a packet length in WebRTC in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted video file.
3211,CVE-2018-6162,"  void WebGLRenderingContextBase::TexImageHelperImageData(
         adjusted_source_image_rect.Height(), format, type, bytes);
   } else {
     GLint upload_height = adjusted_source_image_rect.Height();
     if (function_id == kTexImage3D) {
       ContextGL()->TexImage3D(target, level, internalformat,
                               adjusted_source_image_rect.Width(), upload_height,",Improper deserialization in WebGL in Google Chrome on Mac prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3212,CVE-2018-6163,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
  IDNSpoofChecker::IDNSpoofChecker() {
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
           ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3; [] > u""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3213,CVE-2018-6165,"  void NavigationControllerImpl::Reload(ReloadType reload_type,
       reload_type = ReloadType::NONE;
 
       nav_entry->set_should_replace_entry(true);
      nav_entry->set_is_renderer_initiated(entry->is_renderer_initiated());
       pending_entry_ = nav_entry;
       DCHECK_EQ(-1, pending_entry_index_);
     } else {",Incorrect handling of reloads in Navigation in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3214,CVE-2018-6166,"  IDNSpoofChecker::IDNSpoofChecker() {
       UTRANS_FORWARD, parse_error, status));
 
    
   
    
    
    
    
    
   
   
   
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(
          ""[] > ae; [] > p; [] > h;""
          ""[] > k; [] > n;  > ce;""
          ""[] > t; [] > b;  [] > w;""
          ""[] > m; [] > e;  > r; [] > f;""
          ""[] > c;  > y; [] > x;""
          ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: ""
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
      
      
      ",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3215,CVE-2018-6167,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(
           ""[] > ae; [] > p; [] > h;""
           ""[] > k; [] > n;  > ce;""
          ""[] > t; [] > b;  [] > w;""
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
          ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3; [] > u""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3216,CVE-2018-6168,"  void MetalayerMode::OnVoiceInteractionContextEnabled(bool enabled) {
   UpdateState();
 }
 
void MetalayerMode::OnAssistantFeatureAllowedChanged(
    mojom::AssistantAllowedState state) {
  assistant_allowed_state_ = state;
  UpdateState();
}

 void MetalayerMode::UpdateState() {
   if (enabled() && !selectable())
     delegate()->DisableTool(GetToolId());",Information leak in media engine in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.
3217,CVE-2018-6169," 
 #include ""ui/views/layout/box_layout.h""
 #include ""ui/views/layout/grid_layout.h""
 #include ""ui/views/widget/widget.h""
#include ""ui/views/window/dialog_client_view.h""
 
 using content::OpenURLParams;
 using content::Referrer;
  int GetLeftPaddingForBulletedItems(bool parent_bulleted) {
          (parent_bulleted ? 2 : 1);
 }
 
 
int g_install_delay_in_ms = 500;

 void AddResourceIcon(const gfx::ImageSkia* skia_image, void* data) {
   views::View* parent = static_cast<views::View*>(data);
   views::ImageView* image_view = new views::ImageView();
  ExtensionInstallDialogView::ExtensionInstallDialogView(
       prompt_(std::move(prompt)),
       container_(NULL),
       scroll_view_(NULL),
      handled_result_(false),
      install_button_enabled_(false) {
   InitView();
 }
 
  views::View* ExtensionInstallDialogView::CreateExtraView() {
   return store_link;
 }
 
bool ExtensionInstallDialogView::IsDialogButtonEnabled(
    ui::DialogButton button) const {
  if (button == ui::DIALOG_BUTTON_OK)
    return install_button_enabled_;
  return true;
}

void ExtensionInstallDialogView::SetInstallButtonDelayForTesting(
    int delay_in_ms) {
  g_install_delay_in_ms = delay_in_ms;
}

void ExtensionInstallDialogView::VisibilityChanged(views::View* starting_from,
                                                   bool is_visible) {
  if (is_visible && !install_button_enabled_) {
     
     
    timer_.Start(FROM_HERE,
                 base::TimeDelta::FromMilliseconds(g_install_delay_in_ms),
                 base::Bind(&ExtensionInstallDialogView::EnableInstallButton,
                            base::Unretained(this)));
  }
}

void ExtensionInstallDialogView::EnableInstallButton() {
  install_button_enabled_ = true;
  GetDialogClientView()->UpdateDialogButtons();
}

 void ExtensionInstallDialogView::UpdateInstallResultHistogram(bool accepted)
     const {
   if (prompt_->type() == ExtensionInstallPrompt::INSTALL_PROMPT)",Lack of timeout on extension install prompt in Extensions in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to trigger installation of an unwanted extension via a crafted HTML page.
3218,CVE-2018-6171,"  BluetoothSocketSendFunction::~BluetoothSocketSendFunction() {}
 ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  params_ = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params_.get());
 
  io_buffer_size_ = params_->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params_->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params_->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 ",Use after free in Bluetooth in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to obtain potentially sensitive information from process memory via a crafted Chrome Extension.
3219,CVE-2018-6172,"  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
    
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
  IDNSpoofChecker::IDNSpoofChecker() {
           ""[] > m; [] > e;  > r; [] > f;""
           ""[] > c;  > y; [] > x;""
           ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3; [] > u""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: """,Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3220,CVE-2018-6173,"  IDNSpoofChecker::IDNSpoofChecker() {
       UTRANS_FORWARD, parse_error, status));
 
    
   
    
    
    
    
    
   
   
   
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(
          ""[] > ae; [] > p; [] > h;""
          ""[] > k; [] > n;  > ce;""
          ""[] > t; [] > b;  [] > w;""
          ""[] > m; [] > e;  > r; [] > f;""
          ""[] > c;  > y; [] > x;""
          ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: ""
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
      
      
      ",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3221,CVE-2018-6175,"  IDNSpoofChecker::IDNSpoofChecker() {
       UTRANS_FORWARD, parse_error, status));
 
    
   
    
    
    
    
    
   
   
   
   
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
   
   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(
          ""[] > ae; [] > p; [] > h;""
          ""[] > k; [] > n;  > ce;""
          ""[] > t; [] > b;  [] > w;""
          ""[] > m; [] > e;  > r; [] > f;""
          ""[] > c;  > y; [] > x;""
          ""  > d; [] > g; [] > s;  > j;""
          ""[] > 3""),
       UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: ""
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
      
      
      
      
      
      ",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3222,CVE-2018-6178,"  class GlobalConfirmInfoBar::DelegateProxy : public ConfirmInfoBarDelegate {
    
   infobars::InfoBarDelegate::InfoBarIdentifier GetIdentifier() const override;
   base::string16 GetMessageText() const override;
  gfx::ElideBehavior GetMessageElideBehavior() const override;
   int GetButtons() const override;
   base::string16 GetButtonLabel(InfoBarButton button) const override;
   bool Accept() override;
  base::string16 GlobalConfirmInfoBar::DelegateProxy::GetMessageText() const {
                           : base::string16();
 }
 
gfx::ElideBehavior
GlobalConfirmInfoBar::DelegateProxy::GetMessageElideBehavior() const {
  return global_info_bar_
             ? global_info_bar_->delegate_->GetMessageElideBehavior()
             : ConfirmInfoBarDelegate::GetMessageElideBehavior();
}

 int GlobalConfirmInfoBar::DelegateProxy::GetButtons() const {
   return global_info_bar_ ? global_info_bar_->delegate_->GetButtons()
                           : 0;",Eliding from the wrong side in an infobar in DevTools in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to Hide Chrome Security UI via a crafted Chrome Extension.
3223,CVE-2018-6179," 
 #include ""chrome/browser/ui/browser.h""
 #include ""chrome/browser/ui/tabs/tab_strip_model.h""
 #include ""chrome/test/base/ui_test_utils.h""
#include ""content/public/test/browser_test_utils.h""
 #include ""content/public/test/test_utils.h""
 #include ""extensions/browser/extension_registry.h""
 #include ""extensions/browser/test_extension_registry_observer.h""
  IN_PROC_BROWSER_TEST_F(ExtensionApiTest, FileURLs) {
     return result == ""true"";
   };
 
  auto can_load_file_iframe = [this, &extension_id]() {
    const Extension* extension =
        extension_service()->GetExtensionById(extension_id, false);

     
    GURL page = extension->GetResourceURL(""file_iframe.html"");
    ExtensionTestMessageListener listener(false  );
    ui_test_utils::NavigateToURLWithDisposition(
        browser(), page, WindowOpenDisposition::NEW_FOREGROUND_TAB,
        ui_test_utils::BROWSER_TEST_WAIT_FOR_NAVIGATION);
    EXPECT_TRUE(listener.WaitUntilSatisfied());

    EXPECT_TRUE(listener.message() == ""allowed"" ||
                listener.message() == ""denied"")
        << ""Unexpected message "" << listener.message();
    bool allowed = listener.message() == ""allowed"";

     
    content::RenderFrameHost* file_iframe = content::FrameMatchingPredicate(
        browser()->tab_strip_model()->GetActiveWebContents(),
        base::Bind(&content::FrameMatchesName, ""file_iframe""));
    bool is_file_url = file_iframe->GetLastCommittedURL() == GURL(""file:///"");
    EXPECT_EQ(allowed, is_file_url)
        << ""Unexpected committed url: ""
        << file_iframe->GetLastCommittedURL().spec();

    browser()->tab_strip_model()->CloseSelectedTabs();
    return allowed;
  };

   auto can_script_tab = [this, &extension_id](int tab_id) {
     constexpr char script[] = R""(
       var tabID = %d;
  IN_PROC_BROWSER_TEST_F(ExtensionApiTest, FileURLs) {
    
    
    
   
   EXPECT_TRUE(util::AllowFileAccess(extension_id, profile()));
   EXPECT_FALSE(can_xhr_file_urls());
   EXPECT_FALSE(can_script_tab(active_tab_id));
   EXPECT_FALSE(can_script_tab(inactive_tab_id));
  EXPECT_FALSE(can_load_file_iframe());
 
    
   
   content::WebContents* web_contents =
       browser()->tab_strip_model()->GetActiveWebContents();
   ExtensionActionRunner::GetForWebContents(web_contents)
       ->RunAction(extension, false  );
   EXPECT_FALSE(can_xhr_file_urls());
   EXPECT_FALSE(can_script_tab(active_tab_id));
   EXPECT_FALSE(can_script_tab(inactive_tab_id));
  EXPECT_FALSE(can_load_file_iframe());
 
   
   
   
   ExtensionActionRunner::GetForWebContents(web_contents)
       ->RunAction(extension, true  );
   EXPECT_TRUE(can_xhr_file_urls());
   EXPECT_TRUE(can_script_tab(active_tab_id));
  EXPECT_TRUE(can_load_file_iframe());
   EXPECT_FALSE(can_script_tab(inactive_tab_id));
 
    
  IN_PROC_BROWSER_TEST_F(ExtensionApiTest, FileURLs) {
   EXPECT_TRUE(background_page_ready.WaitUntilSatisfied());
 
    
   
   
   ExtensionActionRunner::GetForWebContents(web_contents)
       ->RunAction(extension, true  );
   EXPECT_FALSE(can_xhr_file_urls());
   EXPECT_FALSE(can_script_tab(active_tab_id));
   EXPECT_FALSE(can_script_tab(inactive_tab_id));
  EXPECT_FALSE(can_load_file_iframe());
 }
 
 }   ",Insufficient enforcement of file access permission in the activeTab case in Extensions in Google Chrome prior to 68.0.3440.75 allowed an attacker who convinced a user to install a malicious extension to access files on the local file system via a crafted Chrome Extension.
3224,CVE-2018-6044," 
 #include ""base/strings/utf_string_conversions.h""
 #include ""base/time/time.h""
 #include ""base/values.h""
#include ""content/public/browser/browser_context.h""
 #include ""content/public/browser/browser_thread.h""
 #include ""content/public/browser/render_frame_host.h""
 #include ""content/public/browser/render_process_host.h""
  bool WebRequestAPI::MaybeProxyURLLoaderFactory(
   }
 
   auto proxy = base::MakeRefCounted<WebRequestProxyingURLLoaderFactory>(
      frame->GetProcess()->GetBrowserContext(),
      frame->GetProcess()->GetBrowserContext()->GetResourceContext(),
      info_map_);
   proxies_.emplace(proxy.get(), proxy);
   BrowserThread::PostTask(
       BrowserThread::IO, FROM_HERE,",
3225,,"  int ScrollableShelfView::CalculateScrollUpperBound() const {
     return 0;
 
    
  int available_length = GetSpaceForIcons() - 2 * GetAppIconEndPadding();
 
    
   const gfx::Size shelf_preferred_size(
  void ScrollableShelfView::Layout() {
                               2 * ShelfConfig::Get()->app_icon_group_margin();
   UpdateLayoutStrategy(adjusted_length);
 
   
  const gfx::Insets padding_insets = CalculateEdgePadding();
  available_space_ = GetLocalBounds();
  available_space_.Inset(padding_insets);
 
   gfx::Size arrow_button_size(kArrowButtonSize, kArrowButtonSize);
   gfx::Rect shelf_container_bounds = gfx::Rect(size());
  void ScrollableShelfView::Layout() {
   gfx::Rect left_arrow_bounds;
   gfx::Rect right_arrow_bounds;
 
  const int before_padding =
      is_horizontal ? padding_insets.left() : padding_insets.top();
  const int after_padding =
      is_horizontal ? padding_insets.right() : padding_insets.bottom();

    
    
   if (layout_strategy_ == kShowLeftArrowButton ||
       layout_strategy_ == kShowButtons) {
     left_arrow_bounds = gfx::Rect(arrow_button_group_size);
    left_arrow_bounds.Offset(before_padding, 0);
     left_arrow_bounds.Inset(kArrowButtonEndPadding, 0, kDistanceToArrowButton,
                             0);
     left_arrow_bounds.ClampToCenteredSize(arrow_button_size);
  void ScrollableShelfView::Layout() {
   if (layout_strategy_ == kShowRightArrowButton ||
       layout_strategy_ == kShowButtons) {
     gfx::Point right_arrow_start_point(
        shelf_container_bounds.right() - after_padding - kArrowButtonGroupWidth,
         0);
     right_arrow_bounds =
         gfx::Rect(right_arrow_start_point, arrow_button_group_size);
  void ScrollableShelfView::Layout() {
   }
 
   shelf_container_bounds.Inset(
      before_padding +
          (left_arrow_bounds.IsEmpty() ? GetAppIconEndPadding() : 0),
       0,
      after_padding +
           (right_arrow_bounds.IsEmpty() ? GetAppIconEndPadding() : 0),
       0);
 
  void ScrollableShelfView::Layout() {
     translate_vector =
         GetShelf()->IsHorizontalAlignment()
             ? gfx::Vector2d(shelf_container_bounds.x() -
                                GetAppIconEndPadding() - before_padding,
                             0)
             : gfx::Vector2d(0, shelf_container_bounds.y() -
                                   GetAppIconEndPadding() - before_padding);
   }
   gfx::Vector2dF total_offset = scroll_offset_ + translate_vector;
   if (ShouldAdaptToRTL())
  gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {
 
   const int icons_size = shelf_view_->GetSizeOfAppIcons(
       shelf_view_->number_of_visible_apps(), false);
  const int base_padding = ShelfConfig::Get()->app_icon_group_margin();
 
   const int available_size_for_app_icons =
       (GetShelf()->IsHorizontalAlignment() ? width() : height()) -
  gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {
           ? available_size_for_app_icons - icons_size   
           : CalculateOverflowPadding(available_size_for_app_icons);   
 
   
  const int before_padding = base_padding + gap / 2;
  const int after_padding = base_padding + (gap % 2 ? gap / 2 + 1 : gap / 2);

  gfx::Insets padding_insets;
  if (GetShelf()->IsHorizontalAlignment()) {
    padding_insets =
        gfx::Insets( 0, before_padding,  0, after_padding);
  } else {
    padding_insets =
        gfx::Insets(before_padding,  0, after_padding,  0);
  }
 
   return padding_insets;
 }
  gfx::Insets ScrollableShelfView::CalculatePaddingForDisplayCentering() const {
 
    
   const gfx::Rect screen_bounds = GetBoundsInScreen();
  const int before_padding = gap - GetShelf()->PrimaryAxisValue(
                                       screen_bounds.x() - display_bounds.x(),
                                       screen_bounds.y() - display_bounds.y());
  const int after_padding =
       gap - GetShelf()->PrimaryAxisValue(
                 display_bounds.right() - screen_bounds.right(),
                 display_bounds.bottom() - screen_bounds.bottom());
 
  gfx::Insets padding_insets;
  if (GetShelf()->IsHorizontalAlignment()) {
    padding_insets =
        gfx::Insets( 0, before_padding,  0, after_padding);
  } else {
    padding_insets =
        gfx::Insets(before_padding,  0, after_padding,  0);
  }

  return padding_insets;
 }
 
 bool ScrollableShelfView::ShouldHandleGestures(const ui::GestureEvent& event) {
  void ScrollableShelfView::ScrollToYOffset(float y_target_offset,
 float ScrollableShelfView::CalculatePageScrollingOffset(bool forward) const {
    
    
  float offset = GetSpaceForIcons() - kArrowButtonGroupWidth -
                  ShelfConfig::Get()->button_size() - GetAppIconEndPadding();
   if (layout_strategy_ == kShowRightArrowButton)
     offset -= (kArrowButtonGroupWidth - GetAppIconEndPadding());
  views::View* ScrollableShelfView::FindLastFocusableChild() {
   return shelf_view_->view_model()->view_at(shelf_view_->last_visible_index());
 }
 
int ScrollableShelfView::GetSpaceForIcons() const {
  return GetShelf()->IsHorizontalAlignment() ? available_space_.width()
                                             : available_space_.height();
}

 }   ",
3226,CVE-2018-6151," 
 #include ""chrome/browser/content_settings/host_content_settings_map_factory.h""
 #include ""chrome/browser/domain_reliability/service_factory.h""
 #include ""chrome/browser/download/chrome_download_manager_delegate.h""
#include ""chrome/browser/download/download_core_service_factory.h""
#include ""chrome/browser/download/download_core_service_impl.h""
 #include ""chrome/browser/favicon/favicon_service_factory.h""
 #include ""chrome/browser/history/history_service_factory.h""
 #include ""chrome/browser/language/url_language_histogram_factory.h""
  base::Time AnHourAgo() {
 class RemoveDownloadsTester {
  public:
   explicit RemoveDownloadsTester(TestingProfile* testing_profile)
      : download_manager_(new content::MockDownloadManager()) {
     content::BrowserContext::SetDownloadManagerForTesting(
         testing_profile, base::WrapUnique(download_manager_));
    std::unique_ptr<ChromeDownloadManagerDelegate> delegate =
        std::make_unique<ChromeDownloadManagerDelegate>(testing_profile);
    chrome_download_manager_delegate_ = delegate.get();
    service_ =
        DownloadCoreServiceFactory::GetForBrowserContext(testing_profile);
    service_->SetDownloadManagerDelegateForTesting(std::move(delegate));

    EXPECT_CALL(*download_manager_, GetBrowserContext())
        .WillRepeatedly(Return(testing_profile));
     EXPECT_CALL(*download_manager_, Shutdown());
   }
 
  ~RemoveDownloadsTester() {
    service_->SetDownloadManagerDelegateForTesting(nullptr);
  }
 
   content::MockDownloadManager* download_manager() { return download_manager_; }
 
  private:
  DownloadCoreService* service_;
   content::MockDownloadManager* download_manager_;   
  ChromeDownloadManagerDelegate* chrome_download_manager_delegate_;
 
   DISALLOW_COPY_AND_ASSIGN(RemoveDownloadsTester);
 };
  TEST_F(ChromeBrowsingDataRemoverDelegateTest,
  
 TEST_F(ChromeBrowsingDataRemoverDelegateTest, RemoveDownloads) {
   RemoveDownloadsTester tester(GetProfile());
   EXPECT_CALL(
       *tester.download_manager(), RemoveDownloadsByURLAndTime(_, _, _));
 ","Bad cast in DevTools in Google Chrome on Win, Linux, Mac, Chrome OS prior to 66.0.3359.117 allowed an attacker who convinced a user to install a malicious extension to perform an out of bounds memory read via a crafted Chrome Extension."
3227,CVE-2018-6152,"  void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
 
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_MAYBE_DANGEROUS_CONTENT,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }","The implementation of the Page.downloadBehavior backend unconditionally marked downloaded files as safe, regardless of file type in Google Chrome prior to 66.0.3359.117 allowed an attacker who convinced a user to install a malicious extension to potentially perform a sandbox escape via a crafted HTML page and user interaction."
3228,,"  class AudioDestinationHandler : public AudioHandler {
   virtual double SampleRate() const = 0;
   virtual unsigned long MaxChannelCount() const = 0;
 
  void ContextDestroyed() { is_execution_context_destroyed_ = true; }
  bool IsExecutionContextDestroyed() const {
    return is_execution_context_destroyed_;
  }

  protected:
    
   size_t current_sample_frame_;

 private:
   
   
   
  bool is_execution_context_destroyed_ = false;
 };
 
  ",
3229,CVE-2018-16067,"  void BaseAudioContext::Initialize() {
 
   if (destination_node_) {
     destination_node_->Handler().Initialize();
     
     
     
     
     
     
    destination_handler_ = &destination_node_->GetAudioDestinationHandler();

      
      
     listener_ = AudioListener::Create(*this);",A use after free in WebAudio in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3230,CVE-2018-16068,"  DataPipeConsumerDispatcher::Deserialize(const void* data,
 
   const SerializedState* state = static_cast<const SerializedState*>(data);
   if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||
      state->options.capacity_num_bytes < state->options.element_num_bytes ||
      state->read_offset >= state->options.capacity_num_bytes ||
      state->bytes_available > state->options.capacity_num_bytes) {
     return nullptr;
   }
 
  DataPipeConsumerDispatcher::Deserialize(const void* data,
     dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;
     if (!dispatcher->InitializeNoLock())
       return nullptr;
    if (state->options.capacity_num_bytes >
        dispatcher->ring_buffer_mapping_.mapped_size()) {
      return nullptr;
    }
     dispatcher->UpdateSignalsStateNoLock();
   }
 ",Missing validation in Mojo in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially perform a sandbox escape via a crafted HTML page.
3231,CVE-2018-16072,"  bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {
 }
 
 bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {
  if (demuxer_found_hls_) {
     
     
    return false;
  }

   if (data_source_)
     return data_source_->HasSingleOrigin();
   return true;
  void WebMediaPlayerImpl::OnError(PipelineStatus status) {
 
 #if defined(OS_ANDROID)
   if (status == PipelineStatus::DEMUXER_ERROR_DETECTED_HLS) {
    demuxer_found_hls_ = true;

     renderer_factory_selector_->SetUseMediaPlayer(true);
 
     pipeline_controller_.Stop();",A missing origin check related to HLS manifests in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass same origin policy via a crafted HTML page.
3232,CVE-2018-16073," 
 #include ""content/public/browser/web_contents_observer.h""
 #include ""content/public/common/content_switches.h""
 #include ""content/public/test/browser_test_utils.h""
#include ""content/public/test/test_utils.h""
 #include ""media/base/media_switches.h""
 #include ""net/base/filename_util.h""
 #include ""net/test/embedded_test_server/embedded_test_server.h""
  class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     const extensions::Extension* extension =
         LoadExtension(test_data_dir_.AppendASCII(""options_page""));
 
     
     GURL omnibox(chrome::kChromeUIOmniboxURL);
     ui_test_utils::NavigateToURL(browser(), omnibox);
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
  class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     EXPECT_EQ(omnibox, tab1->GetURL());
     EXPECT_EQ(host_count, RenderProcessHostCount());
 
     
     GURL page1(""data:text/html,hello world1"");
 
     ui_test_utils::WindowedTabAddedNotificationObserver observer1(
  class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_NE(rph1, rph2);
 
     
     
     
     GURL page2(""data:text/html,hello world2"");
     ui_test_utils::WindowedTabAddedNotificationObserver observer2(
         content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), page2);
     observer2.Wait();
     tab_count++;
    if (content::AreAllSitesIsolatedForTesting())
      host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), page2);
     EXPECT_EQ(host_count, RenderProcessHostCount());
    if (content::AreAllSitesIsolatedForTesting())
      EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
    else
      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);

     
     
     
     
     GURL history(chrome::kChromeUIHistoryURL);
     ui_test_utils::WindowedTabAddedNotificationObserver observer3(
         content::NotificationService::AllSources());
  class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);
 
     
     GURL extension_url(""chrome-extension://"" + extension->id());
     ui_test_utils::WindowedTabAddedNotificationObserver observer4(
         content::NotificationService::AllSources());
  IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {
   int tab_count = 1;
   int host_count = 1;
 
   
   GURL omnibox(chrome::kChromeUIOmniboxURL);
   ui_test_utils::NavigateToURL(browser(), omnibox);
   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
   EXPECT_EQ(host_count, RenderProcessHostCount());
 
   
   GURL page1(""data:text/html,hello world1"");
   ui_test_utils::WindowedTabAddedNotificationObserver observer1(
       content::NotificationService::AllSources());
  IN_PROC_BROWSER_TEST_F(ChromeRenderProcessHostTest, MAYBE_ProcessPerTab) {
   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
   EXPECT_EQ(host_count, RenderProcessHostCount());
 
   
   
   GURL page2(""data:text/html,hello world2"");
   ui_test_utils::WindowedTabAddedNotificationObserver observer2(
       content::NotificationService::AllSources());
   ::ShowSingletonTab(browser(), page2);
   observer2.Wait();
   tab_count++;
  if (content::AreAllSitesIsolatedForTesting())
    host_count++;
   EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
   EXPECT_EQ(host_count, RenderProcessHostCount());
 ",Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.
3233,CVE-2018-16074,"  GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
    
   if (!origin.unique()) {
      
     
     
     DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
     
     
     
     
     
     
    if (url.SchemeIsBlob()) {
       
       
       
       
      if (url.has_ref()) {
        GURL::Replacements replacements;
        replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

     DCHECK(!url.scheme().empty());
     return GURL(url.scheme() + "":"");
   }",Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.
3234,CVE-2018-16075,"  void SetRuntimeFeaturesDefaultsAndUpdateFromArgs(
   WebRuntimeFeatures::EnableV8ContextSnapshot(
       base::FeatureList::IsEnabled(features::kV8ContextSnapshot));
 
   WebRuntimeFeatures::EnablePictureInPicture(
       base::FeatureList::IsEnabled(media::kPictureInPicture));
 ",Insufficient file type enforcement in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to obtain local file data via a crafted HTML page.
3235,CVE-2018-16087,"  void DownloadRequestLimiter::TabDownloadState::DidStartNavigation(
   download_seen_ = false;
   ui_status_ = DOWNLOAD_UI_DEFAULT;
 
  if (status_ == PROMPT_BEFORE_DOWNLOAD || status_ == DOWNLOADS_NOT_ALLOWED) {
    std::string host = navigation_handle->GetURL().host();
     
     
     
     
    if (navigation_handle->IsRendererInitiated()) {
      if (!host.empty())
        restricted_hosts_.emplace(host);
      return;
    }

     
     
     
    if (IsNavigationRestricted(navigation_handle))
      return;
   }
 
   if (status_ == DownloadRequestLimiter::ALLOW_ALL_DOWNLOADS ||
  void DownloadRequestLimiter::TabDownloadState::DidFinishNavigation(
    
   if (status_ == ALLOW_ONE_DOWNLOAD ||
       (status_ == PROMPT_BEFORE_DOWNLOAD &&
       !navigation_handle->IsRendererInitiated() &&
       !IsNavigationRestricted(navigation_handle))) {
      
      
      
  void DownloadRequestLimiter::TabDownloadState::SetDownloadStatusAndNotifyImpl(
   if (!web_contents())
     return;
 
  if (status_ == PROMPT_BEFORE_DOWNLOAD || status_ == DOWNLOADS_NOT_ALLOWED) {
    if (!initial_page_host_.empty())
      restricted_hosts_.emplace(initial_page_host_);
  }

    
    
    
  void DownloadRequestLimiter::TabDownloadState::SetDownloadStatusAndNotifyImpl(
       content::NotificationService::NoDetails());
 }
 
bool DownloadRequestLimiter::TabDownloadState::IsNavigationRestricted(
    content::NavigationHandle* navigation_handle) {
  std::string host = navigation_handle->GetURL().host();
  if (navigation_handle->GetPageTransition() & ui::PAGE_TRANSITION_FORWARD_BACK)
    return restricted_hosts_.find(host) != restricted_hosts_.end();
  return false;
}

  
 
 DownloadRequestLimiter::DownloadRequestLimiter() : factory_(this) {}",Lack of proper state tracking in Permissions in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass navigation restrictions via a crafted HTML page.
3236,CVE-2018-16078,"  const size_t kWaitTimeForDynamicFormsMs = 200;
  
 const int kLimitBeforeRefillMs = 1000;
 
  
  
 base::string16 SanitizeCreditCardFieldValue(const base::string16& value) {
  void AutofillManager::OnQueryFormFieldAutofillImpl(
        
        
        
      if (!has_logged_address_suggestions_count_) {
         AutofillMetrics::LogAddressSuggestionsCount(suggestions.size());
         has_logged_address_suggestions_count_ = true;
       }
  void AutofillManager::GetAvailableSuggestions(
     warning_suggestion.frontend_id =
         POPUP_ITEM_ID_INSECURE_CONTEXT_PAYMENT_DISABLED_MESSAGE;
     suggestions->assign(1, warning_suggestion);
   }
 }
 ",Unsafe handling of credit card details in Autofill in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.
3237,CVE-2018-16079," 
 
 #include ""base/logging.h""
 #include ""chrome/browser/ui/bluetooth/bluetooth_chooser_controller.h""
#include ""components/bubble/bubble_controller.h""
 
 BluetoothChooserDesktop::BluetoothChooserDesktop(
     BluetoothChooserController* bluetooth_chooser_controller)
  BluetoothChooserDesktop::~BluetoothChooserDesktop() {
    
    
   bluetooth_chooser_controller_->ResetEventHandler();
  if (bubble_)
    bubble_->CloseBubble(BUBBLE_CLOSE_FORCED);
 }
 
 void BluetoothChooserDesktop::SetAdapterPresence(AdapterPresence presence) {",A race condition between permission prompts and navigations in Prompts in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3238,CVE-2018-16080,"  void Browser::AddNewContents(WebContents* source,
                              const gfx::Rect& initial_rect,
                              bool user_gesture,
                              bool* was_blocked) {
#if defined(OS_MACOSX)
   
   
   
  if (disposition == WindowOpenDisposition::NEW_POPUP &&
      exclusive_access_manager_->fullscreen_controller()
          ->IsFullscreenForBrowser()) {
    disposition = WindowOpenDisposition::NEW_FOREGROUND_TAB;
  }
#endif

    
    
   if (source && PopupBlockerTabHelper::ConsiderForPopupBlocking(disposition))",A missing check for popup window handling in Fullscreen in Google Chrome on macOS prior to 69.0.3497.81 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
3239,CVE-2018-16081,"  bool PlatformFontSkia::InitDefaultFont() {
 
   bool success = false;
   std::string family = kFallbackFontFamilyName;
  int size_pixels = PlatformFont::kDefaultBaseFontSize;
   int style = Font::NORMAL;
   Font::Weight weight = Font::Weight::NORMAL;
   FontRenderParams params;",Allowing the chrome.debugger API to run on file:// URLs in DevTools in Google Chrome prior to 69.0.3497.81 allowed an attacker who convinced a user to install a malicious extension to access files on the local file system without file access permission via a crafted Chrome Extension.
3240,CVE-2018-16084,"  bool ExternalProtocolDialog::ShouldShowCloseButton() const {
   return false;
 }
 
int ExternalProtocolDialog::GetDefaultDialogButton() const {
  return ui::DIALOG_BUTTON_CANCEL;
}

 base::string16 ExternalProtocolDialog::GetDialogButtonLabel(
     ui::DialogButton button) const {
   return delegate_->GetDialogButtonLabel(button);",The default selected dialog button in CustomHandlers in Google Chrome prior to 69.0.3497.81 allowed a remote attacker who convinced the user to perform certain operations to open external programs via a crafted HTML page.
3241,CVE-2018-16086," 
 #include ""chrome/browser/search/search.h""
 #include ""chrome/browser/ui/browser.h""
 #include ""chrome/browser/ui/javascript_dialogs/javascript_dialog_tab_helper.h""
#include ""chrome/browser/ui/search/local_ntp_test_utils.h""
 #include ""chrome/browser/ui/tabs/tab_strip_model.h""
 #include ""chrome/common/chrome_switches.h""
#include ""chrome/common/webui_url_constants.h""
 #include ""chrome/test/base/ui_test_utils.h""
 #include ""content/public/browser/javascript_dialog_manager.h""
 #include ""content/public/browser/render_frame_host.h""
  IN_PROC_BROWSER_TEST_F(ContentScriptApiTest, ExecuteScriptBypassingSandbox) {
   ASSERT_TRUE(catcher.GetNextResult()) << catcher.message();
 }
 
 
 
 
class NTPInterceptionTest : public ExtensionApiTest {
 public:
  NTPInterceptionTest()
      : https_test_server_(net::EmbeddedTestServer::TYPE_HTTPS) {}

   
  void SetUpOnMainThread() override {
    ExtensionApiTest::SetUpOnMainThread();
    test_data_dir_ = test_data_dir_.AppendASCII(""ntp_content_script"");
    https_test_server_.ServeFilesFromDirectory(test_data_dir_);
    ASSERT_TRUE(https_test_server_.Start());

    GURL ntp_url = https_test_server_.GetURL(""/fake_ntp.html"");
    local_ntp_test_utils::SetUserSelectedDefaultSearchProvider(
        profile(), https_test_server_.base_url().spec(), ntp_url.spec());
  }

  const net::EmbeddedTestServer* https_test_server() const {
    return &https_test_server_;
  }

 private:
  net::EmbeddedTestServer https_test_server_;
  DISALLOW_COPY_AND_ASSIGN(NTPInterceptionTest);
};

 
 
IN_PROC_BROWSER_TEST_F(NTPInterceptionTest, ContentScript) {
   
  ExtensionTestMessageListener listener(""ready"", false  );
  const Extension* extension = LoadExtension(test_data_dir_);
  ASSERT_TRUE(extension);
  ASSERT_TRUE(listener.WaitUntilSatisfied());

   
   
   
  Browser* incognito_browser = CreateIncognitoBrowser(profile());
  ASSERT_TRUE(incognito_browser);

   
   
  ui_test_utils::NavigateToURL(browser(), GURL(chrome::kChromeUINewTabURL));
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();
  ASSERT_TRUE(search::IsInstantNTP(web_contents));

  bool script_injected_in_ntp = false;
  ASSERT_TRUE(ExecuteScriptAndExtractBool(
      web_contents,
      ""window.domAutomationController.send(document.title !== 'Fake NTP');"",
      &script_injected_in_ntp));
  EXPECT_FALSE(script_injected_in_ntp);
}

 }   ",Insufficient policy enforcement in extensions API in Google Chrome prior to 69.0.3497.81 allowed an attacker who convinced a user to install a malicious extension to bypass navigation restrictions via a crafted Chrome Extension.
3242,CVE-2018-16085,"  CoordinatorImpl* CoordinatorImpl::GetInstance() {
 
 CoordinatorImpl::CoordinatorImpl(service_manager::Connector* connector)
     : next_dump_id_(0),
      client_process_timeout_(base::TimeDelta::FromSeconds(15)),
      weak_ptr_factory_(this) {
   process_map_ = std::make_unique<ProcessMap>(connector);
   DCHECK(!g_coordinator_impl);
   g_coordinator_impl = this;
  void CoordinatorImpl::GetVmRegionsForHeapProfiler(
       in_progress_vm_region_requests_[dump_guid].get();
   auto os_callback =
       base::BindRepeating(&CoordinatorImpl::OnOSMemoryDumpForVMRegions,
                          weak_ptr_factory_.GetWeakPtr(), dump_guid);
   QueuedRequestDispatcher::SetUpAndDispatchVmRegionRequest(request_ptr, clients,
                                                            pids, os_callback);
   FinalizeVmRegionDumpIfAllManagersReplied(dump_guid);
  void CoordinatorImpl::RegisterClientProcess(
   mojom::ClientProcess* client_process = client_process_ptr.get();
   client_process_ptr.set_connection_error_handler(
       base::BindOnce(&CoordinatorImpl::UnregisterClientProcess,
                     weak_ptr_factory_.GetWeakPtr(), client_process));
   auto identity = GetClientIdentityForCurrentRequest();
   auto client_info = std::make_unique<ClientInfo>(
       std::move(identity), std::move(client_process_ptr), process_type);
  void CoordinatorImpl::UnregisterClientProcess(
         FROM_HERE,
         base::BindOnce(
             &CoordinatorImpl::FinalizeVmRegionDumpIfAllManagersReplied,
            weak_ptr_factory_.GetWeakPtr(), pair.second->dump_guid));
   }
 
   size_t num_deleted = clients_.erase(client_process);
  void CoordinatorImpl::PerformNextQueuedGlobalMemoryDump() {
     clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);
   }
 
  auto chrome_callback =
      base::Bind(&CoordinatorImpl::OnChromeMemoryDumpResponse,
                 weak_ptr_factory_.GetWeakPtr());
  auto os_callback =
      base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,
                 weak_ptr_factory_.GetWeakPtr(), request->dump_guid);
   QueuedRequestDispatcher::SetUpAndDispatch(request, clients, chrome_callback,
                                             os_callback);
 
   base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
       FROM_HERE,
       base::BindOnce(&CoordinatorImpl::OnQueuedRequestTimedOut,
                     weak_ptr_factory_.GetWeakPtr(), request->dump_guid),
       client_process_timeout_);
 
   if (request->args.add_to_trace && heap_profiler_) {
  void CoordinatorImpl::PerformNextQueuedGlobalMemoryDump() {
             .IsArgumentFilterEnabled();
     heap_profiler_->DumpProcessesForTracing(
         strip_path_from_mapped_files,
        base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,
                            weak_ptr_factory_.GetWeakPtr(),
                            request->dump_guid));
 
     base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
         FROM_HERE,
         base::BindOnce(&CoordinatorImpl::OnHeapDumpTimeOut,
                       weak_ptr_factory_.GetWeakPtr(), request->dump_guid),
         kHeapDumpTimeout);
   }
 
  void CoordinatorImpl::FinalizeGlobalMemoryDumpIfAllManagersReplied() {
     base::SequencedTaskRunnerHandle::Get()->PostTask(
         FROM_HERE,
         base::BindOnce(&CoordinatorImpl::PerformNextQueuedGlobalMemoryDump,
                       weak_ptr_factory_.GetWeakPtr()));
   }
 }
 ",A use after free in ResourceCoordinator in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3243,CVE-2018-6148,"  TEST_F(WebAssociatedURLLoaderTest, MAYBE_UntrustedCheckHeaders) {
    
   CheckHeaderFails(""AcCePt-ChArSeT"");
   CheckHeaderFails(""ProXy-FoO"");
 }
 
  ",Incorrect implementation in Content Security Policy in Google Chrome prior to 67.0.3396.79 allowed a remote attacker to bypass navigation restrictions via a crafted HTML page.
3244,CVE-2018-6123,"  FileReaderLoader::FileReaderLoader(ReadType read_type,
        
        
       handle_watcher_(FROM_HERE, mojo::SimpleWatcher::ArmingPolicy::AUTOMATIC),
      binding_(this),
      weak_factory_(this) {}
 
 FileReaderLoader::~FileReaderLoader() {
   Cleanup();
  void FileReaderLoader::OnFinishLoading() {
 
 void FileReaderLoader::OnCalculatedSize(uint64_t total_size,
                                         uint64_t expected_content_size) {
  auto weak_this = weak_factory_.GetWeakPtr();
   OnStartLoading(expected_content_size);
   
   
  if (!weak_this)
    return;

   if (expected_content_size == 0) {
     received_all_data_ = true;
     return;",A use after free in Blink in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
3245,CVE-2018-6125,"  static int winusbx_abort_transfers(int sub_api, struct usbi_transfer *itransfer)
 static int winusbx_abort_control(int sub_api, struct usbi_transfer *itransfer);
 static int winusbx_reset_device(int sub_api, struct libusb_device_handle *dev_handle);
 static int winusbx_copy_transfer_data(int sub_api, struct usbi_transfer *itransfer, uint32_t io_size);
  
 static int composite_init(int sub_api, struct libusb_context *ctx);
 static int composite_exit(int sub_api);
  HANDLE timer_response = NULL;
 	if (!WinUSBX[sub_api].initialized) return LIBUSB_ERROR_ACCESS; } while(0)
 static struct winusb_interface WinUSBX[SUB_API_MAX];
 const char* sub_api_name[SUB_API_MAX] = WINUSBX_DRV_NAMES;
 
 static inline BOOLEAN guid_eq(const GUID *guid1, const GUID *guid2) {
 	if ((guid1 != NULL) && (guid2 != NULL)) {
  static int auto_claim(struct libusb_transfer *transfer, int *interface_number, i
 
 	switch(api_type) {
 	case USB_API_WINUSBX:
 		break;
 	default:
 		return LIBUSB_ERROR_INVALID_PARAM;
  static int set_composite_interface(struct libusb_context* ctx, struct libusb_dev
 	}
 
 	if (priv->usb_interface[interface_number].path != NULL) {
 		safe_free(priv->usb_interface[interface_number].path);
 	}
 
 	usbi_dbg(""interface[%d] = %s"", interface_number, dev_interface_path);
 	priv->usb_interface[interface_number].path = dev_interface_path;
 	priv->usb_interface[interface_number].apib = &usb_api_backend[api];
 	priv->usb_interface[interface_number].sub_api = sub_api;
 
 	return LIBUSB_SUCCESS;
 }
 
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 	const char* usb_class[] = {""USB"", ""NUSB3"", ""IUSB3""};
 	SP_DEVINFO_DATA dev_info_data = { 0 };
 	SP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_interface_details = NULL;
 #define MAX_ENUM_GUIDS 64
 	const GUID* guid[MAX_ENUM_GUIDS];
 #define HCD_PASS 0
 #define HUB_PASS 1
 #define GEN_PASS 2
 #define DEV_PASS 3
 	int r = LIBUSB_SUCCESS;
 	int api, sub_api;
 	size_t class_index = 0;
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 	 
 	 
 	 
	 
 
 	 
 	guid[HCD_PASS] = &GUID_DEVINTERFACE_USB_HOST_CONTROLLER;
 	guid[HUB_PASS] = &GUID_DEVINTERFACE_USB_HUB;
 	guid[GEN_PASS] = NULL;
 	guid[DEV_PASS] = &GUID_DEVINTERFACE_USB_DEVICE;
	nb_guids = DEV_PASS+1;
 
 	unref_list = (libusb_device**) calloc(unref_size, sizeof(libusb_device*));
 	if (unref_list == NULL) {
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 	for (pass = 0; ((pass < nb_guids) && (r == LIBUSB_SUCCESS)); pass++) {
  
 #ifdef ENUM_DEBUG
		const char *passname[] = { ""HCD"", ""HUB"", ""GEN"", ""DEV"", ""EXT"" };
		usbi_dbg(""\n#### PROCESSING %ss %s"", passname[(pass<=DEV_PASS)?pass:DEV_PASS+1],
 			(pass!=GEN_PASS)?guid_to_string(guid[pass]):"""");
 #endif
 		for (i = 0; ; i++) {
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 					}
 				}
 				break;
 			default:
 				 
 				if ( (!pSetupDiGetDeviceRegistryPropertyA(dev_info, &dev_info_data, SPDRP_INSTALL_STATE,
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 				case USB_API_COMPOSITE:
 				case USB_API_HUB:
 					break;
 				default:
 					 
 					priv->usb_interface[0].path = (char*) calloc(safe_strlen(priv->path)+1, 1);
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 					r = LIBUSB_SUCCESS;
 				}
 				break;
			default:	 
				if (parent_priv->apib->id == USB_API_COMPOSITE) {
 					usbi_dbg(""setting composite interface for [%lX]:"", parent_dev->session_data);
 					switch (set_composite_interface(ctx, parent_dev, dev_interface_path, dev_id_path, api, sub_api)) {
 					case LIBUSB_SUCCESS:
  static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 	}
 
 	 
	for (pass = DEV_PASS+1; pass < nb_guids; pass++) {
 		safe_free(guid[pass]);
 	}
 
  static void windows_clear_transfer_priv(struct usbi_transfer *itransfer)
 	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
 
 	usbi_free_fd(&transfer_priv->pollable_fd);
 	 
 	auto_release(itransfer);
 }
  static int common_configure_endpoints(int sub_api, struct libusb_device_handle *
 const char* hub_driver_names[] = {""USBHUB"", ""USBHUB3"", ""NUSB3HUB"", ""RUSB3HUB"", ""FLXHCIH"", ""TIHUB3"", ""ETRONHUB3"", ""VIAHUB3"", ""ASMTHUB3"", ""IUSB3HUB""};
 const char* composite_driver_names[] = {""USBCCGP""};
 const char* winusbx_driver_names[] = WINUSBX_DRV_NAMES;
 const struct windows_usb_api_backend usb_api_backend[USB_API_MAX] = {
 	{
 		USB_API_UNSUPPORTED,
  const struct windows_usb_api_backend usb_api_backend[USB_API_MAX] = {
 		winusbx_abort_control,
 		winusbx_abort_transfers,
 		winusbx_copy_transfer_data,
 	},
 };
 
  static int get_valid_interface(struct libusb_device_handle *dev_handle, int api_
 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
 	int i;
 
	if ((api_id < USB_API_WINUSBX) || (api_id >= USB_API_MAX)) {
 		usbi_dbg(""unsupported API ID"");
 		return -1;
 	}
  static int winusbx_copy_transfer_data(int sub_api, struct usbi_transfer *itransf
 	return LIBUSB_TRANSFER_COMPLETED;
 }
 
  
  static int composite_open(int sub_api, struct libusb_device_handle *dev_handle)
 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
 	int r = LIBUSB_ERROR_NOT_FOUND;
 	uint8_t i;
	bool available[SUB_API_MAX] = {0};
 
 	for (i=0; i<USB_MAXINTERFACES; i++) {
 		switch (priv->usb_interface[i].apib->id) {
 		case USB_API_WINUSBX:
 			if (priv->usb_interface[i].sub_api != SUB_API_NOTSET)
 				available[priv->usb_interface[i].sub_api] = true;
 			break;
 		default:
 			break;
 		}
  static int composite_open(int sub_api, struct libusb_device_handle *dev_handle)
 			}
 		}
 	}
 	return r;
 }
 
  static void composite_close(int sub_api, struct libusb_device_handle *dev_handle
 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
 	uint8_t i;
 	bool available[SUB_API_MAX];
 
 	for (i = 0; i<SUB_API_MAX; i++) {
 		available[i] = false;
  static void composite_close(int sub_api, struct libusb_device_handle *dev_handle
 		if ( (priv->usb_interface[i].apib->id == USB_API_WINUSBX)
 		  && (priv->usb_interface[i].sub_api != SUB_API_NOTSET) ) {
 			available[priv->usb_interface[i].sub_api] = true;
 		}
 	}
 
  static void composite_close(int sub_api, struct libusb_device_handle *dev_handle
 			usb_api_backend[USB_API_WINUSBX].close(i, dev_handle);
 		}
 	}
 }
 
 static int composite_claim_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface)",
3246,CVE-2018-6127,"  class IndexedDBDatabase::OpenRequest
 
   void UpgradeTransactionFinished(bool committed) override {
      
     if (committed) {
       DCHECK_EQ(pending_->version, db_->metadata_.version);
       pending_->callbacks->OnSuccess(std::unique_ptr<IndexedDBConnection>(),",Early free of object in use in IndexDB in Google Chrome prior to 67.0.3396.62 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.
3247,CVE-2018-6132,"  void OnSuggestionModelAdded(UiScene* scene,
   description_text->SetDrawPhase(kPhaseForeground);
   description_text->SetType(kTypeOmniboxSuggestionDescriptionText);
   description_text->set_hit_testable(false);
  description_text->SetTextLayoutMode(TextLayoutMode::kSingleLineFixedWidth);
   description_text->SetSize(kSuggestionTextFieldWidthDMM, 0);
   description_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);
   BindColor(model, description_text.get(),",Uninitialized data in WebRTC in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted video file.
3248,CVE-2018-6133,"  const size_t kNumberOfLabelsToCheck = 3;
 const unsigned char* g_graph = kDafsa;
 size_t g_graph_length = sizeof(kDafsa);
 
bool LookupMatchInTopDomains(const icu::UnicodeString& ustr_skeleton) {
  std::string skeleton;
  ustr_skeleton.toUTF8String(skeleton);
   DCHECK_NE(skeleton.back(), '.');
   auto labels = base::SplitStringPiece(skeleton, ""."", base::KEEP_WHITESPACE,
                                        base::SPLIT_WANT_ALL);
  IDNSpoofChecker::IDNSpoofChecker() {
    
    
    
    
    
    
  IDNSpoofChecker::IDNSpoofChecker() {
                                    ""[] > b;  [] > w; [] > m;""
                                    ""[] > e;  > r; [] > f; [] > c;""
                                    "" > y; [] > x;""
                                    ""  > d; [] > g; [] > s;  > j;""
                                    ""[] > 3""),
       UTRANS_FORWARD, parse_error, status));
  bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
 
 bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {
   size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);
  icu::UnicodeString host(FALSE, hostname.data(), hostname_length);
    
    
    
  if (lgc_letters_n_ascii_.span(host, 0, USET_SPAN_CONTAINED) == host.length())
    diacritic_remover_.get()->transliterate(host);
  extra_confusable_mapper_.get()->transliterate(host);
 
   UErrorCode status = U_ZERO_ERROR;
  icu::UnicodeString skeleton;

   
   
  int32_t u04cf_pos;
  if ((u04cf_pos = host.indexOf(0x4CF)) != -1) {
    icu::UnicodeString host_alt(host);
    size_t length = host_alt.length();
    char16_t* buffer = host_alt.getBuffer(-1);
    for (char16_t* uc = buffer + u04cf_pos ; uc < buffer + length; ++uc) {
      if (*uc == 0x4CF)
        *uc = 0x6C;   
    }
    host_alt.releaseBuffer(length);
    uspoof_getSkeletonUnicodeString(checker_, 0, host_alt, skeleton, &status);
    if (U_SUCCESS(status) && LookupMatchInTopDomains(skeleton))
      return true;
  }

  uspoof_getSkeletonUnicodeString(checker_, 0, host, skeleton, &status);
  return U_SUCCESS(status) && LookupMatchInTopDomains(skeleton);
 }
 
 bool IDNSpoofChecker::IsMadeOfLatinAlikeCyrillic(",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
3249,CVE-2018-6135,"  void RenderWidgetHostImpl::WasShown(const ui::LatencyInfo& latency_info) {
 
    
    
  ForceFirstFrameAfterNavigationTimeout();
 
   SendScreenRects();
   RestartHangMonitorTimeoutIfNecessary();
  void RenderWidgetHostImpl::DidReceiveFirstFrameAfterNavigation() {
   new_content_rendering_timeout_->Stop();
 }
 
void RenderWidgetHostImpl::ForceFirstFrameAfterNavigationTimeout() {
  if (new_content_rendering_timeout_ &&
      new_content_rendering_timeout_->IsRunning()) {
    new_content_rendering_timeout_->Stop();
    ClearDisplayedGraphics();
  }
}

 void RenderWidgetHostImpl::StopFling() {
   if (input_router_)
     input_router_->StopFling();",Lack of clearing the previous site before loading alerts from a new one in Blink in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to perform domain spoofing via a crafted HTML page.
3250,CVE-2018-6138," 
 #include ""base/values.h""
 #include ""chrome/browser/chrome_notification_types.h""
 #include ""chrome/browser/extensions/active_tab_permission_granter.h""
#include ""chrome/browser/extensions/chrome_test_extension_loader.h""
#include ""chrome/browser/extensions/extension_service.h""
#include ""chrome/browser/extensions/extension_service_test_base.h""
#include ""chrome/browser/extensions/extension_util.h""
 #include ""chrome/browser/extensions/tab_helper.h""
 #include ""chrome/browser/profiles/profile.h""
 #include ""chrome/browser/sessions/session_tab_helper.h""
 
 #include ""content/public/browser/notification_types.h""
 #include ""content/public/browser/web_contents.h""
 #include ""content/public/common/frame_navigate_params.h""
#include ""content/public/test/browser_side_navigation_test_utils.h""
 #include ""content/public/test/navigation_simulator.h""
 #include ""content/public/test/test_browser_thread.h""
#include ""content/public/test/web_contents_tester.h""
 #include ""extensions/browser/extension_registry.h""
#include ""extensions/browser/test_extension_registry_observer.h""
#include ""extensions/common/constants.h""
 #include ""extensions/common/extension.h""
 #include ""extensions/common/extension_builder.h""
 #include ""extensions/common/features/feature.h""
 #include ""extensions/common/features/feature_channel.h""
 #include ""extensions/common/permissions/permissions_data.h""
 #include ""extensions/common/value_builder.h""
#include ""extensions/test/test_extension_dir.h""
 
 #if defined(OS_CHROMEOS)
 #include ""base/run_loop.h""
  class ActiveTabTest : public ChromeRenderViewHostTestHarness {
                                                   nullptr) &&
                   permissions_data->CanRunContentScriptOnPage(
                       extension.get(), url, tab_id, nullptr);
    bool capture = permissions_data->CanCaptureVisiblePage(url, extension.get(),
                                                           tab_id, NULL);
     switch (feature) {
       case PERMITTED_SCRIPT_ONLY:
         return script && !capture;
  TEST_F(ActiveTabTest, GrantToSinglePage) {
 
    
   GURL mail_google(""http://mail.google.com"");
  EXPECT_TRUE(IsBlocked(extension, mail_google));
   EXPECT_TRUE(IsBlocked(another_extension, mail_google));
   EXPECT_TRUE(IsBlocked(extension_without_active_tab, mail_google));
 
  TEST_F(ActiveTabTest, GrantToSinglePage) {
   active_tab_permission_granter()->GrantIfRequested(
       extension_without_active_tab.get());
 
  EXPECT_TRUE(IsBlocked(extension, google));
  EXPECT_TRUE(IsBlocked(another_extension, google));
   EXPECT_TRUE(IsBlocked(extension_without_active_tab, google));
 
   EXPECT_TRUE(IsAllowed(extension, chromium));
  TEST_F(ActiveTabTest, GrantToSinglePage) {
   EXPECT_TRUE(IsAllowed(another_extension, google));
   EXPECT_TRUE(IsBlocked(extension_without_active_tab, google));
 
  EXPECT_TRUE(IsBlocked(extension, chromium));
  EXPECT_TRUE(IsBlocked(another_extension, chromium));
   EXPECT_TRUE(IsBlocked(extension_without_active_tab, chromium));
 }
 
  TEST_F(ActiveTabTest, DelegateIsSet) {
 }
 #endif   
 
 
class ActiveTabWithServiceTest : public ExtensionServiceTestBase {
 public:
  ActiveTabWithServiceTest() {}

  void SetUp() override;
  void TearDown() override;

 private:
  DISALLOW_COPY_AND_ASSIGN(ActiveTabWithServiceTest);
};

void ActiveTabWithServiceTest::SetUp() {
  ExtensionServiceTestBase::SetUp();
  content::BrowserSideNavigationSetUp();
}

void ActiveTabWithServiceTest::TearDown() {
  content::BrowserSideNavigationTearDown();
  ExtensionServiceTestBase::TearDown();
}

 
 
 
TEST_F(ActiveTabWithServiceTest, FileURLs) {
  InitializeEmptyExtensionService();

  TestExtensionDir test_dir;
  test_dir.WriteManifest(R""(
    {
      ""name"": ""Active Tab Capture With File Urls"",
      ""description"": ""Testing activeTab on file urls"",
      ""version"": ""0.1"",
      ""manifest_version"": 2,
      ""permissions"": [""activeTab""]
    })"");

  ChromeTestExtensionLoader loader(profile());
  loader.set_allow_file_access(false);
  scoped_refptr<const Extension> extension =
      loader.LoadExtension(test_dir.UnpackedPath());
  ASSERT_TRUE(extension);
  const std::string id = extension->id();
  ASSERT_TRUE(registry()->enabled_extensions().Contains(id));

  EXPECT_FALSE(util::AllowFileAccess(id, profile()));

  std::unique_ptr<content::WebContents> web_contents(
      content::WebContentsTester::CreateTestWebContents(profile(), nullptr));
  ASSERT_TRUE(web_contents);

  const GURL file_url(""file:///foo"");
  ASSERT_TRUE(content::WebContentsTester::For(web_contents.get()));
  content::WebContentsTester::For(web_contents.get())
      ->NavigateAndCommit(file_url);
  EXPECT_EQ(file_url, web_contents->GetLastCommittedURL());

  TabHelper::CreateForWebContents(web_contents.get());
  ActiveTabPermissionGranter* permission_granter =
      TabHelper::FromWebContents(web_contents.get())
          ->active_tab_permission_granter();
  ASSERT_TRUE(permission_granter);
  const int tab_id = SessionTabHelper::IdForTab(web_contents.get()).id();
  EXPECT_NE(extension_misc::kUnknownTabId, tab_id);

  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), extension.get(), tab_id, nullptr));

  permission_granter->GrantIfRequested(extension.get());
  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), extension.get(), tab_id, nullptr));

  permission_granter->RevokeForTesting();
  TestExtensionRegistryObserver observer(registry(), id);
   
  util::SetAllowFileAccess(id, profile(), true);
  extension = observer.WaitForExtensionLoaded();
  ASSERT_TRUE(extension);

  EXPECT_FALSE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), extension.get(), tab_id, nullptr));
  permission_granter->GrantIfRequested(extension.get());
  EXPECT_TRUE(extension->permissions_data()->CanCaptureVisiblePage(
      web_contents->GetLastCommittedURL(), extension.get(), tab_id, nullptr));
}

 }   
 }   ",Insufficient policy enforcement in Extensions API in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to bypass navigation restrictions via a crafted Chrome Extension.
3251,CVE-2018-6139,"  bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
  if (!session->restricted()) {
    session->AddHandler(base::WrapUnique(
        new protocol::TargetHandler(false  )));
  }
   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(
       protocol::TracingHandler::Renderer,
       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,",Insufficient target checks on the chrome.debugger API in DevTools in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to execute arbitrary code via a crafted Chrome Extension.
3252,CVE-2018-6140,"  class ExtensionDevToolsClientHost : public content::DevToolsAgentHostClient,
 
   ~ExtensionDevToolsClientHost() override;
 
  bool Attach();
   const std::string& extension_id() { return extension_id_; }
   DevToolsAgentHost* agent_host() { return agent_host_.get(); }
  void RespondDetachedToPendingRequests();
   void Close();
   void SendMessageToBackend(DebuggerSendCommandFunction* function,
                             const std::string& method,
  class ExtensionDevToolsClientHost : public content::DevToolsAgentHostClient,
   Profile* profile_;
   scoped_refptr<DevToolsAgentHost> agent_host_;
   std::string extension_id_;
  std::string extension_name_;
   Debuggee debuggee_;
   content::NotificationRegistrar registrar_;
   int last_request_id_;
  ExtensionDevToolsClientHost::ExtensionDevToolsClientHost(
     : profile_(profile),
       agent_host_(agent_host),
       extension_id_(extension_id),
      extension_name_(extension_name),
       last_request_id_(0),
       infobar_(nullptr),
       detach_reason_(api::debugger::DETACH_REASON_TARGET_CLOSED),
  ExtensionDevToolsClientHost::ExtensionDevToolsClientHost(
    
   registrar_.Add(this, chrome::NOTIFICATION_APP_TERMINATING,
                  content::NotificationService::AllSources());
}
 
bool ExtensionDevToolsClientHost::Attach() {
    
  if (!agent_host_->AttachRestrictedClient(this))
    return false;
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           ::switches::kSilentDebuggerExtensionAPI)) {
    return true;
   }
 
    
    
   const Extension* extension =
      ExtensionRegistry::Get(profile_)->enabled_extensions().GetByID(
          extension_id_);
   
   
   
   if (extension && Manifest::IsPolicyLocation(extension->location()))
    return true;
 
   infobar_ = ExtensionDevToolsInfoBar::Create(
      extension_id_, extension_name_, this,
       base::Bind(&ExtensionDevToolsClientHost::InfoBarDismissed,
                  base::Unretained(this)));
  return true;
 }
 
 ExtensionDevToolsClientHost::~ExtensionDevToolsClientHost() {
  ExtensionDevToolsClientHost::~ExtensionDevToolsClientHost() {
 void ExtensionDevToolsClientHost::AgentHostClosed(
     DevToolsAgentHost* agent_host) {
   DCHECK(agent_host == agent_host_.get());
  RespondDetachedToPendingRequests();
   SendDetachedEvent();
   delete this;
 }
  void ExtensionDevToolsClientHost::SendMessageToBackend(
 
 void ExtensionDevToolsClientHost::InfoBarDismissed() {
   detach_reason_ = api::debugger::DETACH_REASON_CANCELED_BY_USER;
  RespondDetachedToPendingRequests();
   SendDetachedEvent();
   Close();
 }
 
void ExtensionDevToolsClientHost::RespondDetachedToPendingRequests() {
  for (const auto& it : pending_requests_)
    it.second->SendDetachedError();
  pending_requests_.clear();
}

 void ExtensionDevToolsClientHost::SendDetachedEvent() {
   if (!EventRouter::Get(profile_))
     return;
  bool DebuggerAttachFunction::RunAsync() {
     return false;
   }
 
  auto host = std::make_unique<ExtensionDevToolsClientHost>(
      GetProfile(), agent_host_.get(), extension()->id(), extension()->name(),
      debuggee_);

  if (!host->Attach()) {
    FormatErrorMessage(keys::kRestrictedError);
    return false;
  }

  host.release();   
   SendResponse(true);
   return true;
 }
  bool DebuggerDetachFunction::RunAsync() {
   if (!InitClientHost())
     return false;
 
  client_host_->RespondDetachedToPendingRequests();
   client_host_->Close();
   SendResponse(true);
   return true;
  void DebuggerSendCommandFunction::SendResponseBody(
   SendResponse(true);
 }
 
void DebuggerSendCommandFunction::SendDetachedError() {
  error_ = keys::kDetachedWhileHandlingError;
  SendResponse(false);
}
 
  
 ",Allowing the chrome.debugger API to attach to Web UI pages in DevTools in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to execute arbitrary code via a crafted Chrome Extension.
3253,CVE-2018-6143,"  IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
   EXPECT_FALSE(form.skip_zero_click);
 }
 
IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
                       StoreExistingCredentialIsNoOp) {
  scoped_refptr<password_manager::TestPasswordStore> password_store =
      static_cast<password_manager::TestPasswordStore*>(
          PasswordStoreFactory::GetForProfile(
              browser()->profile(), ServiceAccessType::IMPLICIT_ACCESS)
              .get());

  GURL origin = embedded_test_server()->base_url();

  autofill::PasswordForm form_1;
  form_1.signon_realm = origin.spec();
  form_1.username_value = base::ASCIIToUTF16(""user1"");
  form_1.password_value = base::ASCIIToUTF16(""abcdef"");
  form_1.preferred = true;

  autofill::PasswordForm form_2;
  form_2.signon_realm = origin.spec();
  form_2.username_value = base::ASCIIToUTF16(""user2"");
  form_2.password_value = base::ASCIIToUTF16(""123456"");

  password_store->AddLogin(form_1);
  password_store->AddLogin(form_2);
  WaitForPasswordStore();

   
  {
    auto found = password_store->stored_passwords().find(origin.spec());
    ASSERT_NE(password_store->stored_passwords().end(), found);
    const std::vector<autofill::PasswordForm>& passwords = found->second;

    ASSERT_EQ(2U, passwords.size());
    EXPECT_EQ(base::ASCIIToUTF16(""user1""), passwords[0].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""abcdef""), passwords[0].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""user2""), passwords[1].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""123456""), passwords[1].password_value);
  }

  {
    NavigateToFile(""/password/simple_password.html"");

     
    ASSERT_TRUE(content::ExecuteScript(
        RenderViewHost(),
        ""navigator.credentials.store(""
        ""  new PasswordCredential({ id: 'user1', password: 'abcdef' }))""
        "".then(cred => window.location = '/password/done.html');""));

    NavigationObserver observer(WebContents());
    observer.SetPathToWaitFor(""/password/done.html"");
    observer.Wait();
  }

  {
    NavigateToFile(""/password/simple_password.html"");

     
    ASSERT_TRUE(content::ExecuteScript(
        RenderViewHost(),
        ""navigator.credentials.store(""
        ""  new PasswordCredential({ id: 'user2', password: '123456' }))""
        "".then(cred => window.location = '/password/done.html');""));

    NavigationObserver observer(WebContents());
    observer.SetPathToWaitFor(""/password/done.html"");
    observer.Wait();
  }
   
  WaitForPasswordStore();

   
  {
    auto found = password_store->stored_passwords().find(origin.spec());
    ASSERT_NE(password_store->stored_passwords().end(), found);
    const std::vector<autofill::PasswordForm>& passwords = found->second;

    ASSERT_EQ(2U, passwords.size());
    EXPECT_EQ(base::ASCIIToUTF16(""user1""), passwords[0].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""abcdef""), passwords[0].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""user2""), passwords[1].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""123456""), passwords[1].password_value);
  }
}

IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
                       StoreUpdatesPasswordOfExistingCredential) {
  scoped_refptr<password_manager::TestPasswordStore> password_store =
      static_cast<password_manager::TestPasswordStore*>(
          PasswordStoreFactory::GetForProfile(
              browser()->profile(), ServiceAccessType::IMPLICIT_ACCESS)
              .get());

  GURL origin = embedded_test_server()->base_url();

  autofill::PasswordForm form_1;
  form_1.signon_realm = origin.spec();
  form_1.username_value = base::ASCIIToUTF16(""user1"");
  form_1.password_value = base::ASCIIToUTF16(""abcdef"");
  form_1.preferred = true;

  autofill::PasswordForm form_2;
  form_2.signon_realm = origin.spec();
  form_2.username_value = base::ASCIIToUTF16(""user2"");
  form_2.password_value = base::ASCIIToUTF16(""123456"");

  password_store->AddLogin(form_1);
  password_store->AddLogin(form_2);
  WaitForPasswordStore();

   
  {
    auto found = password_store->stored_passwords().find(origin.spec());
    ASSERT_NE(password_store->stored_passwords().end(), found);
    const std::vector<autofill::PasswordForm>& passwords = found->second;

    ASSERT_EQ(2U, passwords.size());
    EXPECT_EQ(base::ASCIIToUTF16(""user1""), passwords[0].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""abcdef""), passwords[0].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""user2""), passwords[1].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""123456""), passwords[1].password_value);
  }

  {
    NavigateToFile(""/password/simple_password.html"");

     
    ASSERT_TRUE(content::ExecuteScript(
        RenderViewHost(),
        ""navigator.credentials.store(""
        ""  new PasswordCredential({ id: 'user1', password: 'ABCDEF' }))""
        "".then(cred => window.location = '/password/done.html');""));

    NavigationObserver observer(WebContents());
    observer.SetPathToWaitFor(""/password/done.html"");
    observer.Wait();
  }

  {
    NavigateToFile(""/password/simple_password.html"");

     
    ASSERT_TRUE(content::ExecuteScript(
        RenderViewHost(),
        ""navigator.credentials.store(""
        ""  new PasswordCredential({ id: 'user2', password: 'UVWXYZ' }))""
        "".then(cred => window.location = '/password/done.html');""));

    NavigationObserver observer(WebContents());
    observer.SetPathToWaitFor(""/password/done.html"");
    observer.Wait();
  }

   
  WaitForPasswordStore();

   
  {
    auto found = password_store->stored_passwords().find(origin.spec());
    ASSERT_NE(password_store->stored_passwords().end(), found);
    const std::vector<autofill::PasswordForm>& passwords = found->second;

    ASSERT_EQ(2U, passwords.size());
    EXPECT_EQ(base::ASCIIToUTF16(""user1""), passwords[0].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""ABCDEF""), passwords[0].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""user2""), passwords[1].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""UVWXYZ""), passwords[1].password_value);
  }
}

IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
                       StoreUpdatesPasswordOfExistingCredentialWithAttributes) {
   
   
  scoped_refptr<password_manager::TestPasswordStore> password_store =
      static_cast<password_manager::TestPasswordStore*>(
          PasswordStoreFactory::GetForProfile(
              browser()->profile(), ServiceAccessType::IMPLICIT_ACCESS)
              .get());

  GURL origin = embedded_test_server()->base_url();

  autofill::PasswordForm form_1;
  form_1.signon_realm = origin.spec();
  form_1.username_value = base::ASCIIToUTF16(""user1"");
  form_1.password_value = base::ASCIIToUTF16(""abcdef"");
  form_1.username_element = base::ASCIIToUTF16(""user"");
  form_1.password_element = base::ASCIIToUTF16(""pass"");
  form_1.origin = GURL(origin.spec() + ""/my/custom/path/"");
  form_1.preferred = true;

  autofill::PasswordForm form_2;
  form_2.signon_realm = origin.spec();
  form_2.username_value = base::ASCIIToUTF16(""user2"");
  form_2.password_value = base::ASCIIToUTF16(""123456"");
  form_2.username_element = base::ASCIIToUTF16(""username"");
  form_2.password_element = base::ASCIIToUTF16(""password"");
  form_2.origin = GURL(origin.spec() + ""/my/other/path/"");

  password_store->AddLogin(form_1);
  password_store->AddLogin(form_2);
  WaitForPasswordStore();

   
  {
    auto found = password_store->stored_passwords().find(origin.spec());
    ASSERT_NE(password_store->stored_passwords().end(), found);
    const std::vector<autofill::PasswordForm>& passwords = found->second;

    ASSERT_EQ(2U, passwords.size());
    EXPECT_EQ(base::ASCIIToUTF16(""user1""), passwords[0].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""abcdef""), passwords[0].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""user""), passwords[0].username_element);
    EXPECT_EQ(base::ASCIIToUTF16(""pass""), passwords[0].password_element);
    EXPECT_EQ(base::ASCIIToUTF16(""user2""), passwords[1].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""123456""), passwords[1].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""username""), passwords[1].username_element);
    EXPECT_EQ(base::ASCIIToUTF16(""password""), passwords[1].password_element);
  }

  {
    NavigateToFile(""/password/simple_password.html"");

     
    ASSERT_TRUE(content::ExecuteScript(
        RenderViewHost(),
        ""navigator.credentials.store(""
        ""  new PasswordCredential({ id: 'user1', password: 'ABCDEF' }))""
        "".then(cred => window.location = '/password/done.html');""));

    NavigationObserver observer(WebContents());
    observer.SetPathToWaitFor(""/password/done.html"");
    observer.Wait();
  }

  {
    NavigateToFile(""/password/simple_password.html"");

     
    ASSERT_TRUE(content::ExecuteScript(
        RenderViewHost(),
        ""navigator.credentials.store(""
        ""  new PasswordCredential({ id: 'user2', password: 'UVWXYZ' }))""
        "".then(cred => window.location = '/password/done.html');""));

    NavigationObserver observer(WebContents());
    observer.SetPathToWaitFor(""/password/done.html"");
    observer.Wait();
  }

   
  WaitForPasswordStore();

   
   
   
  {
    auto found = password_store->stored_passwords().find(origin.spec());
    ASSERT_NE(password_store->stored_passwords().end(), found);
    const std::vector<autofill::PasswordForm>& passwords = found->second;

    ASSERT_EQ(2U, passwords.size());
    EXPECT_EQ(base::ASCIIToUTF16(""user1""), passwords[0].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""ABCDEF""), passwords[0].password_value);
    EXPECT_EQ(base::ASCIIToUTF16(""user2""), passwords[1].username_value);
    EXPECT_EQ(base::ASCIIToUTF16(""UVWXYZ""), passwords[1].password_value);
  }
}

 IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
                        StoreSavesPSLMatchedCredential) {
   scoped_refptr<password_manager::TestPasswordStore> password_store =
  IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
   EXPECT_TRUE(base::ContainsKey(passwords, www_url.spec()));
 }
 
IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
                       UpdatingPSLMatchedCredentialCreatesSecondEntry) {
  scoped_refptr<password_manager::TestPasswordStore> password_store =
      static_cast<password_manager::TestPasswordStore*>(
          PasswordStoreFactory::GetForProfile(
              browser()->profile(), ServiceAccessType::IMPLICIT_ACCESS)
              .get());

   
  GURL psl_url = https_test_server().GetURL(""psl.example.com"", ""/"");

  autofill::PasswordForm signin_form;
  signin_form.signon_realm = psl_url.spec();
  signin_form.password_value = base::ASCIIToUTF16(""password"");
  signin_form.username_value = base::ASCIIToUTF16(""user"");
  signin_form.origin = psl_url;
  password_store->AddLogin(signin_form);

  NavigateToURL(https_test_server(), ""www.example.com"",
                ""/password/password_form.html"");

   
  ASSERT_TRUE(content::ExecuteScript(
      RenderViewHost(),
      ""navigator.credentials.store(""
      ""  new PasswordCredential({ id: 'user', password: 'P4SSW0RD' }))""
      "".then(cred => window.location = '/password/done.html');""));

  NavigationObserver observer(WebContents());
  observer.SetPathToWaitFor(""/password/done.html"");
  observer.Wait();

  BubbleObserver prompt_observer(WebContents());
  prompt_observer.WaitForAutomaticSavePrompt();
  ASSERT_TRUE(prompt_observer.IsSavePromptShownAutomatically());
  prompt_observer.AcceptSavePrompt();
  WaitForPasswordStore();

   
  password_manager::TestPasswordStore::PasswordMap passwords =
      password_store->stored_passwords();
  GURL www_url = https_test_server().GetURL(""www.example.com"", ""/"");
  EXPECT_EQ(2U, passwords.size());
  EXPECT_TRUE(base::ContainsKey(passwords, psl_url.spec()));
  EXPECT_TRUE(base::ContainsKey(passwords, www_url.spec()));
  EXPECT_EQ(base::ASCIIToUTF16(""user""),
            passwords[psl_url.spec()].front().username_value);
  EXPECT_EQ(base::ASCIIToUTF16(""password""),
            passwords[psl_url.spec()].front().password_value);
  EXPECT_EQ(base::ASCIIToUTF16(""user""),
            passwords[www_url.spec()].front().username_value);
  EXPECT_EQ(base::ASCIIToUTF16(""P4SSW0RD""),
            passwords[www_url.spec()].front().password_value);
}

 IN_PROC_BROWSER_TEST_F(CredentialManagerBrowserTest,
                        ObsoleteHttpCredentialMovedOnMigrationToHstsSite) {
    ",Insufficient validation in V8 in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
3254,CVE-2018-6144,"  const base::FilePath& OfflinePageModelTaskified::GetArchiveDirectory(
   return archive_manager_->GetPersistentArchivesDir();
 }
 
bool OfflinePageModelTaskified::IsArchiveInInternalDir(
    const base::FilePath& file_path) const {
  DCHECK(!file_path.empty());

   
   
  return archive_manager_->GetTemporaryArchivesDir().IsParent(file_path) ||
         archive_manager_->GetPersistentArchivesDir().IsParent(file_path);
}

 ClientPolicyController* OfflinePageModelTaskified::GetPolicyController() {
   return policy_controller_.get();
 }",Off-by-one error in PDFium in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to perform an out of bounds memory write via a crafted PDF file.
3255,CVE-2018-6147,"  class RenderWidgetHostViewMacEditCommandHelper;
 class WebContents;
 }
 
namespace ui {
class ScopedPasswordInputEnabler;
}

 @class FullscreenWindowManager;
 @protocol RenderWidgetHostViewMacDelegate;
 
  class CONTENT_EXPORT RenderWidgetHostViewMac
 
   std::unique_ptr<CursorManager> cursor_manager_;
 
   
  std::unique_ptr<ui::ScopedPasswordInputEnabler> password_input_enabler_;

    
   base::WeakPtrFactory<RenderWidgetHostViewMac> weak_factory_;
 ",Lack of secure text entry mode in Browser UI in Google Chrome on Mac prior to 67.0.3396.62 allowed a local attacker to obtain potentially sensitive information from process memory via a local process.
3256,CVE-2018-6121,"  IN_PROC_BROWSER_TEST_F(ProcessManagerBrowserTest,
   }
 }
 
 
 
 
IN_PROC_BROWSER_TEST_F(ProcessManagerBrowserTest,
                       NestedURLNavigationsToExtensionBlockedInSubframe) {
   
   
   
  PrefService* prefs = browser()->profile()->GetPrefs();
  prefs->SetBoolean(prefs::kWebKitWebSecurityEnabled, false);

   
  const Extension* extension = CreateExtension(""Extension"", false);
  embedded_test_server()->ServeFilesFromDirectory(extension->path());
  ASSERT_TRUE(embedded_test_server()->Start());

   
   
  NavigateToURL(embedded_test_server()->GetURL(""/two_iframes.html""));
  ProcessManager* pm = ProcessManager::Get(profile());
  EXPECT_EQ(0u, pm->GetAllFrames().size());
  EXPECT_EQ(0u, pm->GetRenderFrameHostsForExtension(extension->id()).size());

  content::WebContents* tab =
      browser()->tab_strip_model()->GetActiveWebContents();

   
   
  const GURL extension_url(extension->url().Resolve(""empty.html""));
  EXPECT_TRUE(content::NavigateIframeToURL(tab, ""frame1"", extension_url));
  EXPECT_EQ(1u, pm->GetRenderFrameHostsForExtension(extension->id()).size());
  EXPECT_EQ(1u, pm->GetAllFrames().size());

  content::RenderFrameHost* main_frame = tab->GetMainFrame();
  content::RenderFrameHost* extension_frame = ChildFrameAt(main_frame, 0);

   
  url::Origin extension_origin(extension_frame->GetLastCommittedOrigin());
  GURL blob_url(CreateBlobURL(extension_frame, ""foo""));
  EXPECT_EQ(extension_origin, url::Origin::Create(blob_url));
  GURL filesystem_url(CreateFileSystemURL(extension_frame, ""foo""));
  EXPECT_EQ(extension_origin, url::Origin::Create(filesystem_url));

   
   
   
  OverrideLastCommittedOrigin(main_frame, extension_origin);

   
   
  GURL nested_urls[] = {blob_url, filesystem_url};
  for (size_t i = 0; i < arraysize(nested_urls); i++) {
    EXPECT_TRUE(content::NavigateIframeToURL(tab, ""frame2"", nested_urls[i]));
    content::RenderFrameHost* second_frame = ChildFrameAt(main_frame, 1);

    EXPECT_NE(nested_urls[i], second_frame->GetLastCommittedURL());
    EXPECT_FALSE(extension_origin.IsSameOriginWith(
        second_frame->GetLastCommittedOrigin()));
    EXPECT_NE(""foo"", GetTextContent(second_frame));
    EXPECT_EQ(1u, pm->GetRenderFrameHostsForExtension(extension->id()).size());
    EXPECT_EQ(1u, pm->GetAllFrames().size());

    EXPECT_TRUE(
        content::NavigateIframeToURL(tab, ""frame2"", GURL(url::kAboutBlankURL)));
  }
}

  
  
  ",Insufficient validation of input in Blink in Google Chrome prior to 66.0.3359.170 allowed a remote attacker to perform privilege escalation via a crafted HTML page.
3257,CVE-2018-6118,"  TEST_F(DiskCacheBackendTest, SparseEvict) {
   entry2->Close();
   entry0->Close();
 }

TEST_F(DiskCacheBackendTest, InMemorySparseDoom) {
  const int kMaxSize = 512;

  SetMaxSize(kMaxSize);
  SetMemoryOnlyMode();
  InitCache();

  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(64));
  CacheTestFillBuffer(buffer->data(), 64, false);

  disk_cache::Entry* entry = nullptr;
  ASSERT_THAT(CreateEntry(""http://www.0.com/"", &entry), IsOk());

  ASSERT_EQ(net::ERR_FAILED, WriteSparseData(entry, 4337, buffer.get(), 64));
  entry->Close();

   
   
  DoomAllEntries();
}",A double-eviction in the Incognito mode cache that lead to a user-after-free in cache in Google Chrome prior to 66.0.3359.139 allowed a remote attacker who had compromised the renderer process to execute arbitrary code via a crafted HTML page.
3258,CVE-2017-15402,"  bool NavigationControllerImpl::RendererDidNavigate(
   active_entry->SetTimestamp(timestamp);
   active_entry->SetHttpStatusCode(params.http_status_code);
 
   
   
   
   
   FrameNavigationEntry* frame_entry =
       active_entry->GetFrameEntry(rfh->frame_tree_node());
  if (frame_entry && frame_entry->site_instance() != rfh->GetSiteInstance())
    frame_entry = nullptr;
    
    
    ",Using an ID that can be controlled by a compromised renderer which allows any frame to overwrite the page_state of any other frame in the same process in Navigation in Google Chrome on Chrome OS prior to 62.0.3202.74 allowed a remote attacker who had compromised the renderer process to potentially perform a sandbox escape via a crafted HTML page.
3259,CVE-2017-15397,"  void ChunkedUploadDataStream::AppendData(
   if (data_len > 0) {
     DCHECK(data);
     upload_data_.push_back(
        std::make_unique<std::vector<char>>(data, data + data_len));
   }
   all_data_appended_ = is_done;
 ",Inappropriate implementation in ChromeVox in Google Chrome OS prior to 62.0.3202.74 allowed a remote attacker in a privileged network position to observe or tamper with certain cleartext HTTP requests by leveraging that position.
3260,CVE-2016-1672,"  IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest, HandlerFunctionTypeChecking) {
   EXPECT_EQ(""success"", result);
 }
 
IN_PROC_BROWSER_TEST_F(ExtensionBindingsApiTest,
                       MoreNativeFunctionInterceptionTests) {
  ASSERT_TRUE(embedded_test_server()->Start());

   
   
  ASSERT_TRUE(
      LoadExtension(test_data_dir_.AppendASCII(""bindings"")
                        .AppendASCII(""externally_connectable_everywhere"")));

  ui_test_utils::NavigateToURL(
      browser(),
      embedded_test_server()->GetURL(
          ""/extensions/api_test/bindings/function_interceptions.html""));
  content::WebContents* web_contents =
      browser()->tab_strip_model()->GetActiveWebContents();
  EXPECT_FALSE(web_contents->IsCrashed());
   
  std::string result;
  EXPECT_TRUE(content::ExecuteScriptAndExtractString(
      web_contents, ""window.domAutomationController.send(window.testStatus);"",
      &result));
  EXPECT_EQ(""success"", result);
}

 }   
 }   ","The ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the extension bindings in Google Chrome before 51.0.2704.63 mishandles properties, which allows remote attackers to conduct bindings-interception attacks and bypass the Same Origin Policy via unspecified vectors."
3261,CVE-2016-1674,"  AutomationInternalCustomBindings::AutomationInternalCustomBindings(
    
    
    
#define ROUTE_FUNCTION(FN)                                        \
  RouteFunction(#FN, ""automation"",                                \
                 base::Bind(&AutomationInternalCustomBindings::FN, \
                           base::Unretained(this)))
   ROUTE_FUNCTION(IsInteractPermitted);
   ROUTE_FUNCTION(GetSchemaAdditions);
   ROUTE_FUNCTION(GetRoutingID);",The extensions subsystem in Google Chrome before 51.0.2704.63 allows remote attackers to bypass the Same Origin Policy via unspecified vectors.
3262,CVE-2016-1675,"  std::string TestURLLoader::TestUntendedLoad() {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
                         static_cast<int32_t>(total_bytes_to_be_received));
     if (bytes_received == total_bytes_to_be_received)
       break;
      ","Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Same Origin Policy by leveraging the mishandling of Document reattachment during destruction, related to FrameLoader.cpp and LocalFrame.cpp."
3263,CVE-2016-1678,"  class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     else
       EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
 
     
     
      
      
      
  class ChromeRenderProcessHostTest : public extensions::ExtensionBrowserTest {
     ::ShowSingletonTab(browser(), history);
     observer3.Wait();
     tab_count++;
    host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), GURL(history));
     EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph1);
 
      
     GURL extension_url(""chrome-extension://"" + extension->id());","objects.cc in Google V8 before 5.0.71.32, as used in Google Chrome before 51.0.2704.63, does not properly restrict lazy deoptimization, which allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted JavaScript code."
3264,CVE-2016-1679,"  v8::Local<v8::Value> V8ValueConverterImpl::ToV8Array(
     const base::ListValue* val) const {
   v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));
 
   
  v8::Local<v8::Context> context = isolate->GetCurrentContext();

   for (size_t i = 0; i < val->GetSize(); ++i) {
     const base::Value* child = NULL;
     CHECK(val->Get(i, &child));
  v8::Local<v8::Value> V8ValueConverterImpl::ToV8Array(
         ToV8ValueImpl(isolate, creation_context, child);
     CHECK(!child_v8.IsEmpty());
 
    v8::Maybe<bool> maybe =
        result->CreateDataProperty(context, static_cast<uint32_t>(i), child_v8);
    if (!maybe.IsJust() || !maybe.FromJust())
      LOG(ERROR) << ""Failed to set value at index "" << i;
   }
 
   return result;
  v8::Local<v8::Value> V8ValueConverterImpl::ToV8Object(
     const base::DictionaryValue* val) const {
   v8::Local<v8::Object> result(v8::Object::New(isolate));
 
   
  v8::Local<v8::Context> context = isolate->GetCurrentContext();

   for (base::DictionaryValue::Iterator iter(*val);
        !iter.IsAtEnd(); iter.Advance()) {
     const std::string& key = iter.key();
     v8::Local<v8::Value> child_v8 =
         ToV8ValueImpl(isolate, creation_context, &iter.value());
     CHECK(!child_v8.IsEmpty());
 
    v8::Maybe<bool> maybe = result->CreateDataProperty(
        context,
        v8::String::NewFromUtf8(isolate, key.c_str(), v8::String::kNormalString,
                                key.length()),
         child_v8);
    if (!maybe.IsJust() || !maybe.FromJust())
      LOG(ERROR) << ""Failed to set property with key "" << key;
   }
 
   return result;","The ToV8Value function in content/child/v8_value_converter_impl.cc in the V8 bindings in Google Chrome before 51.0.2704.63 does not properly restrict use of getters and setters, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted JavaScript code."
3265,CVE-2016-1686,"  TEST_F(ArcInputMethodManagerServiceTest, IMEOperations) {
       test_context_handler.last_update_composition_arg().composition_text.text);
   EXPECT_EQ(1, test_context_handler.commit_text_call_count());
 
   
  connection->FinishComposingText();
   
  EXPECT_EQ(1, test_context_handler.commit_text_call_count());

   test_context_handler.Reset();
   connection->SetComposingText(text, 0, base::make_optional<gfx::Range>(1, 3));
   EXPECT_EQ(1u, test_context_handler.last_update_composition_arg()","The CPDF_DIBSource::CreateDecoder function in core/fpdfapi/fpdf_render/fpdf_render_loadimage.cpp in PDFium, as used in Google Chrome before 51.0.2704.63, mishandles decoder-initialization failure, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PDF document."
3266,CVE-2016-1687,"  const FeatureEntry kFeatureEntries[] = {
     {""crostini-files"", flag_descriptions::kCrostiniFilesName,
      flag_descriptions::kCrostiniFilesDescription, kOsCrOS,
      SINGLE_VALUE_TYPE(chromeos::switches::kCrostiniFiles)},
    {""crostini-usb-support"", flag_descriptions::kCrostiniUsbSupportName,
     flag_descriptions::kCrostiniUsbSupportDescription, kOsCrOS,
     FEATURE_VALUE_TYPE(chromeos::features::kCrostiniUsbSupport)},
 #endif   
 
 #if defined(OS_WIN)","The renderer implementation in Google Chrome before 51.0.2704.63 does not properly restrict public exposure of classes, which allows remote attackers to obtain sensitive information via vectors related to extensions."
3267,CVE-2016-1689,"  ASH_EXPORT constexpr SkColor kShelfIconColor = SK_ColorWHITE;
  
 ASH_EXPORT constexpr int kShelfTranslucentOverAppList = 51;             
 ASH_EXPORT constexpr int kShelfTranslucentAlpha = 153;                  
 
 
 
ASH_EXPORT constexpr int kShelfTranslucentMaximizedWindow = 254;        
 
  
  ",Heap-based buffer overflow in content/renderer/media/canvas_capture_handler.cc in Google Chrome before 51.0.2704.63 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted web site.
3268,CVE-2016-1690,"  PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
     : content::RenderFrameObserver(render_frame),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false) {
   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }
 ","The Autofill implementation in Google Chrome before 51.0.2704.63 mishandles the interaction between field updates and JavaScript code that triggers a frame deletion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site, a different vulnerability than CVE-2016-1701."
3269,CVE-2016-1691," 
 #include ""content/public/test/url_loader_interceptor.h""
 #include ""device/bluetooth/bluetooth_adapter_factory.h""
 #include ""device/bluetooth/test/mock_bluetooth_adapter.h""
#include ""device/usb/mock_usb_device.h""
#include ""device/usb/mojo/type_converters.h""
 #include ""extensions/browser/api/messaging/messaging_delegate.h""
 #include ""extensions/browser/disable_reason.h""
 #include ""extensions/browser/extension_dialog_auto_confirm.h""
  IN_PROC_BROWSER_TEST_F(PolicyTest, WebUsbDefault) {
   EXPECT_TRUE(context->CanRequestObjectPermission(kTestUrl, kTestUrl));
 }
 
IN_PROC_BROWSER_TEST_F(PolicyTest, WebUsbAllowDevicesForUrls) {
  const GURL kTestUrl(""https://foo.com:443"");
  scoped_refptr<device::UsbDevice> device =
      base::MakeRefCounted<device::MockUsbDevice>(0, 0, ""Google"", ""Gizmo"",
                                                  ""123ABC"");
  auto device_info = device::mojom::UsbDeviceInfo::From(*device);

   
  auto* context = UsbChooserContextFactory::GetForProfile(browser()->profile());
  EXPECT_FALSE(context->HasDevicePermission(kTestUrl, kTestUrl, *device_info));

   
   
  PolicyMap policies;

  base::Value device_value(base::Value::Type::DICTIONARY);
  device_value.SetKey(""vendor_id"", base::Value(0));
  device_value.SetKey(""product_id"", base::Value(0));

  base::Value devices_value(base::Value::Type::LIST);
  devices_value.GetList().push_back(std::move(device_value));

  base::Value url_patterns_value(base::Value::Type::LIST);
  url_patterns_value.GetList().emplace_back(base::Value(""https://[*.]foo.com""));

  base::Value entry(base::Value::Type::DICTIONARY);
  entry.SetKey(""devices"", std::move(devices_value));
  entry.SetKey(""url_patterns"", std::move(url_patterns_value));

  auto policy_value = std::make_unique<base::Value>(base::Value::Type::LIST);
  policy_value->GetList().push_back(std::move(entry));

  SetPolicy(&policies, key::kWebUsbAllowDevicesForUrls,
            std::move(policy_value));
  UpdateProviderPolicy(policies);

  EXPECT_TRUE(context->HasDevicePermission(kTestUrl, kTestUrl, *device_info));

   
  SetPolicy(&policies, key::kWebUsbAllowDevicesForUrls,
            std::make_unique<base::Value>(base::Value::Type::LIST));
  UpdateProviderPolicy(policies);

  EXPECT_FALSE(context->HasDevicePermission(kTestUrl, kTestUrl, *device_info));
}

  
  
 class WebAppInstallForceListPolicyTest : public PolicyTest {","Skia, as used in Google Chrome before 51.0.2704.63, mishandles coincidence runs, which allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted curves, related to SkOpCoincidence.cpp and SkPathOpsCommon.cpp."
